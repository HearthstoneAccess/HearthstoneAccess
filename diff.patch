diff --git a/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
index 9f1d687..f151c5e 100644
--- a/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
@@ -5,6 +5,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 {
@@ -127,7 +128,7 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	protected SlidingTray m_slidingTray;
 
-	protected PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
 	private AudioSource m_lastPickLine;
 
@@ -398,7 +399,7 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 		}
 	}
 
-	protected virtual void InitForMode(SceneMgr.Mode mode)
+    protected virtual void InitForMode(SceneMgr.Mode mode)
 	{
 		switch (mode)
 		{
@@ -592,10 +593,12 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 				SoundManager.Get().LoadAndPlay(button.HeroPickerSelectedPrefab, button.gameObject, 1f, OnLastPickLineLoaded);
 			}
 			SetPlayButtonEnabled(flag);
-		}
-	}
 
-	protected virtual void UpdateHeroInfo(HeroPickerButton button)
+            OnChosenHero();
+        }
+    }
+
+    protected virtual void UpdateHeroInfo(HeroPickerButton button)
 	{
 	}
 
@@ -1417,6 +1420,8 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	protected void FireFormatTypePickerClosedEvent()
 	{
+		AccessibleFormatTypePickerPopup.Hide();
+
 		FormatTypePickerClosed[] array = m_FormatTypePickerClosedListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
@@ -1670,4 +1675,30 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 	{
 		StartCoroutine(LoadHeroButtons(buttonsToDisplay));
 	}
+
+	#region Accessibility
+
+	protected virtual void OnChosenHero()
+	{
+
+	}
+
+    protected bool SupportedAdventure()
+    {
+		if (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE)
+		{
+			return false;
+		}
+
+		var selectedAdventure = AdventureConfig.Get().SelectedAdventure;
+
+		return selectedAdventure == AdventureDbId.BOH;
+    }
+
+    protected void PressBackButton()
+    {
+		m_backButton.TriggerRelease();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AbsHeroPickerButtons.cs b/Decompiled/Assembly-CSharp/AbsHeroPickerButtons.cs
index b2f5d89..f427490 100644
--- a/Decompiled/Assembly-CSharp/AbsHeroPickerButtons.cs
+++ b/Decompiled/Assembly-CSharp/AbsHeroPickerButtons.cs
@@ -35,7 +35,7 @@ public abstract class AbsHeroPickerButtons : MonoBehaviour
 
 	protected int m_HeroPickerButtonCount;
 
-	protected List<HeroPickerButton> m_heroButtons = new List<HeroPickerButton>();
+	internal List<HeroPickerButton> m_heroButtons = new List<HeroPickerButton>();
 
 	protected HeroPickerButton m_selectedHeroButton;
 
@@ -266,12 +266,12 @@ public abstract class AbsHeroPickerButtons : MonoBehaviour
 		}
 	}
 
-	public void Show()
+	public virtual void Show()
 	{
 		m_rootObject.SetActive(value: true);
 	}
 
-	public void Hide()
+	public virtual void Hide()
 	{
 		m_rootObject.SetActive(value: false);
 	}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
new file mode 100644
index 0000000..fbe9535
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
@@ -0,0 +1,7 @@
+﻿namespace Accessibility
+{
+    class AccessibilityConfig
+    {
+        internal static bool CAN_HEAR = true; // Could look into doing something like this for deaf-blind support
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
new file mode 100644
index 0000000..f148a64
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
@@ -0,0 +1,628 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    static class AccessibilityMgr
+    {
+        private static AccessibleKey s_forcedKey; // Override everything else e.g. sometimes we need to press enter before anything is possible but we don't necessarily want a screen or UI
+        private static Action s_forcedAction;
+
+        private static List<AccessibleUI> s_curUIs = new List<AccessibleUI>();
+
+        private static AccessibleScreen s_curScreen;
+
+        private static PegUIElement s_curNotificationDismissButton;
+
+        private static HSASpeech s_helpSpeech;
+
+        // Our sound game object
+        private static GameObject s_soundGameObject;
+
+        private static bool s_enabled;
+
+        private static bool s_textInputAllowed;
+
+        private static bool s_transitioningUIs;
+
+        internal static void Initialize(GameObject rootGameObject)
+        {
+            try
+            {
+                Log.Accessibility.Print("Accessibility initialized");
+
+                ScreenReader.Load();
+                rootGameObject.AddComponent<AccessibleInputMgr>();
+
+                s_enabled = true;
+
+                // Init sound stuff for narration
+                s_soundGameObject = InitSoundGameObject();
+                s_soundGameObject.transform.parent = rootGameObject.transform;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void Shutdown()
+        {
+            Log.Accessibility.Print("Accessibility shutdown");
+            ScreenReader.Unload();
+        }
+
+        internal static void SetScreen(AccessibleScreen screen)
+        {
+            Log.Accessibility.Print($"Setting screen {screen}");
+            var prevScreen = s_curScreen;
+            s_curScreen = screen;
+
+            if (s_curScreen != prevScreen && s_curUIs.Count == 0 && DialogManager.Get().GetNumQueuedDialogs() == 0)
+            {
+                NotifyScreenFocused();
+            }
+        }
+
+        private static void NotifyScreenFocused()
+        {
+            try
+            {
+                s_curScreen.OnGainedFocus();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void TransitioningScreens()
+        {
+            Log.Accessibility.Print($"Transitioning screens");
+            s_curScreen = null;
+        }
+
+        internal static void SetNotification(PegUIElement dismissButton)
+        {
+            if (s_curNotificationDismissButton != null)
+            {
+                // Remove any pending listeners
+                s_curNotificationDismissButton.RemoveEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+            }
+
+            s_curNotificationDismissButton = dismissButton;
+
+            s_curNotificationDismissButton.AddEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+        }
+
+        private static void OnNotificationDismissButtonReleased(UIEvent uiEvent)
+        {
+            s_curNotificationDismissButton = null;
+        }
+
+        public static void ShowUI(AccessibleUI ui)
+        {
+            try
+            {
+                Log.Accessibility.Print($"ShowUI({ui})");
+
+                if (GetFocusedUI() != ui)
+                {
+                    s_curUIs.Add(ui);
+                    s_transitioningUIs = false;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void HideUI(AccessibleUI ui)
+        {
+            if (ui == null)
+            {
+                return;
+            }
+
+            try
+            {
+				Log.Accessibility.Print($"HideUI({ui})");
+
+				var curUI = GetFocusedUI();
+                var numRemovedUIs = s_curUIs.RemoveAll(obj => obj == ui);
+
+                if (numRemovedUIs > 0)
+                {
+                    OnUIPopped(ui, curUI);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void OnUIPopped(AccessibleUI ui, AccessibleUI focusedUIWhenPopped)
+        {
+            var curUI = GetFocusedUI();
+
+            if (curUI == null)
+            {
+                if (s_curScreen != null)
+                {
+                    if (focusedUIWhenPopped != ui || DialogManager.Get().GetNumQueuedDialogs() > 0 || s_transitioningUIs)
+					{
+                        return;
+					}
+
+                    NotifyScreenFocused();
+                }
+            }
+        }
+
+        private static AccessibleUI GetFocusedUI()
+        {
+            if (s_curUIs.Count == 0)
+            {
+                return null;
+            }
+
+            return s_curUIs[s_curUIs.Count - 1];
+        }
+
+        internal static void OutputAndWait(string text, Action onStart, Action onEnd)
+        {
+            GetSpeechMgr().OutputTextAndWait(text, onStart, onEnd);
+        }
+
+        public static void OutputNotification(string text, bool interrupt=false)
+        {
+            Output(text, interrupt);
+        }
+
+        public static void Output(AccessibleComponent speaker, string text, bool interrupt=false)
+        {
+            try
+            {
+                var curUI = GetFocusedUI();
+
+                if (speaker == null)
+                {
+                    // Something we haven't made accessible yet so read anyways in case it helps
+                    // Note: this is also useful for tests in some places where a UI doesn't necessarily exist
+                    Output(text, interrupt);
+                }
+                else if (curUI != null && speaker == curUI)
+                {
+                    Output(text, interrupt);
+                }
+                else if (curUI == null)
+                {
+                    if (s_curScreen != null && s_curScreen == speaker)
+                    {
+                        Output(text, interrupt);
+                    }
+                }
+                // Ignore text from non-focused screens
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void Output(string text, bool interrupt=false)
+        {
+            try
+            {
+                if (interrupt)
+                {
+                    GetSpeechMgr().OutputTextImmediately(text);
+                }
+                else
+                {
+                    Output(text);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void Output(string text)
+        {
+            GetSpeechMgr().OutputText(text);
+        }
+
+        public static void HandleKeyboardInput()
+        {
+            try
+            {
+                if (Input.anyKeyDown)
+                {
+                    InterruptHelpSpeeches();
+
+                    if (ScreenReader.IsUsingSAPI())
+                    {
+                        InterruptTexts();
+
+                        ScreenReader.Interrupt();
+                    }
+                }
+
+                HandleGlobalInput();
+
+                var curUI = GetFocusedUI();
+
+                if (AccessibleKey.HELP.IsPressed())
+                {
+                    if (s_helpSpeech != null)
+                    {
+                        NarrateHelp(s_helpSpeech);
+                    }
+                    else if (s_forcedKey != null)
+                    {
+                        Output(LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, s_forcedKey));
+                    }
+                    else if (s_curNotificationDismissButton != null)
+                    {
+                        Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                    }
+                    else if (curUI != null)
+                    {
+                        Output(curUI.GetAccessibleHelp());
+                    }
+                    else if (s_curScreen != null)
+                    {
+                        Output(s_curScreen.GetHelp());
+                    }
+                    else
+                    {
+                        Output(LocalizedText.GLOBAL_LOADING);
+                        Output(LocalizedText.GLOBAL_PLEASE_WAIT);
+                    }
+
+                    return;
+                }
+
+                if (s_forcedKey != null)
+                {
+                    if (s_forcedKey.IsPressed())
+                    {
+                        s_forcedKey = null;
+                        s_forcedAction();
+                    }
+                }
+                else if (s_curNotificationDismissButton != null)
+                {
+                    if (AccessibleKey.CONFIRM.IsPressed())
+                    {
+                        s_curNotificationDismissButton.TriggerRelease();
+                    }
+                }
+                else if (curUI != null)
+                {
+                    curUI.HandleAccessibleInput();
+                }
+                else if (s_curScreen != null)
+                {
+                    s_curScreen.HandleInput();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void AllowTextInput()
+        {
+            s_textInputAllowed = true;
+        }
+
+        internal static void DisallowTextInput()
+        {
+            s_textInputAllowed = false;
+        }
+
+        internal static bool IsTextInputAllowed()
+        {
+            return s_textInputAllowed;
+        }
+
+        private static void InterruptHelpSpeeches()
+        {
+            GetSpeechMgr().InterruptNarrations();
+        }
+
+        private static void InterruptTextSpeeches()
+        {
+            GetSpeechMgr().InterruptNarrations();
+        }
+
+        private static void HandleGlobalInput()
+        {
+            BnetBar bnetBar = BnetBar.Get();
+            BnetBarFriendButton bnetBarFriendButton = BnetBarFriendButton.Get();
+
+            if (bnetBar != null && AccessibleKey.OPEN_GAME_MENU.IsPressed())
+            {
+                if (ChatMgr.Get().IsFriendListShowing())
+                {
+                    bnetBar.HideFriendList();
+                }
+                else
+				{
+					bnetBar.ToggleGameMenu();
+				}
+			}
+            else if (bnetBarFriendButton != null && AccessibleKey.OPEN_SOCIAL_MENU.IsPressed() && !IsSomeOptionsMenuShown())
+            {
+                bnetBarFriendButton.TriggerRelease();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F5))
+            {
+                CheatMgr.Get().ShowConsole();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F6))
+            {
+                InGameSystemTests.BuildTestCardEffectInterpreter();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F7))
+            {
+                InGameSystemTests.Run();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.Backslash))
+            {
+                HSADevTools.RunTests();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F10))
+            {
+                // Smoke test speeches
+                GetSpeechMgr().Narrate(false, null, AccessibleSpeech.WELCOME_TO_HEARTHSTONE);
+            }
+            else if (AccessibleKey.INCREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().IncreaseSpeechRate();
+            }
+            else if (AccessibleKey.DECREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().DecreaseSpeechRate();
+            }
+        }
+
+        private static bool IsSomeOptionsMenuShown()
+        {
+            if (BnetBar.Get()?.IsGameMenuShown() ?? false)
+            {
+                return true;
+            }
+            else if (OptionsMenu.Get()?.IsShown() ?? false)
+            {
+                return true;
+            }
+            else if (MiscellaneousMenu.Get()?.IsShown() ?? false)
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        public static void WaitForForcedKey(AccessibleKey key, Action action)
+        {
+            s_forcedKey = key;
+            s_forcedAction = action;
+        }
+
+        public static void BlockAllInput(bool blockGlobalInput=false, bool blockHelpSpeech=false)
+        {
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            foreach (var key in AccessibleKey.GetAllKeys(blockGlobalInput))
+            {
+                key.Disable();
+            }
+
+            if (!blockGlobalInput && blockHelpSpeech)
+            {
+                AccessibleKey.HELP.Disable();
+            }
+        }
+
+        public static void UnblockAllInput()
+        {
+            m_isInWhitelistMode = false;
+
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            s_helpSpeech = null;
+        }
+
+        public static void OverrideHelpSpeech(HSASpeech helpSpeech)
+        {
+            s_helpSpeech = helpSpeech;
+            AccessibleKey.HELP.Enable();
+        }
+
+        public static void BlockHelpSpeech()
+        {
+            AccessibleKey.HELP.Disable();
+        }
+
+        public static void ResetHelpSpeech()
+        {
+            s_helpSpeech = null;
+            AccessibleKey.HELP.Enable();
+        }
+
+        private static bool m_isInWhitelistMode;
+
+        public static void WhitelistKeys(HSASpeech helpSpeech, params AccessibleKey[] keys)
+        {
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Enable();
+            }
+
+            OverrideHelpSpeech(helpSpeech);
+            m_isInWhitelistMode = true;
+        }
+
+        public static void BlacklistKeys(params AccessibleKey[] keys)
+        {
+            if (!m_isInWhitelistMode)
+            {
+                // e.g. it's useful to be able to disable end turn on Tutorial01, but we don't always want to block input after that
+                return;
+            }
+
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Disable();
+            }
+
+            s_helpSpeech = null;
+            AccessibleKey.HELP.Disable();
+        }
+
+        private static GameObject InitSoundGameObject()
+        {
+            var ret = new GameObject();
+
+            ret.AddComponent<AudioSource>();
+            ret.AddComponent<AccessibleSpeechMgr>();
+
+            return ret;
+        }
+
+        public static IEnumerator Narrate(HSASpeech speech)
+        {
+            return GetSpeechMgr().Narrate(speech);
+        }
+
+        public static void NarrateHelp(params HSASpeech[] speeches)
+        {
+            try
+            {
+                NarrateSpeeches(true, null, speeches);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void NarrateAndWait(HSASpeech speech, Action onFinish=null)
+        {
+            try
+            {
+                NarrateSpeeches(false, onFinish, speech);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void NarrateSpeeches(bool interruptable, Action onFinish=null, params HSASpeech[] speeches)
+        {
+            try
+            {
+                if (speeches == null || speeches.Length == 0)
+                {
+                    return;
+                }
+
+                GetSpeechMgr().Narrate(interruptable, onFinish, speeches);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static AccessibleSpeechMgr GetSpeechMgr()
+        {
+            return s_soundGameObject.GetComponent<AccessibleSpeechMgr>();
+        }
+
+        internal static int GetCPS()
+        {
+            return GetSpeechMgr().GetCPS();
+        }
+
+        public static void InterruptTexts()
+        {
+            try
+            {
+                GetSpeechMgr().InterruptTexts();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static bool IsAccessibilityEnabled()
+        {
+            return s_enabled;
+        }
+
+        internal static void ToggleEnabled()
+        {
+            s_enabled = !s_enabled;
+
+            if (s_enabled)
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.GLOBAL_ACCESSIBILITY_ON));
+            }
+            else
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.GLOBAL_ACCESSIBILITY_OFF));
+            }
+        }
+
+        internal static bool IsCurrentlyFocused(AccessibleComponent component)
+        {
+            var curUI = GetFocusedUI();
+
+            if (curUI != null && curUI == component)
+            {
+                return true;
+            }
+            else if (curUI == null)
+            {
+                return s_curScreen == component;
+            }
+
+            return false;
+        }
+
+		internal static void TransitioningUIs()
+		{
+            AccessibilityUtils.LogDebug("Transitioning UIs");
+            s_transitioningUIs = true;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
new file mode 100644
index 0000000..f955cae
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
@@ -0,0 +1,470 @@
+﻿using Assets;
+using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibilityUtils
+    {
+        private static bool s_logEnabled = HearthstoneAccessConstants.DEV_MODE;
+
+        private static bool s_cheatAllowPvP;
+
+        public static void DisableLogs()
+        {
+            s_logEnabled = false;
+        }
+
+        public static void LogDebug(string text)
+        {
+            try
+            {
+                if (!s_logEnabled)
+                {
+                    return;
+                }
+
+                Log.Accessibility.Print(text);
+            }
+            catch (Exception e)
+            {
+                LogFatalError(e);
+            }
+        }
+
+        public static string CurateText(string text)
+        {
+            if (text == null || text.Length == 0)
+			{
+                return "";
+			}
+
+            try
+            {
+                LogDebug($"CT Before: {text}");
+                text = text.Trim();
+                text = FixWeirdText(text);
+                LogDebug($"CT: {text}");
+                text = HandleNewLines(text);
+                text = HandleSequentialBolds(text);
+                LogDebug($"CT: {text}");
+                text = RemoveHTMLTags(text);
+                LogDebug($"CT: {text}");
+                text = RemoveLooseFormattingTags(text);
+                LogDebug($"CT: {text}");
+                text = RemoveReadOnlyCharacters(text);
+                LogDebug($"CT: {text}");
+                text = RemoveAttackHealthParenthesisText(text);
+                LogDebug($"CT: {text}");
+                text = FixForwardSlashes(text);
+                LogDebug($"CT: {text}");
+                text = CapitalizeSentences(text);
+                LogDebug($"CT: {text}");
+                text = RemoveUnderscores(text);
+                LogDebug($"CT: {text}");
+                text = CollapsePeriods(text);
+                LogDebug($"CT: {text}");
+                text = NormalizeSpaces(text);
+                LogDebug($"CT: {text}");
+                text = text.Trim();
+                LogDebug($"CT: {text}");
+                //text = ExpandPlusSigns(text); // Not sure due to localization
+                LogDebug($"CT: {text}");
+                //text = ConvertNumbersToWrittenNumbers(text); // Bad idea as it breaks localization
+                LogDebug($"CT: {text}");
+
+                if (text.Length == 0)
+                {
+                    return text;
+                }
+
+                text = AddPeriodIfNeeded(text);
+
+                LogDebug($"CT After: {text}");
+
+                return text;
+            }
+            catch (Exception e)
+            {
+                LogFatalError(e);
+                return "";
+            }
+        }
+
+		internal static bool CanSeeShop()
+		{
+            return !ShopUtils.IsVirtualCurrencyEnabled();
+		}
+
+		internal static bool CanPlayPvP()
+		{
+            if (s_cheatAllowPvP)
+			{
+                return true;
+			}
+
+			return AchieveManager.Get().HasUnlockedFeature(Achieve.Unlocks.VANILLA_HEROES);
+		}
+
+		public static void PrintStackTrace()
+        {
+            if (s_logEnabled)
+            {
+                LogDebug("Printing stack trace");
+                LogDebug(Environment.StackTrace);
+            }
+        }
+
+        private static string CapitalizeSentences(string text)
+        {
+            var sb = new StringBuilder(text.Length);
+
+            bool newSentence = true;
+
+            for (int i = 0; i < text.Length; i++)
+            {
+                if (newSentence && char.IsLetterOrDigit(text[i]))
+                {
+                    sb.Append(char.ToUpper(text[i]));
+                    newSentence = false;
+                }
+                else
+                {
+                    sb.Append(text[i]);
+                }
+
+                if (IsSentenceEndingCharacter(text[i]))
+                {
+                    newSentence = true;
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static bool IsSentenceEndingCharacter(char c)
+        {
+            return LocalizationUtils.GetSentenceEndingCharacters().Contains(c);
+        }
+
+        private static string CollapsePeriods(string text)
+        {
+            var period = LocalizationUtils.GetPeriod();
+
+            if (period.Equals(""))
+			{
+                // e.g. thTH doesn't have periods
+                return text;
+			}
+
+            var threePeriods = $"{period}{period}{period}";
+            var twoPeriods = $"{period}{period}"; // Whatever
+
+            return text.Replace(threePeriods, period).Replace(twoPeriods, period); // . reads better than ... (.. reads dot/dot so needs to be removed)
+        }
+
+        private static string RemoveUnderscores(string text)
+        {
+            return text.Replace("_", " ");
+        }
+
+        private static string NormalizeSpaces(string text)
+        {
+            var sb = new StringBuilder();
+            bool ws = false;
+
+            foreach(var c in text)
+            {
+                if (c == ' ')
+                {
+                    if (!ws)
+                    {
+                        sb.Append(c);
+                    }
+
+                    ws = true;
+                }
+                else
+                {
+                    ws = false;
+                    sb.Append(c);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string AddPeriodIfNeeded(string text)
+        {
+            if (text.Length == 0)
+            {
+                return text;
+            }
+
+            var sentenceEndingCharacters = LocalizationUtils.GetSentenceEndingCharacters();
+            var lastChar = text[text.Length - 1];
+
+            LogDebug($"AddPeriodIfNeeded({text}) ; lastChar={lastChar}");
+
+            if (sentenceEndingCharacters.Contains(lastChar) || text.EndsWith(".\"") || text.EndsWith(":")) // Edge cases in a lot of languages
+            {
+                return text;
+            }
+
+            return text + LocalizationUtils.GetPeriod();
+        }
+
+        private static Regex s_attackAndHealthParenthesisRegex = new Regex(@"(.*)(\(\+\d Attack\/\+\d Health\))(.*)"); // TODO: Think if we want to bother with this
+
+        private static string RemoveAttackHealthParenthesisText(string text)
+        {
+            var match = s_attackAndHealthParenthesisRegex.Match(text);
+
+            if (match.Success)
+            {
+                return text.Replace(match.Groups[2].Value, "");
+            }
+            else
+            {
+                return text;
+            }
+        }
+
+        private static string FixForwardSlashes(string text)
+        {
+            return text.Replace("/", " ");
+        }
+
+        private static string FixWeirdText(string text)
+        {
+            return text.Replace("HIMSELF", "himself") // Injured Blademaster
+                .Replace("ALL", "all") // Various cards
+                .Replace("LOT", "lot"); // Deck recipe - you're missing a LOT of cards
+        }
+
+        private static Regex s_boldLinesRegex = new Regex("^<b>.*</b>$");
+
+        private static string HandleNewLines(string text)
+        {
+            // e.g. Battlecry on a single line and then something else below / Passive on a single line, etc.
+            var lines = text.Split('\n');
+            var sb = new StringBuilder();
+
+            for (var i = 0; i < lines.Length - 1; i++) // Last line doesn't matter
+            {
+                var line = lines[i];
+
+                if (s_boldLinesRegex.Match(line).Success)
+                {
+                    sb.Append($"{line}{LocalizationUtils.GetPeriod()} ");
+                }
+                else
+                {
+                    sb.Append($"{line} ");
+                }
+            }
+
+            sb.Append(lines[lines.Length - 1]);
+
+            return sb.ToString();
+        }
+
+        private static Regex s_htmlTagsRegex = new Regex("<[^>]*>");
+
+        private static string RemoveHTMLTags(string text)
+        {
+            return s_htmlTagsRegex.Replace(text, "");
+        }
+
+        private static string HandleSequentialBolds(string text)
+        {
+            return text.Replace("</b> <b>", $"</b>{LocalizationUtils.GetPeriod()} <b>");
+        }
+
+        private static string RemoveLooseFormattingTags(string text)
+        {
+            return text.Replace("[X]", "")
+                .Replace("[x]", "");
+        }
+
+        private static string RemoveReadOnlyCharacters(string text)
+        {
+            return text.Replace("*", "");
+        }
+
+        internal static void ReadTooltip(AccessibleComponent reader)
+        {
+            foreach (var tooltip in TooltipPanelManager.Get()?.GetTooltipPanels())
+            {
+                AccessibilityMgr.Output(reader, tooltip.m_name.Text);
+                AccessibilityMgr.Output(reader, tooltip.m_body.Text);
+            }
+
+            if (TutorialKeywordManager.Get()?.GetPanels() != null)
+            {
+                foreach (var tooltip in TutorialKeywordManager.Get().GetPanels())
+                {
+                    AccessibilityMgr.Output(reader, tooltip.m_name.Text);
+                    AccessibilityMgr.Output(reader, tooltip.m_body.Text);
+                }
+            }
+        }
+
+        internal static void LogFatalError(Exception e)
+        {
+            Log.Accessibility.PrintError("FATAL ERROR - UNCAUGHT EXCEPTION");
+            Log.Accessibility.PrintError(e.ToString());
+        }
+
+        internal static void LogFatalError(String message)
+        {
+            Log.Accessibility.PrintError($"FATAL ERROR - {message}");
+            Log.Accessibility.PrintError(Environment.StackTrace);
+        }
+
+        internal static void GoBackToHub()
+        {
+			Navigation.Clear();
+            SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
+        }
+
+        internal static void CenterScrollbarAroundObject(UIBScrollable scrollbar, GameObject gameObject)
+        {
+            scrollbar.CenterObjectInView(gameObject, 0f, null, iTween.EaseType.linear, 0f);
+        }
+
+        internal static void ProcessQueue(Queue<Action> queuedActions)
+        {
+            while (queuedActions.Count > 0)
+            {
+                queuedActions.Dequeue()();
+            }
+        }
+
+        #region Debugging
+
+        public static void DebugGameObject(GameObject go)
+        {
+            if (!s_logEnabled)
+            {
+                return;
+            }
+            LogDebug($"Debugging GameObject");
+            LogDebug($"name: {GetObjectNameWithComponents(go)}");
+
+            LogDebug($"childCount: {go.transform.childCount}");
+            DebugChildren(go, 1);
+        }
+
+        internal static void DebugGameObjectInHierarchy(GameObject go)
+        {
+            if (!s_logEnabled)
+            {
+                return;
+            }
+            LogDebug($"Debugging GameObject in hierarchy");
+            LogDebug($"name: {GetObjectNameWithComponents(go)}");
+
+            DebugParent(go, 1);
+        }
+
+		internal static bool IsInPvPGame()
+		{
+			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
+			{
+                return false;
+			}
+
+            var gameType = GameMgr.Get()?.GetGameType();
+
+            switch(gameType)
+			{
+                case PegasusShared.GameType.GT_VS_FRIEND:
+                case PegasusShared.GameType.GT_ARENA:
+                case PegasusShared.GameType.GT_RANKED:
+                case PegasusShared.GameType.GT_CASUAL:
+                case PegasusShared.GameType.GT_TAVERNBRAWL:
+                case PegasusShared.GameType.GT_BATTLEGROUNDS:
+                case PegasusShared.GameType.GT_BATTLEGROUNDS_FRIENDLY:
+                    return true;
+                default:
+                    return false;
+			}
+		}
+
+		private static string GetObjectNameWithComponents(GameObject go)
+        {
+            var sb = new StringBuilder();
+
+            sb.Append(go.name);
+
+            var components = go.GetComponents(typeof(Component));
+
+            if (components.Length > 0)
+            {
+                sb.Append(" (");
+                for (int i = 0; i < components.Length; i++)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(", ");
+                    }
+                    sb.Append(components[i].GetType());
+                }
+                sb.Append(")");
+            }
+
+            return sb.ToString();
+        }
+
+        private static void DebugChildren(GameObject go, int depth)
+        {
+            for (int i = 0; i < go.transform.childCount; i++)
+            {
+                var child = go.transform.GetChild(i).gameObject;
+                var indent = new string('-', depth*3);
+                LogDebug($"{indent} {GetObjectNameWithComponents(child)}");
+
+                DebugChildren(child, depth + 1);
+            }
+        }
+
+        private static void DebugParent(GameObject go, int depth)
+        {
+            if (go.transform.parent == null)
+            {
+                return;
+            }
+
+            var parent = go.transform.parent.gameObject;
+            var indent = new string('+', depth * 3);
+            LogDebug($"{indent} {GetObjectNameWithComponents(parent)}");
+
+            DebugParent(parent, depth + 1);
+        }
+
+		internal static void OutputTimerIfNecessary(int curSeconds, int prevSeconds)
+		{
+			if (curSeconds < prevSeconds && curSeconds == 10) // was 15 and 5 but some players complained
+			{
+                OutputSecondsRemaining(curSeconds);
+			}
+		}
+
+        internal static void OutputSecondsRemaining(int seconds)
+		{
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_N_SECONDS_REMAINING, seconds));
+		}
+
+		internal static void Cheat_SetPvPOverride(bool val)
+		{
+            s_cheatAllowPvP = val;
+		}
+
+		#endregion
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
new file mode 100644
index 0000000..b22db7e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
@@ -0,0 +1,323 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleAdventureScene : AccessibleScreen
+    {
+        private enum State { LOADING, CHOOSING_ADVENTURE, CHOOSING_ADVENTURE_MODE, CHOOSING_DECK, CHOOSING_OPPONENT }; // Finding game is a loading state as well
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_curMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_chooseDeckMenu;
+
+        private AccessibleHorizontalMenu<AccessiblePracticeAIButton> m_chooseOpponentMenu;
+
+        private AdventureChooserTray m_adventureChooserTray;
+
+        private List<CustomDeckPage> m_customDeckPages;
+
+        private List<PracticeAIButton> m_practiceAIButtons;
+
+        private bool chosenDeck;
+
+        private static AccessibleAdventureScene s_instance = new AccessibleAdventureScene();
+
+        internal static AccessibleAdventureScene Get()
+        {
+            return s_instance;
+        }
+        
+        public void OnAdventureSceneShown()
+        {
+            try
+            {
+                m_practiceAIButtons = null; // Cleanup in case of unlocked heroes
+                m_curState = State.LOADING;
+
+                GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubSceneLoaded(AdventureData.Adventuresubscene subscene)
+        {
+            AccessibilityUtils.LogDebug($"OnSubSceneLoaded({subscene})");
+            m_curState = State.LOADING;
+
+            try
+            {
+                if (subscene == AdventureData.Adventuresubscene.CHOOSER)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                    SetupAndReadChooseAdventureMenu();
+                }
+                else if (subscene == AdventureData.Adventuresubscene.PRACTICE)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION));
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupAndReadChooseAdventureMenu()
+        {
+            m_curState = State.CHOOSING_ADVENTURE;
+            m_curMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE), OnGoBackToHub);
+
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION), OnChoosePracticeAdventure);
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION), OnChooseBookOfHeroesAdventure);
+            m_curMenu.AddOption(LocalizedText.SCREEN_GO_BACK, OnGoBackToHub);
+
+            m_curMenu.StartReading();
+        }
+
+        private void OnChoosePracticeAdventure()
+        {
+            m_curState = State.CHOOSING_ADVENTURE_MODE;
+            m_curMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE), SetupAndReadChooseAdventureMenu);
+
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION), OnChooseNormalAdventure);
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION), OnChooseExpertAdventure);
+
+            m_curMenu.StartReading();
+        }
+
+        private void OnChooseExpertAdventure()
+        {
+            if (!AdventureConfig.CanPlayMode(AdventureDbId.PRACTICE, AdventureModeDbId.EXPERT))
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED));
+            }
+            else
+            {
+                ChooseAdventure(AdventureDbId.PRACTICE, AdventureModeDbId.EXPERT);
+            }
+        }
+
+        private void OnChooseBookOfHeroesAdventure()
+        {
+            ChooseAdventure(AdventureDbId.BOH, AdventureModeDbId.DUNGEON_CRAWL);
+        }
+
+        public void OnAdventureChooserTrayAwake(AdventureChooserTray adventureChooserTray)
+        {
+            AccessibilityUtils.LogDebug($"OnAdventureChooserTrayAwake({adventureChooserTray})");
+            m_adventureChooserTray = adventureChooserTray;
+        }
+
+        private void OnChooseNormalAdventure()
+        {
+            ChooseAdventure(AdventureDbId.PRACTICE, AdventureModeDbId.LINEAR);
+        }
+
+        private void ChooseAdventure(AdventureDbId adventure, AdventureModeDbId mode)
+        {
+            AdventureConfig.Get().SetSelectedAdventureMode(adventure, mode);
+            m_adventureChooserTray.m_ChooseButton.TriggerRelease();
+        }
+
+        private void OnGoBackToHub()
+        {
+            m_adventureChooserTray.m_BackButton.TriggerRelease();
+        }
+
+        public void OnPracticePickerTrayDisplayShown(List<PracticeAIButton> practiceAIButtons)
+        {
+            try
+            {
+                m_practiceAIButtons = practiceAIButtons;
+                SetupChooseOpponentMenu();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupChooseOpponentMenu()
+        {
+            m_curState = State.CHOOSING_OPPONENT;
+            var chooseOpponentMenu = new AccessibleHorizontalMenu<AccessiblePracticeAIButton>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_TITLE), OnGoBackToChooseDeckMenuFromChooseOpponentMenu);
+
+            foreach (var btn in m_practiceAIButtons)
+            {
+                chooseOpponentMenu.AddOption(new AccessiblePracticeAIButton(this, btn), () => SelectOpponent(btn));
+            }
+
+            m_chooseOpponentMenu = chooseOpponentMenu;
+            m_chooseOpponentMenu.StartReading();
+        }
+
+        private void SetupChooseDeckMenu()
+        {
+            chosenDeck = false;
+            m_curState = State.CHOOSING_DECK;
+            m_chooseDeckMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), OnGoBackToChooseAdventureFromChooseDeckMenu);
+
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+            var selectedDeckId = deckPickerTrayDisplay.GetLastChosenDeckId();
+            var selectedDeckIdx = 0;
+
+            for (int i = 0, curIdx = 0; i < m_customDeckPages.Count; i++)
+            {
+                var page = m_customDeckPages[i];
+                var pageDecks = page.m_customDecks;
+
+                for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+                {
+                    var deck = pageDecks[j];
+                    var deckId = deck.GetDeckID();
+
+                    if (deckId == -1L)
+                    {
+                        break;
+                    }
+                    else if (deckId == selectedDeckId)
+                    {
+                        selectedDeckIdx = curIdx;
+                    }
+
+                    var deckPageIdx = i;
+
+                    var accessibleDeck = new AccessibleCollectionDeckBoxVisual(this, deck);
+
+                    m_chooseDeckMenu.AddOption(accessibleDeck, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+                }
+            }
+
+            m_chooseDeckMenu.SetIndex(selectedDeckIdx);
+            m_chooseDeckMenu.StartReading();
+        }
+
+        private void OnGoBackToChooseDeckMenuFromChooseOpponentMenu()
+        {
+            PracticePickerTrayDisplay.Get().m_backButton.TriggerRelease();
+            SetupChooseDeckMenu();
+        }
+
+        private void OnGoBackToChooseAdventureFromChooseDeckMenu()
+        {
+            DeckPickerTrayDisplay.Get().m_backButton.TriggerRelease();
+        }
+
+        private void SelectOpponent(PracticeAIButton btn)
+        {
+            btn.TriggerRelease();
+            PracticePickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                m_chooseDeckMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                m_chooseOpponentMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState != State.LOADING)
+            {
+                m_curMenu?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                return m_chooseDeckMenu?.GetHelp();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                return m_chooseOpponentMenu?.GetHelp();
+            }
+            else if (m_curState != State.LOADING)
+            {
+                return m_curMenu?.GetHelp();
+            }
+
+            return "";
+        }
+
+        public void OnDeckPickerTrayDisplayReady(List<CustomDeckPage> pages)
+        {
+            try
+            {
+                m_customDeckPages = pages;
+                m_practiceAIButtons = null; // Cleanup in case we go out of adventure and in again
+                SetupChooseDeckMenu();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SelectDeck(CollectionDeckBoxVisual deck)
+        {
+            chosenDeck = true;
+            deck.TriggerRelease();
+            //DeckPickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        public void OnSelectedDeck(CollectionDeckBoxVisual deck)
+        {
+            if (AccessibilityMgr.IsAccessibilityEnabled() && chosenDeck)
+            {
+                DeckPickerTrayDisplay.Get().m_playButton.TriggerRelease();
+            }
+        }
+
+        private void ShowDeckPage(int pageIndex)
+        {
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+
+            if (deckPickerTrayDisplay.GetCurrentPageIndex() != pageIndex)
+            {
+                deckPickerTrayDisplay.ShowPage(pageIndex);
+            }
+        }
+
+        private bool OnFindGameEvent(FindGameEventData eventData, object userData)
+        {
+            m_curState = State.LOADING;
+
+            return false;
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.LOADING)
+            {
+                return;
+            }
+
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                m_chooseDeckMenu?.StartReading();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                m_chooseOpponentMenu?.StartReading();
+            }
+            else
+            {
+                m_curMenu?.StartReading();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
new file mode 100644
index 0000000..75b068e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
@@ -0,0 +1,38 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class AccessibleAttackSpellController
+    {
+        private PowerTaskList m_taskList;
+
+        public AccessibleAttackSpellController(PowerTaskList taskList)
+        {
+            m_taskList = taskList;
+        }
+
+        public void OnLaunchAttack()
+        {
+            try
+            {
+                AccessiblePlayDescriber.Get().OnAttack(m_taskList);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+		internal void OnBattlegroundsFinisherFinished()
+		{
+            try
+            {
+                AccessiblePlayDescriber.Get().BattlegroundsOnAttack(m_taskList);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs
new file mode 100644
index 0000000..ae7ea37
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs
@@ -0,0 +1,251 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public abstract class AccessibleCard : AccessibleItem
+    {
+        protected readonly Card m_card;
+
+        internal AccessibleCard(AccessibleComponent parent, Card card) : base(parent)
+        {
+            m_card = card;
+        }
+
+        internal Card GetCard()
+        {
+            return m_card;
+        }
+
+        public static AccessibleCard CreateCard(AccessibleComponent parent, Card card)
+		{
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+				return new AccessibleBattlegroundsCard(parent, card);
+			}
+            else
+			{
+                // Use traditional for everything else so players can play other unsupported game modes such as Mercenaries with OCR
+                return new AccessibleTraditionalCard(parent, card);
+			}
+		}
+
+        #region Common stuff
+
+        protected List<string> GetHeader()
+		{
+            var ret = new List<string>();
+
+            var name = GetName();
+
+            ret.Add(name);
+
+            AddTrailingHeader(ret);
+
+            return ret;
+		}
+
+		protected void AddTrailingHeader(List<string> ret)
+		{
+            if (AccessibleCardUtils.IsCursed(m_card.GetEntity()))
+			{
+                ret.Add(LocalizationUtils.Get(LocalizationKey.GLOBAL_CURSED));
+			}
+
+            if (AccessibleCardUtils.IsReady(m_card))
+			{
+                ret.Add(LocalizationUtils.Get(LocalizationKey.GLOBAL_READY));
+			}
+		}
+
+		protected string GetName()
+        {
+            if (m_card.GetEntity().IsHero() && m_card.GetEntity().GetZone() == TAG_ZONE.PLAY)
+            {
+                if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+                {
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO);
+                }
+                else
+                {
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HERO);
+                }
+            }
+            else if (m_card.GetEntity().IsSecret() && m_card.GetControllerSide() != Player.Side.FRIENDLY)
+            {
+                var secretClass = GameStrings.GetClassName(m_card.GetEntity().GetClass());
+                return LocalizationUtils.Format(LocalizationKey.GLOBAL_SECRET, secretClass);
+            }
+            else
+            {
+                return m_card.GetEntity().GetEntityDef().GetName();
+            }
+        }
+
+        protected string GetEffects()
+        {
+            // Note: Remember to update GetEffectsNotInEntityDef() as well if this needs updating
+            // Could simply have a flag defaulting instead but that would add significant complexity and I'd rather split the fault domains for now
+
+            List<string> effects = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            if (AccessibleCardUtils.IsSilencedMinion(entity)) effects.Add(LocalizedText.GLOBAL_SILENCE);
+
+            if (entity.HasDivineShield()) effects.Add(LocalizedText.GLOBAL_DIVINE_SHIELD);
+            if (entity.IsFrozen()) effects.Add(LocalizedText.GLOBAL_FROZEN);
+            if (entity.HasLifesteal()) effects.Add(LocalizedText.GLOBAL_LIFESTEAL);
+            if (entity.HasDeathrattle()) effects.Add(LocalizedText.GLOBAL_DEATHRATTLE);
+            if (entity.IsPoisonous()) effects.Add(LocalizedText.GLOBAL_POISONOUS);
+            if (entity.IsStealthed()) effects.Add(LocalizedText.GLOBAL_STEALTH);
+            if (entity.HasTaunt()) effects.Add(LocalizedText.GLOBAL_TAUNT);
+            if (entity.IsImmune()) effects.Add(LocalizedText.GLOBAL_IMMUNE);
+            if (entity.IsDormant()) effects.Add(LocalizedText.GLOBAL_DORMANT);
+            if (entity.HasReborn()) effects.Add(LocalizedText.GLOBAL_REBORN);
+
+            if (effects.Count == 0)
+            {
+                return "";
+            }
+
+            return AccessibleSpeechUtils.HumanizeList(effects);
+        }
+
+        protected string GetEffectsNotInEntityDef()
+        {
+            // Note: This is only used for Battlegrounds at the moment to reduce the chattiness when narrating the opponent's board at the start of the combat phase
+            List<string> effects = new List<string>();
+
+            var entity = m_card.GetEntity();
+            var entityDef = entity.GetEntityDef();
+
+            if (AccessibleCardUtils.IsSilencedMinion(entity)) effects.Add(LocalizedText.GLOBAL_SILENCE);
+
+            if (entity.HasDivineShield() && !entityDef.HasDivineShield()) effects.Add(LocalizedText.GLOBAL_DIVINE_SHIELD);
+            if (entity.IsFrozen() && !entityDef.IsFrozen()) effects.Add(LocalizedText.GLOBAL_FROZEN);
+            if (entity.HasLifesteal() && !entityDef.HasLifesteal()) effects.Add(LocalizedText.GLOBAL_LIFESTEAL);
+            if (entity.HasDeathrattle() && !entityDef.HasDeathrattle()) effects.Add(LocalizedText.GLOBAL_DEATHRATTLE);
+            if (entity.IsPoisonous() && !entityDef.IsPoisonous()) effects.Add(LocalizedText.GLOBAL_POISONOUS);
+            if (entity.IsStealthed() && !entityDef.IsStealthed()) effects.Add(LocalizedText.GLOBAL_STEALTH);
+            if (entity.HasTaunt() && !entityDef.HasTaunt()) effects.Add(LocalizedText.GLOBAL_TAUNT);
+            if (entity.IsImmune() && !entityDef.IsImmune()) effects.Add(LocalizedText.GLOBAL_IMMUNE);
+            if (entity.IsDormant() && !entityDef.IsDormant()) effects.Add(LocalizedText.GLOBAL_DORMANT);
+            if (entity.HasReborn() && !entityDef.HasReborn()) effects.Add(LocalizedText.GLOBAL_REBORN);
+
+            if (effects.Count == 0)
+            {
+                return "";
+            }
+
+            return AccessibleSpeechUtils.HumanizeList(effects);
+        }
+
+        protected List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (!AccessibleCardUtils.IsCostHidden(m_card))
+            {
+                lines.Add(AccessibleCardUtils.GetCost(m_card));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+
+        protected string GetDescription()
+        {
+            Entity entity = m_card.GetEntity();
+
+            if (AccessibleCardUtils.IsSilencedMinion(entity))
+            {
+                return LocalizedText.GLOBAL_SILENCE;
+            }
+
+            return entity.GetCardTextBuilder().BuildCardTextInHand(entity);
+        }
+
+        protected List<string> GetLinesForOpponentSecret()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+            return lines;
+        }
+
+        protected string GetResources()
+        {
+            if (m_card.GetEntity().IsDormant() || m_card.GetEntity().HasTag(GAME_TAG.DORMANT_VISUAL))
+            {
+                return "";
+            }
+            else if (m_card.GetEntity().GetTag(GAME_TAG.HIDE_STATS) == 1)
+            {
+                // e.g. Divine Bell in BoH Garrosh 7
+                return "";
+            }
+            else if (m_card.GetEntity().IsMinion()) {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp);
+            } 
+            else if (m_card.GetEntity().IsWeapon()) {
+                var atk = m_card.GetEntity().GetATK();
+                var durability = m_card.GetEntity().GetCurrentDurability();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, atk, durability);
+            } 
+            else if (m_card.GetEntity().IsHero())
+            {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                var armor = m_card.GetEntity().GetArmor();
+
+                var atkHidden = AccessibleCardUtils.IsAttackHidden(m_card);
+                var hpHidden = AccessibleCardUtils.IsHealthHidden(m_card);
+                var armorHidden = AccessibleCardUtils.IsArmorHidden(m_card);
+
+                var showAtk = !atkHidden && atk > 0;
+                var showHp = !hpHidden;
+                var showArmor = !armorHidden && armor > 0;
+
+                var stats = new List<string>();
+
+                if (showAtk)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ATK, atk));
+                }
+                if (showArmor)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+                }
+                if (showHp)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, hp));
+                }
+
+                return AccessibleSpeechUtils.HumanizeList(stats);
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        protected string GetCardType()
+        {
+            return AccessibleCardUtils.GetType(m_card.GetEntity().GetCardType());
+        }
+
+        protected string GetRace()
+        {
+            // Note: This handles spell school as well
+            return m_card.GetEntity().GetEntityDef().GetRaceText();
+        }
+
+		#endregion
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs
new file mode 100644
index 0000000..54d9cf2
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs
@@ -0,0 +1,404 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCardUtils
+    {
+        internal static string GetType(TAG_CARDTYPE type)
+        {
+            return GameStrings.GetCardTypeName(type);
+        }
+
+        internal static string GetRarity(EntityDef entityDef)
+        {
+            if (entityDef.IsElite())
+            {
+                // All elite cards are legendary at the moment. Legendary cards like Cairne Bloodhoof are elite but have their rarity set to invalid for some reason
+                return GameStrings.GetRarityText(TAG_RARITY.LEGENDARY);
+            }
+
+            var rarity = entityDef.GetRarity();
+
+            if (rarity == TAG_RARITY.INVALID || rarity == TAG_RARITY.FREE)
+            {
+                return "";
+            }
+
+            return GameStrings.GetRarityText(rarity);
+        }
+
+        internal static List<string> GetLinesForNormalEntityDef(EntityDef entityDef, TAG_PREMIUM premiumType, string className=null, bool readOwned=false, int numCopies=0)
+        {
+            var ret = new List<string>();
+
+            ret.Add(GetNameWithPremium(entityDef.GetName(), premiumType)); // Golden/Diamond edition
+
+            if (readOwned)
+			{
+                AddOwnedLine(ret, numCopies);
+			}
+
+            if (className != null)
+            {
+                ret.Add(className); // We don't always want to show the class name but it's useful sometimes e.g. pack opening
+            }
+
+            ret.Add(GetCardCost(entityDef.GetCost())); // x mana
+
+            AddLineIfExists(GetResourcesForEntityDef(entityDef), ret); // Resources
+            AddLineIfExists(entityDef.GetCardTextInHand(), ret); // Description
+            AddLineIfExists(entityDef.GetRaceText(), ret); // Race or spell school
+
+            ret.Add(GetType(entityDef.GetCardType())); // Weapon, spell, etc.
+
+            AddLineIfExists(GetRarity(entityDef), ret); // Legendary, elite, etc.
+
+            return ret;
+        }
+
+		internal static void AddOwnedLine(List<string> lines, int numCopies)
+		{
+            if (numCopies > 0)
+			{
+                lines.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_OWNED"));
+			}
+            else
+			{
+                lines.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_MISSING"));
+			}
+		}
+
+        internal static void AddLineIfExists(string line, List<string> lines)
+        {
+            if (line == null || line.Length == 0)
+            {
+                return;
+            }
+
+            lines.Add(line);
+        }
+
+        internal static string GetResourcesForEntityDef(EntityDef entityDef)
+        {
+            if (entityDef.GetCardType() == TAG_CARDTYPE.MINION)
+            {
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, entityDef.GetATK(), entityDef.GetHealth());
+            } 
+            else if (entityDef.GetCardType() == TAG_CARDTYPE.WEAPON)
+            {
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, entityDef.GetATK(), entityDef.GetDurability());
+            } 
+            else if (entityDef.GetCardType() == TAG_CARDTYPE.HERO)
+            {
+                var atk = entityDef.GetATK();
+                var hp = entityDef.GetHealth();
+                var armor = entityDef.GetArmor();
+
+                var stats = new List<string>();
+
+                if (atk > 0)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ATK, atk));
+                }
+                if (armor > 0)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+                }
+
+                stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, hp));
+
+                return AccessibleSpeechUtils.HumanizeList(stats);
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        public static List<string> GetHeroPowerCardLinesForHeroCard(string heroCardId)
+        {
+            var ret = new List<string>();
+
+            var heroPowerCardId = GameUtils.GetHeroPowerCardIdFromHero(heroCardId);
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(heroPowerCardId);
+            var heroPowerName = entityDef.GetName();
+
+            ret.Add(AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO_POWER), heroPowerName));
+
+			AddLineIfExists(GetEntityDefCost(entityDef), ret);
+            AddLineIfExists(entityDef.GetCardTextInHand(), ret);
+
+            return ret;
+        }
+
+		public static List<string> GetHeroBuddyCardLinesForHeroCard(string heroCardId)
+        {
+            var ret = new List<string>();
+
+            var heroBuddyCardId = GameUtils.GetHeroBuddyCardIdFromHero(heroCardId);
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(heroBuddyCardId);
+            var buddyName = entityDef.GetName();
+
+            ret.Add(AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_ZONE_HERO_BUDDY), buddyName));
+
+            ret.Add($"{entityDef.GetATK()} {entityDef.GetHealth()}");
+
+			AddLineIfExists(entityDef.GetCardTextInHand(), ret);
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER, entityDef.GetTag(GAME_TAG.TECH_LEVEL)));
+
+            return ret;
+        }
+
+		private static string GetEntityDefCost(EntityDef entityDef)
+		{
+            if (entityDef.HasTag(GAME_TAG.HIDE_STATS) || entityDef.HasTag(GAME_TAG.HIDE_COST))
+			{
+                return null;
+			}
+
+            // TODO: Refactor once we get to BG collection as well
+            var cost = entityDef.GetCost();
+
+			if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+				return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST, cost);
+			}
+			else
+			{
+				return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+			}
+		}
+
+        public static List<string> GetQuestRewardCardLines(string cardId)
+        {
+            var ret = new List<string>();
+
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+            var cardName = entityDef.GetName();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, cardName));
+
+            if (!entityDef.HasTag(GAME_TAG.HIDE_STATS) && !entityDef.HasTag(GAME_TAG.HIDE_COST))
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, entityDef.GetCost()));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetResources(entityDef), ret);
+            AccessibleCardUtils.AddLineIfExists(entityDef.GetCardTextInHand(), ret);
+            AccessibleCardUtils.AddLineIfExists(entityDef.GetRaceText(), ret);
+
+            ret.Add(GetType(entityDef.GetCardType()));
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(entityDef), ret);
+
+            return ret;
+        }
+
+        private static string GetResources(EntityDef entityDef)
+        {
+            if (entityDef.IsMinion())
+            {
+                var atk = entityDef.GetATK();
+                var hp = entityDef.GetHealth();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp);
+            } 
+            else if (entityDef.IsWeapon())
+            {
+                var atk = entityDef.GetATK();
+                var durability = entityDef.GetDurability();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, atk, durability);
+            } 
+            // TODO: Hero cards
+            else
+            {
+                return "";
+            }
+        }
+
+        internal static string GetQuestProgressLine(Entity entity)
+        {
+            var curProgress = entity.GetTag(GAME_TAG.QUEST_PROGRESS);
+            var questProgressTotal = entity.GetTag(GAME_TAG.QUEST_PROGRESS_TOTAL);
+
+            return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, curProgress, questProgressTotal);
+        }
+
+		internal static string GetInGameCardNameWithPremium(Card card)
+		{
+            return GetInGameEntityNameWithPremium(card.GetEntity());
+		}
+
+		internal static string GetInGameEntityNameWithPremium(Entity entity)
+		{
+            var entityName = entity.GetName();
+            var premiumType = entity.GetPremiumType();
+
+            if (premiumType == TAG_PREMIUM.GOLDEN)
+			{
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_PREMIUM_GOLDEN, entityName);
+			}
+            else
+			{
+                return entityName;
+			}
+		}
+
+		internal static string GetRewardCardIDFromQuestCardID(Entity entity)
+        {
+            return QuestController.GetRewardCardIDFromQuestCardID(entity);
+        }
+
+        internal static string GetNameWithPremium(string name, TAG_PREMIUM premiumType)
+        {
+            switch (premiumType)
+            {
+                case TAG_PREMIUM.GOLDEN:
+                    return LocalizationUtils.Format(LocalizationKey.READ_COLLECTION_CARD_NAME_GOLDEN, name);
+                case TAG_PREMIUM.DIAMOND:
+                    return LocalizationUtils.Format(LocalizationKey.READ_COLLECTION_CARD_NAME_DIAMOND, name);
+                default:
+                    return name;
+            }
+        }
+
+        internal static string GetCardCost(int cost)
+        {
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+        }
+
+        internal static string GetCardPackName(int packId)
+        {
+            BoosterDbfRecord record = GameDbf.Booster.GetRecord(packId);
+
+            if (record == null)
+            {
+                return null;
+            }
+
+            var name = record.Name?.GetString();
+
+            if (name == null || name.Length == 0)
+            {
+                if (record.NoteDesc != null && record.NoteDesc.Length > 0)
+                {
+                    // e.g. standard warrior pack from BoH Garrosh
+                    return record.NoteDesc;
+                }
+
+                return null;
+            }
+
+            return name;
+        }
+
+        internal static bool ShouldShowFavoriteHeroText(EntityDef entityDef)
+		{
+            if (entityDef == null)
+			{
+                return false;
+			}
+
+            TAG_CLASS @class = entityDef.GetClass();
+
+			bool show = false;
+			NetCache.CardDefinition favoriteHero = CollectionManager.Get().GetFavoriteHero(entityDef.GetClass());
+			if (favoriteHero != null)
+			{
+        show = CollectionManager.Get().GetCountOfHeroClassPlayerOwns(@class) > 1 && !string.IsNullOrEmpty(favoriteHero.Name) && favoriteHero.Name == entityDef.GetCardId();
+			}
+
+            return show;
+		}
+
+		internal static bool HasHiddenStats(Entity card)
+		{
+            return card.HasTag(GAME_TAG.HIDE_STATS);
+		}
+
+		internal static bool IsCursed(Entity entity)
+		{
+            if (entity == null)
+			{
+                return false;
+			}
+
+            return entity.HasTag(GAME_TAG.EVIL_GLOW);
+		}
+
+		internal static bool IsReady(Card card)
+		{
+            var actorStateType = card?.GetActor()?.GetActorStateType();
+
+            return actorStateType == ActorStateType.CARD_POWERED_UP || actorStateType == ActorStateType.CARD_COMBO;
+		}
+
+		internal static bool IsSilencedMinion(Entity entity)
+		{
+            if (entity == null)
+			{
+                return false;
+			}
+
+            if (entity.GetCardType() != TAG_CARDTYPE.MINION || entity.GetZone() != TAG_ZONE.PLAY)
+			{
+                return false;
+			}
+
+            return entity.IsSilenced();
+		}
+
+		internal static string GetCost(Card card)
+		{
+			int cost = card.GetEntity().GetCost();
+
+            if (IsCostHidden(card))
+            {
+                cost = 0;
+            }
+
+            if (card.GetEntity().HasTag(GAME_TAG.CARD_COSTS_HEALTH))
+			{
+                // Stealer of souls changes cost to health instead of mana
+                return LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, cost);
+			}
+            else
+			{
+                if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+				{
+					return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST, cost);
+				}
+                else
+				{
+					return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+				}
+			}
+		}
+
+		internal static bool IsCostHidden(Card card)
+        {
+            return AreStatsHidden(card) || card.GetEntity().HasTag(GAME_TAG.HIDE_COST);
+        }
+
+        internal static bool AreStatsHidden(Card card)
+        {
+            return card.GetEntity().HasTag(GAME_TAG.HIDE_STATS);
+        }
+
+        internal static bool IsAttackHidden(Card card)
+        {
+            return AreStatsHidden(card) || card.GetEntity().HasTag(GAME_TAG.HIDE_ATTACK);
+        }
+
+        internal static bool IsHealthHidden(Card card)
+        {
+            return AreStatsHidden(card) || card.GetEntity().HasTag(GAME_TAG.HIDE_HEALTH);
+        }
+
+        internal static bool IsArmorHidden(Card card)
+        {
+            return AreStatsHidden(card);
+        }
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs
new file mode 100644
index 0000000..926fe77
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs
@@ -0,0 +1,34 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleCheckBox : AccessibleElement
+    {
+        private readonly CheckBox m_checkBox;
+
+        internal AccessibleCheckBox(AccessibleComponent parent, CheckBox checkBox) : base(parent)
+        {
+            m_checkBox = checkBox;
+        }
+
+        public void Toggle()
+        {
+            m_checkBox.TriggerRelease();
+            ReadState();
+        }
+
+        private void ReadState()
+        {
+            if (m_checkBox.IsChecked())
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED));
+            }
+            else
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED));
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
new file mode 100644
index 0000000..249b277
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
@@ -0,0 +1,277 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectibleCard : AccessibleItem
+    {
+        private readonly CollectibleCard m_card;
+
+        private bool m_readCount;
+
+        private bool m_readClass;
+
+        private bool m_countOverride;
+        private int m_count;
+
+        private bool m_readOwned; // Used to read missing vs owned when e.g. crafting cards or seeing hero skins
+
+        private bool m_readFavorites; // Used to read things like "favorite rogue" when reading hero skins or "favorite" when reading card backs
+
+        internal AccessibleCollectibleCard(AccessibleComponent parent, CollectibleCard card, bool readCount=true, bool readClass=false, bool readOwned=false, bool readFavorites=false) : base(parent)
+        {
+            m_card = card;
+            m_readCount = readCount;
+            m_readClass = readClass;
+            m_readOwned = readOwned;
+            m_readFavorites = readFavorites;
+        }
+
+        // Used for listing cards in e.g. deck building where the card count is not necessarily the owned count
+        internal AccessibleCollectibleCard(AccessibleComponent parent,CollectibleCard card, int count) : base(parent)
+        {
+            m_card = card;
+            m_countOverride = true;
+            m_count = count;
+            m_readCount = true;
+            m_readClass = false;
+            m_readOwned = false;
+            m_readFavorites = false;
+        }
+
+        internal override List<string> GetLines()
+        {
+            switch (m_card.CardType)
+            {
+                case TAG_CARDTYPE.HERO:
+                    return GetLinesForHero();
+                case TAG_CARDTYPE.HERO_POWER:
+                    return GetLinesForHeroPower();
+                case TAG_CARDTYPE.WEAPON:
+                case TAG_CARDTYPE.ENCHANTMENT:
+                case TAG_CARDTYPE.MINION:
+                case TAG_CARDTYPE.SPELL:
+                    return GetLinesForNormalCard();
+                default:
+                    Log.Accessibility.PrintError($"AccessibleCollectibleCard: Found unhandled CardType {m_card.CardType}");
+                    return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            if (m_card.IsHeroSkin)
+            {
+                return GetLinesForHeroSkin();
+            }
+            else if (m_card.GetEntityDef().GetArmor() > 0) // TODO: Figure out how we can differentiate this as this is a wild guess
+            {
+                return GetLinesForHeroCard();
+            }
+            else
+            {
+                // Generic default just in case we're missing something
+                var lines = new List<string>();
+                lines.Add(GetName());
+
+                AccessibleCardUtils.AddLineIfExists(GetResources(), lines);
+
+                return lines;
+            }
+        }
+
+        private List<string> GetLinesForHeroCard()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (m_readClass)
+			{
+                lines.Add(GetClassName());
+			}
+
+            AddOwnedIfNeeded(lines);
+
+            lines.Add(GetCost());
+            lines.Add(GetCardType());
+
+            var armor = m_card.GetEntityDef().GetArmor();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            try
+            {
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(m_card.GetEntityDef().GetCardId()));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+		private string GetClassName()
+		{
+			return GameStrings.GetClassName(m_card.GetEntityDef().GetClass());
+		}
+
+		private List<string> GetLinesForHeroSkin()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (m_readFavorites && AccessibleCardUtils.ShouldShowFavoriteHeroText(m_card.GetEntityDef()))
+			{
+                lines.Add(GameStrings.Format("GLUE_COLLECTION_MANAGER_FAVORITE_DEFAULT_TEXT", GameStrings.GetClassName(m_card.GetEntityDef().GetClass())));
+			}
+            else if (m_readClass)
+			{
+                lines.Add(GetClassName());
+			}
+
+            AddOwnedIfNeeded(lines);
+
+            return lines;
+        }
+
+		private void AddOwnedIfNeeded(List<string> lines)
+		{
+            if (m_readOwned)
+			{
+                AccessibleCardUtils.AddOwnedLine(lines, GetNumCopies());
+			}
+		}
+
+		private List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            string className = null;
+            if (m_readClass)
+			{
+                className = GetClassName();
+			}
+
+            var lines = new List<string>();
+
+            if (IsCoin())
+			{
+				AddCoinName(lines);
+				AddFavoriteCoinIfNeeded(lines);
+                AddOwnedIfNeeded(lines);
+
+				lines.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_card.GetEntityDef(), m_card.PremiumType));
+			}
+            else
+			{
+				lines.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_card.GetEntityDef(), m_card.PremiumType, className, m_readOwned, GetNumCopies()));
+			}
+
+			AccessibleCardUtils.AddLineIfExists(GetCardCount(), lines);
+
+            return lines;
+        }
+
+		private bool IsCoin()
+		{
+            return CoinManager.Get()?.IsCoinCard(m_card) ?? false;
+		}
+
+		private void AddCoinName(List<string> lines)
+		{
+			var coinRecord = CoinManager.Get()?.GetCoinRecord(m_card);
+
+			if (coinRecord != null)
+			{
+				lines.Add(coinRecord.Name);
+			}
+		}
+
+		private void AddFavoriteCoinIfNeeded(List<string> lines)
+		{
+            if (!m_readFavorites)
+			{
+                return;
+			}
+
+            if (m_card.GetEntityDef().GetCardId().Equals(CoinManager.Get().GetFavoriteCoinCardId()))
+			{
+                lines.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_FAVORITE_COIN"));
+			}
+		}
+
+		private string GetDescription()
+        {
+            return m_card.CardInHandText;
+        }
+
+        private string GetCardType()
+        {
+            return AccessibleCardUtils.GetType(m_card.CardType);
+        }
+
+        private string GetRarity()
+        {
+            return AccessibleCardUtils.GetRarity(m_card.GetEntityDef());
+        }
+
+        private string GetCost()
+        {
+            return AccessibleCardUtils.GetCardCost(m_card.ManaCost);
+        }
+
+        private string GetCardCount()
+        {
+            if (!m_readCount)
+            {
+                return "";
+            }
+
+            var numCopies = GetNumCopies();
+
+            if (numCopies <= 1)
+            {
+                return "";
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_N_COPIES, numCopies);
+        }
+
+        private int GetNumCopies()
+		{
+            if (m_countOverride)
+            {
+                // Used by e.g. deck builder
+                return m_count;
+            }
+            else
+            {
+                return m_card.OwnedCount;
+            }
+		}
+
+        private string GetResources()
+        {
+            return AccessibleCardUtils.GetResourcesForEntityDef(m_card.GetEntityDef());
+        }
+
+        internal string GetName()
+        {
+            return AccessibleCardUtils.GetNameWithPremium(m_card.Name, m_card.PremiumType);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectionHeroPickerButton.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectionHeroPickerButton.cs
new file mode 100644
index 0000000..d1c5423
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectionHeroPickerButton.cs
@@ -0,0 +1,49 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionHeroPickerButton : AccessibleItem
+    {
+        private readonly HeroPickerButton m_button;
+
+        internal AccessibleCollectionHeroPickerButton(AccessibleComponent parent, HeroPickerButton button) : base(parent)
+        {
+            m_button = button;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            var heroClass = m_button.GetEntityDef().GetClass();
+            var className = GameStrings.GetClassName(heroClass);
+
+            if (className != null && className.Length > 0)
+            {
+                ret.Add(className);
+            }
+
+            var numHeroesForClass = GetCountOfHeroesForClass(heroClass);
+			var numHeroesOwnedForClass = CollectionManager.Get().GetCountOfHeroClassPlayerOwns(heroClass);
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_UNLOCK_PROGRESS, numHeroesOwnedForClass, numHeroesForClass));
+
+            return ret;
+        }
+
+		private int GetCountOfHeroesForClass(TAG_CLASS heroClass)
+		{
+			List<CollectibleCard> cards = CollectionManager.Get().FindCards(null, null, null, null, minOwned: 0, isHero: true, theseClassTypes: new TAG_CLASS[1] { heroClass }).m_cards;
+            var uniqueHeroes = new HashSet<int>(); // Keep track of IDs so golden skins and similar things don't interfere
+
+            cards.ForEach(c => uniqueHeroes.Add(c.CardDbId));
+
+            return uniqueHeroes.Count;
+		}
+
+		internal HeroPickerButton GetHeroPickerButton()
+        {
+            return m_button;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleComponent.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleComponent.cs
new file mode 100644
index 0000000..3523cc1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleComponent.cs
@@ -0,0 +1,6 @@
+﻿namespace Accessibility
+{
+    public interface AccessibleComponent
+    {
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs
new file mode 100644
index 0000000..af45324
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs
@@ -0,0 +1,119 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleDropdownControl : AccessibleElement
+    {
+        private readonly DropdownControl m_dropdown;
+
+        private Action m_onDone;
+
+        private AccessibleMenu m_menu;
+
+        internal AccessibleDropdownControl(AccessibleComponent parent, DropdownControl dropdown, Action onDone) : base(parent)
+        {
+            m_dropdown = dropdown;
+            m_onDone = onDone;
+
+            SetupMenu();
+        }
+
+        private void SetupMenu()
+        {
+            m_menu = new AccessibleMenu(m_parent, "", OnBackPressed, true);
+            
+            foreach(var item in m_dropdown.m_items)
+            {
+                m_menu.AddOption(item.m_text.Text, () => SelectItem(item));
+            }
+        }
+
+        private void OnBackPressed()
+        {
+            m_dropdown.m_cancelCatcher.TriggerRelease();
+            m_onDone();
+        }
+
+        private void SelectItem(DropdownMenuItem item)
+        {
+            item.TriggerRelease();
+            m_onDone();
+        }
+
+        public void HandleInput()
+        {
+            m_menu?.HandleAccessibleInput();
+            /*if (GlobalAccessibleMenuUtils.ReadNextIsPressed())
+            {
+                ReadNextItem(1);
+            }
+            else if (GlobalAccessibleMenuUtils.ReadPrevIsPressed())
+            {
+                ReadNextItem(-1);
+            }
+            else if (GlobalAccessibleMenuUtils.BackIsPressed() || GlobalAccessibleMenuUtils.ConfirmIsPressed())
+            {
+                m_onDone();
+            }*/
+        }
+
+        private void ReadNextItem(int inc)
+        {
+            var selectedItem = GetSelectedItem();
+            var curIndex = FindItemIndex(selectedItem);
+            var targetIndex = curIndex + inc;
+            var numItems = m_dropdown.m_items.Count;
+
+            if (targetIndex >= numItems)
+            {
+                targetIndex = curIndex;
+            }
+            else if (targetIndex < 0)
+            {
+                targetIndex = 0;
+            }
+
+            var newItem = m_dropdown.m_items[targetIndex];
+            newItem.TriggerRelease();
+
+            StartReading();
+        }
+
+        public void StartReading()
+        {
+            /*var selectedItem = GetSelectedItem();
+
+            var curItemName = selectedItem?.m_text?.Text;
+            var curItemNumber = FindItemIndex(selectedItem) + 1;
+            var numItems = m_dropdown.m_items.Count;
+
+            AccessibilityMgr.Output(AccessibleSpeech.MENU_OPTION(curItemName, curItemNumber, numItems));*/
+
+            var selectedItem = GetSelectedItem();
+            var curItemIndex = FindItemIndex(selectedItem);
+            m_menu.SetIndex(curItemIndex);
+            m_menu.StartReading();
+            m_dropdown.m_button.TriggerRelease();
+        }
+
+        private DropdownMenuItem GetSelectedItem()
+        {
+            return m_dropdown.m_selectedItem;
+        }
+
+        private int FindItemIndex(DropdownMenuItem item)
+        {
+            for (int i = 0; i < m_dropdown.m_items.Count; i++)
+            {
+                if (m_dropdown.m_items[i].GetValue().Equals(item.GetValue()))
+                {
+                    return i;
+                }
+            }
+
+            return 0;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleElement.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleElement.cs
new file mode 100644
index 0000000..cc94417
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleElement.cs
@@ -0,0 +1,17 @@
+﻿namespace Accessibility
+{
+    public class AccessibleElement
+    {
+        protected AccessibleComponent m_parent;
+
+        public AccessibleElement(AccessibleComponent parent)
+        {
+            m_parent = parent;
+        }
+
+        protected void Output(string text)
+        {
+            AccessibilityMgr.Output(m_parent, text);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
new file mode 100644
index 0000000..34c93b1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
@@ -0,0 +1,78 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleEndGameScreen : AccessibleScreen
+    {
+        private static AccessibleEndGameScreen s_instance = new AccessibleEndGameScreen();
+
+        private PegUIElement m_continue;
+
+        private AccessibleMultilineText s_curText;
+
+        internal static AccessibleEndGameScreen Get()
+        {
+            return s_instance;
+        }
+
+        internal void OnShow()
+        {
+            s_curText = null;
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        internal void OnShown(PegUIElement hitbox)
+        {
+            m_continue = hitbox;
+
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_continue.TriggerRelease();
+            }
+            else
+			{
+                s_curText?.HandleAccessibleInput();
+			}
+        }
+
+		public void OnGainedFocus()
+        {
+        }
+
+		internal void OnDebugEndGameScreen(PegUIElement debugClickCatcher)
+		{
+            OnShown(debugClickCatcher);
+		}
+
+		internal void OnDebugEndGameScreenHide()
+		{
+            m_continue = null;
+
+            AccessibilityMgr.SetScreen(AccessibleHub.Get());
+		}
+
+        public void SetupLines(List<string> lines)
+		{
+            // Allow components to set up accessible lines so players can reread
+            // TODO: Refactor all of this once we start integrating reprompts
+            s_curText = new AccessibleMultilineText(this, lines, lines.Count - 1);
+		}
+
+		public void ClearLines()
+		{
+            s_curText = null;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs
new file mode 100644
index 0000000..9259009
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs
@@ -0,0 +1,110 @@
+﻿using Hearthstone.DataModels;
+using Hearthstone.UI;
+using System;
+
+namespace Accessibility
+{
+    class AccessibleGameModeScene : AccessibleScreen
+    {
+        private enum State { LOADING, MAIN_MENU };
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_mainMenu;
+
+        private GameModeSceneDataModel m_gameModeSceneDataModel;
+
+        private static AccessibleGameModeScene s_instance = new AccessibleGameModeScene();
+
+        internal static AccessibleGameModeScene Get()
+        {
+            return s_instance;
+        }
+
+        public void OnDisplayReady(GameModeSceneDataModel gameModeSceneDataModel)
+        {
+            try
+            {
+                m_gameModeSceneDataModel = gameModeSceneDataModel;
+
+                SetupMainMenu();
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE), OnClickBackButton);
+
+            m_mainMenu.AddOption(LocalizedText.MODES_SOLO_ADVENTURES_OPTION, OnClickSoloAdventures);
+            m_mainMenu.AddOption(LocalizedText.SCREEN_GO_BACK, OnClickBackButton);
+
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void OnClickBackButton()
+        {
+            GameModeDisplay.Get().m_backButton.TriggerRelease();
+        }
+
+        private void OnClickSoloAdventures()
+        {
+            var soloAdventuresButton = GetSoloAdventuresButton();
+
+            if (soloAdventuresButton == null)
+            {
+                AccessibilityUtils.LogFatalError(new Exception("Could not find solo adventures button"));
+            }
+
+            GameModeDisplay.Get().SelectMode(soloAdventuresButton);
+            GameModeDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        private GameModeButtonDataModel GetSoloAdventuresButton()
+        {
+            foreach (var button in m_gameModeSceneDataModel.GameModeButtons)
+            {
+                if (button.GameModeRecordId == 6)
+                {
+                    return button;
+                }
+            }
+
+            return null;
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                default:
+                    break;
+            }
+
+            return "";
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu.StartReading();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
new file mode 100644
index 0000000..f8339a1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
@@ -0,0 +1,2592 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleGameplay : AccessibleScreen
+    {
+        protected enum AccessibleGamePhase
+        {
+            WAITING_FOR_GAME_TO_START,
+            MULLIGAN,
+            WAITING_FOR_OPPONENT_MULLIGAN,
+            PLAYING,
+            GAME_OVER
+        }
+
+        protected enum AccessibleGameState
+        {
+            UNKNOWN,
+            WAITING,
+            OPPONENT_TURN,
+            MAIN_OPTION_MODE,
+            SUB_OPTION_MODE,
+            TARGET_MODE,
+            CHOICE_MODE,
+            SUMMONING_MINION,
+            PLAYING_CARD,
+            TRADING_CARD,
+            CONFIRMING_END_TURN,
+            BROWSING_HISTORY,
+            ALL_MINIONS_TO_FACE,
+
+            // Battlegrounds-only
+            BUYING_MINION,
+            SELLING_MINION,
+            MOVING_MINION,
+            READING_LEADERBOARD,
+        }
+
+        private static AccessibleGameplay s_instance;
+
+        protected AccessibleGamePhase m_curPhase;
+
+        protected AccessibleGameState m_curState;
+
+        protected AccessibleGameState m_prevState;
+
+        protected GameState.ResponseMode m_curResponseMode;
+        protected GameState.ResponseMode m_prevResponseMode;
+
+        protected Zone m_curZone;
+
+        protected AccessibleCard m_cardBeingRead;
+
+        protected Card m_heldCard;
+
+        protected bool m_playerTurn;
+
+        private bool m_confirmingEndTurn;
+
+        private bool m_sendingAllMinionsToFace;
+        private Card m_curFaceAttacker;
+
+        private float m_nextAction = 0; // Needed to circumvent a lot of frame-related issues that would arise otherwise
+
+        // Choice mode
+        protected AccessibleListOfItems<AccessibleCard> m_accessibleChoiceCards;
+
+        // Mulligan
+        protected AccessibleListOfItems<AccessibleCard> m_accessibleMulliganCards;
+        private Dictionary<AccessibleCard, bool> m_mulliganMarkedForReplacement;
+        protected NormalButton m_mulliganConfirmButton;
+        private bool m_waitingForMulliganReplacementCards;
+
+        protected bool m_justReconnected;
+
+        private bool m_tradingCard;
+        private bool m_tradingCardWaitingForHold; // Used to prevent "Summon?" or "Play?" when a card is traded straight from hand but we still need to wait for it to be held
+
+        internal static AccessibleGameplay Get()
+        {
+            if (s_instance == null)
+			{
+                InitInstance();
+			}
+
+            return s_instance;
+        }
+
+		private static void InitInstance()
+		{
+            if (AccessibleGameplayUtils.IsFindingOrPlayingBattlegrounds())
+			{
+				s_instance = new AccessibleBattlegroundsGameplay();
+			}
+            else
+			{
+                s_instance = new AccessibleGameplay();
+			}
+		}
+
+		public void OnTurnStart()
+        {
+            try
+            {
+                AccessiblePowerTaskListDescriber.Get().OnTurnStart();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnCoinResult(bool friendlyPlayerGoesFirst)
+        {
+            if (friendlyPlayerGoesFirst)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOU_GO_FIRST));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_GOES_FIRST));
+            }
+        }
+
+        public void OnStartingHand(List<Card> cards)
+        {
+			try
+			{
+				if (AccessibilityUtils.IsInPvPGame())
+				{
+					var opponent = GameState.Get().GetOpposingSidePlayer();
+					var opponentName = opponent.GetName();
+					var opponentClass = opponent.GetHero().GetClass();
+					var opponentClassName = GameStrings.GetClassName(opponentClass);
+					AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_VS_PLAYER_ANNOUNCEMENT, opponentName, opponentClassName));
+				}
+			}
+			catch (Exception e)
+			{
+				AccessibilityUtils.LogFatalError(e);
+			}
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_YOU_START_WITH_N_CARDS, cards.Count));
+		}
+
+		public virtual void EndMulligan()
+        {
+            try
+            {
+                if (m_accessibleMulliganCards != null)
+                {
+                    var originalCards = new HashSet<Card>(m_accessibleMulliganCards.Count);
+                    m_accessibleMulliganCards.Items.ForEach(c => originalCards.Add(c.GetCard()));
+                    var cardsAfterMulligan = GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCards();
+                    var newCards = new List<Card>();
+                    var droppedCards = new List<Card>();
+
+                    foreach (var card in originalCards)
+                    {
+                        if (!cardsAfterMulligan.Contains(card))
+                        {
+                            droppedCards.Add(card);
+                        }
+                    }
+
+                    foreach (var card in cardsAfterMulligan)
+                    {
+                        if (!originalCards.Contains(card) && !IsCoinCard(card.GetEntity()))
+                        {
+                            newCards.Add(card);
+                        }
+                    }
+
+                    if (droppedCards.Count > 0)
+                    {
+                        var droppedNames = AccessibleSpeechUtils.GetNames(droppedCards);
+                        var newNames = AccessibleSpeechUtils.GetNames(newCards);
+
+                        AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARDS, newNames));
+                    }
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            TransitionFromMulliganToGame();
+        }
+
+		protected void TransitionFromMulliganToGame()
+		{
+            m_accessibleMulliganCards = null;
+            m_waitingForMulliganReplacementCards = false;
+
+            OnGameStart();
+		}
+
+		private bool IsCoinCard(Entity entity)
+        {
+            return entity.GetCardId() == CoinManager.Get()?.GetFavoriteCoinCardId();
+        }
+
+        public void OnMulliganCardsDealt(List<Card> cards)
+        {
+        }
+
+        public void OnGameplayScreenStart()
+        {
+            Reset();
+
+            InitInstance();
+            s_instance.Reset();
+
+            AccessibilityMgr.SetScreen(s_instance);
+        }
+
+        protected virtual void Reset()
+        {
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            m_curState = AccessibleGameState.UNKNOWN;
+            m_prevState = AccessibleGameState.UNKNOWN;
+            m_curResponseMode = GameState.ResponseMode.NONE;
+            m_prevResponseMode = GameState.ResponseMode.NONE;
+            m_curZone = null;
+            m_cardBeingRead = null;
+            m_heldCard = null;
+            m_playerTurn = false;
+            m_confirmingEndTurn = false;
+            m_sendingAllMinionsToFace = false;
+            m_curFaceAttacker = null;
+            m_nextAction = 0;
+            m_accessibleChoiceCards = null;
+            m_zoneSelectedListeners.Clear();
+            m_cardSelectedListeners.Clear();
+            m_summoningMinionListeners.Clear();
+            m_stopHidingMouse = false;
+            m_waitingForMulliganReplacementCards = false;
+            m_tradingCard = false;
+            m_tradingCardWaitingForHold = false;
+            AccessibleHistoryMgr.Get().Reset();
+        }
+
+		public void OnCoinCard()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOU_GET_THE_COIN));
+        }
+
+        public virtual void WaitingForOpponentToFinishMulligan()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_WAITING_FOR_OPPONENT));
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN;
+        }
+
+        public void OnDrawCard(Card card)
+        {
+        }
+
+        private void SetCardBeingRead(Card card, bool forceZoneRead)
+        {
+            m_cardBeingRead = AccessibleCard.CreateCard(this, card);
+            var prevZone = m_curZone;
+            m_curZone = card.GetZone();
+            ReadZoneChangeIfNecessary(card, prevZone, m_curZone, forceZoneRead);
+        }
+
+		protected void ReadZoneChangeIfNecessary(Card card, Zone fromZone, Zone toZone, bool forceZoneRead)
+        {
+            if (fromZone == toZone && !forceZoneRead)
+            {
+                return;
+            }
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            if (card.GetEntity() == player.GetHeroPower())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO_POWER));
+            }
+            else if (card.GetEntity() == opponent.GetHeroPower())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HERO_POWER));
+            }
+            else if (card == player.GetWeaponCard())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_WEAPON));
+            }
+            else if (card == opponent.GetWeaponCard())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_WEAPON));
+            }
+            else if (toZone == player.GetHandZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HAND));
+            }
+            else if (toZone == opponent.GetHandZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HAND)); // Not needed atm
+            }
+            else if (toZone == player.GetBattlefieldZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_MINIONS));
+            }
+            else if (toZone == opponent.GetBattlefieldZone())
+            {
+                ReadOpponentZoneName();
+            }
+            else if (toZone == player.GetSecretZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_SECRETS));
+            }
+            else if (toZone == opponent.GetSecretZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_SECRETS)); // Not needed atm
+            }
+        }
+
+		protected virtual void ReadOpponentZoneName()
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_MINIONS));
+		}
+
+		public virtual void HandleInput()
+        {
+            if (GameState.Get() == null || InputManager.Get() == null)
+            {
+                // Game hasn't even started yet
+                return;
+            }
+
+            if (GameState.Get().IsMulliganPhase())
+            {
+                m_curPhase = AccessibleGamePhase.MULLIGAN;
+            }
+            else if (GameState.Get().IsGameOver())
+            {
+                m_curPhase = AccessibleGamePhase.GAME_OVER;
+            }
+            else if (GameState.Get().IsMulliganPhasePending())
+			{
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+			}
+            else if (GameState.Get().IsGameCreated())
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+            }
+            else
+            {
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                HandleTooltipReading();
+            }
+
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.PLAYING:
+                    HandleInGameInput();
+                    break;
+                case AccessibleGamePhase.MULLIGAN:
+                    HandleMulliganInput();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+		private void HandleMulliganInput()
+        {
+            if (m_accessibleMulliganCards == null)
+            {
+                return; // yield
+            }
+
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+            }
+
+            if (AccessibleKey.MULLIGAN_MARK_CARD.IsPressed())
+            {
+                var focusedCard = m_accessibleMulliganCards.GetItemBeingRead();
+                AccessibleInputMgr.MoveMouseTo(focusedCard.GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+                m_mulliganMarkedForReplacement[focusedCard] = !m_mulliganMarkedForReplacement[focusedCard];
+
+                if (m_mulliganMarkedForReplacement[focusedCard])
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_WILL_BE_REPLACED));
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED));
+                }
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_mulliganConfirmButton.TriggerRelease();
+
+                // Prevent flicker while the game starts and new cards are drawn
+                m_waitingForMulliganReplacementCards = true;
+                HideMouse();
+            }
+            else if (!m_waitingForMulliganReplacementCards)
+            {
+                m_accessibleMulliganCards.HandleAccessibleInput();
+                MoveMouseToCard(m_accessibleMulliganCards.GetItemBeingRead().GetCard());
+            }
+        }
+
+        private void HandleInGameInput()
+        {
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GAMEPLAY_YOUR_TURN);
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GAMEPLAY_OPPONENT_TURN);
+                }
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+                AccessiblePowerTaskListDescriber.Get().OnReconnected();
+            }
+
+            UpdateState();
+
+            if (m_curState == AccessibleGameState.ALL_MINIONS_TO_FACE)
+            {
+                HandleAllMinionsToFace();
+                return;
+            }
+            else if (m_curState == AccessibleGameState.TRADING_CARD)
+            {
+                HandleTradingCard();
+                return;
+            }
+
+            try
+            {
+                UpdateMousePosition();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            if (m_curState == AccessibleGameState.CONFIRMING_END_TURN)
+            {
+                if (AccessibleKey.CONFIRM.IsPressedDown() || AccessibleKey.END_TURN.IsPressedDown())
+                {
+                    EndTurn();
+                    return;
+                }
+                else if (Input.anyKeyDown)
+                {
+                    m_confirmingEndTurn = false;
+                }
+            }
+
+            if ((m_curState == AccessibleGameState.OPPONENT_TURN || m_curState == AccessibleGameState.MAIN_OPTION_MODE) && HandleEmotes())
+            {
+                return;
+            }
+
+            switch(m_curState)
+            {
+                case AccessibleGameState.WAITING:
+                case AccessibleGameState.UNKNOWN:
+                case AccessibleGameState.OPPONENT_TURN:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleZoneInput();
+                    HandleValidOptionsSelectionInput();
+                    HandleZoneSelection();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleMainOptionMode();
+                    HandleEndTurnInput();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    HandleCheckStatusKeys();
+                    HandleSubOptionMode();
+                    return;
+                case AccessibleGameState.CHOICE_MODE:
+                    HandleCheckStatusKeys();
+                    HandleChoiceMode();
+                    return;
+                case AccessibleGameState.TARGET_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleTargetMode();
+                    return;
+                case AccessibleGameState.SUMMONING_MINION:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleSummoningMinion();
+                    HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.PLAYING_CARD:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandlePlayingCard();
+                    HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.BROWSING_HISTORY:
+                    HandleHistoryInput();
+                    return;
+                default:
+                    return;
+            }
+        }
+
+		protected void HandleTooltipReading()
+        {
+            AccessibilityUtils.ReadTooltip(this);
+        }
+
+        private void HandleAllMinionsToFace()
+        {
+            if (Time.time < m_nextAction)
+            {
+                return;
+            }
+
+            if (m_curFaceAttacker != null)
+            {
+                ClickCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+                m_curFaceAttacker = null;
+                SetNextAction();
+            }
+            else
+            {
+                List<Card> remainingAttackers = GetValidFaceAttackers();
+
+                if (remainingAttackers.Count > 0)
+                {
+                    m_curFaceAttacker = remainingAttackers[0];
+                    ClickCard(m_curFaceAttacker);
+                    SetNextAction();
+                }
+                else
+                {
+                    m_sendingAllMinionsToFace = false;
+                }
+            }
+        }
+
+        private void SetNextAction()
+        {
+            m_nextAction = Time.time + 1.0f;
+        }
+
+        private void ClickCard(Card card)
+        {
+            MoveMouseToCard(card);
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        private void UpdateMousePosition()
+        {
+            if (m_heldCard != null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead != null)
+            {
+                MoveMouseToCard(m_cardBeingRead.GetCard());
+            }
+            else
+            {
+                HideMouse();
+            }
+        }
+
+        private void HideMouse()
+        {
+            if (!m_stopHidingMouse)
+            {
+                AccessibleInputMgr.HideMouse();
+            }
+        }
+
+        private void HandleTradeCardWhenHoldingCardInput()
+        {
+            if (AccessibleKey.TRADE_CARD.IsPressed() && CanTradeCard(m_heldCard))
+            {
+                QueryTradeCard();
+            }
+        }
+
+        private void QueryTradeCard()
+        {
+            m_tradingCard = true;
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_TRADE_CARD));
+        }
+
+        private bool CanTradeCard(Card card)
+        {
+            if (card == null || card.GetZone() != GameState.Get().GetFriendlySidePlayer().GetHandZone())
+            {
+                return false;
+            }
+
+            return card.GetEntity().IsTradeable();
+        }
+
+        private int m_summonPos;
+
+        protected void HandleSummoningMinion()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION));
+                    OnSummoningMinion(m_heldCard);
+                }
+
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    m_summonPos = playerMinions.GetLastPos();
+                    QuerySummonPosition(0);
+                }
+
+                HandleSummoningPositionInput();
+
+                if (m_summonPos == playerMinions.GetLastPos())
+                {
+                    MoveMouseToRightOfZone(playerMinions);
+                }
+                else if (m_summonPos == 1)
+                {
+                    MoveMouseToLeftOfZone(playerMinions);
+                }
+                else
+                {
+                    var prevMinion = playerMinions.GetCardAtPos(m_summonPos - 1);
+                    var nextMinion = playerMinions.GetCardAtPos(m_summonPos);
+                    var pos = prevMinion.transform.position + (nextMinion.transform.position - prevMinion.transform.position) / 2;
+                    AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+                }
+            }
+
+            HandleConfirmOrCancel();
+        }
+
+        private void HandleSummoningPositionInput()
+        {
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                QuerySummonPosition(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                QuerySummonPosition(1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+			{
+                m_summonPos = 1;
+                QuerySummonPosition(0);
+			}
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+			{
+				var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+				var lastPos = playerMinions.GetLastPos();
+                m_summonPos = lastPos;
+                QuerySummonPosition(0);
+			}
+            else
+			{
+				int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+                if (numKeyPressed.HasValue)
+				{
+					var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+					var lastPos = playerMinions.GetLastPos();
+
+                    m_summonPos = Math.Min(lastPos, numKeyPressed.Value);
+                    QuerySummonPosition(0);
+				}
+			}
+        }
+
+        private void QuerySummonPosition(int inc)
+        {
+            var prevSummonPos = m_summonPos;
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var lastPos = playerMinions.GetLastPos();
+
+            m_summonPos += inc;
+
+            if (m_summonPos > lastPos)
+            {
+                m_summonPos = lastPos;
+            }
+            else if (m_summonPos < 1)
+            {
+                m_summonPos = 1;
+            }
+
+            if (inc != 0 && prevSummonPos == m_summonPos)
+            {
+                return;
+            }
+
+            if (m_summonPos == lastPos)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT));
+                OnSummoningMinion(m_heldCard);
+            }
+            else if (m_summonPos == 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT));
+                OnSummoningMinion(m_heldCard);
+            }
+            else
+            {
+                var prevMinion = playerMinions.GetCardAtPos(m_summonPos - 1);
+                var nextMinion = playerMinions.GetCardAtPos(m_summonPos);
+                var prevMinionName = GetPreferredCardName(prevMinion);
+                var nextMinionName = GetPreferredCardName(nextMinion);
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN, prevMinionName, nextMinionName));
+                OnSummoningMinion(m_heldCard);
+            }
+        }
+
+        protected virtual string GetPreferredCardName(Card card)
+		{
+            return card.GetEntity().GetName();
+		}
+
+		protected void HandlePlayingCard()
+        { 
+            if (AccessibleUnityInput.Get().GetMousePosition().y < AccessibleInputMgr.GetMousePosition(GameState.Get().GetFriendlySidePlayer().GetHeroCard()).y)
+            {
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                HandleTargetMode();
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.PLAYING_CARD && !RequiresTarget(m_heldCard)) // If a target is required, "choose a target" will already indicate we're using it
+                {
+                    QueryPlayCard();
+                }
+
+                HandleConfirmOrCancel();
+            }
+        }
+
+        private void HandleTradingCard()
+        {
+            Collider collider = Board.Get().GetTradeArea();
+            if (collider != null)
+            {
+                var cardBounds = m_heldCard.GetActor().GetMeshRenderer().bounds;
+                Vector3 tradeAreaCenter = collider.bounds.ClosestPoint(m_heldCard.gameObject.transform.position);
+                Vector3 target = tradeAreaCenter;
+                target.x += cardBounds.size.x / 2;
+                AccessibleInputMgr.MoveMouseToWorldPosition(target);
+            }
+
+            HandleConfirmOrCancel();
+        }
+
+        private bool RequiresTarget(Card heldCard)
+        {
+            return GameState.Get().EntityHasTargets(heldCard.GetEntity());
+        }
+
+        private void QueryPlayCard()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_PLAY_CARD));
+        }
+
+        private void HandleConfirmOrCancel(bool targetRequired=false)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (!targetRequired || m_cardBeingRead != null)
+                {
+                    AccessibleInputMgr.ClickLeftMouseButton();
+                }
+            }
+            else if (AccessibleKey.BACK.IsPressed())
+            {
+                CancelOption();
+            }
+        }
+
+        private void HandleEndTurnInput()
+        {
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                return;
+            }
+
+            if (AccessibleKey.FORCE_END_TURN.IsPressedDown())
+            {
+                EndTurn();
+            }
+
+            if (AccessibleKey.END_TURN.IsPressedDown())
+            {
+                if (EndTurnButton.Get().HasNoMorePlays())
+                {
+                    EndTurn();
+                }
+                else
+                {
+                    if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK));
+                    }
+                    else if (PlayerCanStillUseHeroPower())
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER));
+                    }
+                    else
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS));
+                    }
+
+                    StopReadingCard();
+                    m_confirmingEndTurn = true;
+                }
+            }
+        }
+
+        private bool PlayerCanStillUseHeroPower()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var heroPower = player.GetHeroPower();
+
+            if (heroPower == null)
+            {
+                return false;
+            }
+
+            return GameState.Get().HasResponse(heroPower);
+        }
+
+        private void HandleMainOptionMode()
+        {
+            if (AccessibleKey.SEND_ALL_MINIONS_TO_FACE.IsPressed())
+            {
+                SendAllMinionsToFace();
+                return;
+            }
+
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                ClickCard();
+            }
+            else if (AccessibleKey.TRADE_CARD.IsPressed() && m_cardBeingRead != null && CanTradeCard(m_cardBeingRead.GetCard()))
+            {
+                QueryTradeCard();
+                ClickCard(true);
+            }
+        }
+
+        private void SendAllMinionsToFace()
+        {
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_NO_MINIONS));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeAttacked())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeTargetedByOpponents())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED));
+                return;
+            }
+
+            List<Card> validAttackers = GetValidFaceAttackers();
+
+            if (validAttackers.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS));
+            }
+            else
+            {
+                m_sendingAllMinionsToFace = true;
+            }
+        }
+
+        public void OnReconnected()
+        {
+            AccessibilityMgr.InterruptTexts();
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_RECONNECTED);
+
+            m_justReconnected = true;
+        }
+
+        private List<Card> GetValidFaceAttackers()
+        {
+            List<Card> ret = new List<Card>();
+            List<Entity> faceTargetters = GetOptionsWithTarget(GameState.Get().GetOpposingSidePlayer().GetHero());
+
+            foreach (var entity in faceTargetters)
+            {
+                if (entity.GetCard()?.GetZone() == GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone())
+                {
+                    ret.Add(entity.GetCard());
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Entity> GetOptionsWithTarget(Entity target)
+        {
+            List<Entity> ret = new List<Entity>();
+            Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+
+            if (optionsPacket == null) {
+                return ret;
+            }
+
+            for (int i = 0; i < optionsPacket.List.Count; i++)
+            {
+                Network.Options.Option option = optionsPacket.List[i];
+                if (option.Type == Network.Options.Option.OptionType.POWER)
+                {
+                    if (option.Main.IsValidTarget(target.GetEntityId()))
+                    {
+                        ret.Add(GameState.Get().GetEntity(option.Main.ID));
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private void EndTurn()
+        {
+            InputManager.Get().DoEndTurnButton();
+            StopReadingCard();
+        }
+
+        protected void HandleSubOptionMode()
+        {
+            HandleChoiceMode();
+        }
+
+        protected void HandleChoiceMode()
+        {
+            if (m_accessibleChoiceCards == null || !m_accessibleChoiceCards.IsReading())
+            {
+                return; // yield
+            }
+
+            try
+            {
+                m_cardBeingRead = m_accessibleChoiceCards.GetItemBeingRead();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                AccessibleInputMgr.MoveMouseTo(m_cardBeingRead.GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+            }
+            else
+            {
+                m_accessibleChoiceCards.HandleAccessibleInput();
+            }
+        }
+
+        protected void HandleTargetMode()
+        {
+            //if (m_prevState != AccessibleGameState.TARGET_MODE) // Was broken due to play
+            if (m_prevResponseMode != m_curResponseMode)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_TARGET));
+
+                if (m_cardBeingRead != null && m_cardBeingRead.GetCard().GetZone() == GameState.Get().GetFriendlySidePlayer().GetHandZone())
+                {
+                    StopReadingCard(false);
+                }
+            }
+
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection(true);
+
+            HandleConfirmOrCancel(true);
+        }
+
+        private void UpdateState()
+        {
+            try
+            {
+                UpdateCardBeingReadState();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            m_heldCard = InputManager.Get().GetHeldCard();
+            m_playerTurn = GameState.Get().IsFriendlySidePlayerTurn();
+
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                m_confirmingEndTurn = false;
+            }
+
+			// TODO: Debug this properly as I think this is the flow causing the tab right after choose one issues
+			ResetChoiceCardsIfNecessary();
+
+            if (m_heldCard == null)
+            {
+                m_tradingCard = false;
+            }
+            else if (m_tradingCardWaitingForHold && CanTradeCard(m_heldCard))
+            {
+                // Additional check via CanTradeCard to prevent potential race conditions around turns ending in-between trades/selections
+                m_tradingCardWaitingForHold = false;
+                m_tradingCard = true;
+            }
+
+            m_prevState = m_curState;
+            m_prevResponseMode = m_curResponseMode;
+            m_curResponseMode = GameState.Get().GetResponseMode();
+
+            // Proper states
+            if (!m_playerTurn)
+            {
+                m_curState = AccessibleGameState.OPPONENT_TURN;
+                m_sendingAllMinionsToFace = false;
+            } 
+            else if (m_sendingAllMinionsToFace)
+            {
+                m_curState = AccessibleGameState.ALL_MINIONS_TO_FACE;
+            }
+            else if (m_tradingCard)
+            {
+                m_curState = AccessibleGameState.TRADING_CARD;
+            }
+            else if (m_confirmingEndTurn)
+            {
+                m_curState = AccessibleGameState.CONFIRMING_END_TURN;
+            }
+            else if (AccessibleHistoryMgr.Get().IsReadingHistory())
+            {
+                m_curState = AccessibleGameState.BROWSING_HISTORY;
+            }
+            else if (m_heldCard != null)
+            {
+                if (m_heldCard.GetEntity().IsMinion())
+                {
+                    m_curState = AccessibleGameState.SUMMONING_MINION;
+                }
+                else if (GameState.Get().IsInMainOptionMode())
+                {
+                    m_curState = AccessibleGameState.PLAYING_CARD;
+                }
+            }
+            else if (GameState.Get().IsInMainOptionMode())
+            {
+                m_curState = AccessibleGameState.MAIN_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                m_curState = AccessibleGameState.SUB_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                m_curState = AccessibleGameState.CHOICE_MODE;
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                m_curState = AccessibleGameState.TARGET_MODE;
+            } 
+            else
+            {
+                // Normally happens in between turns (i.e. after button press but before response) due to network time
+                m_curState = AccessibleGameState.UNKNOWN;
+            }
+
+            if (m_curState != AccessibleGameState.BROWSING_HISTORY)
+            {
+                // Reset history in case turn ends while we're reading history or something
+                AccessibleHistoryMgr.Get().StopReadingHistory();
+            }
+        }
+
+		protected void ResetChoiceCardsIfNecessary()
+		{
+			if (m_prevState != m_curState && (m_prevState == AccessibleGameState.CHOICE_MODE || m_prevState == AccessibleGameState.SUB_OPTION_MODE))
+            {
+                if (!ChoiceCardMgr.Get()?.IsFriendlyShown() ?? false)
+				{
+					// Potential race condition when multiple choices happen in a game
+					m_accessibleChoiceCards = null;
+				}
+			}
+		}
+
+		protected void UpdateCardBeingReadState()
+        {
+            if (m_cardBeingRead == null || m_curZone == null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead.GetCard().GetZone() != m_curZone)
+            {
+                StopReadingCard();
+            }
+        }
+
+        protected void StopReadingCard(bool hideMouse=true)
+        {
+            m_cardBeingRead = null;
+            m_curZone = null;
+
+            if (hideMouse)
+            {
+                HideMouse();
+            }
+        }
+
+        protected void HandleZoneSelection(bool minionsAndHeroesOnly = false)
+        {
+            if (AccessibleKey.SEE_PLAYER_HAND.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerHand();
+            }
+            else if (IsSeePlayerSecretsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerSecrets();
+            }
+            else if (IsSeeOpponentSecretsPressed() && !minionsAndHeroesOnly)
+            {
+                SeeOpponentSecrets();
+            }
+            else if (AccessibleKey.SEE_PLAYER_MINIONS.IsPressed())
+            {
+                SeePlayerMinions();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MINIONS.IsPressed())
+            {
+                SeeOpponentMinions();
+            }
+            else if (IsSeeOpponentHeroPressed())
+            {
+                SeeOpponentHero();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HERO.IsPressed())
+            {
+                SeePlayerHero();
+            }
+            else if (IsSeePlayerHeroPowerPressed())
+            {
+                SeePlayerHeroPower();
+            }
+            else if (IsSeeOpponentHeroPowerPressed())
+            {
+                SeeOpponentHeroPower();
+            }
+            else if (AccessibleKey.SEE_PLAYER_WEAPON.IsPressed())
+            {
+                SeePlayerWeapon();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_WEAPON.IsPressed())
+            {
+                SeeOpponentWeapon();
+            }
+        }
+
+		private bool IsSeePlayerSecretsPressed()
+		{
+            return AccessibleKey.SEE_PLAYER_SECRETS.IsPressed();
+		}
+
+		private bool IsSeeOpponentSecretsPressed()
+		{
+            return AccessibleKey.SEE_OPPONENT_SECRETS.IsPressed();
+		}
+
+        protected virtual bool IsSeeOpponentHeroPressed()
+		{
+            return AccessibleKey.SEE_OPPONENT_HERO.IsPressed();
+		}
+
+        protected virtual bool IsSeePlayerHeroPowerPressed()
+		{
+            return AccessibleKey.SEE_PLAYER_HERO_POWER.IsPressed();
+		}
+
+        protected virtual bool IsSeeOpponentHeroPowerPressed()
+		{
+            return AccessibleKey.SEE_OPPONENT_HERO_POWER.IsPressed();
+		}
+
+		private void HandleHistoryInput()
+        {
+            AccessibleHistoryMgr.Get().HandleAccessibleInput();
+        }
+
+        protected virtual void HandleCheckStatusKeys()
+        {
+            if (AccessibleKey.SEE_PLAYER_MANA.IsPressed())
+            {
+                ReadPlayerResources();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MANA.IsPressed())
+            {
+                ReadOpponentResources();
+            }
+            else if (AccessibleKey.SEE_PLAYER_DECK.IsPressed())
+            {
+                ReadPlayerDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_DECK.IsPressed())
+            {
+                ReadOpponentDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HAND.IsPressed())
+            {
+                ReadOpponentHand();
+            }
+        }
+
+        protected void HandleCardReadingInput()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            if (AccessibleKey.READ_ORIGINAL_CARD_STATS.IsPressed() && m_cardBeingRead.GetCard().GetEntity().IsMinion())
+            {
+                ReadBigCard();
+            }
+            else
+            {
+                m_cardBeingRead.HandleAccessibleInput();
+            }
+        }
+
+        private void ReadBigCard()
+        {
+            ReadBigCardStats();
+
+            var bigCard = BigCard.Get();
+            if (bigCard != null && bigCard.GetCard() != null && bigCard.isActiveAndEnabled)
+            {
+                // Banner (e.g. turns until this revives: 2 on BoH valeera 5)
+                var bannerText = bigCard.m_enchantmentBanner?.m_EnchantmentBannerText;
+
+                if (bannerText?.gameObject.activeInHierarchy ?? false)
+				{
+                    AccessibilityMgr.Output(this, bannerText.Text);
+				}
+
+                // Normal enchantments
+                var enchantments = bigCard.m_enchantmentBanner?.m_enchantmentPool?.GetActiveList();
+                foreach (var enchantment in enchantments)
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GLOBAL_ENCHANTMENT);
+                    AccessibilityMgr.Output(this, enchantment.m_HeaderText.Text);
+                    AccessibilityMgr.Output(this, enchantment.m_BodyText.Text);
+                }
+            }
+        }
+
+		private void ReadBigCardStats()
+		{
+            var entity = m_cardBeingRead.GetCard().GetEntity();
+
+            if (AccessibleCardUtils.HasHiddenStats(entity))
+			{
+                // e.g. BoH Valeera 06
+                return;
+			}
+
+			var atk = entity.GetEntityDef().GetATK();
+			var hp = entity.GetEntityDef().GetHealth();
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp));
+		}
+
+		protected void SeeOpponentMinions()
+        {
+            var opponentMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+
+            if (opponentMinions.GetCardCount() == 0)
+            {
+                ReadOpponentMinionsEmpty();
+            }
+            else
+            {
+                SeeZone(opponentMinions);
+            }
+        }
+
+		protected virtual void ReadOpponentMinionsEmpty()
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY));
+		}
+
+		protected void SeePlayerMinions()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerMinions);
+            }
+        }
+
+        protected void SeePlayerSecrets()
+        {
+            var playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+
+            if (playerSecrets.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerSecrets);
+            }
+        }
+
+        protected void SeeOpponentSecrets()
+        {
+            var opponentSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone();
+
+            if (opponentSecrets.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY));
+            }
+            else
+            {
+                SeeZone(opponentSecrets);
+            }
+        }
+
+
+        protected void SeeOpponentHero()
+        {
+            FocusOnCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), false);
+        }
+
+        protected void SeePlayerHero()
+        {
+            FocusOnCard(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), false);
+        }
+
+        protected void SeePlayerHeroPower()
+        {
+            var heroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY));
+            }
+        }
+
+        protected void SeeOpponentHeroPower()
+        {
+            var heroPower = GameState.Get().GetOpposingSidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY));
+            }
+        }
+
+        protected virtual void SeePlayerWeapon()
+        {
+            var weapon = GameState.Get().GetFriendlySidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY));
+            }
+        }
+
+        protected virtual void SeeOpponentWeapon()
+        {
+            var weapon = GameState.Get().GetOpposingSidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY));
+            }
+        }
+
+        private void ClickCard(bool tradingCard=false)
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            if (tradingCard)
+            {
+                m_tradingCardWaitingForHold = true;
+            }
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        internal virtual void ReadPlayerResources()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int availableMana = player.GetNumAvailableResources();
+            int totalMana = player.GetTag(GAME_TAG.RESOURCES);
+
+            if (availableMana != totalMana)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL, availableMana, totalMana));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA, availableMana));
+            }
+
+            // Overloaded crystals this turn
+            var overloadedMana = player.GetTag(GAME_TAG.OVERLOAD_OWED);
+            if (overloadedMana > 0)
+			{
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_OVERLOADED_MANA, overloadedMana));
+			}
+
+            // Locked crystals due to overload last turn
+            var lockedMana = player.GetTag(GAME_TAG.OVERLOAD_LOCKED);
+            if (lockedMana > 0)
+			{
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_LOCKED_MANA, lockedMana));
+			}
+        }
+
+        internal virtual void ReadOpponentResources()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            int totalMana = opponent.GetTag(GAME_TAG.RESOURCES);
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_MANA, totalMana));
+
+            // Overloaded crystals this turn
+            var overloadedMana = opponent.GetTag(GAME_TAG.OVERLOAD_OWED);
+            if (overloadedMana > 0)
+			{
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA, overloadedMana));
+			}
+        }
+
+        protected void HandleZoneInput()
+        {
+            if (m_curZone == null)
+            {
+                return;
+            }
+
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                ReadCardInZone(numKeyPressed.Value);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos + 1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos - 1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+            {
+                ReadCardInZone(1);
+            }
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+            {
+                ReadCardInZone(m_curZone.GetCardCount());
+            }
+        }
+
+		protected void HandleValidOptionsSelectionInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard();
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard(true);
+            }
+        }
+
+        private void FindNextValidCard(bool reverseDirection = false)
+        {
+            List<Card> candidates = GetCandidateOptions();
+            List<Card> validOptions = GetValidOptions(candidates);
+
+            if (validOptions.Count == 0)
+            {
+                OnNoValidPlays();
+                return;
+            }
+            else if (validOptions.Count == 1)
+            {
+                // The old interface read "no more valid options" instead of reading the focused card again when this happened
+                // However, quite a few players found it confusing and often mistakenly ended their turn as "no more valid options" is quite similar to "no valid plays"
+                FocusOnCard(validOptions[0], true);
+            }
+
+            if (GameState.Get().IsInTargetMode() && m_cardBeingRead?.GetCard() == GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard())
+            {
+                m_cardBeingRead = null;
+            }
+
+            if (m_cardBeingRead == null)
+            {
+                if (reverseDirection)
+                {
+                    FocusOnCard(validOptions[validOptions.Count - 1], false);
+                    return;
+                }
+                else
+                {
+                    FocusOnCard(validOptions[0], false);
+                    return;
+                }
+            }
+
+            int curCardIndex = 0;
+            for (int i = 0; i < candidates.Count; i++)
+            {
+                if (candidates[i] == m_cardBeingRead.GetCard())
+                {
+                    curCardIndex = i;
+                }
+            }
+
+            int inc = reverseDirection ? -1 : 1;
+
+            for (int toRead = candidates.Count - 1, i = curCardIndex + inc; toRead > 0; toRead--, i += inc)
+            {
+                if (i < 0)
+                {
+                    i = candidates.Count - 1;
+                }
+                else if (i >= candidates.Count)
+                {
+                    i = 0;
+                }
+
+                var card = candidates[i];
+
+                if (IsValidOption(card))
+                {
+                    FocusOnCard(card, false);
+                    return;
+                }
+            }
+        }
+
+        private List<Card> GetValidOptions(List<Card> candidates)
+        {
+            var ret = new List<Card>();
+
+            foreach (var card in candidates)
+            {
+                if (IsValidOption(card))
+                {
+                    ret.Add(card);
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Card> GetCandidateOptions()
+        {
+            var cycleFriendlyEntitiesFirst = true;
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                var source = GameState.Get().GetSelectedNetworkOption();
+                var sourceEntity = GameState.Get().GetEntity(source.Main.ID);
+
+                if (CardEffectInterpreter.GetEffect(sourceEntity.GetCardId()) == CardEffectInterpreter.CardEffect.UNFRIENDLY)
+                {
+                    cycleFriendlyEntitiesFirst = false;
+                }
+            }
+
+            var ret = new List<Card>();
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerWeapon = player.GetWeaponCard();
+            var playerHero = player.GetHeroCard();
+            var playerHeroPower = player.GetHeroPowerCard();
+            var opponentWeapon = opponent.GetWeaponCard();
+            var opponentHero = opponent.GetHeroCard();
+            var opponentHeroPower = opponent.GetHeroPowerCard();
+
+            var playerEntities = new List<Card>();
+            var opponentEntities = new List<Card>();
+
+            playerEntities.AddRange(player.GetHandZone().GetCards());
+            if (playerWeapon != null) playerEntities.Add(playerWeapon);
+            if (playerHero != null) playerEntities.Add(playerHero);
+            if (playerHeroPower != null) playerEntities.Add(playerHeroPower);
+            playerEntities.AddRange(player.GetBattlefieldZone().GetCards());
+
+            opponentEntities.AddRange(opponent.GetBattlefieldZone().GetCards());
+            if (opponentHero != null) opponentEntities.Add(opponentHero);
+            if (opponentWeapon != null) opponentEntities.Add(opponentWeapon);
+            if (opponentHeroPower != null) opponentEntities.Add(opponentHeroPower);
+
+            if (cycleFriendlyEntitiesFirst)
+            {
+                ret.AddRange(playerEntities);
+                ret.AddRange(opponentEntities);
+            }
+            else
+            {
+                ret.AddRange(opponentEntities);
+                ret.AddRange(playerEntities);
+            }
+
+
+            return ret;
+        }
+
+        private bool IsValidOption(Card card)
+        {
+            if (card == null)
+            {
+                return false;
+            }
+
+            Entity entity = card.GetEntity();
+
+            if (GameState.Get().IsInMainOptionMode())
+            {
+                return GameState.Get().IsValidOption(entity);
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                return GameState.Get().IsValidSubOption(entity);
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                return GameState.Get().IsChoice(entity);
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                return GameState.Get().IsValidOptionTarget(entity, true);
+            }
+
+            return false;
+        }
+
+        private int GetCardBeingReadPosition()
+        {
+            for (int i = 1; i <= m_curZone.GetCardCount(); i++)
+            {
+                if (m_curZone.GetCardAtPos(i) == m_cardBeingRead.GetCard())
+                {
+                    return i;
+                }
+            }
+
+            return 0;
+        }
+
+        private void ReadCardInZone(int pos)
+        {
+            Card card = m_curZone.GetCardAtPos(pos);
+
+            if (card != null)
+            {
+                FocusOnCard(card, false);
+            }
+        }
+
+		private void FocusOnCard(Card card, bool forceZoneRead)
+        {
+            SetCardBeingRead(card, forceZoneRead);
+
+            var speech = m_cardBeingRead.GetLine(0);
+
+            var zonePos = card.GetZone().FindCardPos(card); // card.GetZonePosition() isn't trustworthy. Wasn't working for secrets
+
+            if (ShouldReadCardAsList(card))
+            {
+                AccessibilityMgr.Output(this, AccessibleSpeech.MENU_OPTION(speech, zonePos, card.GetZone().GetCardCount()));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, speech);
+            }
+            MoveMouseToCard(card);
+            OnCardSelected(card, m_cardBeingRead);
+        }
+
+        protected bool ShouldReadCardAsList(Card card)
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var cardZone = card.GetZone();
+
+            return cardZone == player.GetHandZone() ||
+                cardZone == opponent.GetHandZone() ||
+                cardZone == player.GetBattlefieldZone() ||
+                cardZone == opponent.GetBattlefieldZone() ||
+                cardZone == player.GetSecretZone() ||
+                cardZone == opponent.GetSecretZone();
+        }
+
+        protected virtual void MoveMouseToCard(Card card)
+        {
+            if (card.GetZone()?.GetType() == typeof(ZoneHand))
+            {
+				if (!card.IsMousedOver())
+                {
+                    // Note: All of this code was added to trace a rare edge case some players have fallen into with cards such as shadowstep.
+                    // I haven't been able to reproduce so far but I think the bug has something to do with a NPE somewhere in the actor/manaObject chain
+                    // TODO: Clean all of this up once the bug is detected/fixed
+                    try
+					{
+						AccessibleInputMgr.MoveMouseTo(card.GetActor().m_manaObject.transform);
+					}
+                    catch(Exception e)
+					{
+                        AccessibilityUtils.LogFatalError(e);
+                        AccessibilityUtils.LogFatalError($"card.GetActor(): {card.GetActor()}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject: {card.GetActor()?.m_manaObject}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject?.transform: {card.GetActor()?.m_manaObject?.transform}");
+                        AccessibilityUtils.LogFatalError($"card.GetEntity()?.GetCardId(): {card.GetEntity()?.GetCardId()}");
+
+                        if (card.GetActor() != null)
+						{
+                            if (card.GetActor().m_attackObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_attackObject.transform);
+                            else if (card.GetActor().m_healthObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_healthObject.transform);
+                            else AccessibilityUtils.LogFatalError("Unable to recover - Aborting MoveMouseToCard");
+						}
+                    }
+				}
+            }
+            else
+            {
+                AccessibleInputMgr.MoveMouseTo(card);
+            }
+        }
+
+		private void MoveMouseToZone(Zone zone)
+        {
+            Vector3 zoneCenter = zone.GetComponent<Collider>().bounds.center;
+            AccessibleInputMgr.MoveMouseToWorldPosition(zoneCenter);
+        }
+
+        protected void MoveMouseToRightOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x += bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        protected void MoveMouseToLeftOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x -= bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        private void CancelOption()
+        {
+            AccessibleInputMgr.ClickRightMouseButton();
+            HideMouse();
+        }
+
+        internal virtual void ReadOpponentHand()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetHandZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_HAND, numCards));
+        }
+
+        internal virtual void ReadPlayerDeck()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int numCards = player.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_DECK, numCards));
+        }
+
+        internal virtual void ReadOpponentDeck()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_DECK, numCards));
+        }
+
+        internal Card GetSelectedCard()
+        {
+            return m_cardBeingRead?.GetCard();
+        }
+
+        protected void SeePlayerHand()
+        {
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            if (playerHand.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerHand);
+            }
+        }
+
+        private void SeeZone(Zone zone)
+        {
+            if (zone == null)
+            {
+                return;
+            }
+
+            Card card = zone.GetCardAtPos(1);
+
+            if (card != null) // Race conditions
+            {
+                FocusOnCard(card, true);
+            }
+        }
+
+        private void OnGameStart()
+        {
+            try
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+                m_curState = AccessibleGameState.WAITING;
+                AccessibleHistoryMgr.Get().Reset();
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        protected void OnGameOver(TAG_PLAYSTATE playState, object userData)
+        {
+            m_curPhase = AccessibleGamePhase.GAME_OVER;
+
+            AccessibilityMgr.Output(this, GetGameOverMessage(playState));
+        }
+
+        private string GetGameOverMessage(TAG_PLAYSTATE playState)
+        {
+            switch (playState)
+            {
+                case TAG_PLAYSTATE.WON:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_WON);
+                case TAG_PLAYSTATE.LOST:
+                case TAG_PLAYSTATE.CONCEDED:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_LOST);
+                case TAG_PLAYSTATE.TIED:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_TIED);
+                default:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_GENERIC);
+            }
+        }
+
+        public void OnRevealDrawnOpponentCard(Card card)
+        {
+        }
+
+        public void OnDrawUnknownOpponentCard(Card card)
+        {
+        }
+
+        public void OnCardToDeck(Card card)
+        {
+        }
+
+        public void OnShowBigCard(HistoryCard card)
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug($"Card played: {card.GetEntity().GetName()} / type = {card.m_historyInfoType}");
+
+                if (card.m_historyInfoType == HistoryInfoType.CARD_PLAYED)
+                {
+                    OnCardPlayed(card.OriginTaskList, card.GetEntity());
+                }
+                else if (card.m_historyInfoType == HistoryInfoType.TRIGGER)
+                {
+                    OnCardTriggered(card.OriginTaskList, card.GetEntity());
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void OnCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardTriggered(taskList, card);
+        }
+
+        private void OnCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardPlayed(taskList, card);
+        }
+
+        public void OnChoice(List<Card> cards, Banner choiceBanner, NormalButton confirmChoiceButton)
+        {
+            // Clear up any previous choices
+            m_accessibleChoiceCards = null;
+            StopReadingCard();
+
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(AccessibleCard.CreateCard(this, c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+
+                AccessibilityMgr.Output(this, choiceBanner.m_headline.Text);
+                m_accessibleChoiceCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubOption(List<Card> cards)
+        {
+            // Clear up any previous choices
+            m_accessibleChoiceCards = null;
+            StopReadingCard();
+
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(AccessibleCard.CreateCard(this, c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_ONE));
+                m_accessibleChoiceCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnMulliganChoiceStart(List<Card> startingCards, NormalButton mulliganConfirmButton)
+        {
+            try
+            {
+                m_mulliganConfirmButton = mulliganConfirmButton;
+
+                var accessibleCards = new List<AccessibleCard>(startingCards.Count);
+                startingCards.ForEach(c => accessibleCards.Add(AccessibleCard.CreateCard(this, c)));
+
+                m_accessibleMulliganCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+                m_mulliganMarkedForReplacement = new Dictionary<AccessibleCard, bool>();
+                accessibleCards.ForEach(c => m_mulliganMarkedForReplacement.Add(c, false));
+
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN));
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS));
+                m_accessibleMulliganCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Help
+        public virtual string GetHelp()
+        {
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.WAITING_FOR_GAME_TO_START:
+                    return GetWaitingForGameToStartHelp();
+                case AccessibleGamePhase.MULLIGAN:
+                    return GetMulliganHelp();
+                case AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN:
+                    return GetWaitingForOpponentHelp();
+                case AccessibleGamePhase.PLAYING:
+                    return GetPlayingHelp();
+                case AccessibleGamePhase.GAME_OVER:
+                    return GetGameOverHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetGameOverHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_GENERIC);
+        }
+
+        protected virtual string GetPlayingHelp()
+        {
+            if (EmoteHandler.Get()?.AreEmotesActive() ?? false)
+			{
+                return m_accessibleEmotes?.GetHelp();
+			}
+            else if (EnemyEmoteHandler.Get()?.AreEmotesActive() ?? false)
+			{
+                return m_accessibleEnemyEmotes?.GetHelp();
+			}
+
+            switch (m_curState)
+            {
+                case AccessibleGameState.OPPONENT_TURN:
+                    return GetOpponentTurnHelp();
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    return GetMainOptionModeHelp();
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    return GetSubOptionModeHelp();
+                case AccessibleGameState.TARGET_MODE:
+                    return GetTargetModeHelp();
+                case AccessibleGameState.CHOICE_MODE:
+                    return GetChoiceModeHelp();
+                case AccessibleGameState.SUMMONING_MINION:
+                    return GetSummoningMinionHelp();
+                case AccessibleGameState.PLAYING_CARD:
+                    return GetPlayingCardHelp();
+                case AccessibleGameState.CONFIRMING_END_TURN:
+                    return GetConfirmingEndTurnHelp();
+                case AccessibleGameState.BROWSING_HISTORY:
+                    return GetBrowsingHistoryHelp();
+                case AccessibleGameState.TRADING_CARD:
+                    return GetTradingCardHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetWaitingForOpponentHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_WAITING_FOR_OPPONENT);
+        }
+
+        protected virtual string GetMulliganHelp()
+        {
+            return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_MULLIGAN_HELP, AccessibleKey.MULLIGAN_MARK_CARD, AccessibleKey.CONFIRM);
+        }
+
+        private string GetWaitingForGameToStartHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START);
+        }
+
+        private string GetBrowsingHistoryHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_READ_HISTORY_HELP);
+        }
+
+        private string GetConfirmingEndTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CONFIRM_END_TURN_HELP);
+        }
+
+        private string GetPlayingCardHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+        }
+
+        private string GetTradingCardHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_2_5);
+        }
+
+        private string GetSummoningMinionHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_SUMMON_MINION_HELP);
+        }
+
+        private string GetChoiceModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        private string GetTargetModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOOSE_TARGET_HELP);
+        }
+
+        private string GetSubOptionModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        protected virtual string GetMainOptionModeHelp()
+        {
+            if (m_cardBeingRead != null)
+            {
+                return NarrateMainOptionWhenCardBeingRead();
+            }
+            else
+            {
+                return NarrateMainOption();
+            }
+        }
+
+        private string NarrateMainOption()
+        {
+            var speeches = GetMainOptionSpeeches(false);
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        private List<HSASpeech> GetMainOptionSpeeches(bool hasReadEndTurn, bool readManaFirst=false)
+        {
+            var playerHasValidOptions = PlayerHasValidOptions();
+
+            var speeches = new List<HSASpeech>();
+
+            if (!hasReadEndTurn && !playerHasValidOptions)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+            }
+
+            if (readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_VALID_OPTIONS);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HAND_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetSecretZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_SECRETS_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP);
+            }
+
+            if (GameState.Get().GetOpposingSidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_HERO_HELP);
+
+            if (GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP);
+            }
+
+            // Counts
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_PLAYER_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_HAND_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP);
+            }
+
+            if (!readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_MANA_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_OPEN_HISTORY_LOG_HELP);
+            }
+
+            return speeches;
+        }
+
+        private bool IsPlayingTutorial()
+        {
+            var gameEntity = GameState.Get().GetGameEntity();
+
+            return gameEntity.GetType().IsSubclassOf(typeof(TutorialEntity));
+        }
+
+        private bool PlayerHasValidOptions()
+        {
+            var candidates = GetCandidateOptions();
+            return GetValidOptions(candidates).Count > 0;
+        }
+
+        private string NarrateMainOptionWhenCardBeingRead()
+        {
+            var card = m_cardBeingRead.GetCard();
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            var playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var playerHero = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+            var playerHeroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+
+            var speeches = new List<HSASpeech>();
+
+            var hasReadEndTurn = false;
+
+            if (!PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                hasReadEndTurn = true;
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_HELP);
+
+            if (TooltipPanelManager.Get()?.GetTooltipPanels()?.Count > 0 || TutorialKeywordManager.Get()?.GetPanels()?.Count > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_TOOLTIP_HELP);
+            }
+
+            var readManaFirst = false;
+
+            if (IsValidOption(card))
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+
+                    if (card.GetEntity().IsTradeable())
+                    {
+                        speeches.Add(AccessibleSpeech.GAMEPLAY_TRADE_CARD_HELP);
+                    }
+                }
+                else if (card.GetZone() == playerBattlefield)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_MINION_HELP);
+                }
+                else if (card == playerHero)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_HERO_HELP);
+                }
+                else if (card == playerHeroPower)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_USE_HERO_POWER_HELP);
+                }
+            }
+            else
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    readManaFirst = true;
+                }
+            }
+
+            speeches.AddRange(GetMainOptionSpeeches(hasReadEndTurn, readManaFirst));
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        protected virtual string GetOpponentTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_OPPONENT_TURN_VOICE);
+        }
+
+        private string GetOrNarrateHelpSpeech(HSASpeech speech)
+        {
+            if (IsPlayingTutorial())
+            {
+                AccessibilityMgr.NarrateHelp(speech);
+                return "";
+            }
+            else
+            {
+                return speech.GetLocalizedText();
+            }
+        }
+
+        private string GetOrNarrateHelpSpeeches(List<HSASpeech> speeches)
+        {
+            if (IsPlayingTutorial())
+            {
+                AccessibilityMgr.NarrateHelp(speeches.ToArray());
+                return "";
+            }
+            else
+            {
+                var lines = new List<string>(speeches.Count);
+                speeches.ForEach(s => lines.Add(s.GetLocalizedText()));
+
+                return AccessibleSpeechUtils.CombineLines(lines);
+            }
+        }
+
+        #endregion Help
+
+        public void OnGainedFocus()
+        {
+            // TODO: Think about this but we probably don't want to say anything given that no one will forget they're playing a game
+        }
+
+        #region Tutorial stuff
+        private Dictionary<Zone, Action> m_zoneSelectedListeners = new Dictionary<Zone, Action>();
+        private Dictionary<Card, Action<AccessibleCard>> m_cardSelectedListeners = new Dictionary<Card, Action<AccessibleCard>>();
+        private Dictionary<Card, Action> m_summoningMinionListeners = new Dictionary<Card, Action>();
+
+        private void OnZoneSelected(Zone zone)
+        {
+            if (m_zoneSelectedListeners.ContainsKey(zone))
+            {
+                m_zoneSelectedListeners[zone]();
+                m_zoneSelectedListeners.Remove(zone);
+            }
+        }
+
+		private void OnCardSelected(Card card, AccessibleCard accessibleCard)
+        {
+            OnZoneSelected(card.GetZone());
+
+            if (m_cardSelectedListeners.ContainsKey(card))
+            {
+                m_cardSelectedListeners[card](accessibleCard);
+                m_cardSelectedListeners.Remove(card);
+            }
+        }
+
+        private void OnSummoningMinion(Card card)
+        {
+            if (m_summoningMinionListeners.ContainsKey(card))
+            {
+                m_summoningMinionListeners[card]();
+                m_summoningMinionListeners.Remove(card);
+            }
+        }
+
+        internal void RegisterZoneSelectedListener(Zone zone, Action action)
+        {
+            m_zoneSelectedListeners[zone] = action;
+        }
+
+        internal void RegisterCardSelectedListener(Card card, Action<AccessibleCard> action)
+        {
+            m_cardSelectedListeners[card] = action;
+        }
+
+        internal void RegisterSummoningCardListener(Card card, Action action)
+        {
+            m_summoningMinionListeners[card] = action;
+        }
+
+        private Action m_noValidPlaysListener;
+
+        internal void RegisterNoValidPlaysListener(Action action)
+        {
+            m_noValidPlaysListener = action;
+        }
+
+        private void OnNoValidPlays()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_NO_VALID_PLAYS));
+            StopReadingCard();
+
+            if (m_noValidPlaysListener != null)
+            {
+                m_noValidPlaysListener();
+                m_noValidPlaysListener = null;
+            }
+        }
+
+		private bool m_stopHidingMouse;
+
+        // Useful for e.g. pack opening in the tutorial
+        internal void StopHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+
+        internal void StartHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+        #endregion
+
+        #region Emotes
+        private AccessibleMenu m_accessibleEmotes;
+        private AccessibleMenu m_accessibleEnemyEmotes;
+
+		internal void OnEmotesShown(List<EmoteOption> availableEmotes)
+		{
+            m_accessibleEmotes = new AccessibleMenu(this, "", EmoteHandler.Get().HideEmotes, false, true);
+
+            foreach (var emote in availableEmotes)
+			{
+                m_accessibleEmotes.AddOption(emote.m_Text.Text, emote.DoClick);
+			}
+
+            m_accessibleEmotes.StartReading();
+		}
+
+		internal void OnEnemyEmotesShown(string curSquelchText)
+		{
+            m_accessibleEnemyEmotes = new AccessibleMenu(this, "", EnemyEmoteHandler.Get().HideEmotes, false, true);
+
+			m_accessibleEnemyEmotes.AddOption(curSquelchText, EnemyEmoteHandler.Get().DoSquelchClick);
+
+			m_accessibleEnemyEmotes.StartReading();
+		}
+
+		private bool HandleEmotes()
+		{
+            if (EmoteHandler.Get()?.AreEmotesActive() ?? false)
+			{
+                m_accessibleEmotes?.HandleAccessibleInput();
+                return true;
+			}
+            else if (EnemyEmoteHandler.Get()?.AreEmotesActive() ?? false)
+			{
+                m_accessibleEnemyEmotes?.HandleAccessibleInput();
+                return true;
+			}
+            else if (AccessibleKey.SPACE.IsPressed())
+			{
+				if (m_cardBeingRead == null)
+				{
+					return false;
+				}
+
+				var entity = m_cardBeingRead.GetCard().GetEntity();
+
+				if (!entity.IsHero() || entity.GetZone() != TAG_ZONE.PLAY)
+				{
+					return false;
+				}
+
+                if (entity.IsControlledByFriendlySidePlayer())
+				{
+					EmoteHandler.Get()?.ShowEmotes();
+					return true;
+				}
+                else
+				{
+					EnemyEmoteHandler.Get()?.ShowEmotes();
+                    return true;
+				}
+			}
+
+            return false;
+		}
+        #endregion
+
+        #region Battlegrounds-only
+
+		internal virtual void OnBattlegroundsCombatPhasePopupShown()
+		{
+			// No-op
+		}
+
+		internal virtual void OnBattlegroundsShopPhasePopupShown()
+		{
+            // No-op
+		}
+
+		internal virtual void OnFreezeOrUnfreezeEvent()
+		{
+            // No-op
+		}
+
+		internal virtual void OnOpponentHeroChanged()
+		{
+			// No-op
+		}
+
+		internal virtual void OnAnyHeroGainedAtk()
+		{
+			// No-op
+		}
+
+		internal virtual void OnPlayerAvailableResourcesChanged(int before, int after)
+		{
+            // No-op
+		}
+
+		internal virtual void OnTurnEnded()
+		{
+            // No-op
+		}
+
+		internal virtual void OnFirstTaskListStart()
+		{
+			// No-op
+		}
+
+		internal virtual void OnMainStepEnd()
+		{
+            // No-op
+		}
+
+		internal virtual void OnEnterMultiplayerWaitingArea(List<Card> startingCards, string mulliganBannerText, string mulliganBannerSubtitleText, NormalButton confirmButton)
+		{
+            // No-op
+		}
+
+		internal virtual void OnMainActionStep()
+		{
+			// No-op
+		}
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplayUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplayUtils.cs
new file mode 100644
index 0000000..ee68336
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplayUtils.cs
@@ -0,0 +1,79 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleGameplayUtils
+    {
+        internal static bool IsPlayingTutorial()
+        {
+            return GameState.Get().GetGameEntity() is TutorialEntity;
+        }
+
+        internal static bool IsPlayingBattlegrounds()
+        {
+            return GameMgr.Get().IsPlayingBattlegrounds();
+        }
+
+        internal static bool IsInBattlegroundsShopPhase()
+		{
+            return IsPlayingBattlegrounds() && IsInBattlegroundsPhase(TB_BaconShop.GAME_PHASE_SHOP);
+		}
+
+        internal static bool IsInBattlegroundsCombatPhase()
+		{
+            return IsPlayingBattlegrounds() && IsInBattlegroundsPhase(TB_BaconShop.GAME_PHASE_COMBAT);
+		}
+
+        private static bool IsInBattlegroundsPhase(int phaseId)
+		{
+            var gameEntity = GameState.Get().GetGameEntity() as TB_BaconShop;
+
+            return gameEntity.GetCurPhase() == phaseId;
+		}
+
+		internal static bool IsFindingOrPlayingBattlegrounds()
+		{
+			if (GameMgr.Get().IsFindingGame())
+			{
+				return GameMgr.Get().IsPlayingBattlegrounds();
+			}
+            else
+			{
+				return IsPlayingBattlegrounds();
+			}
+		}
+
+		private static HashSet<string> s_battlegroundsSpecialCards = new HashSet<string>()
+		{
+			"TB_BaconShopTechUp02_Button", "TB_BaconShopTechUp03_Button", "TB_BaconShopTechUp04_Button", "TB_BaconShopTechUp05_Button", "TB_BaconShopTechUp06_Button",
+			"TB_BaconShopLockAll_Button", "TB_BaconShop_DragBuy", "TB_BaconShop_DragSell",
+			"TB_BaconShop_1p_Reroll_Button", "TB_BaconShop_8p_Reroll_Button", // TODO: Check if there's others
+		};
+
+		internal static bool IsBattlegroundsSpecialCard(Entity card)
+		{
+			if (card == null)
+			{
+                return false;
+			}
+
+			return s_battlegroundsSpecialCards.Contains(card.GetCardId());
+		}
+
+		internal static bool ShouldNarrateBattlegroundsAttackPhase()
+		{
+			return Options.Get().GetBool(Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS);
+		}
+
+		internal static bool ToggleBattlegroundsAttackPhaseNarration()
+		{
+			var curState = ShouldNarrateBattlegroundsAttackPhase();
+			var newState = !curState;
+
+			Options.Get().SetBool(Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS, newState);
+
+			return newState;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
new file mode 100644
index 0000000..3291f55
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
@@ -0,0 +1,62 @@
+﻿using System;
+using System.Net;
+
+namespace Accessibility
+{
+    static class AccessibleHearthstoneApplication
+    {
+        internal static void OnLoading()
+        {
+            AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_LOADING_GAME));
+
+            Log.Accessibility.Print($"Hearthstone version: {HearthstoneAccessConstants.HEARTHSTONE_VERSION}");
+            Log.Accessibility.Print($"Hearthstone Access version: {HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION}");
+
+            if (HearthstoneAccessUpdateRequired())
+            {
+                AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE));
+            }
+        }
+
+        internal static void OnClosing()
+        {
+            AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_CLOSING_GAME));
+        }
+
+        private static bool HearthstoneAccessUpdateRequired()
+        {
+            try
+            {
+                var fileName = "hsa-version";
+                var hsaRepoUrl = HearthstoneAccessConstants.GetHearthstoneAccessRepoUrl();
+                var url = $"{hsaRepoUrl}/{HearthstoneAccessConstants.HEARTHSTONE_VERSION}/{fileName}";
+
+                ServicePointManager.Expect100Continue = true;
+                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;
+
+                using (WebClient wc = new WebClient())
+                {
+                    var githubToken = HearthstoneAccessConstants.GetGithubToken();
+                    if (githubToken != null)
+                    {
+                        // Dev only
+                        wc.Headers.Add("Authorization", $"token {githubToken}");
+                    }
+
+                    wc.Headers.Add(HttpRequestHeader.UserAgent, "HSA");
+
+                    var hsaVersion = wc.DownloadString(url);
+
+                    return !hsaVersion.Equals(HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION);
+                }
+            }
+            catch (Exception e)
+            {
+                // Not really fatal since we'll just keep going but let's log it as such in case someone runs into issues
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs
new file mode 100644
index 0000000..2709a4d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs
@@ -0,0 +1,67 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleHeroPickerButton : AccessibleItem
+    {
+        private readonly HeroPickerButton m_button;
+
+        private bool m_inCreateDeckMode;
+
+        internal AccessibleHeroPickerButton(AccessibleComponent parent, HeroPickerButton button, bool inCreateDeckMode=false) : base(parent)
+        {
+            m_button = button;
+            m_inCreateDeckMode = inCreateDeckMode;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_inCreateDeckMode)
+            {
+                return GetLinesForCreateDeckMode();
+            }
+            else
+            {
+                return GetLinesForAdventureMode();
+            }
+        }
+
+        private List<string> GetLinesForCreateDeckMode()
+        {
+            var ret = new List<string>();
+
+            var heroClass = GameStrings.GetClassName(m_button.GetEntityDef().GetClass());
+
+            if (heroClass != null && heroClass.Length > 0)
+            {
+                ret.Add(heroClass);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForAdventureMode()
+        {
+            var ret = new List<string>();
+
+            var heroName = m_button.GetEntityDef()?.GetName();
+
+            if (heroName != null && heroName.Length > 0)
+            {
+                ret.Add(heroName);
+            }
+
+            if (m_button.m_crown.activeInHierarchy)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE));
+            }
+
+            return ret;
+        }
+
+        internal HeroPickerButton GetHeroPickerButton()
+        {
+            return m_button;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
new file mode 100644
index 0000000..ed5a085
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
@@ -0,0 +1,126 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleHistoryMgr
+    {
+        private List<string> m_entries = new List<string>();
+
+        private int m_entryBeingReadIndex;
+
+        private bool m_readingHistory;
+
+        private static AccessibleHistoryMgr s_instance;
+
+        internal static AccessibleHistoryMgr Get()
+        {
+            if (s_instance == null)
+            {
+                s_instance = new AccessibleHistoryMgr();
+            }
+
+            return s_instance;
+        }
+
+        internal void AddEntry(string entry)
+        {
+            if (entry == null || entry.Length == 0)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"HIST add entry: {entry}");
+            m_entries.Add(entry);
+        }
+
+        internal void Reset()
+        {
+            AccessibilityUtils.LogDebug("HIST Reset");
+            m_entries.Clear();
+            m_entryBeingReadIndex = -1;
+            m_readingHistory = false;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.SEE_HISTORY.IsPressed() && !m_readingHistory)
+            {
+                StartReadingHistory();
+                return true;
+            }
+            else if (AccessibleKey.BACK.IsPressed() && m_readingHistory)
+            {
+                StopReadingHistory();
+                return true;
+            }
+            else if (m_readingHistory && AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex + 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex - 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadToEnd();
+            }
+
+            return false;
+        }
+
+        private void ReadToEnd()
+        {
+            for (int i = m_entryBeingReadIndex; i < m_entries.Count; i++)
+            {
+                ReadEntry(i);
+            }
+        }
+
+        private void StartReadingHistory()
+        {
+            if (m_entries.Count == 0)
+            {
+                AccessibilityMgr.Output(AccessibleGameplay.Get(),LocalizationUtils.Get(LocalizationKey.GAMEPLAY_HISTORY_LOG_EMPTY));
+            }
+            else
+            {
+                m_readingHistory = true;
+                ReadEntry(m_entries.Count - 1);
+            }
+        }
+
+        private void ReadEntry(int index)
+        {
+            if (index < 0 || index >= m_entries.Count)
+            {
+                return;
+            }
+
+            m_entryBeingReadIndex = index;
+
+            var curEntry = m_entries[m_entryBeingReadIndex];
+            AccessibilityMgr.Output(AccessibleGameplay.Get(), LocalizationUtils.Format(LocalizationKey.GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT, m_entryBeingReadIndex + 1, m_entries.Count, curEntry));
+        }
+
+        internal bool IsReadingHistory()
+        {
+            return m_readingHistory;
+        }
+
+        internal void StopReadingHistory()
+        {
+            if (m_readingHistory)
+            {
+                AccessibilityMgr.Output(AccessibleGameplay.Get(),LocalizationUtils.Get(LocalizationKey.GAMEPLAY_HISTORY_LOG_CLOSE));
+                m_entryBeingReadIndex = -1;
+                m_readingHistory = false;
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs
new file mode 100644
index 0000000..5d27e91
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs
@@ -0,0 +1,197 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class AccessibleHorizontalMenu<T> : AccessibleElement where T : AccessibleItem
+    {
+        private class MenuOption
+        {
+            internal T m_option;
+            internal Action m_onClickAction;
+            internal Action m_onReadAction;
+
+            internal MenuOption(T option, Action onClickAction)
+            {
+                m_option = option;
+                m_onClickAction = onClickAction;
+            }
+
+            internal MenuOption(T option, Action onClickAction, Action onReadAction)
+            {
+                m_option = option;
+                m_onClickAction = onClickAction;
+                m_onReadAction = onReadAction;
+            }
+        }
+
+        private string m_menuName;
+
+        private List<MenuOption> m_options;
+
+        private int m_curOptionIdx;
+
+        private Action m_goBackAction;
+
+        private bool m_isReading;
+
+        public AccessibleHorizontalMenu(AccessibleComponent parent, string menuName, Action goBackAction) : base(parent)
+        {
+            m_menuName = menuName;
+            m_options = new List<MenuOption>();
+            m_goBackAction = goBackAction;
+        }
+
+        public void AddOption(T option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(T option, Action onClickAction, Action onReadAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction, onReadAction));
+        }
+
+        public bool HandleAccessibleInput()
+        {
+            try
+            {
+                if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+                {
+                    return ReadNextOption(1);
+                }
+                else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+                {
+                    return ReadNextOption(-1);
+                }
+                else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+				{
+                    return ReadOption(0);
+				}
+                else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+				{
+                    return ReadOption(m_options.Count - 1);
+				}
+                else if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    return SelectOption();
+                }
+                else if (AccessibleKey.BACK.IsPressed())
+                {
+                    return GoBack();
+                }
+                else if (m_isReading)
+                {
+                    m_options[m_curOptionIdx].m_option.HandleAccessibleInput();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+
+        private bool ReadNextOption(int inc)
+        {
+            return ReadOption(m_curOptionIdx + inc);
+        }
+
+        private bool ReadOption(int optionIdx)
+        {
+            if (optionIdx < 0 || optionIdx >= m_options.Count)
+            {
+                return false;
+            }
+
+            m_curOptionIdx = optionIdx;
+            var curOption = m_options[m_curOptionIdx];
+            curOption.m_option.Reset();
+
+            var firstLine = curOption.m_option.GetLine(0);
+            var speech = AccessibleSpeech.MENU_OPTION(firstLine, m_curOptionIdx + 1, m_options.Count);
+            Output(speech);
+
+            if (curOption.m_onReadAction != null)
+            {
+                curOption.m_onReadAction();
+            }
+
+            return true;
+        }
+
+        private bool SelectOption()
+        {
+            if (!m_isReading || m_options.Count == 0)
+            {
+                return false;
+            }
+
+            m_options[m_curOptionIdx].m_onClickAction();
+
+            return true;
+        }
+
+        private bool GoBack()
+        {
+            if (m_goBackAction == null) {
+                return false;
+            }
+
+            m_goBackAction();
+
+            return true;
+        }
+
+        public void StartReading()
+        {
+            Output(m_menuName);
+
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public void SetIndex(int index)
+        {
+            m_curOptionIdx = index;
+        }
+
+        public string GetHelp()
+        {
+            if (m_options.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HORIZONTAL_HELP(m_goBackAction != null);
+            }
+        }
+
+        public void ReadCurrentOption()
+        {
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public int GetNumItems()
+        {
+            return m_options.Count;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs
new file mode 100644
index 0000000..359cd9b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs
@@ -0,0 +1,268 @@
+﻿using Hearthstone.Progression;
+using PegasusShared;
+using System;
+
+namespace Accessibility
+{
+    class AccessibleHub : AccessibleScreen
+    {
+        private enum State { LOADING, MAIN_MENU, PLAY_RANKED_MENU_CHOOSE_FORMAT };
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_mainMenu;
+
+        private static AccessibleHub s_instance = new AccessibleHub();
+
+        internal static AccessibleHub Get()
+        {
+            return s_instance;
+        }
+
+        public void OnHubOpened()
+        {
+            try
+            {
+                SetupMainMenu();
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizedText.HUB_MAIN_MENU_TITLE, null);
+
+            if (AccessibilityUtils.CanPlayPvP())
+			{
+                m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_RANKED), OnPlayRanked);
+                m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_CASUAL), PlayCasual);
+			}
+
+            m_mainMenu.AddOption(AccessibleKey.HUB_MODES, LocalizedText.HUB_GAME_MODES_OPTION, OnClickModes);
+            m_mainMenu.AddOption(AccessibleKey.HUB_BATTLEGROUNDS, LocalizedText.HUB_BATTLEGROUNDS_OPTION, OnClickBattlegrounds);
+            m_mainMenu.AddOption(AccessibleKey.HUB_MY_COLLECTION, LocalizedText.HUB_MY_COLLECTION_OPTION, OnClickMyCollection);
+            m_mainMenu.AddOption($"{LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS)} {Box.Get().m_OpenPacksButton.m_count.Text}", OnClickOpenPacks);
+			m_mainMenu.AddOption(AccessibleKey.HUB_JOURNAL, LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL), OnClickJournal);
+
+            if (AccessibilityUtils.CanSeeShop())
+			{
+				m_mainMenu.AddOption(AccessibleKey.HUB_SHOP, LocalizationUtils.Get(LocalizationKey.GLOBAL_SHOP), OnClickShop);
+			}
+
+			m_mainMenu.AddOption(LocalizedText.HUB_HELP_OPTION, OnClickHelp);
+            m_mainMenu.AddOption(LocalizedText.GAME_MENU_TITLE, OnClickGameMenu);
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_MENU_NAME), OnClickSocialMenu);
+
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void RereadMainMenu()
+		{
+            m_mainMenu?.StartReading();
+            m_curState = State.MAIN_MENU;
+		}
+
+        private void OnClickGameMenu()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_GAME_MENU, AccessibleKey.OPEN_GAME_MENU));
+        }
+
+        private void OnClickSocialMenu()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_SOCIAL_MENU, AccessibleKey.OPEN_SOCIAL_MENU));
+        }
+
+        private void OnClickHelp()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_HELP, AccessibleKey.HELP, AccessibleKey.TOGGLE_ACCESSIBILITY));
+        }
+
+        private void ClickPlay()
+        {
+            Box.Get().m_PlayButton.TriggerRelease();
+        }
+
+        private void OnClickModes()
+        {
+            Box.Get().m_GameModesButton.TriggerRelease();
+        }
+
+        private void OnClickBattlegrounds()
+        {
+            Box.Get().m_BattleGroundsButton.TriggerRelease();
+        }
+
+        private void OnClickMyCollection()
+        {
+            Box.Get().m_CollectionButton.TriggerRelease();
+        }
+
+        private void OnClickOpenPacks()
+        {
+            var openPacksButton = Box.Get().m_OpenPacksButton;
+            if (openPacksButton.m_numPacks < 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_PACK_OPENING_NO_CARD_PACKS));
+            }
+            else
+            {
+                Box.Get().m_OpenPacksButton.TriggerRelease();
+            }
+        }
+
+        private void OnClickJournal()
+        {
+            AccessibleWidgetUtils.TriggerButtonClicked(Box.Get().m_journalButtonWidget);
+        }
+
+        private void OnClickShop()
+        {
+            Box.Get().m_StoreButton.TriggerRelease();
+        }
+
+        #region Ranked and Casual
+        private AccessibleMenu m_playRankedChooseFormatMenu;
+
+        private void PlayCasual()
+		{
+            if (!AccessibleRankedUtils.PlayerHasCasualDecks())
+			{
+                NotifyNeedToBuildDeckFirst();
+                return;
+			}
+
+            Options.SetInRankedPlayMode(false);
+            Options.SetFormatType(FormatType.FT_STANDARD);
+            ClickPlay();
+		}
+
+        private void OnPlayRanked()
+		{
+            if (CollectionManager.Get().ShouldAccountSeeStandardWild())
+			{
+                ReadPlayRankedChooseFormatMenu();
+			}
+            else if (AccessibleRankedUtils.PlayerHasStandardDecks())
+			{
+                PlayRankedStandard();
+			}
+            else
+			{
+                NotifyNeedToBuildDeckFirst();
+			}
+		}
+
+		private void NotifyNeedToBuildDeckFirst()
+		{
+            AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_DECK"));
+		}
+
+		private void NotifyNoStandardDeck()
+		{
+            AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_STANDARD_DECK"));
+		}
+
+		private void NotifyNoClassicDeck()
+		{
+            AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_CLASSIC_DECK"));
+		}
+
+		private void EnterRankedMode(FormatType format)
+		{
+            Options.SetInRankedPlayMode(true);
+            Options.SetFormatType(format);
+            ClickPlay();
+		}
+
+		private void ReadPlayRankedChooseFormatMenu()
+		{
+            m_playRankedChooseFormatMenu = new AccessibleMenu(this, "", RereadMainMenu);
+
+            m_playRankedChooseFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_STANDARD), PlayRankedStandard);
+			m_playRankedChooseFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_WILD), PlayRankedWild);
+			m_playRankedChooseFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_CLASSIC), PlayRankedClassic);
+
+			m_playRankedChooseFormatMenu.StartReading();
+			m_curState = State.PLAY_RANKED_MENU_CHOOSE_FORMAT;
+		}
+
+		private void PlayRankedStandard()
+		{
+            if (!AccessibleRankedUtils.PlayerHasStandardDecks())
+			{
+                NotifyNoStandardDeck();
+                return;
+			}
+
+            EnterRankedMode(FormatType.FT_STANDARD);
+		}
+
+		private void PlayRankedWild()
+		{
+            if (!AccessibleRankedUtils.PlayerCanPlayWild())
+			{
+                NotifyNeedToBuildDeckFirst();
+                return;
+			}
+
+            EnterRankedMode(FormatType.FT_WILD);
+		}
+
+		private void PlayRankedClassic()
+		{
+            if (!AccessibleRankedUtils.PlayerCanPlayClassic())
+			{
+                NotifyNoClassicDeck();
+                return;
+			}
+
+            EnterRankedMode(FormatType.FT_CLASSIC);
+		}
+
+		#endregion
+
+        public void HandleInput()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+				m_mainMenu?.HandleAccessibleInput();
+			}
+			else if (m_curState == State.PLAY_RANKED_MENU_CHOOSE_FORMAT)
+			{
+                m_playRankedChooseFormatMenu?.HandleAccessibleInput();
+			}
+        }
+
+		public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                case State.PLAY_RANKED_MENU_CHOOSE_FORMAT:
+                    return m_playRankedChooseFormatMenu?.GetHelp();
+                default:
+                    break;
+            }
+
+            return "";
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.StartReading();
+            }
+            else if (m_curState == State.PLAY_RANKED_MENU_CHOOSE_FORMAT)
+			{
+                m_playRankedChooseFormatMenu?.StartReading();
+			}
+        }
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
new file mode 100644
index 0000000..08b17dc
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
@@ -0,0 +1,2269 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessibleInGameState
+    {
+        private class EntitySpeech : IEquatable<EntitySpeech>
+        {
+            public string SingularSpeech { get; private set; }
+            public string PluralSpeech { get; private set; }
+
+            public EntitySpeech(string speech)
+            {
+                SingularSpeech = PluralSpeech = speech;
+            }
+
+            public EntitySpeech(string singularSpeech, string pluralSpeech)
+            {
+                SingularSpeech = singularSpeech;
+                PluralSpeech = pluralSpeech;
+            }
+
+            public bool Equals(EntitySpeech other)
+            {
+                return SingularSpeech.Equals(other.SingularSpeech) && PluralSpeech.Equals(other.PluralSpeech);
+            }
+
+            public override bool Equals(object obj)
+            {
+                return Equals(obj as EntitySpeech);
+            }
+
+            public override int GetHashCode()
+            {
+                return SingularSpeech.GetHashCode() ^ PluralSpeech.GetHashCode();
+            }
+
+            public override string ToString()
+            {
+                return $"Singular={SingularSpeech} ; Plural={PluralSpeech}";
+            }
+        }
+
+		private class EntityDiff
+        {
+            private Entity m_before, m_after;
+
+            private bool m_died;
+            private bool m_transformed;
+            private bool m_revealed;
+            private int m_healedAmt;
+            private int m_healthDiff;
+            private int m_armorDiff;
+            private int m_atkDiff;
+            private bool m_becameInvulnerable;
+            private bool m_becameImmune;
+
+            private string m_descSingular;
+            private string m_descPlural;
+
+            internal EntityDiff(Entity before, Entity after, AccessibleInGameState gameStateBefore, AccessibleInGameState gameStateAfter)
+            {
+                m_before = before;
+                m_after = after;
+
+                m_died = HasDied(before, after);
+                m_transformed = HasTransformed(before, after);
+                m_revealed = HasRevealed(before, after);
+                m_healedAmt = Math.Abs(Math.Min(after.GetDamage() - before.GetDamage(), 0));
+                m_healthDiff = after.GetHealth() - before.GetHealth();
+                m_armorDiff = after.GetArmor() - before.GetArmor();
+                m_atkDiff = after.GetATK() - before.GetATK();
+                m_becameInvulnerable = before.CanBeAttacked() && !after.CanBeAttacked();
+                m_becameImmune = !before.IsImmune() && after.IsImmune();
+
+                InitDiffDescriptions();
+            }
+
+            private int GetDamageTaken()
+            {
+                if (m_after.IsCharacter())
+                {
+                    var afterDmg = m_after.GetDamage();
+                    var beforeDmg = m_before.GetDamage();
+
+                    var dmgTaken = 0;
+
+                    if (afterDmg > beforeDmg)
+                    {
+                        dmgTaken += afterDmg - beforeDmg;
+                    }
+
+                    return dmgTaken;
+                }
+                else if (m_after.IsWeapon())
+                {
+                    var afterDurability = m_after.GetCurrentDurability();
+                    var beforeDurability = m_before.GetCurrentDurability();
+
+                    if (afterDurability < beforeDurability)
+                    {
+                        return beforeDurability - afterDurability;
+                    }
+                }
+
+                return 0;
+            }
+
+            internal List<string> GetRawDiff()
+            {
+                var ret = new List<string>();
+
+                var beforeTags = m_before.GetTags().GetMap();
+                var afterTags = m_after.GetTags().GetMap();
+
+                foreach (var beforeEntry in beforeTags)
+                {
+                    int tag = beforeEntry.Key;
+                    int beforeVal = beforeEntry.Value;
+
+                    if (!afterTags.ContainsKey(tag))
+                    {
+                        ret.Add($"--- {GetTagName(tag)} ({beforeVal})");
+                    }
+                    else
+                    {
+                        int afterVal = afterTags[tag];
+
+                        if (beforeVal != afterVal)
+                        {
+                            ret.Add($"CCC {GetTagName(tag)}: {beforeVal} -> {afterVal}");
+                        }
+                    }
+                }
+
+                foreach (var afterEntry in afterTags)
+                {
+                    int tag = afterEntry.Key;
+                    int afterVal = afterEntry.Value;
+                    if (!beforeTags.ContainsKey(tag))
+                    {
+                        ret.Add($"+++ {GetTagName(tag)}={afterVal}");
+                    }
+                }
+
+                return ret;
+            }
+
+            private string GetTagName(int tag)
+            {
+                var ret = Enum.GetName(typeof(GAME_TAG), tag);
+
+                if (ret == null)
+                {
+                    ret = tag.ToString();
+                }
+
+                return ret;
+            }
+
+            internal int GetEntityId()
+            {
+                return m_before.GetEntityId();
+            }
+
+            internal bool HasDied()
+            {
+                return m_died;
+            }
+
+            private static bool IsInvalid(Entity entity)
+            {
+                return entity.GetCardType() == TAG_CARDTYPE.INVALID;
+            }
+
+            private static bool IsDead(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsDeadZone(entity.GetZone());
+            }
+
+            private static bool IsAlive(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsAliveZone(entity.GetZone());
+            }
+
+            private static bool IsDeadZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.GRAVEYARD || zone == TAG_ZONE.REMOVEDFROMGAME || zone == TAG_ZONE.SETASIDE;
+            }
+
+            private static bool IsAliveZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.PLAY; // Only PLAY should count as alive as e.g. in-hand cards are not "alive"
+            }
+
+            private static bool IsAbleToLive(Entity entity)
+            {
+                return entity.IsCharacter() || entity.IsWeapon();
+            }
+
+            internal EntitySpeech GetDeathSpeech()
+            {
+                if (m_before.IsWeapon())
+                {
+                    if (m_after.GetController().GetWeaponCard() == null)
+                    {
+                        return new EntitySpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_WEAPON_BROKE));
+                    }
+                    else
+                    {
+                        return new EntitySpeech("");
+                    }
+                }
+                else
+                {
+                    return new EntitySpeech(
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_DIED),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED)
+                    );
+                }
+            }
+
+            private static bool HasDied(Entity before, Entity after)
+            {
+                var died = IsAlive(before) && IsDead(after);
+
+                if (!died)
+                {
+                    return false;
+                }
+
+                if (!before.IsWeapon())
+                {
+                    return true;
+                }
+
+                if (after.GetController().GetWeaponCard() == null)
+                {
+                    s_heroWeaponBroke.Add(after.GetController().GetHero());
+                }
+
+                return true;
+            }
+
+            internal bool HasChanges()
+            {
+                return !m_died && !m_transformed && GetDiffDescription().SingularSpeech.Length > 0;
+            }
+
+            internal Entity GetBeforeEntity()
+            {
+                return m_before;
+            }
+
+            internal Entity GetAfterEntity()
+            {
+                return m_after;
+            }
+
+            internal EntitySpeech GetTransformedSpeech()
+            {
+                return new EntitySpeech(
+                    LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TRANSFORMED, GetEntityName(m_after)),
+                    LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED, GetEntityName(m_after))
+                );
+            }
+
+            internal bool HasTransformed()
+            {
+                return m_transformed;
+            }
+
+            private bool HasTransformed(Entity before, Entity after)
+            {
+                if (m_died || m_before.GetZone() != m_after.GetZone())
+                {
+                    return false;
+                }
+
+                var afterEntityName = GetEntityName(m_after);
+                var beforeEntityName = GetEntityName(m_before);
+
+                return !HasRevealed(before, after) && !afterEntityName.Equals(beforeEntityName);
+            }
+
+            private bool HasRevealed(Entity before, Entity after)
+            {
+                var afterEntityName = GetEntityName(m_after);
+                var beforeEntityName = GetEntityName(m_before);
+
+                return before.GetZone() == TAG_ZONE.SECRET && !MovedZone() && !afterEntityName.Equals(beforeEntityName);
+            }
+
+            internal bool MovedZone()
+            {
+                return !m_died && (m_before.GetZone() != m_after.GetZone()) || (m_before.GetController() != m_after.GetController());
+            }
+
+            internal EntitySpeech GetDiffDescription()
+            {
+                return new EntitySpeech(m_descSingular, m_descPlural);
+            }
+
+            private void InitDiffDescriptions()
+            {
+                if (m_died || m_transformed || m_revealed || IsHeroCardBeingPlayed())
+                {
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (IsInvalid(m_before) || IsInvalid(m_after))
+                {
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (IsDead(m_before) && IsDead(m_after))
+                {
+                    // Has been dead for a while
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (MovedZone() && (m_after.GetZone() != TAG_ZONE.PLAY))
+                {
+                    // We don't want to call out stat changes in things like return to hand
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                List<string> sDescriptions = new List<string>();
+                List<string> pDescriptions = new List<string>();
+                List<string> sGainedDescriptions = new List<string>();
+                List<string> pGainedDescriptions = new List<string>();
+                List<string> sLostDescriptions = new List<string>();
+                List<string> pLostDescriptions = new List<string>();
+
+                bool gainedAtk = m_atkDiff > 0;
+                bool lostAtk = m_atkDiff < 0;
+                bool gainedHealth = m_healthDiff > 0;
+                bool lostHealth = m_healthDiff < 0;
+                bool gainedArmor = m_armorDiff > 0;
+                bool lostArmor = m_armorDiff < 0;
+
+                int dmgTaken = GetDamageTaken();
+
+                if (lostArmor && ShouldDescribeStatChanges())
+                {
+                    // Armor first so make sure we say "lost 2 armor and took 3 damage" instead of the other way around with the rest of the stats
+                    var lostArmorDescription = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, Math.Abs(m_armorDiff));
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_LOST_STATS, lostArmorDescription));
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS, lostArmorDescription));
+                }
+
+                if (dmgTaken > 0 && !m_after.IsWeapon() && ShouldDescribeStatChanges())
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE, dmgTaken));
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE, dmgTaken));
+                }
+
+                if (m_healedAmt > 0 && ShouldDescribeStatChanges())
+                {
+                    if (m_after.IsWeapon())
+                    {
+                        // You can never have more than 1 weapon at once
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_DURABILITY, m_healedAmt));
+                    }
+                    else
+                    {
+                        sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH, m_healedAmt));
+                        pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH, m_healedAmt));
+                    }
+                }
+
+                if (m_becameInvulnerable && !AccessibleGameplayUtils.IsPlayingTutorial() && !m_becameImmune) // Heroes and minions become invulnerable randomly in tutorial games for some reason (even though they wouldn't even get hit)
+                {
+                    // Don't call out invulnerable + immune e.g. Divine Bell in Garrosh BoH 7
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE));
+                }
+
+                if (!AccessibleCardUtils.IsCursed(m_before) && AccessibleCardUtils.IsCursed(m_after)) 
+				{
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_WAS_CURSED));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_CURSED));
+				}
+
+                if (!m_before.IsSilenced() && m_after.IsSilenced())
+                {
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED));
+                }
+                else
+                {
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasTaunt(), m_after.HasTaunt(), LocalizedText.GLOBAL_TAUNT);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasDeathrattle(), m_after.HasDeathrattle(), LocalizedText.GLOBAL_DEATHRATTLE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasBattlecry(), m_after.HasBattlecry(), LocalizedText.GLOBAL_BATTLECRY);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasCharge(), m_after.HasCharge(), LocalizedText.GLOBAL_CHARGE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasLifesteal(), m_after.HasLifesteal(), LocalizedText.GLOBAL_LIFESTEAL);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasRush(), m_after.HasRush(), LocalizedText.GLOBAL_RUSH);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasWindfury(), m_after.HasWindfury(), LocalizedText.GLOBAL_WINDFURY);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasDivineShield(), m_after.HasDivineShield(), LocalizedText.GLOBAL_DIVINE_SHIELD);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.IsFreeze(), m_after.IsFreeze(), LocalizedText.GLOBAL_FREEZE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasReborn(), m_after.HasReborn(), LocalizedText.GLOBAL_REBORN);
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsDormant(), m_after.IsDormant(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT));
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsFrozen(), m_after.IsFrozen(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN));
+
+                    if (ShouldReadImmunityChanges())
+                    {
+                        AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsImmune(), m_after.IsImmune(),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE));
+                    }
+
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsMagnet(), m_after.IsMagnet(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC));
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsPoisonous(), m_after.IsPoisonous(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS));
+                    AddGainedDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsStealthed(), m_after.IsStealthed(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED));
+                }
+
+                if (ShouldDescribeStatChanges())
+                {
+                    // Handle weapons to prevent spam on sheathe/unsheathe/break
+                    if (lostAtk && s_heroSheathedWeapon.Contains(m_after))
+                    {
+                        lostAtk = false;
+                        s_heroSheathedWeapon.Remove(m_after);
+                        AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to sheathe");
+                    }
+                    else if (lostAtk && s_heroWeaponBroke.Contains(m_after))
+                    {
+                        lostAtk = false;
+                        s_heroWeaponBroke.Remove(m_after);
+                        AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to broken weapon");
+                    }
+                    else if (gainedAtk && s_heroUnsheathedWeapon.Contains(m_after))
+                    {
+                        gainedAtk = false;
+                        s_heroUnsheathedWeapon.Remove(m_after);
+                        AccessibilityUtils.LogDebug("WEP Ignoring gainAtk due to unsheathe");
+                    }
+
+                    // Normal stats
+                    if (gainedAtk)
+                    {
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, m_atkDiff));
+                        pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, m_atkDiff));
+                    }
+                    else if (lostAtk)
+                    {
+                        sLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, Math.Abs(m_atkDiff)));
+                        pLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, Math.Abs(m_atkDiff)));
+                    }
+
+                    if (gainedHealth)
+                    {
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, m_healthDiff));
+                        pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, m_healthDiff));
+                    }
+                    else if (lostHealth)
+                    {
+                        sLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, Math.Abs(m_healthDiff)));
+                        pLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, Math.Abs(m_healthDiff)));
+                    }
+
+                    if (gainedArmor)
+                    {
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, m_armorDiff));
+                        pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, m_armorDiff));
+                    }
+                }
+
+                var sGroupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(sGainedDescriptions);
+                var pGroupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(pGainedDescriptions);
+                var sGroupedLostDescriptions = AccessibleSpeechUtils.HumanizeList(sLostDescriptions);
+                var pGroupedLostDescriptions = AccessibleSpeechUtils.HumanizeList(pLostDescriptions);
+
+                if (sGroupedGainedDescriptions.Length > 0)
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_GAINED_STATS, sGroupedGainedDescriptions));
+                }
+                if (pGroupedGainedDescriptions.Length > 0)
+                {
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS, pGroupedGainedDescriptions));
+                }
+
+                if (sGroupedLostDescriptions.Length > 0)
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_LOST_STATS, sGroupedLostDescriptions));
+                }
+                if (pGroupedLostDescriptions.Length > 0)
+                {
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS, pGroupedLostDescriptions));
+                }
+
+                m_descSingular = AccessibleSpeechUtils.HumanizeList(sDescriptions);
+                m_descPlural = AccessibleSpeechUtils.HumanizeList(pDescriptions);
+            }
+
+			private bool ShouldDescribeStatChanges()
+			{
+                if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase() && !m_after.IsControlledByFriendlySidePlayer())
+				{
+                    // Don't call out stat changes for Bob's Minions as that can get annoying very quickly due to hero powers and cards like Nomi etc
+                    return false;
+				}
+
+                return true;
+			}
+
+			private bool IsHeroCardBeingPlayed()
+            {
+                return m_after.IsHero() && m_before.GetZone() == TAG_ZONE.HAND && m_after.GetZone() == TAG_ZONE.PLAY;
+            }
+
+            private bool ShouldReadImmunityChanges()
+            {
+                if (m_after.IsWeapon())
+                {
+                    // e.g. Gorehowl in BoH Garrosh
+                    return false;
+                }
+
+                if (m_after.IsHero() && AccessibleGameplayUtils.IsInBattlegroundsShopPhase() && !m_after.IsControlledByFriendlySidePlayer())
+				{
+                    // Tavern Bob sometimes becomes immune but we don't want to read that as it doesn't matter
+                    return false;
+				}
+
+                return true;
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> singularGainedDescriptions, List<string> pluralGainedDescriptions, List<string> singularLostDescriptions, List<string> pluralLostDescriptions, bool hadBefore, bool hasAfter, string gainedOrLostEffect)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularGainedDescriptions.Add(gainedOrLostEffect);
+                    pluralGainedDescriptions.Add(gainedOrLostEffect);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    singularLostDescriptions.Add(gainedOrLostEffect);
+                    pluralLostDescriptions.Add(gainedOrLostEffect);
+                }
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> singularDescriptions, List<string> pluralDescriptions, bool hadBefore, bool hasAfter, string gainedTextSingular, string gainedTextPlural, string lostTextSingular, string lostTextPlural)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularDescriptions.Add(gainedTextSingular);
+                    pluralDescriptions.Add(gainedTextPlural);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    singularDescriptions.Add(lostTextSingular);
+                    pluralDescriptions.Add(lostTextPlural);
+                }
+            }
+
+            private void AddGainedDescriptionIfExists(List<string> singularDescriptions, List<string> pluralDescriptions, bool hadBefore, bool hasAfter, string gainedTextSingular, string gainedTextPlural)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularDescriptions.Add(gainedTextSingular);
+                    pluralDescriptions.Add(gainedTextPlural);
+                }
+            }
+        }
+
+		internal List<Entity> GetPlayerMinions()
+		{
+            return m_playerMinions;
+		}
+
+		internal static bool HasPlayerReceivedCards(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            return before.m_playerHand.Count != after.m_playerHand.Count;
+		}
+
+		internal static bool HasAnyHeroGainedAtk(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var beforePlayerAtk = before.m_playerHero.GetATK();
+            var afterPlayerAtk = after.m_playerHero.GetATK();
+            var beforeOpponentAtk = before.m_opponentHero.GetATK();
+            var afterOpponentAtk = after.m_opponentHero.GetATK();
+
+            return afterPlayerAtk > beforePlayerAtk || afterOpponentAtk > beforeOpponentAtk;
+		}
+
+		internal static bool HasAnyHeroLostAtk(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var beforePlayerAtk = before.m_playerHero.GetATK();
+            var afterPlayerAtk = after.m_playerHero.GetATK();
+            var beforeOpponentAtk = before.m_opponentHero.GetATK();
+            var afterOpponentAtk = after.m_opponentHero.GetATK();
+
+            return afterPlayerAtk < beforePlayerAtk || afterOpponentAtk < beforeOpponentAtk;
+		}
+
+		internal static bool HasAnyHeroRecoveredHealth(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var beforePlayerHealth = before.m_playerHero.GetCurrentHealth();
+            var afterPlayerHealth = after.m_playerHero.GetCurrentHealth();
+            var beforeOpponentHealth = before.m_opponentHero.GetCurrentHealth();
+            var afterOpponentHealth = after.m_opponentHero.GetCurrentHealth();
+
+            return afterPlayerHealth > beforePlayerHealth || afterOpponentHealth > beforeOpponentHealth;
+		}
+
+		internal static bool WasAnyPlayerMinionBuffedOrDebuffed(AccessibleInGameState before, AccessibleInGameState after, HashSet<string> filterCardIds=null)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var friendlyPlayerDiffs = CreateFriendlyPlayerEntityDiffs(before, after, filterCardIds);
+
+            foreach (var diff in friendlyPlayerDiffs)
+			{
+                if (diff.HasChanges() || diff.HasTransformed())
+				{
+                    return true;
+				}
+			}
+
+            return false;
+		}
+
+        private static List<EntityDiff> CreateFriendlyPlayerEntityDiffs(AccessibleInGameState before, AccessibleInGameState after, HashSet<string> filterCardIds)
+        {
+            // Used in Battlegrounds only for outputting permanent effects
+            // Note: filterCardIds is used for certain cases such as Tarecgosas where we don't care about other minions
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityBefore in before.m_playerMinions)
+            {
+                var entityAfter = after.GetEntity(entityBefore.GetEntityId());
+
+                if (entityAfter != null && (filterCardIds == null || filterCardIds.Contains(entityAfter.GetCardId())))
+                {
+                    ret.Add(new EntityDiff(entityBefore, entityAfter, before, after));
+                }
+            }
+
+            return ret;
+        }
+
+		internal static bool HasOpponentHeroChanged(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || before.m_opponentHero == null)
+			{
+                return false;
+			}
+
+            return before.m_opponentHero.GetEntityId() != after.m_opponentHero.GetEntityId();
+		}
+
+		private class EntityGroup
+        {
+            private string m_name;
+            private List<Entity> m_entities;
+
+            internal EntityGroup(string name, List<Entity> entities)
+            {
+                m_name = name;
+                m_entities = entities;
+            }
+
+            internal bool IsSubsetOf(List<Entity> entities)
+            {
+                var entitiesMap = new HashSet<Entity>(entities, new EntityComparer());
+
+                foreach (var entity in m_entities)
+                {
+                    if (!entitiesMap.Contains(entity))
+                    {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+
+            internal string GetName()
+            {
+                return m_name;
+            }
+
+            internal List<Entity> GetEntities()
+            {
+                return m_entities;
+            }
+        }
+
+        private PowerTaskList m_powerTaskList;
+
+        private bool m_gameCreated;
+
+        private TAG_STEP m_step;
+
+        private Player m_currentPlayer;
+        private int m_playerAvailableResources;
+        private int m_playerResources;
+        private int m_opponentAvailableResources;
+        private int m_opponentResources;
+        private int m_playerNumTurnsInPlay;
+        private int m_playerSpellpower;
+        private int m_opponentSpellpower;
+
+        private Entity m_playerHero, m_opponentHero;
+        private Entity m_playerHeroPower, m_opponentHeroPower;
+        private Entity m_playerWeapon, m_opponentWeapon;
+
+        private List<Entity> m_playerHand, m_opponentHand;
+        private List<Entity> m_playerDeck, m_opponentDeck;
+        private List<Entity> m_playerGraveyard, m_opponentGraveyard;
+        private List<Entity> m_playerMinions, m_opponentMinions;
+        private List<Entity> m_playerSecrets, m_opponentSecrets;
+
+        private List<Entity> m_entities;
+
+        private AccessibleInGameState(PowerTaskList powerTaskList)
+        {
+            m_powerTaskList = powerTaskList;
+
+            if (!GameState.Get().IsGameCreated())
+            {
+                return;
+            }
+
+            m_gameCreated = true;
+
+            m_step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            m_currentPlayer = GameState.Get().GetCurrentPlayer();
+
+            Player player = GameState.Get().GetFriendlySidePlayer();
+            Player opponent = GameState.Get().GetOpposingSidePlayer();
+
+            m_playerAvailableResources = player.GetNumAvailableResources();
+            m_opponentAvailableResources = opponent.GetNumAvailableResources();
+            m_playerResources = player.GetTag(GAME_TAG.RESOURCES);
+            m_opponentResources = opponent.GetTag(GAME_TAG.RESOURCES);
+            m_playerSpellpower = player.TotalSpellpower(player);
+            m_opponentSpellpower = opponent.TotalSpellpower(opponent);
+            m_playerNumTurnsInPlay = player.GetNumTurnsInPlay();
+
+            m_playerHero = Clone(player.GetHero());
+            m_opponentHero = Clone(opponent.GetHero());
+            m_playerHeroPower = Clone(player.GetHeroPower());
+            m_opponentHeroPower = Clone(opponent.GetHeroPower());
+            m_playerWeapon = Clone(player.GetWeaponCard()?.GetEntity());
+            m_opponentWeapon = Clone(opponent.GetWeaponCard()?.GetEntity());
+
+            m_playerHand = Clone(GetEntitiesFromZone(player.GetHandZone()));
+            m_opponentHand = Clone(GetEntitiesFromZone(opponent.GetHandZone()));
+            m_playerDeck = Clone(GetEntitiesFromZone(player.GetDeckZone()));
+            m_opponentDeck = Clone(GetEntitiesFromZone(opponent.GetDeckZone()));
+            m_playerGraveyard = Clone(GetEntitiesFromZone(player.GetGraveyardZone()));
+            m_opponentGraveyard = Clone(GetEntitiesFromZone(opponent.GetGraveyardZone()));
+            m_playerMinions = Clone(GetEntitiesFromZone(player.GetBattlefieldZone()));
+            m_opponentMinions = Clone(GetEntitiesFromZone(opponent.GetBattlefieldZone()));
+            m_playerSecrets = Clone(GetEntitiesFromZone(player.GetSecretZone()));
+            m_opponentSecrets = Clone(GetEntitiesFromZone(opponent.GetSecretZone()));
+
+            m_entities = new List<Entity>();
+            m_entities.Add(m_playerHero);
+            m_entities.Add(m_opponentHero);
+            if (m_playerHeroPower != null) m_entities.Add(m_playerHeroPower);
+            if (m_opponentHeroPower != null) m_entities.Add(m_opponentHeroPower);
+            if (m_playerWeapon != null) m_entities.Add(m_playerWeapon);
+            if (m_opponentWeapon != null) m_entities.Add(m_opponentWeapon);
+            m_entities.AddRange(m_playerHand);
+            m_entities.AddRange(m_opponentHand);
+            m_entities.AddRange(m_playerDeck);
+            m_entities.AddRange(m_opponentDeck);
+            m_entities.AddRange(m_playerGraveyard);
+            m_entities.AddRange(m_opponentGraveyard);
+            m_entities.AddRange(m_playerMinions);
+            m_entities.AddRange(m_opponentMinions);
+            m_entities.AddRange(m_playerSecrets);
+            m_entities.AddRange(m_opponentSecrets);
+        }
+
+        internal bool HasWeaponEquipped(Entity hero)
+        {
+            return GetWeapon(hero.GetController()) != null;
+        }
+
+        private Entity GetWeapon(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerWeapon;
+            }
+            else
+            {
+                return m_opponentWeapon;
+            }
+        }
+
+        private Entity GetHero(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerHero;
+            }
+            else
+            {
+                return m_opponentHero;
+            }
+        }
+
+        internal static AccessibleInGameState GetCurrentState(PowerTaskList powerTaskList)
+        {
+            return new AccessibleInGameState(powerTaskList);
+        }
+
+        internal Entity GetEntity(int entityId)
+        {
+            foreach (var entity in m_entities)
+            {
+                if (entity.GetEntityId() == entityId)
+                {
+                    return entity;
+                }
+            }
+
+            return null;
+        }
+
+        private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            // Groups
+            var allFriendlyCharacters = ConcatEntities(before.m_playerMinions, before.m_playerHero);
+            var allEnemies = ConcatEntities(before.m_opponentMinions, before.m_opponentHero);
+            var allMinions = ConcatEntities(before.m_playerMinions, before.m_opponentMinions);
+            var everyone = ConcatEntities(allFriendlyCharacters, allEnemies);
+            var bothHeroes = ConcatEntities(before.m_playerHero, before.m_opponentHero);
+
+            var groups = new List<EntityGroup>();
+            if (everyone.Count > 2) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_EVERYONE), everyone));
+            groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_BOTH_HEROES), bothHeroes));
+            if (allMinions.Count > 0 && before.m_playerMinions.Count > 0 && before.m_opponentMinions.Count > 0) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ALL_MINIONS), allMinions));
+            if (allEnemies.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ENEMIES), allEnemies));
+            if (allFriendlyCharacters.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS), allFriendlyCharacters));
+            if (before.m_opponentMinions.Count > 1) groups.Add(new EntityGroup(GetOpponentMinionsGroupName(), before.m_opponentMinions));
+            if (before.m_playerMinions.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS), before.m_playerMinions));
+
+            if (sourceEntity != null)
+            {
+                AddOtherThanSourceEntityGroups(sourceEntity, everyone, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE));
+                AddOtherThanSourceEntityGroups(sourceEntity, allMinions, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS));
+                AddOtherThanSourceEntityGroups(sourceEntity, allEnemies, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES));
+                AddOtherThanSourceEntityGroups(sourceEntity, allFriendlyCharacters, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS));
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_opponentMinions, groups, GetOtherOpponentMinionsGroupName());
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_playerMinions, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS));
+            }
+            AddSameNameEntityGroups(before.m_playerMinions, groups, true);
+            AddSameNameEntityGroups(before.m_opponentMinions, groups, false);
+
+            return GetDiffSpeech(sourceEntity, before, after, groups);
+        }
+
+		private static string GetOpponentMinionsGroupName()
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_MINIONS : LocalizationKey.GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS;
+            return LocalizationUtils.Get(key);
+		}
+
+		private static string GetOtherOpponentMinionsGroupName()
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_OTHER_BARTENDER_MINIONS : LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS;
+			return LocalizationUtils.Get(key);
+		}
+
+		private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after, List<EntityGroup> groups)
+        {
+            // Note: sourceEntity is a duplicate but I think it can be null in some cases
+
+            List<Entity> destroyedEntities = GetDestroyedEntities(before, after);
+            List<Entity> newEntities = GetNewEntities(before, after);
+
+            var newEntitySpeeches = GetNewEntitySpeeches(newEntities);
+
+            List<EntityDiff> entityDiffs = CreateEntityDiffs(before, after);
+            List<EntityDiff> affectedEntities = GetAffectedEntities(entityDiffs);
+            List<EntityDiff> movedEntities = GetMovedEntities(sourceEntity, entityDiffs, after.m_entities);
+            List<EntityDiff> transformedEntities = GetTransformedEntities(entityDiffs); // Technically a change but we want to state these first due to enchantments (e.g. polymorph on a stormwind champion)
+            List<EntityDiff> justDiedEntities = GetJustDiedEntities(entityDiffs);
+
+            DebugEntityDiffs(entityDiffs);
+
+            AccessibilityUtils.LogDebug($"DBG justDiedEntities: {GetEntityNamesDbg(justDiedEntities)}");
+
+            var ret = new List<string>();
+
+            // Testing
+            var affectedEntitySpeeches = GetEntitySpeeches(affectedEntities);
+            var transformedEntitySpeeches = GetTransformedEntitySpeeches(transformedEntities);
+            var deadEntitySpeeches = GetDeadEntitySpeeches(justDiedEntities);
+
+            var groupedMovementSpeeches = GetZoneMovementSpeeches(movedEntities, groups);
+
+            AccessibilityUtils.LogDebug("DBG Groups");
+            foreach (var group in groups)
+            {
+                AccessibilityUtils.LogDebug($"DBG {group.GetName()}: {GetEntityNamesDbg(group.GetEntities())}");
+            }
+
+            AccessibilityUtils.LogDebug("DBG Grouping affectedEntities speeches");
+            var groupedSpeeches = GroupSpeeches(affectedEntities, groups, affectedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping transformedEntities speeches");
+            var groupedTransformedSpeeches = GroupSpeeches(transformedEntities, groups, transformedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping justDiedEntities speeches");
+            var groupedDeathSpeeches = GroupSpeeches(justDiedEntities, groups, deadEntitySpeeches, false);
+
+            ret.AddRange(newEntitySpeeches);
+            ret.AddRange(groupedMovementSpeeches);
+            ret.AddRange(groupedTransformedSpeeches);
+            ret.AddRange(groupedDeathSpeeches);
+            ret.AddRange(groupedSpeeches);
+
+            return ret;
+        }
+
+        private static void AddOtherThanSourceEntityGroups(Entity source, List<Entity> entities, List<EntityGroup> groups, string groupName)
+        {
+            var otherEntities = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                if (entity.GetEntityId() != source.GetEntityId())
+                {
+                    otherEntities.Add(entity);
+                }
+            }
+
+            if (otherEntities.Count > 1)
+            {
+                groups.Add(new EntityGroup(groupName, otherEntities));
+            }
+        }
+
+        private static void AddSameNameEntityGroups(List<Entity> entities, List<EntityGroup> groups, bool friendlySide)
+        {
+            Dictionary<string, List<Entity>> entitiesByName = new Dictionary<string, List<Entity>>();
+
+            foreach (var entity in entities)
+            {
+                var entityName = GetEntityName(entity);
+                if (!entitiesByName.ContainsKey(entityName))
+                {
+                    var newList = new List<Entity>();
+                    newList.Add(entity);
+                    entitiesByName.Add(entityName, newList);
+                }
+                else
+                {
+                    entitiesByName[entityName].Add(entity);
+                }
+            }
+
+            foreach (var entry in entitiesByName)
+            {
+                if (entry.Value.Count > 1)
+                {
+                    if (friendlySide)
+                    {
+                        groups.Add(new EntityGroup(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES, entry.Value.Count, entry.Key), entry.Value));
+                    }
+                    else
+                    {
+                        var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_SAME_NAME_ENTITIES : LocalizationKey.GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES;
+                        groups.Add(new EntityGroup(LocalizationUtils.Format(key, entry.Value.Count, entry.Key), entry.Value));
+                    }
+                }
+            }
+        }
+
+		private static List<string> GroupSpeeches(List<EntityDiff> entityDiffs, List<EntityGroup> groups, Dictionary<Entity, EntitySpeech> entitySpeeches, bool useZoneOrder)
+        {
+            var handled = new Dictionary<Entity, bool>(new EntityComparer());
+            var entities = new List<Entity>(entityDiffs.Count);
+
+			// TODO: Refactor this entire thing properly to use EntityDiffs instead of Entities as we don't always want to necessarily use the before entity
+            // e.g. x transformed into y should use before
+            //      x moved from deck to battlefield should use after (since before will still be invalid)
+            //      x died should use before (to differentiate e.g. your 2nd murloc died vs your murloc died or even your tenth murloc died if you already had 9 in GY)
+			var beforeEntityToAfterEntity = new Dictionary<Entity, Entity>(new EntityComparer());
+
+			entityDiffs.ForEach(e =>
+			{
+				entities.Add(e.GetBeforeEntity());
+				handled.Add(e.GetBeforeEntity(), false);
+				beforeEntityToAfterEntity.Add(e.GetBeforeEntity(), e.GetAfterEntity());
+			});
+
+			var groupedSpeeches = new Dictionary<string, EntitySpeech>();
+
+            AccessibilityUtils.LogDebug("DBG Grouping speeches");
+            AccessibilityUtils.LogDebug($"DBG entities: {GetEntityNamesDbg(entities)}");
+            AccessibilityUtils.LogDebug($"DBG speeches:");
+            foreach (var entry in entitySpeeches)
+            {
+                AccessibilityUtils.LogDebug($"DBG {entry.Key.GetName()}: {entry.Value}");
+            }
+
+            foreach (var group in groups)
+            {
+                if (group.GetEntities().Count > 1 && group.IsSubsetOf(entities))
+                {
+                    AccessibilityUtils.LogDebug($"DBG Group with > 1 and subset found: {group.GetName()}");
+                    if (!SpeechesAlreadyHandled(group, handled) && AllEntitiesShareSpeech(group.GetEntities(), entitySpeeches))
+                    {
+                        AccessibilityUtils.LogDebug($"DBG Handling group {group.GetName()}");
+                        var speech = entitySpeeches[group.GetEntities()[0]];
+                        groupedSpeeches[group.GetName()] = speech;
+                        MarkHandled(group, handled);
+                    }
+                }
+            }
+
+            var remainingSpeeches = new Dictionary<string, EntitySpeech>();
+
+            var remainingEntities = GetUnhandledEntities(handled);
+            AccessibilityUtils.LogDebug($"DBG remainingEntities: {GetEntityNamesDbg(remainingEntities)}");
+            remainingEntities.ForEach(e =>
+            {
+                if (entitySpeeches.ContainsKey(e))
+                {
+
+                    // Only add if we have proper changes (e.g. being destroyed does not warrant a speech as it would be covered by death anyways)
+                    if (useZoneOrder)
+                    {
+                        remainingSpeeches.Add(GetFullNameInZone(e), entitySpeeches[e]);
+                    }
+                    else
+                    {
+						// e.g. Death speeches (since we may have more than one in graveyard)
+                        // e.g. move from deck to battlefield speeches
+
+						var afterEntity = beforeEntityToAfterEntity[e]; // TODO: Refactor everything to use EntityDiffs. See above
+
+                        if (e.GetCardType() == TAG_CARDTYPE.INVALID && afterEntity.GetCardType() != TAG_CARDTYPE.INVALID)
+						{
+                            // e.g. deck->battlefield (after is ok / before is still invalid)
+                            // This is a mess but can't fix it properly until all of this is refactored to use EntityDiffs instead of entities
+							remainingSpeeches.Add(GetFullName(afterEntity), entitySpeeches[e]);
+						}
+                        else
+						{
+							remainingSpeeches.Add(GetFullNameInList(e, remainingEntities), entitySpeeches[e]);
+						}
+					}
+                }
+            });
+
+            return CombineSpeeches(groupedSpeeches, remainingSpeeches);
+        }
+
+        private static string GetEntityNamesDbg(List<Entity> entities)
+        {
+            var sb = new StringBuilder();
+            sb.Append("[");
+
+            for (int i = 0; i < entities.Count; i++)
+            {
+                if (i != 0)
+                {
+                    sb.Append(", ");
+                }
+
+                sb.Append(entities[i].GetName());
+            }
+
+            sb.Append("]");
+            return sb.ToString();
+        }
+
+        private static string GetEntityNamesDbg(List<EntityDiff> entityDiffs)
+        {
+            var entities = new List<Entity>(entityDiffs.Count);
+
+            foreach (var diff in entityDiffs)
+            {
+                entities.Add(diff.GetAfterEntity());
+            }
+
+            return GetEntityNamesDbg(entities);
+        }
+
+        private static List<string> CombineSpeeches(Dictionary<string, EntitySpeech> groupedSpeeches, Dictionary<string, EntitySpeech> remainingSpeeches)
+        {
+            var ret = new List<string>();
+            var speechToEntityNames = new Dictionary<EntitySpeech, List<string>>();
+
+            foreach (var entry in groupedSpeeches)
+            {
+                if (speechToEntityNames.ContainsKey(entry.Value))
+                {
+                    speechToEntityNames[entry.Value].Add(entry.Key);
+                }
+                else
+                {
+                    speechToEntityNames.Add(entry.Value, new List<string> { entry.Key });
+                }
+            }
+
+            foreach (var entry in remainingSpeeches)
+            {
+                if (speechToEntityNames.ContainsKey(entry.Value))
+                {
+                    speechToEntityNames[entry.Value].Add(entry.Key);
+                }
+                else
+                {
+                    speechToEntityNames.Add(entry.Value, new List<string> { entry.Key });
+                }
+            }
+
+            foreach (var entry in speechToEntityNames)
+            {
+                var speech = entry.Key;
+                var entities = entry.Value;
+
+                string resultingSpeech = speech.SingularSpeech;
+
+                if (entities.Count > 1)
+                {
+                    // Single remaining entities joined with a group or other remaining entities, forming a group
+                    resultingSpeech = speech.PluralSpeech;
+                }
+
+                if (entities.Count == 1 && groupedSpeeches.ContainsKey(entities[0]))
+                {
+                    // Was already grouped in the first place
+                    resultingSpeech = speech.PluralSpeech;
+                }
+
+                var entitiesAsList = AccessibleSpeechUtils.HumanizeList(entities);
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT, entitiesAsList, resultingSpeech));
+            }
+
+            return ret;
+        }
+
+        private static bool AllEntitiesShareSpeech(List<Entity> entities, Dictionary<Entity, EntitySpeech> speeches)
+        {
+            EntitySpeech speech = null;
+
+            foreach (var entity in entities)
+            {
+                if (!speeches.ContainsKey(entity))
+                {
+                    return false;
+                }
+
+                if (speech == null)
+                {
+                    speech = speeches[entity];
+                }
+                else if (!speeches[entity].Equals(speech))
+                {
+                    return false;
+                }
+            }
+
+            return speech.SingularSpeech.Length > 0; // We're not interested if they're not saying anything
+        }
+
+        private static bool SpeechesAlreadyHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                if (handled[entity])
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private static void MarkHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                handled[entity] = true;
+            }
+        }
+
+        private static List<Entity> GetUnhandledEntities(Dictionary<Entity, bool> handled)
+        {
+            var ret = new List<Entity>();
+
+            foreach (var entry in handled)
+            {
+                if (!entry.Value)
+                {
+                    ret.Add(entry.Key);
+                }
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetEntitySpeeches(List<EntityDiff> entities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in entities)
+            {
+                var desc = entity.GetDiffDescription();
+
+                if (desc.SingularSpeech.Length > 0)
+                {
+                    ret[entity.GetAfterEntity()] = desc;
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetNewEntitySpeeches(List<Entity> entities)
+        {
+            var ret = new List<string>();
+            var addedToPlayerHand = new List<string>();
+            var addedToOpponentHand = new List<string>();
+            var addedToPlayerDeck = new List<string>();
+            var addedToOpponentDeck = new List<string>();
+            var addedToPlayerBattlefield = new List<string>();
+            var addedToOpponentBattlefield = new List<string>();
+            var addedToPlayerSecrets = new List<string>();
+            var addedToOpponentSecrets = new List<string>();
+
+            foreach (var entity in entities)
+            {
+                Zone curZone = entity.GetCard().GetZone();
+
+                string cardName = GetCardNameForZoneMovement(entity);
+
+                Zone playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+                Zone opponentHand = GameState.Get().GetOpposingSidePlayer().GetHandZone();
+                Zone playerDeck = GameState.Get().GetFriendlySidePlayer().GetDeckZone();
+                Zone opponentDeck = GameState.Get().GetOpposingSidePlayer().GetDeckZone();
+                Zone playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+                Zone opponentBattlefield = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+                Zone playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+                Zone opponentSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone();
+
+                // Spawned card
+                if (curZone == playerHand)
+                {
+                    addedToPlayerHand.Add(cardName);
+                }
+                else if (curZone == opponentHand)
+                {
+                    addedToOpponentHand.Add(cardName);
+                }
+                else if (curZone == playerDeck)
+                {
+                    addedToPlayerDeck.Add(cardName);
+                }
+                else if (curZone == opponentDeck)
+                {
+                    addedToOpponentDeck.Add(cardName);
+                }
+                else if (curZone == playerBattlefield)
+                {
+                    addedToPlayerBattlefield.Add(cardName);
+                }
+                else if (curZone == opponentBattlefield)
+                {
+                    addedToOpponentBattlefield.Add(cardName);
+                }
+                else if (entity.GetCard() == GameState.Get().GetFriendlySidePlayer().GetWeaponCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON, cardName));
+                }
+                else if (entity.GetCard() == GameState.Get().GetOpposingSidePlayer().GetWeaponCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON, cardName));
+                }
+                else if (curZone == playerSecrets)
+                {
+                    if (entity.IsSecret())
+                    {
+                        addedToPlayerSecrets.Add(cardName);
+                    }
+
+                    // TODO: Handle quests, sidequests and questlines differently
+                }
+                else if (curZone == opponentSecrets)
+                {
+                    if (entity.IsSecret())
+                    {
+                        var className = GameStrings.GetClassName(entity.GetClass());
+                        addedToOpponentSecrets.Add(className);
+                    }
+
+                    // TODO: Handle quests, sidequests and questlines differently
+                }
+                else if (entity == GameState.Get().GetFriendlySidePlayer().GetHeroPower())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED, cardName));
+                }
+                else if (entity == GameState.Get().GetOpposingSidePlayer().GetHeroPower())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED, cardName));
+                }
+            }
+
+            InsertZoneMovements(ret, addedToPlayerHand, GetSingularCardAddedToPlayerHandKey(), GetPluralCardAddedToPlayerHandKey());
+            InsertZoneMovements(ret, addedToOpponentHand, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND);
+            InsertZoneMovements(ret, addedToPlayerDeck, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK);
+            InsertZoneMovements(ret, addedToOpponentDeck, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK);
+            InsertZoneMovements(ret, addedToPlayerBattlefield, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD);
+            InsertZoneMovements(ret, addedToOpponentBattlefield, GetSingularCardAddedToOpponentBattlefieldKey(), GetPluralCardAddedToOpponentBattlefieldKey());
+            InsertOpponentSecretMovements(ret, addedToOpponentSecrets);
+
+            return ret;
+        }
+
+		private static LocalizationKey GetSingularCardAddedToOpponentBattlefieldKey()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN;
+            }
+            else
+			{
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD;
+			}
+		}
+
+		private static LocalizationKey GetPluralCardAddedToOpponentBattlefieldKey()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN;
+            }
+            else
+			{
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD;
+			}
+		}
+
+		private static LocalizationKey GetSingularCardAddedToPlayerHandKey()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_HAND;
+            }
+            else
+			{
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND;
+			}
+		}
+
+        private static LocalizationKey GetPluralCardAddedToPlayerHandKey()
+        {
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+            {
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_HAND;
+            }
+            else
+            {
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND;
+            }
+        }
+
+		private static List<string> GetZoneMovementSpeeches(List<EntityDiff> entities, List<EntityGroup> groups)
+        {
+            var ret = new List<string>();
+
+            var drawnPlayerCards = new List<string>();
+            var drawnOpponentCards = new List<string>();
+            var discardedPlayerCards = new List<string>();
+            var discardedOpponentCards = new List<string>();
+            var takenControlByPlayerCards = new List<string>();
+            var takenControlByOpponentCards = new List<string>();
+            var castPlayerSecrets = new List<string>();
+            var castOpponentSecrets = new List<string>();
+
+            var speeches = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerHand = player.GetHandZone();
+            var opponentHand = opponent.GetHandZone();
+            var playerMinions = player.GetBattlefieldZone();
+            var opponentMinions = opponent.GetBattlefieldZone();
+            var playerSecrets = player.GetSecretZone();
+            var opponentSecrets = opponent.GetSecretZone();
+            var playerDeck = player.GetDeckZone();
+            var opponentDeck = opponent.GetDeckZone();
+            var playerGraveyard = player.GetGraveyardZone();
+            var opponentGraveyard = opponent.GetGraveyardZone();
+
+            var zoneNames = new Dictionary<Zone, string>();
+            zoneNames.Add(playerHand, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_HAND));
+            zoneNames.Add(opponentHand, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_HAND));
+            zoneNames.Add(playerMinions, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD));
+            zoneNames.Add(opponentMinions, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD));
+            zoneNames.Add(playerSecrets, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS));
+            zoneNames.Add(opponentSecrets, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS));
+            zoneNames.Add(playerDeck, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_DECK));
+            zoneNames.Add(opponentDeck, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_DECK));
+            zoneNames.Add(playerGraveyard, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD));
+            zoneNames.Add(opponentGraveyard, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD));
+
+            foreach (var entity in entities)
+            {
+                var before = entity.GetBeforeEntity();
+                var after = entity.GetAfterEntity();
+
+                var beforeZoneType = before.GetZone();
+                var afterZoneType = after.GetZone();
+
+                var beforeZone = GetZone(before);
+                var afterZone = GetZone(after);
+
+                // Note: play->graveyard movements are currently covered by EntityDiffs themselves (when checking HasMoved)
+                // Other -> graveyard movements aren't though (e.g. secrets being triggered)
+                if (afterZoneType == TAG_ZONE.GRAVEYARD)
+                {
+                    if (beforeZoneType != TAG_ZONE.PLAY && beforeZoneType != TAG_ZONE.SECRET)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+
+                    continue;
+                }
+
+                // Weapons are edge cases since we don't really know if they were equipped before or not
+                if (beforeZoneType == TAG_ZONE.PLAY && before.GetCardType() == TAG_CARDTYPE.WEAPON && before.GetControllerSide() == Player.Side.FRIENDLY)
+                {
+                    if (before.GetControllerSide() == Player.Side.FRIENDLY && afterZone == playerHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if (before.GetControllerSide() == Player.Side.OPPOSING && afterZone == opponentHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE, afterZone),
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE, afterZone)
+                        );
+                        speeches.Add(after, speech);
+                    }
+
+                    continue;
+                }
+
+                // Fallback zones
+                if (beforeZone == null || afterZone == null)
+                {
+                    if (after.GetZone() == TAG_ZONE.SETASIDE && before.IsHeroPower())
+                    {
+                        // A bit of a weird path but this is how Hero cards seem to be working
+                        var newHeroPower = before.GetController().GetHeroPower();
+
+                        if (newHeroPower != null && newHeroPower.GetEntityId() != before.GetEntityId())
+                        {
+                            var newHeroPowerName = newHeroPower.GetName();
+
+                            if (newHeroPower.IsControlledByFriendlySidePlayer())
+                            {
+                                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED, newHeroPowerName));
+                            }
+                            else
+                            {
+                                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED, newHeroPowerName));
+                            }
+                        }
+                    }
+                    else if (after.GetZone() == TAG_ZONE.SETASIDE)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+                    else
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC)
+                        );
+                        speeches.Add(after, speech);
+                    }
+
+                    continue;
+                }
+
+                // Normal scenarios
+                if (zoneNames.ContainsKey(beforeZone) && zoneNames.ContainsKey(afterZone))
+                {
+                    if (beforeZone == playerDeck && afterZone == playerHand)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+                        drawnPlayerCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentDeck && afterZone == opponentHand)
+                    {
+						var cardName = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+
+                        if (after.IsRevealed())
+						{
+							// Tradeable and shuffled cards reuse the same ID for some reason which means the client knows what the opponent is drawing
+							// This should be handled server-side but until then (if ever), handling any card without a specific REVEALED tag as a
+							// unknown card draw should work
+							cardName = GetCardNameForZoneMovement(after);
+						}
+
+                        drawnOpponentCards.Add(cardName);
+                    }
+                    else if ((beforeZone == playerMinions || beforeZone == playerSecrets) && afterZone == playerHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if ((beforeZone == opponentMinions || beforeZone == opponentSecrets) && afterZone == opponentHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if (beforeZone == playerMinions && afterZone == opponentMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByOpponentCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentMinions && afterZone == playerMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByPlayerCards.Add(cardName);
+                    }
+                    else if (afterZone == opponentSecrets)
+                    {
+                        if (after.IsSecret())
+                        {
+                            var className = GameStrings.GetClassName(after.GetClass());
+                            castOpponentSecrets.Add(className);
+                        }
+
+                        // TODO: Handle quests, sidequests and questlines differently
+                    }
+                    else if (afterZone == playerSecrets)
+                    {
+                        if (after.IsSecret())
+                        {
+                            var cardName = GetName(after);
+                            castPlayerSecrets.Add(cardName);
+                        }
+
+                        // TODO: Handle quests, sidequests and questlines differently
+                    }
+                    else
+                    {
+                        var beforeZoneName = zoneNames[beforeZone];
+                        var afterZoneName = zoneNames[afterZone];
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE, beforeZoneName, afterZoneName),
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE, beforeZoneName, afterZoneName)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                }
+                else if (zoneNames.ContainsKey(afterZone))
+                {
+                    var toZoneName = zoneNames[afterZone];
+                    var speech = new EntitySpeech(
+                        LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE, toZoneName),
+                        LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE, toZoneName)
+                    );
+                    speeches.Add(after, speech);
+                }
+                else
+                {
+                    var speech = new EntitySpeech(
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC)
+                    );
+                    speeches.Add(after, speech);
+                }
+            }
+
+            var groupedMovementSpeeches = GroupSpeeches(entities, groups, speeches, false);
+
+            InsertPlayerInducedZoneMovements(ret, drawnPlayerCards, LocalizationKey.GAMEPLAY_PLAYER_DREW_CARDS);
+            InsertPlayerInducedZoneMovements(ret, drawnOpponentCards, LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARDS);
+            InsertPlayerInducedZoneMovements(ret, discardedPlayerCards, LocalizationKey.GAMEPLAY_PLAYER_DISCARDED_CARDS);
+            InsertPlayerInducedZoneMovements(ret, discardedOpponentCards, LocalizationKey.GAMEPLAY_OPPONENT_DISCARDED_CARDS);
+            InsertPlayerInducedZoneMovements(ret, takenControlByPlayerCards, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER);
+            InsertPlayerInducedZoneMovements(ret, takenControlByOpponentCards, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT);
+            InsertPlayerInducedZoneMovements(ret, castPlayerSecrets, LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET);
+            InsertOpponentSecretMovements(ret, castOpponentSecrets);
+
+            ret.AddRange(groupedMovementSpeeches);
+
+            return ret;
+        }
+
+        private static void InsertOpponentSecretMovements(List<string> ret, List<string> castOpponentSecrets)
+        {
+            if (castOpponentSecrets.Count == 1)
+            {
+                InsertZoneMovements(ret, castOpponentSecrets, LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, LocalizationKey.GAMEPLAY_OPPONENT_CAST_N_SECRETS);
+            }
+            else if (castOpponentSecrets.Count > 1)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_N_SECRETS, castOpponentSecrets.Count));
+            }
+        }
+
+        private static Zone GetZone(Entity entity)
+        {
+            var controller = entity.GetController();
+
+            switch(entity.GetZone())
+            {
+                case TAG_ZONE.PLAY:
+                    return controller.GetBattlefieldZone();
+                case TAG_ZONE.DECK:
+                    return controller.GetDeckZone();
+                case TAG_ZONE.HAND:
+                    return controller.GetHandZone();
+                case TAG_ZONE.GRAVEYARD:
+                    return controller.GetGraveyardZone();
+                case TAG_ZONE.SECRET:
+                    return controller.GetSecretZone();
+                default:
+                    return null;
+            }
+        }
+
+        private static void InsertZoneMovements(List<string> ret, List<string> cards, LocalizationKey singularKey, LocalizationKey pluralKey)
+        {
+            if (cards.Count == 0)
+            {
+                return;
+            }
+
+            ret.Add(FormatZoneMovementText(cards, singularKey, pluralKey));
+        }
+
+        private static void InsertPlayerInducedZoneMovements(List<string> ret, List<string> cards, LocalizationKey key)
+        {
+            if (cards.Count == 0)
+            {
+                return;
+            }
+
+            var counts = new Dictionary<string, int>();
+            foreach (var card in cards)
+            {
+                if (!counts.ContainsKey(card))
+                {
+                    counts.Add(card, 1);
+                }
+                else
+                {
+                    counts[card]++;
+                }
+            }
+
+            var cardNames = HumanizeNames(cards, counts);
+
+            ret.Add(LocalizationUtils.Format(key, cardNames));
+        }
+
+        private static string GetCardNameForZoneMovement(Entity entity)
+        {
+            if (entity.GetCardType() != TAG_CARDTYPE.INVALID)
+            {
+                return GetEntityName(entity);
+            }
+            else
+            {
+                return LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+            }
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetTransformedEntitySpeeches(List<EntityDiff> transformedEntities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in transformedEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetTransformedSpeech();
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetDeadEntitySpeeches(List<EntityDiff> deadEntities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in deadEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetDeathSpeech();
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> list, Entity entity)
+        {
+            var ret = new List<Entity>(list.Count + 1);
+            ret.AddRange(list);
+            ret.Add(entity);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> l1, List<Entity> l2)
+        {
+            var ret = new List<Entity>(l1.Count + l2.Count);
+            ret.AddRange(l1);
+            ret.AddRange(l2);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(Entity e1, Entity e2)
+        {
+            var ret = new List<Entity>(2);
+            ret.Add(e1);
+            ret.Add(e2);
+            return ret;
+        }
+
+        private static void DebugEntityDiffs(List<EntityDiff> entityDiffs)
+        {
+            AccessibilityUtils.LogDebug("DebugEntityDiffs start");
+            foreach (var diff in entityDiffs)
+            {
+                var rawDiff = diff.GetRawDiff();
+                if (rawDiff.Count > 0)
+                {
+                    AccessibilityUtils.LogDebug($"DBG {diff.GetAfterEntity().GetName()}:");
+                    foreach (var entry in rawDiff)
+                    {
+                        AccessibilityUtils.LogDebug($"DBG {entry}");
+                    }
+                }
+                else
+                {
+                    AccessibilityUtils.LogDebug($"DBG {diff.GetAfterEntity().GetName()} - NO CHANGES");
+                }
+            }
+        }
+
+        internal static string DescribeDiff(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var lines = new List<string>();
+
+            // Handle starting turn when the game has just been created
+            if (before == null && after != null && after.m_gameCreated)
+            {
+                // TODO: describer already has logic for this as well and Hogger is weird. Need to think
+                return null;
+            }
+
+            if (before == null || after == null || !before.m_gameCreated || !after.m_gameCreated)
+            {
+                return null;
+            }
+
+            var sourceEntity = taskList.GetSourceEntity();
+
+            AccessibilityUtils.LogDebug($"DBG Describing diff. sourceEntity={sourceEntity}");
+            AccessibilityUtils.LogDebug(Environment.StackTrace);
+            AccessibilityUtils.LogDebug("DebugDiff done");
+
+            lines.AddRange(GetQuestProgressChanges(before, after));
+
+            lines.AddRange(GetHeroChanges(before, after));
+
+            lines.AddRange(GetSpeechLines(taskList, before, after));
+
+            // Turn stuff. At the end so we describe any pending triggers before this (done when NEXT_STEP = MAIN_START)
+            if (before.m_step != after.m_step && after.m_step == TAG_STEP.MAIN_START && after.m_currentPlayer == GameState.Get().GetFriendlySidePlayer())
+            {
+                // TODO: Doing this in powerlist describer now to see if it makes more sense to sync up with the animation
+                //lines.Add($"You have {after.m_playerAvailableResources} mana");
+            }
+            else if (after.m_step > TAG_STEP.MAIN_START && after.m_step < TAG_STEP.MAIN_END)
+            {
+                lines.AddRange(GetResourceChanges(before, after));
+            }
+
+            lines.AddRange(GetSpellpowerChanges(before, after));
+
+            return CombineLines(lines);
+        }
+
+        private static List<string> GetSpellpowerChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            if (before.m_playerSpellpower < after.m_playerSpellpower)
+            {
+                var amt = after.m_playerSpellpower - before.m_playerSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE, amt));
+            }
+            else if (after.m_playerSpellpower < before.m_playerSpellpower)
+            {
+                var amt = before.m_playerSpellpower - after.m_playerSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE, amt));
+            }
+
+            if (before.m_opponentSpellpower < after.m_opponentSpellpower)
+            {
+                var amt = after.m_opponentSpellpower - before.m_opponentSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE, amt));
+            }
+            else if (after.m_opponentSpellpower < before.m_opponentSpellpower)
+            {
+                var amt = before.m_opponentSpellpower - after.m_opponentSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE, amt));
+            }
+
+            return ret;
+        }
+
+        private static string CombineLines(List<string> lines)
+        {
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (sb.Length > 0)
+                {
+                    sb.Append(". ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetQuestProgressChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            // Note: there can only be 1 progress at once since this is part of a quest trigger
+
+            foreach (var entity in after.m_entities)
+            {
+                if (entity.IsQuest() || entity.IsSideQuest() || entity.IsQuestline())
+                {
+                    var beforeEntity = before.GetEntity(entity.GetEntityId());
+
+                    if (beforeEntity != null)
+                    {
+                        var beforeProgress = AccessibleCardUtils.GetQuestProgressLine(beforeEntity);
+                        var afterProgress = AccessibleCardUtils.GetQuestProgressLine(entity);
+
+                        if (!beforeProgress.Equals(afterProgress))
+                        {
+                            ret.Add(afterProgress);
+                        }
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetHeroChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            AddHeroChangeIfNeeded(ret, before.m_playerHero, after.m_playerHero, true);
+            AddHeroChangeIfNeeded(ret, before.m_opponentHero, after.m_opponentHero, false);
+
+            return ret;
+        }
+
+        private static void AddHeroChangeIfNeeded(List<string> ret, Entity heroBefore, Entity heroAfter, bool isFriendlyHero)
+        {
+            if (heroBefore.GetEntityId() != heroAfter.GetEntityId())
+            {
+                var newHeroName = heroAfter.GetName();
+                var translationKey = isFriendlyHero ? LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED : LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED;
+
+                ret.Add(LocalizationUtils.Format(translationKey, newHeroName));
+            }
+        }
+
+        private static List<string> GetResourceChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            var playerAvailableResourcesDiff = after.m_playerAvailableResources - before.m_playerAvailableResources;
+            var playerResourcesDiff = after.m_playerResources - before.m_playerResources;
+            var opponentAvailableResourcesDiff = after.m_opponentAvailableResources - before.m_opponentAvailableResources;
+            var opponentResourcesDiff = after.m_opponentResources - before.m_opponentResources;
+
+            if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+				ret.AddRange(GetResourceChanges(true, playerAvailableResourcesDiff, playerResourcesDiff));
+				ret.AddRange(GetResourceChanges(false, opponentAvailableResourcesDiff, opponentResourcesDiff));
+			}
+
+			if (playerAvailableResourcesDiff != 0)
+			{
+                AccessibleGameplay.Get().OnPlayerAvailableResourcesChanged(before.m_playerAvailableResources, after.m_playerAvailableResources);
+			}
+
+            return ret;
+        }
+
+        private static List<string> GetResourceChanges(bool friendlySidePlayer, int availableResourcesDiff, int resourcesDiff)
+        {
+            var ret = new List<string>();
+
+            if (resourcesDiff > 0)
+            {
+                if (availableResourcesDiff > 0)
+                {
+                    if (availableResourcesDiff >= resourcesDiff)
+                    {
+                        if (friendlySidePlayer)
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA, availableResourcesDiff));
+                        }
+                        else
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA, availableResourcesDiff));
+                        }
+                    }
+                    else
+                    {
+                        var numEmptyManaCrystals = resourcesDiff - availableResourcesDiff;
+
+                        if (friendlySidePlayer)
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS, availableResourcesDiff, numEmptyManaCrystals));
+                        }
+                        else
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS, availableResourcesDiff, numEmptyManaCrystals));
+                        }
+                    }
+                }
+                else
+                {
+                    if (friendlySidePlayer)
+                    {
+                        ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS, resourcesDiff));
+                    }
+                    else
+                    {
+                        ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS, resourcesDiff));
+                    }
+                }
+            }
+            else if (availableResourcesDiff > 0)
+            {
+                if (friendlySidePlayer)
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA, availableResourcesDiff));
+                }
+                else
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA, availableResourcesDiff));
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetSpeechLines(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            return GetDiffSpeech(taskList.GetSourceEntity(), before, after);
+        }
+
+        private static List<EntityDiff> GetAffectedEntities(List<EntityDiff> entityDiffs)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (diff.HasChanges())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> CreateEntityDiffs(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                var entityAfter = after.GetEntity(entityBefore.GetEntityId());
+
+                if (entityAfter != null)
+                {
+                    ret.Add(new EntityDiff(entityBefore, entityAfter, before, after));
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetMovedEntities(Entity sourceEntity, List<EntityDiff> entityDiffs, List<Entity> entitiesAfterMovement)
+        {
+            var ret = new List<EntityDiff>();
+
+            // Must iterate through entitiesAfterMovement or they will be out of order. e.g. drawing 2 cards means drawing the last 2 from your deck into your hand in rev order
+            Dictionary<Entity, EntityDiff> entityAfterToEntityDiff = new Dictionary<Entity, EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (!entityAfterToEntityDiff.ContainsKey(diff.GetAfterEntity()))
+                {
+                    entityAfterToEntityDiff.Add(diff.GetAfterEntity(), diff);
+                }
+                else
+                {
+                    Log.Accessibility.Print($"Ignored duplicate entity in GetMovedEntities: {diff.GetAfterEntity().GetName()}");
+                }
+            }
+
+            var orderedEntityDiffs = new List<EntityDiff>(entityDiffs.Count);
+
+            foreach (var entity in entitiesAfterMovement)
+            {
+                if (entityAfterToEntityDiff.ContainsKey(entity))
+                {
+                    orderedEntityDiffs.Add(entityAfterToEntityDiff[entity]);
+                }
+            }
+
+            foreach (var diff in orderedEntityDiffs)
+            {
+                if (sourceEntity != null && diff.GetEntityId() == sourceEntity.GetEntityId())
+                {
+                    // Ignore source as we handle explicit movement outside (in the powerTaskList describer)
+                    continue;
+                }
+
+                if (diff.MovedZone())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetDestroyedEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                if (after.GetEntity(entityBefore.GetEntityId()) == null)
+                {
+                    ret.Add(entityBefore);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetNewEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityAfter in after.m_entities)
+            {
+                if (before.GetEntity(entityAfter.GetEntityId()) == null)
+                {
+                    ret.Add(entityAfter);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetTransformedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasTransformed())
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetJustDiedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasDied() && entityDiff.GetDeathSpeech().SingularSpeech.Length > 0) // Length > 0 is because of replacing weapons e.g. equipping 1 wicked knife when 1 already exists
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> Clone(List<Entity> entities)
+        {
+            List<Entity> ret = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                ret.Add(entity.CloneForAccessibility());
+            }
+
+            return ret;
+        }
+
+        private static Entity Clone(Entity entity)
+        {
+            if (entity == null)
+            {
+                return null;
+            }
+
+            return entity.CloneForAccessibility();
+        }
+
+        private static List<Entity> GetEntitiesFromZone(Zone zone)
+        {
+            var ret = new List<Entity>();
+            var cards = zone.GetCards();
+
+            if (cards == null)
+            {
+                return ret;
+            }
+
+            foreach (var card in cards)
+            {
+                ret.Add(card.GetEntity());
+            }
+
+            return ret;
+        }
+
+        #region Weapon stuff
+
+        private static HashSet<Entity> s_heroWeaponBroke = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroSheathedWeapon = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroUnsheathedWeapon = new HashSet<Entity>(new EntityComparer());
+
+        internal static void MarkWeaponUnsheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponUnsheathed: {hero}");
+            s_heroUnsheathedWeapon.Add(hero);
+        }
+
+        internal static void MarkWeaponSheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponSheathed: {hero}");
+            s_heroSheathedWeapon.Add(hero);
+        }
+
+
+        internal static void Reset()
+        {
+            s_heroWeaponBroke.Clear();
+            s_heroSheathedWeapon.Clear();
+            s_heroUnsheathedWeapon.Clear();
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
new file mode 100644
index 0000000..d88d15f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
@@ -0,0 +1,236 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleInputMgr : MonoBehaviour
+    {
+        private static bool[] m_setMouseButtonDown = new bool[3];
+
+        private static Vector3 m_setMousePosition = Vector3.zero;
+
+        private void LateUpdate()
+        {
+            AccessibleUnityInput.Get().SetMousePosition(m_setMousePosition);
+
+            for (int button = 0; button < m_setMouseButtonDown.Length; button++) 
+            {
+                AccessibleUnityInput.Get().SetMouseButtonDown(button, m_setMouseButtonDown[button]);
+                m_setMouseButtonDown[button] = false; // TODO: Would have to add a lot more logic if we wanted to hold/drag/etc. but don't think that'll be needed
+            }
+
+            if (AccessibleKey.TOGGLE_ACCESSIBILITY.IsPressed())
+            {
+                ToggleAccessibility();
+            }
+
+            // Debug stuff
+            if (HearthstoneAccessConstants.DEV_MODE && Input.GetKeyUp(KeyCode.F6))
+            {
+                Vector3 dbgMousePos = Input.mousePosition;
+                AccessibilityUtils.LogDebug($"[DBG] Mouse position is {dbgMousePos}");
+            }
+        }
+
+        private void ToggleAccessibility()
+        {
+            AccessibleUnityInput.Get().ToggleEnabled();
+            AccessibilityMgr.ToggleEnabled();
+        }
+
+        private static void ClickLeftMouseButtonImpl()
+        {
+            AccessibilityUtils.LogDebug($"[DBG] Clicked left mouse at {m_setMousePosition}");
+            m_setMouseButtonDown[0] = true;
+        }
+
+        public static void ClickLeftMouseButton()
+        {
+            ClickLeftMouseButtonImpl();
+        }
+
+        public static void ClickLeftMouseButton(Component component)
+        {
+            MoveMouseTo(component);
+            ClickLeftMouseButtonImpl();
+        }
+
+        private static void ClickRightMouseButtonImpl()
+        {
+            AccessibilityUtils.LogDebug($"[DBG] Clicked right mouse at {m_setMousePosition}");
+            m_setMouseButtonDown[1] = true;
+        }
+
+        internal static void ClickRightMouseButton()
+        {
+            ClickRightMouseButtonImpl();
+        }
+
+        private static void ClickMiddleMouseButton()
+        {
+            m_setMouseButtonDown[2] = true;
+        }
+
+        private static void SetMousePosition(Vector3 pos)
+        {
+            if (pos != m_setMousePosition)
+			{
+				AccessibilityUtils.LogDebug($"SetMousePosition{pos}");
+			}
+			m_setMousePosition = pos;
+        }
+
+        internal static void MoveMouseTo(Component component)
+        {
+            if (component == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(component.transform);
+        }
+
+        internal static Vector3 GetMousePosition(Component component)
+        {
+            return GetMousePosition(component.transform);
+        }
+
+        internal static void MoveMouseToTransform(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+
+            MoveMouseToWorldPosition(transform.position);
+        }
+
+        internal static Vector3 GetMousePosition(Transform transform)
+        {
+            return GetMousePosition(transform.position);
+        }
+
+        public static void ClickCenterOfScreen()
+        {
+            MoveMouseToCenterOfScreen();
+            ClickLeftMouseButton();
+        }
+
+        public static void RightClickCenterOfScreen()
+        {
+            MoveMouseToCenterOfScreen();
+            ClickRightMouseButton();
+        }
+
+        internal static void MoveMouseToCenterOfScreen()
+        {
+            var center = new Vector3(Screen.width / 2, Screen.height / 2);
+            SetMousePosition(center);
+        }
+
+        internal static void MoveMouseToWorldPosition(Vector3 pos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(pos);
+            screenPos.z = 0;
+            SetMousePosition(screenPos);
+        }
+
+        internal static Vector3 GetMousePosition(Vector3 worldPos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPos);
+            screenPos.z = 0;
+            return screenPos;
+        }
+
+        internal static void HideMouse()
+        {
+            SetMousePosition(Vector3.zero);
+        }
+
+        internal static bool IsMouseHidden()
+		{
+            return m_setMousePosition == Vector3.zero;
+		}
+
+        internal static void Click(Component component)
+        {
+            if (component == null)
+            {
+                return;
+            }
+            Click(component.transform);
+        }
+
+        internal static void Click(GameObject gameObject)
+        {
+            if (gameObject == null)
+            {
+                return;
+            }
+            Click(gameObject.transform);
+        }
+
+        internal static void Click(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(transform);
+            ClickLeftMouseButton();
+        }
+
+        internal static void Click(Vector3 worldPosition)
+        {
+            SetMousePosition(worldPosition);
+            ClickLeftMouseButton();
+        }
+
+        private static bool m_holdingAnyKeyDown;
+
+        internal static bool AnyKeyUp()
+        {
+            var ret = false;
+
+            if (Input.anyKey)
+            {
+                m_holdingAnyKeyDown = true;
+            }
+
+            if (!Input.anyKey)
+            {
+                if (m_holdingAnyKeyDown)
+                {
+                    ret = true;
+                }
+
+                m_holdingAnyKeyDown = false;
+            }
+
+            return ret;
+        }
+
+        internal static int? TryGetPressedNumKey()
+        {
+            for (var i = 0; i <= 9; i++)
+            {
+                if (Input.GetKeyUp(KeyCode.Alpha0 + i))
+                {
+                    if (i == 0)
+                    {
+                        return 10;
+                    } else
+                    {
+                        return i;
+                    }
+                }
+            }
+
+            return null;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs
new file mode 100644
index 0000000..7314e22
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs
@@ -0,0 +1,172 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public abstract class AccessibleItem : AccessibleElement
+    {
+        // TODO: consider having short vs long descriptions in the future?
+        private string[] m_lines;
+
+        private int m_curLine;
+
+        private Action m_finishReadAction;
+
+        public AccessibleItem(AccessibleComponent parent) : this(parent, 0) { }
+
+        public AccessibleItem(AccessibleComponent parent, int startReadingFromLine) : base(parent)
+        {
+            m_curLine = startReadingFromLine;
+        }
+
+        private void SetupLines()
+        {
+            var lines = GetLines();
+            m_lines = lines.ToArray();
+        }
+
+        internal abstract List<string> GetLines();
+
+        internal void ReadLine()
+        {
+            SetupLines();
+            ReadLineImpl();
+        }
+
+        internal void ReadLine(int line)
+        {
+            SetupLines();
+            ReadLineImpl(line);
+        }
+
+        internal string GetLine(int line)
+        {
+            SetupLines();
+
+            if (line >= m_lines.Length)
+            {
+                return "";
+            }
+
+            return m_lines[line];
+        }
+
+        private void ReadLineImpl()
+        {
+            ReadLineImpl(m_curLine);
+        }
+
+        private void ReadLineImpl(int line)
+        {
+            if (line >= m_lines.Length)
+            {
+                return;
+            }
+
+            Output(m_lines[line]);
+        }
+
+        internal void ReadNextLine()
+        {
+            SetupLines();
+
+            if (IncLine(1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void ReadPrevLine()
+        {
+            SetupLines();
+            if (IncLine(-1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void Reset()
+        {
+            m_curLine = 0;
+        }
+
+        private bool IncLine(int inc)
+        {
+            m_curLine += inc;
+
+            if (m_curLine < 0)
+            {
+                m_curLine = 0;
+                return false;
+            }
+            else if (m_curLine >= m_lines.Length)
+            {
+                m_curLine = m_lines.Length - 1;
+                return false;
+            }
+
+            if (m_curLine == m_lines.Length - 1)
+            {
+                OnFinishReading();
+            }
+
+            return true; // new line
+        }
+
+        private void OnFinishReading()
+        {
+            if (m_finishReadAction != null)
+            {
+                m_finishReadAction();
+                m_finishReadAction = null;
+            }
+        }
+
+        internal void RegisterFinishReadListener(Action action)
+        {
+            m_finishReadAction = action;
+        }
+
+        internal void ReadAllLines()
+        {
+            if (m_curLine == 0)
+            {
+                SetupLines();
+            }
+
+            while (m_curLine < m_lines.Length - 1)
+            {
+                ReadLineImpl();
+                IncLine(1); // This has a guard so we need to read after as well
+            }
+
+            ReadLineImpl();
+        }
+
+        internal virtual bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadNextLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadPrevLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadLineImpl();
+                return true;
+            }
+            else if (AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadAllLines();
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleJournal.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleJournal.cs
new file mode 100644
index 0000000..4d02b45
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleJournal.cs
@@ -0,0 +1,608 @@
+﻿using Hearthstone.DataModels;
+using Hearthstone.Progression;
+using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleJournal : AccessibleUI
+    {
+        private enum State
+        {
+            LOADING,
+            MAIN_MENU,
+            QUESTS_MENU,
+            READING_DAILY_QUESTS,
+            READING_WEEKLY_QUESTS,
+            REWARDS_TRACK_MENU,
+            CLAIMING_REWARD,
+            CHOOSING_REWARD
+        };
+
+        private State m_curState = State.LOADING;
+
+        private Widget m_JournalWidget;
+
+        private AccessibleMenu m_mainMenu;
+
+        // Quests
+        private AccessibleMenu m_questsMenu;
+        private AccessibleListOfItems<AccessibleQuest> m_dailyQuests;
+        private AccessibleListOfItems<AccessibleQuest> m_weeklyQuests;
+
+        // Rewards Track
+        private AccessibleMenu m_rewardsTrackMenu;
+
+        private static AccessibleJournal s_instance = new AccessibleJournal();
+
+        internal static AccessibleJournal Get()
+        {
+            return s_instance;
+        }
+
+        public void OnJournalOpened(Widget widget)
+        {
+            Reset();
+
+            m_JournalWidget = widget;
+
+            AccessibilityMgr.ShowUI(this);
+
+            ReadJournal();
+        }
+
+        private void Reset()
+        {
+            m_mainMenu = null;
+            m_questsMenu = null;
+            m_dailyQuests = null;
+            m_weeklyQuests = null;
+            m_curState = State.LOADING;
+        }
+
+        public void OnJournalClosed()
+        {
+            AccessibilityMgr.HideUI(this);
+        }
+
+        private void ReadJournal()
+        {
+            var buttonManager = GetButtonManager();
+            var questButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "QuestButton/JournalButtonTab/Root");
+            var rewardButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "RewardButton/JournalButtonTab/Root");
+            var achievementButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "AchievementButton/JournalButtonTab/Root");
+            var profileButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "ProfileButton/JournalButtonTab/Root");
+
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL), CloseJournal);
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_QUESTS_TITLE"), () =>  AccessibleWidgetUtils.ClickButton(questButton));
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_REWARDS_TITLE"), ReadRewardsTrack);
+            //m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_REWARDS_TITLE"), () => AccessibleWidgetUtils.ClickButton(rewardButton));
+            /*m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_ACHIEVEMENTS_TITLE"), () => AccessibleWidgetUtils.ClickButton(achievementButton));
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_PROFILE_TITLE"), () => AccessibleWidgetUtils.ClickButton(profileButton));*/
+
+            m_mainMenu.StartReading();
+
+            m_curState = State.MAIN_MENU;
+        }
+
+		internal void OnTabChanged(JournalMetaDataModel data)
+        {
+            AccessibilityUtils.LogDebug($"AccessibleJournal.OnTabChanged({data.TabIndex})");
+
+            if (data.TabIndex == 1)
+            {
+                ReadQuestLog();
+            }
+        }
+
+		#region Quests
+
+		private void ReadQuestLog()
+        {
+            var journalInnerTrayManager = GetJournalInnerTrayManager();
+            var questLog = AccessibleUnityUtils.GetChildObject(journalInnerTrayManager, "Root/QuestLog/QuestLog");
+
+            var dailySpecific = AccessibleUnityUtils.GetChildObject(questLog.gameObject, "Root/DailySpecific");
+            var weeklySpecific = AccessibleUnityUtils.GetChildObject(questLog.gameObject, "Root/WeeklySpecific");
+
+            var dailyQuestList = AccessibleUnityUtils.GetChildObject(dailySpecific, "DailyQuestList/QuestList");
+            var weeklyQuestList = AccessibleUnityUtils.GetChildObject(weeklySpecific, "WeeklyQuestList/QuestList");
+
+            var dailyTitle = AccessibleUnityUtils.GetChildObject(dailySpecific, "DailyTitle_Text");
+            var weeklyTitle = AccessibleUnityUtils.GetChildObject(weeklySpecific, "WeeklyTitle_Text");
+
+            var dailyQuestTiles = GetQuestTiles(dailyQuestList);
+            var weeklyQuestTiles = GetQuestTiles(weeklyQuestList);
+
+            var dailyQuests = CreateQuestsFromQuestTiles(dailyQuestTiles);
+            var weeklyQuests = CreateQuestsFromQuestTiles(weeklyQuestTiles);
+
+            if (dailyQuests.Count == 0 && weeklyQuests.Count == 0)
+			{
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_QUEST_LOG_NO_QUESTS));
+                return;
+			}
+
+            if (!dailyTitle.activeInHierarchy)
+            {
+                dailyQuests.AddRange(weeklyQuests);
+                m_dailyQuests = new AccessibleListOfItems<AccessibleQuest>(this, dailyQuests);
+				ReadQuests(m_dailyQuests, State.READING_DAILY_QUESTS);
+            }
+            else
+            {
+                m_dailyQuests = new AccessibleListOfItems<AccessibleQuest>(this, dailyQuests);
+                m_weeklyQuests = new AccessibleListOfItems<AccessibleQuest>(this, weeklyQuests);
+
+				m_questsMenu = new AccessibleMenu(this, "", ReadJournal);
+                m_questsMenu.AddOption(GetQuestPoolName(dailyTitle), () => ReadQuests(m_dailyQuests, State.READING_DAILY_QUESTS));
+                m_questsMenu.AddOption(GetQuestPoolName(weeklyTitle), () => ReadQuests(m_weeklyQuests, State.READING_WEEKLY_QUESTS));
+
+                m_questsMenu.StartReading();
+                m_curState = State.QUESTS_MENU;
+            }
+        }
+
+		internal void OnQuestRerolled(Hearthstone.Progression.QuestTile questTile)
+		{
+            RereadQuestsAfterInteract();
+		}
+
+		private List<AccessibleQuest> CreateQuestsFromQuestTiles(List<Hearthstone.Progression.QuestTile> questTiles)
+		{
+			var ret = new List<AccessibleQuest>();
+
+            foreach(var questTile in questTiles)
+            {
+				ret.Add(new AccessibleQuest(this, questTile.GetQuestDataModel(), questTile));
+            }
+
+            return ret;
+		}
+
+		private void ReadQuests(AccessibleListOfItems<AccessibleQuest> quests, State state)
+        {
+            quests.StartReading();
+            m_curState = state;
+        }
+
+        private string GetQuestPoolName(GameObject titleGO)
+        {
+            var uberText = titleGO.GetComponent<UberText>();
+
+            if (uberText != null)
+            {
+                return GameStrings.Get(uberText.Text);
+            }
+
+            return "";
+        }
+
+        private List<Hearthstone.Progression.QuestTile> GetQuestTiles(GameObject questList)
+        {
+            var ret = new List<Hearthstone.Progression.QuestTile>();
+
+            if (questList == null)
+            {
+                return ret;
+            }
+
+            var root = questList.transform.Find("Root");
+
+            for (int i = 0; i < root.childCount; i++)
+            {
+                var child = root.GetChild(i);
+
+                var questTileGO = child.Find("QuestTile");
+
+                if (questTileGO != null)
+                {
+                    var questTile = questTileGO.GetComponent<Hearthstone.Progression.QuestTile>();
+
+                    if (questTile != null)
+                    {
+                        ret.Add(questTile);
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+		private void ReadQuestsOrJournal()
+        {
+            if (m_questsMenu != null)
+            {
+                m_questsMenu.StartReading();
+                m_curState = State.QUESTS_MENU;
+            }
+            else
+            {
+                ReadJournal();
+            }
+        }
+
+		internal void OnQuestAbandoned(Hearthstone.Progression.QuestTile questTile)
+		{
+            AccessibilityMgr.ShowUI(this); // Make it so we can output while the alert popup disappears
+            if (RefreshMenuAfterAbandonIfNeeded(m_dailyQuests, questTile) && m_dailyQuests.Count == 0)
+            {
+                ReadJournal();
+                return;
+            }
+            else if (RefreshMenuAfterAbandonIfNeeded(m_weeklyQuests, questTile) && m_weeklyQuests.Count == 0)
+			{
+                ReadJournal();
+                return;
+			}
+
+            RereadQuestsAfterInteract();
+		}
+
+		private bool RefreshMenuAfterAbandonIfNeeded(AccessibleListOfItems<AccessibleQuest> quests, Hearthstone.Progression.QuestTile abandonedQuest)
+		{
+            if (quests == null)
+			{
+                return false;
+			}
+
+            var questsBeforeAbandon = quests.Items;
+
+            var accessibleAbandonedQuest = questsBeforeAbandon.Find(q => q.GetQuestTile() == abandonedQuest);
+
+            if (accessibleAbandonedQuest != null)
+			{
+                quests.RemoveItem(accessibleAbandonedQuest);
+                return true;
+			}
+
+            return false;
+		}
+
+		internal void OnQuestAbandonCancel()
+		{
+            AccessibilityMgr.ShowUI(this); // Make it so we can output while the alert popup disappears
+            RereadQuestsAfterInteract();
+		}
+
+		private void RereadQuestsAfterInteract()
+		{
+            if (m_curState == State.READING_DAILY_QUESTS)
+			{
+                m_dailyQuests.StartReading();
+			}
+            else if (m_curState == State.READING_WEEKLY_QUESTS)
+			{
+                m_weeklyQuests.StartReading();
+			}
+		}
+
+		#endregion
+
+		private GameObject GetJournalInnerTrayManager()
+        {
+            return m_JournalWidget.transform.Find("Root/JournalInnerTrayManager/JournalInnerTrayManager").gameObject;
+        }
+
+        private GameObject GetButtonManager()
+        {
+            return m_JournalWidget.transform.Find("Root/ButtonManager").gameObject;
+        }
+
+        private void CloseJournal()
+        {
+            m_JournalWidget.TriggerEvent("HIDE");
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if ((m_curState == State.READING_DAILY_QUESTS || m_curState == State.READING_WEEKLY_QUESTS) && AccessibleKey.BACK.IsPressed())
+			{
+				// Everything else are menus so they handle their own BACKs
+				{
+					ReadQuestsOrJournal();
+					return;
+				}
+			}
+
+			if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.READING_DAILY_QUESTS)
+            {
+				m_dailyQuests?.HandleAccessibleInput();
+			}
+			else if (m_curState == State.READING_WEEKLY_QUESTS)
+            {
+				m_weeklyQuests?.HandleAccessibleInput();
+			}
+			else if (m_curState == State.QUESTS_MENU)
+            {
+                m_questsMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.REWARDS_TRACK_MENU)
+            {
+                m_rewardsTrackMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.CHOOSING_REWARD)
+            {
+                if (AccessibleKey.CONFIRM.IsPressed())
+				{
+                    ClaimChooseOneReward(m_chooseOneRewards.GetItemBeingRead());
+                    return;
+				}
+                m_chooseOneRewards?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+            if (m_curState == State.LOADING)
+            {
+                return LocalizedText.GLOBAL_LOADING;
+            }
+            else if (m_curState == State.MAIN_MENU)
+            {
+                return m_mainMenu?.GetHelp();
+            }
+            else if (m_curState == State.READING_DAILY_QUESTS || m_curState == State.READING_WEEKLY_QUESTS)
+            {
+                return LocalizationUtils.Get(LocalizationKey.UI_QUEST_NOTIFICATION_POPUP_HELP);
+            }
+            else if (m_curState == State.READING_WEEKLY_QUESTS)
+            {
+                return m_weeklyQuests?.GetHelp(true);
+            }
+            else if (m_curState == State.QUESTS_MENU)
+            {
+                return m_questsMenu?.GetHelp();
+            }
+            else if (m_curState == State.REWARDS_TRACK_MENU)
+            {
+                return m_rewardsTrackMenu?.GetHelp();
+            }
+            else if (m_curState == State.CHOOSING_REWARD)
+            {
+                return m_chooseOneRewards.GetHelp(false);
+            }
+
+            return "";
+        }
+
+        #region Rewards Track
+		private void ReadRewardsTrack()
+        {
+            var numRewards = GetUnclaimedRewardsCount();
+
+			m_rewardsTrackMenu = new AccessibleMenu(this, "", ReadJournal);
+
+            m_rewardsTrackMenu.AddOption(LocalizationUtils.Format(LocalizationKey.UI_REWARDS_TRACK_CLAIM_REWARDS, numRewards), ClaimRewardsTrackRewards);
+			m_rewardsTrackMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_REWARDS_TRACK_READ_LEVEL), ReadRewardsTrackLevel);
+
+			m_rewardsTrackMenu.StartReading();
+			m_curState = State.REWARDS_TRACK_MENU;
+		}
+
+        private int GetCurrentTrackLevel()
+		{
+            if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+                return AccessibleRewardsTrackTestingUtils.GetCurrentTrackLevel();
+			}
+
+			return RewardTrackManager.Get().TrackDataModel.Level;
+		}
+
+        private int GetCurrentTrackId()
+		{
+            if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+                return AccessibleRewardsTrackTestingUtils.GetCurrentTrackId();
+			}
+
+			return RewardTrackManager.Get().TrackDataModel.RewardTrackId;
+		}
+
+        private List<RewardTrackLevelDbfRecord> GetUnclaimedRewards()
+		{
+            var ret = new List<RewardTrackLevelDbfRecord>();
+
+            int trackLevel = GetCurrentTrackLevel();
+            int trackId = GetCurrentTrackId();
+			int levelCap = RewardTrackManager.Get().RewardTrackAsset.LevelCapSoft;
+
+			foreach (var record in RewardTrackManager.Get().RewardTrackAsset.Levels)
+			{
+				if (trackId == record.RewardTrackId && record.Level <= trackLevel && record.Level <= levelCap && RewardTrackManager.Get().HasUnclaimedRewardsForLevel(record))
+				{
+                    ret.Add(record);
+				}
+			}
+
+            ret.Sort((a, b) => a.Level - b.Level);
+
+            return ret;
+		}
+
+		private void ClaimRewardsTrackRewards()
+		{
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            if (unclaimedRewards.Count == 0)
+			{
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_REWARDS_TRACK_CLAIM_REWARDS_NO_REWARDS));
+			}
+            else
+			{
+                ClaimNextTrackReward();
+			}
+		}
+
+		private void ClaimNextTrackReward()
+		{
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            if (unclaimedRewards.Count == 0)
+			{
+                return;
+			}
+            else
+			{
+                var nextReward = unclaimedRewards[0];
+                var nextRewardLevel = nextReward.Level;
+                var rewardState = RewardTrackManager.Get().GetPlayerRewardTrackLevelState(nextRewardLevel);
+                var forPaidTrack = true;
+
+                if (rewardState.HasFreeRewardStatus && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrackManager.RewardStatus)rewardState.FreeRewardStatus))
+				{
+                    forPaidTrack = false;
+				}
+
+                if (IsChooseOneReward(nextReward, forPaidTrack))
+				{
+					ReadChooseOneRewards(nextReward, forPaidTrack);
+				}
+                else
+				{
+					m_curState = State.CLAIMING_REWARD;
+					RewardTrackManager.Get().ClaimRewardTrackReward(nextReward.RewardTrackId, nextReward.Level, forPaidTrack);
+				}
+			}
+		}
+
+        private AccessibleListOfItems<AccessibleRewardItemDataModel> m_chooseOneRewards;
+
+		private void ReadChooseOneRewards(RewardTrackLevelDbfRecord record, bool forPaidTrack)
+		{
+            var dbfRecord = (forPaidTrack ? record.PaidRewardListRecord : record.FreeRewardListRecord);
+
+            if (dbfRecord == null)
+			{
+                AccessibilityUtils.LogFatalError($"ReadChooseOneRewards() reached null dbfRecord: record.RewardTrackId={record.RewardTrackId} record.ID={record.ID} forPaidTrack={forPaidTrack}");
+                return;
+			}
+
+            if (!dbfRecord.ChooseOne)
+			{
+                AccessibilityUtils.LogFatalError($"ReadChooseOneRewards() reached a non-choose one dbfRecord: record.RewardTrackId={record.RewardTrackId} record.ID={record.ID} forPaidTrack={forPaidTrack}");
+                return;
+			}
+
+            var choices = dbfRecord.RewardItems;
+            var isHeroSkinChoice = true;
+            foreach (var choice in choices)
+			{
+                if (choice.RewardType != Assets.RewardItem.RewardType.HERO_SKIN)
+				{
+                    isHeroSkinChoice = false;
+				}
+			}
+
+            var menuTitle = isHeroSkinChoice ? GameStrings.Get("GLUE_PROGRESSION_REWARD_TRACK_POPUP_SKIN_CHOICE_TITLE") : GameStrings.Get("GAMEPLAY_CHOOSE_ONE");
+            AccessibilityMgr.Output(this, menuTitle, true);
+
+			var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+			
+			foreach (var choice in choices)
+            {
+                // Note: subsets may return more than 1 but this seems very unlikely to ever happen since choose one is just hero skins
+                var rewardsItems = RewardFactory.CreateRewardItemDataModel(choice);
+				accessibleRewards.Add(new AccessibleRewardItemDataModel(this, rewardsItems[0], !isHeroSkinChoice));
+            }
+
+			m_chooseOneRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(this, accessibleRewards);
+            m_chooseOneRewards.StartReading();
+            m_curState = State.CHOOSING_REWARD;
+		}
+
+		private void ClaimChooseOneReward(AccessibleRewardItemDataModel chosen)
+		{
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            if (unclaimedRewards.Count == 0)
+			{
+                AccessibilityUtils.LogFatalError("ClaimChooseOneReward reached invalid state: unclaimedRewards was empty");
+                return;
+			}
+            else
+			{
+                var nextReward = unclaimedRewards[0];
+                var nextRewardLevel = nextReward.Level;
+                var rewardState = RewardTrackManager.Get().GetPlayerRewardTrackLevelState(nextRewardLevel);
+                var forPaidTrack = true;
+
+                if (rewardState.HasFreeRewardStatus && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrackManager.RewardStatus)rewardState.FreeRewardStatus))
+				{
+                    forPaidTrack = false;
+				}
+
+                if (IsChooseOneReward(nextReward, forPaidTrack))
+				{
+					m_curState = State.CLAIMING_REWARD;
+					RewardTrackManager.Get().ClaimRewardTrackReward(nextReward.RewardTrackId, nextReward.Level, forPaidTrack, chosen.GetDataModel().AssetId);
+				}
+                else
+				{
+					AccessibilityUtils.LogFatalError($"ClaimChooseOneReward reached invalid state: reward was not choose one. trackId={nextReward.RewardTrackId} trackLevel={nextReward.Level} forPaidTrack={forPaidTrack}");
+					return;
+				}
+			}
+		}
+
+		private bool IsChooseOneReward(RewardTrackLevelDbfRecord record, bool forPaidTrack)
+		{
+            var dbfRecord = (forPaidTrack ? record.PaidRewardListRecord : record.FreeRewardListRecord);
+
+            if (dbfRecord == null)
+			{
+                return false;
+			}
+
+			return dbfRecord.ChooseOne;
+		}
+
+		private int GetUnclaimedRewardsCount()
+		{
+            var ret = 0;
+
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            foreach (var unclaimedReward in unclaimedRewards)
+			{
+                var freeRecord = unclaimedReward.FreeRewardListRecord;
+                var paidRecord = unclaimedReward.PaidRewardListRecord;
+                var playerRewardTrackLevelState = RewardTrackManager.Get().GetPlayerRewardTrackLevelState(unclaimedReward.Level);
+                var premiumRewardsUnlocked = RewardTrackManager.Get().ArePremiumRewardsUnlocked();
+
+                if (freeRecord != null && freeRecord.RewardItems?.Count > 0 && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrackManager.RewardStatus)playerRewardTrackLevelState.FreeRewardStatus))
+				{
+                    ret++;
+				}
+
+                if (premiumRewardsUnlocked && paidRecord != null && paidRecord.RewardItems?.Count > 0 && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrackManager.RewardStatus)playerRewardTrackLevelState.PaidRewardStatus))
+				{
+                    ret++;
+				}
+			}
+
+            return ret;
+		}
+
+		internal void OnTrackRewardAckd(int rewardTrackId, int level, bool forPaidTrack)
+		{
+            if (m_curState == State.CLAIMING_REWARD)
+			{
+                ReadRewardsTrack();
+			}
+		}
+
+		private void ReadRewardsTrackLevel()
+		{
+            AccessibilityMgr.Output(this, $"{GetCurrentTrackLevel()}");
+		}
+		#endregion
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs
new file mode 100644
index 0000000..6594547
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs
@@ -0,0 +1,378 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleKey
+    {
+        public static AccessibleKey CONFIRM = CreateKey(KeyCode.Return);
+        public static AccessibleKey GLOBAL_CONFIRM = CreateGlobalKey(KeyCode.Return);
+        public static AccessibleKey BACK = CreateKey(KeyCode.Backspace);
+        public static AccessibleKey GLOBAL_BACK = CreateGlobalKey(KeyCode.Backspace);
+        public static AccessibleKey OPEN_GAME_MENU = CreateGlobalKey(KeyCode.Escape);
+        public static AccessibleKey HELP = CreateGlobalKey(KeyCode.F1);
+        public static AccessibleKey OPEN_SOCIAL_MENU = CreateGlobalKey(KeyCode.F4);
+        public static AccessibleKey TOGGLE_ACCESSIBILITY = CreateGlobalKey(KeyCode.F8);
+        public static AccessibleKey READ_NEXT_LINE = CreateKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_LINE = CreateKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_CUR_LINE = CreateKey(KeyCode.UpArrow, true);
+        public static AccessibleKey READ_TO_END = CreateKey(KeyCode.DownArrow, true);
+        public static AccessibleKey READ_NEXT_ITEM = CreateKey(KeyCode.RightArrow);
+        public static AccessibleKey READ_PREV_ITEM = CreateKey(KeyCode.LeftArrow);
+        public static AccessibleKey READ_NEXT_VALID_ITEM = CreateKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_VALID_ITEM = CreateKey(KeyCode.Tab, true);
+        public static AccessibleKey READ_FIRST_ITEM = CreateKey(KeyCode.Home);
+        public static AccessibleKey READ_LAST_ITEM = CreateKey(KeyCode.End);
+        public static AccessibleKey READ_FIRST_ITEM_GLOBAL = CreateKey(KeyCode.Home, true);
+        public static AccessibleKey READ_LAST_ITEM_GLOBAL = CreateKey(KeyCode.End, true);
+        public static AccessibleKey READ_NEXT_PAGE = CreateKey(KeyCode.PageDown);
+        public static AccessibleKey READ_PREV_PAGE = CreateKey(KeyCode.PageUp);
+        public static AccessibleKey SKIP_NOTIFICATION = CreateKey(KeyCode.Space);
+        public static AccessibleKey SPACE = CreateKey(KeyCode.Space);
+        public static AccessibleKey ESC = CreateKey(KeyCode.Escape);
+
+        public static AccessibleKey GLOBAL_FIND = CreateHotkey(KeyCode.F);
+
+        public static AccessibleKey DECREASE_GAME_SPEED = CreateKey(KeyCode.F11);
+        public static AccessibleKey INCREASE_GAME_SPEED = CreateKey(KeyCode.F12);
+
+        public static AccessibleKey GLOBAL_LEFT = CreateGlobalKey(KeyCode.LeftArrow);
+        public static AccessibleKey GLOBAL_RIGHT = CreateGlobalKey(KeyCode.RightArrow);
+
+        #region Menu Controls
+        public static AccessibleKey READ_NEXT_MENU_OPTION = CreateKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_MENU_OPTION = CreateKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_CUR_MENU_OPTION = CreateKey(KeyCode.UpArrow, true);
+        public static AccessibleKey READ_NEXT_VALID_MENU_OPTION = CreateKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_VALID_MENU_OPTION = CreateKey(KeyCode.Tab, true);
+        public static AccessibleKey READ_NEXT_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_CUR_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.UpArrow, true);
+        public static AccessibleKey READ_NEXT_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab, true);
+        #endregion
+
+        #region Hub
+        // TODO: Play Ranked, Play Casual
+        public static AccessibleKey HUB_SHOP = CreateKey(KeyCode.S);
+        public static AccessibleKey HUB_MY_COLLECTION = CreateKey(KeyCode.C);
+        public static AccessibleKey HUB_JOURNAL = CreateKey(KeyCode.J);
+        public static AccessibleKey HUB_BATTLEGROUNDS = CreateKey(KeyCode.B);
+        public static AccessibleKey HUB_MODES = CreateKey(KeyCode.M);
+        #endregion
+
+        #region My Collection
+        public static AccessibleKey SEE_DECKS = CreateKey(KeyCode.D);
+        public static AccessibleKey CREATE_DECK = CreateKey(KeyCode.N);
+        public static AccessibleKey DELETE_DECK = CreateKey(KeyCode.Delete);
+        public static AccessibleKey EDIT_DECK = CreateKey(KeyCode.E);
+        #endregion
+
+        #region Quest Log
+        public static AccessibleKey REROLL_QUEST = CreateKey(KeyCode.R);
+        public static AccessibleKey ABANDON_QUEST = CreateKey(KeyCode.A);
+        #endregion
+
+        #region Game Keys
+        public static AccessibleKey MULLIGAN_MARK_CARD = CreateKey(KeyCode.Space);
+        public static AccessibleKey SEE_PLAYER_HAND = CreateKey(KeyCode.C);
+        public static AccessibleKey SEE_OPPONENT_HAND = CreateKey(KeyCode.C, true);
+        public static AccessibleKey SEE_PLAYER_DECK = CreateKey(KeyCode.D);
+        public static AccessibleKey SEE_OPPONENT_DECK = CreateKey(KeyCode.D, true);
+        public static AccessibleKey SEE_PLAYER_MANA = CreateKey(KeyCode.A);
+        public static AccessibleKey SEE_OPPONENT_MANA = CreateKey(KeyCode.A, true);
+        public static AccessibleKey SEE_PLAYER_SECRETS = CreateKey(KeyCode.S);
+        public static AccessibleKey SEE_OPPONENT_SECRETS = CreateKey(KeyCode.S, true);
+        public static AccessibleKey SEE_PLAYER_MINIONS = CreateKey(KeyCode.B);
+        public static AccessibleKey SEE_OPPONENT_MINIONS = CreateKey(KeyCode.G);
+        public static AccessibleKey SEE_OPPONENT_HERO = CreateKey(KeyCode.F);
+        public static AccessibleKey SEND_ALL_MINIONS_TO_FACE = CreateKey(KeyCode.F, true);
+        public static AccessibleKey SEE_PLAYER_HERO = CreateKey(KeyCode.V);
+        public static AccessibleKey SEE_PLAYER_HERO_POWER = CreateKey(KeyCode.R);
+        public static AccessibleKey SEE_OPPONENT_HERO_POWER = CreateKey(KeyCode.R, true);
+        public static AccessibleKey SEE_PLAYER_WEAPON = CreateKey(KeyCode.W);
+        public static AccessibleKey SEE_OPPONENT_WEAPON = CreateKey(KeyCode.W, true);
+        public static AccessibleKey SEE_HISTORY = CreateKey(KeyCode.Y);
+        public static AccessibleKey END_TURN = CreateKey(KeyCode.E);
+        public static AccessibleKey FORCE_END_TURN = CreateKey(KeyCode.E, true);
+        public static AccessibleKey READ_TOOLTIP = CreateKey(KeyCode.I);
+        public static AccessibleKey READ_ORIGINAL_CARD_STATS = CreateKey(KeyCode.K);
+        public static AccessibleKey TRADE_CARD = CreateKey(KeyCode.T);
+		#endregion
+
+		#region Battlegrounds-specific Keys
+        public static AccessibleKey SEE_TAVERN = CreateKey(KeyCode.T);
+        public static AccessibleKey UPGRADE_TAVERN = CreateKey(KeyCode.U);
+        public static AccessibleKey FREEZE_TAVERN = CreateKey(KeyCode.F);
+        public static AccessibleKey REFRESH_TAVERN = CreateKey(KeyCode.R);
+
+        public static AccessibleKey FORCE_UPGRADE_TAVERN = CreateKey(KeyCode.U, true);
+        public static AccessibleKey FORCE_FREEZE_TAVERN = CreateKey(KeyCode.F, true);
+        public static AccessibleKey FORCE_REFRESH_TAVERN = CreateKey(KeyCode.R, true);
+
+        public static AccessibleKey BATTLEGROUNDS_SEE_PLAYER_HERO_POWER = CreateKey(KeyCode.P);
+        public static AccessibleKey BATTLEGROUNDS_SEE_OPPONENT_HERO_POWER = CreateKey(KeyCode.P, true);
+
+        public static AccessibleKey BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS = CreateKey(KeyCode.N);
+        public static AccessibleKey BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS_TO_END = CreateKey(KeyCode.N, true);
+        public static AccessibleKey BATTLEGROUNDS_READ_MY_STATS = CreateKey(KeyCode.M);
+        public static AccessibleKey BATTLEGROUNDS_READ_MY_STATS_TO_END = CreateKey(KeyCode.M, true);
+        public static AccessibleKey BATTLEGROUNDS_READ_LEADERBOARD = CreateKey(KeyCode.L);
+        public static AccessibleKey BATTLEGROUNDS_READ_RACES_IN_GAME = CreateKey(KeyCode.O);
+        public static AccessibleKey BATTLEGROUNDS_READ_HERO_BUDDY = CreateKey(KeyCode.D);
+        #endregion
+
+        #region Dev Utils
+        public static AccessibleKey DEV_1 = CreateKey(KeyCode.Alpha1);
+        public static AccessibleKey DEV_2 = CreateKey(KeyCode.Alpha2);
+        #endregion
+
+        private bool m_requiresModifier;
+
+        private bool m_isHotkey; // Hotkeys are ctrl+something
+
+        private KeyCode m_keyCode;
+
+        private bool m_enabled;
+
+		private AccessibleKey(KeyCode keyCode, bool requiresModifier = false, bool isHotkey = false)
+		{
+			m_keyCode = keyCode;
+            m_requiresModifier = requiresModifier;
+            m_isHotkey = isHotkey;
+            m_enabled = true;
+        }
+
+        public bool IsPressed()
+        {
+            var ret = IsPressedInternal();
+
+            if (ret)
+            {
+                AccessibilityUtils.LogDebug($"Pressed key: {m_keyCode}");
+            }
+
+            return ret;
+        }
+
+        private bool IsPressedInternal()
+        {
+            if (!m_enabled)
+            {
+                if (IsKeyUp(m_keyCode))
+                {
+                    AccessibilityUtils.LogDebug($"ZYY Tried to press {m_keyCode} but it was disabled");
+                }
+                return false;
+            }
+
+            if (m_isHotkey)
+			{
+                return IsHoldingCtrl() && IsKeyUp(m_keyCode);
+			}
+            else if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && IsKeyUp(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && IsKeyUp(m_keyCode);
+            }
+        }
+
+        private bool IsKeyUp(KeyCode keyCode)
+        {
+            if (keyCode == KeyCode.Return && Input.GetKeyUp(KeyCode.KeypadEnter))
+            {
+                // Quick fix as some players asked for this
+                return true;
+            }
+
+            return Input.GetKeyUp(keyCode);
+        }
+
+        public bool IsDown()
+        {
+            if (!m_enabled)
+            {
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && Input.GetKey(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && Input.GetKey(m_keyCode);
+            }
+        }
+
+        public bool IsPressedDown()
+        {
+            if (!m_enabled)
+            {
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && Input.GetKeyDown(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && Input.GetKeyDown(m_keyCode);
+            }
+        }
+
+        private static bool IsHoldingModifier()
+        {
+            return Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
+        }
+
+        private static bool IsHoldingCtrl()
+        {
+            return Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl);
+        }
+
+        public override string ToString()
+        {
+            if (m_isHotkey)
+			{
+                return LocalizationUtils.Format(LocalizationKey.INPUT_COMMAND_WITH_CTRL_FORMAT, ReadKey(m_keyCode));
+			}
+            else if (m_requiresModifier)
+            {
+                return LocalizationUtils.Format(LocalizationKey.INPUT_COMMAND_WITH_MODIFIER_FORMAT, ReadKey(m_keyCode));
+            }
+            else
+            {
+                return ReadKey(m_keyCode);
+            }
+        }
+
+        public string ToEnglishString()
+        {
+            // Used for narrations only (a vs. eh)
+            if (m_isHotkey)
+			{
+                return $"Ctrl + {ReadKeyInEnglish(m_keyCode)}";
+			}
+            else if (m_requiresModifier)
+            {
+                return $"Shift + {ReadKeyInEnglish(m_keyCode)}";
+            }
+            else
+            {
+                return ReadKeyInEnglish(m_keyCode);
+            }
+        }
+
+        private string ReadKeyInEnglish(KeyCode keyCode)
+        {
+            switch (keyCode)
+            {
+                case KeyCode.Return:
+                    return "Enter";
+                case KeyCode.A:
+                    return "eh";
+                case KeyCode.I:
+                    return "eye";
+                default:
+                    return keyCode.ToString();
+            }
+        }
+
+        private string ReadKey(KeyCode keyCode)
+        {
+            if (LocalizationUtils.HasOverrideForKey(keyCode))
+            {
+                return LocalizationUtils.GetOverrideForKey(keyCode);
+            }
+
+            return keyCode.ToString();
+        }
+
+        public void Enable()
+        {
+            m_enabled = true;
+        }
+
+        public void Disable()
+        {
+            m_enabled = false;
+        }
+
+        #region Key Registation
+        private static HashSet<AccessibleKey> s_allKeys;
+        private static HashSet<AccessibleKey> s_nonGlobalKeys;
+        private static HashSet<AccessibleKey> s_globalKeys;
+
+        private static AccessibleKey CreateKey(KeyCode keyCode, bool requiresModifier=false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresModifier);
+            s_allKeys.Add(newKey);
+            s_nonGlobalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static AccessibleKey CreateGlobalKey(KeyCode keyCode, bool requiresModifier=false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresModifier);
+            s_allKeys.Add(newKey);
+            s_globalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static AccessibleKey CreateHotkey(KeyCode keyCode)
+        {
+            // Hotkeys area always ctrl+something
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, false, true);
+            s_allKeys.Add(newKey);
+            s_nonGlobalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static void InitializeKeySetsIfNeeded()
+        {
+            if (s_allKeys == null)
+            {
+                s_allKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_nonGlobalKeys == null)
+            {
+                s_nonGlobalKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_globalKeys == null)
+            {
+                s_globalKeys = new HashSet<AccessibleKey>();
+            }
+        }
+
+        public static HashSet<AccessibleKey> GetAllKeys(bool includeGlobals=true)
+        {
+            if (includeGlobals)
+            {
+                return s_allKeys;
+            }
+            else
+            {
+                return s_nonGlobalKeys;
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
new file mode 100644
index 0000000..e1f8d2c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
@@ -0,0 +1,218 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleListOfItems<T> : AccessibleElement where T : AccessibleItem
+    {
+        private List<T> m_items;
+
+        private int m_curItemIdx;
+
+        private T m_curItem;
+
+        private string m_noItemsTextOverride; // Useful for e.g. no results when searching collection where the message may be dynamic
+
+        internal int Count => m_items.Count;
+
+        internal List<T> Items => m_items;
+
+		internal AccessibleListOfItems(AccessibleComponent parent, List<T> items, string noItemsTextOverride = null) : base(parent)
+		{
+			m_items = items;
+            m_noItemsTextOverride = noItemsTextOverride;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (m_items.Count == 0 && m_noItemsTextOverride != null)
+			{
+                // TODO: Refactor this list to do this properly
+                return HandleAccessibleInputForEmptyList();
+			}
+
+            if (!IsReading())
+            {
+                return false;
+            }
+
+            if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                return ReadNextItem(1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                return ReadNextItem(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                return ReadNextItem(1, true);
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                return ReadNextItem(-1, true);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+            {
+                ReadFromTop();
+                return true;
+            }
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+            {
+                ReadFromBottom();
+                return true;
+            }
+            else if (m_curItem != null && m_curItem.HandleAccessibleInput())
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+		private bool HandleAccessibleInputForEmptyList()
+		{
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed() || AccessibleKey.READ_NEXT_ITEM.IsPressed() ||
+                AccessibleKey.READ_PREV_VALID_ITEM.IsPressed() || AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed() ||
+                AccessibleKey.READ_FIRST_ITEM.IsPressed() || AccessibleKey.READ_LAST_ITEM.IsPressed() ||
+                AccessibleKey.READ_PREV_LINE.IsPressed() || AccessibleKey.READ_NEXT_LINE.IsPressed() ||
+                AccessibleKey.READ_CUR_LINE.IsPressed() || AccessibleKey.READ_TO_END.IsPressed())
+			{
+                OutputNoItems();
+			}
+
+            return false;
+		}
+
+		private bool ReadNextItem(int inc, bool wrapAround = false)
+        {
+			int nextItemIdx = m_curItemIdx + inc;
+
+            if (nextItemIdx < 0 || nextItemIdx >= m_items.Count)
+            {
+                if (wrapAround && m_items.Count > 0)
+                {
+                    nextItemIdx = inc < 0 ? m_items.Count - 1 : 0;
+                }
+                else
+                {
+                    return false;
+                }
+            }
+
+            m_curItemIdx = nextItemIdx;
+            m_curItem = m_items[m_curItemIdx];
+            m_curItem.Reset();
+            var line = m_curItem.GetLine(0);
+            if (line.Length > 0)
+            {
+                Output(AccessibleSpeech.MENU_OPTION(line, m_curItemIdx + 1, m_items.Count));
+            }
+
+            return true;
+        }
+
+        internal bool IsReading()
+        {
+            return m_curItem != null;
+        }
+
+        internal void StartReading()
+        {
+            if (m_items.Count == 0)
+            {
+                OutputNoItems();
+			}
+            else
+            {
+                ReadNextItem(0);
+            }
+        }
+
+		private void OutputNoItems()
+		{
+			if (m_noItemsTextOverride != null)
+			{
+				Output(m_noItemsTextOverride);
+			}
+			else
+			{
+				Output(LocalizedText.MENU_NO_ITEMS);
+			}
+		}
+
+		private void ReadFromTop()
+        {
+            m_curItemIdx = 0;
+            StartReading();
+        }
+
+        private void ReadFromBottom()
+        {
+            m_curItemIdx = m_items.Count - 1;
+            StartReading();
+        }
+
+        internal void StartReadingFromIndex(int startingIndex)
+		{
+            m_curItemIdx = startingIndex;
+            StartReading();
+		}
+
+        internal void StartReadingReverse()
+        {
+            ReadNextItem(m_items.Count - 1);
+        }
+
+        internal T GetItemBeingRead()
+        {
+            return m_items[m_curItemIdx];
+        }
+
+        internal int GetItemBeingReadIndex()
+        {
+            return m_curItemIdx;
+        }
+
+        internal string GetHelp(bool hasBackButton)
+        {
+            if (m_items.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HORIZONTAL_HELP(hasBackButton);
+            }
+        }
+
+        internal void UpdateItems(List<T> items)
+        {
+            m_items = items;
+
+            if (items.Count == 0)
+            {
+                m_curItemIdx = 0;
+            }
+            else if (m_curItemIdx >= items.Count)
+            {
+                m_curItemIdx = items.Count - 1;
+            }
+        }
+
+		internal void RemoveItem(T item)
+		{
+			var newItems = new List<T>();
+
+			foreach (var i in m_items)
+			{
+				if (i != item)
+				{
+					newItems.Add(i);
+				}
+			}
+
+			UpdateItems(newItems);
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
new file mode 100644
index 0000000..fd348ca
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
@@ -0,0 +1,43 @@
+﻿using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleLoginScreen : AccessibleScreen
+    {
+        private static AccessibleLoginScreen s_instance = new AccessibleLoginScreen();
+
+        private PegUIElement m_startButton;
+
+        internal static AccessibleLoginScreen Get() {
+            return s_instance;
+        }
+
+        public void OnGameLoaded(PegUIElement startButton)
+        {
+            AccessibilityMgr.SetScreen(this);
+
+            m_startButton = startButton;
+
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_GAME_LOADED);
+            AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_START;
+        }
+
+        public void HandleInput()
+        {
+            if (m_startButton != null && AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_startButton.TriggerRelease();
+                AccessibilityMgr.TransitioningScreens();
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs
new file mode 100644
index 0000000..0c59df1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs
@@ -0,0 +1,331 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class AccessibleMenu : AccessibleElement
+    {
+        private class MenuOption
+        {
+            internal string m_text;
+            internal Action m_onClickAction;
+            internal Action m_onReadAction;
+
+            internal MenuOption(string text, Action onClickAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+            }
+
+            internal MenuOption(string text, Action onClickAction, Action onReadAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+                m_onReadAction = onReadAction;
+            }
+        }
+
+        private string m_menuName;
+
+        private List<MenuOption> m_options;
+
+        private int m_curOptionIdx;
+
+        private Action m_goBackAction;
+
+        private bool m_isReading;
+
+        private bool m_isGlobalMenu;
+
+        private bool m_canConfirmWithSpace; // Only for local menus (e.g. emotes)
+
+        private Dictionary<AccessibleKey, MenuOption> m_hotkeys;
+
+        public AccessibleMenu(AccessibleComponent parent, string menuName, Action goBackAction, bool globalMenu=false, bool canConfirmWithSpace=false) : base(parent)
+        {
+            m_menuName = menuName;
+            m_options = new List<MenuOption>();
+            m_goBackAction = goBackAction;
+            m_isGlobalMenu = globalMenu;
+            m_canConfirmWithSpace = canConfirmWithSpace;
+            m_hotkeys = new Dictionary<AccessibleKey, MenuOption>();
+        }
+
+        public void AddOption(AccessibleKey hotkey, string option, Action onClickAction)
+        {
+            var newOption = new MenuOption(option, onClickAction);
+            m_options.Add(newOption);
+            m_hotkeys.Add(hotkey, newOption);
+        }
+
+        public void AddOption(AccessibleKey hotkey, string option, Action onClickAction, Action onReadAction)
+        {
+            var newOption = new MenuOption(option, onClickAction, onReadAction);
+            m_options.Add(newOption);
+            m_hotkeys.Add(hotkey, newOption);
+        }
+
+        public void AddOption(string option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(string option, Action onClickAction, Action onReadAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction, onReadAction));
+        }
+
+        public bool HandleAccessibleInput()
+        {
+            try
+            {
+                if (ReadNextIsPressed())
+                {
+                    return ReadNextOption(1);
+                }
+                else if (ReadPrevIsPressed())
+                {
+                    return ReadNextOption(-1);
+                }
+                else if (ReadCurIsPressed())
+				{
+                    return ReadNextOption(0);
+				}
+                else if (ReadFirstIsPressed())
+				{
+                    return ReadFirstOption();
+				}
+                else if (ReadLastIsPressed())
+				{
+                    return ReadLastOption();
+				}
+                else if (ConfirmIsPressed())
+                {
+                    return SelectOption();
+                }
+                else if (BackIsPressed())
+                {
+                    return GoBack();
+                }
+                else
+				{
+                    return HandleHotkeys();
+				}
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+
+		private bool HandleHotkeys()
+		{
+			foreach (var hotkey in m_hotkeys)
+			{
+                if (hotkey.Key.IsPressed())
+				{
+                    hotkey.Value.m_onClickAction();
+                    return true;
+				}
+			}
+
+            return false;
+		}
+
+		private bool BackIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.BackIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.BACK.IsPressed();
+            }
+        }
+
+        private bool ConfirmIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ConfirmIsPressed();
+            }
+            else
+            {
+                if (m_canConfirmWithSpace && AccessibleKey.SPACE.IsPressed())
+				{
+                    return true;
+				}
+
+                return AccessibleKey.CONFIRM.IsPressed();
+            }
+        }
+
+        private bool ReadPrevIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ReadPrevIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_PREV_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadCurIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_CUR_GLOBAL_MENU_OPTION.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_CUR_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadFirstIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_FIRST_ITEM_GLOBAL.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_FIRST_ITEM.IsPressed();
+            }
+        }
+
+        private bool ReadLastIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_LAST_ITEM_GLOBAL.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_LAST_ITEM.IsPressed();
+            }
+        }
+
+        private bool ReadNextIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ReadNextIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_NEXT_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadFirstOption()
+        {
+            return ReadOption(0);
+        }
+
+        private bool ReadLastOption()
+        {
+            return ReadOption(m_options.Count - 1);
+        }
+
+        private bool ReadNextOption(int inc)
+        {
+            return ReadOption(m_curOptionIdx + inc);
+        }
+
+        private bool ReadOption(int optionIdx)
+		{
+            if (optionIdx < 0 || optionIdx >= m_options.Count)
+            {
+                return false;
+            }
+
+            m_curOptionIdx = optionIdx;
+            var curOption = m_options[m_curOptionIdx];
+
+            var speech = AccessibleSpeech.MENU_OPTION(curOption.m_text, m_curOptionIdx + 1, m_options.Count);
+            Output(speech);
+
+            if (curOption.m_onReadAction != null)
+            {
+                curOption.m_onReadAction();
+            }
+
+            return true;
+		}
+
+        private bool SelectOption()
+        {
+            if (!m_isReading || m_options.Count == 0)
+            {
+                return false;
+            }
+
+            m_options[m_curOptionIdx].m_onClickAction();
+
+            return true;
+        }
+
+        public bool GoBack()
+        {
+            if (m_goBackAction == null)
+            {
+                return false;
+            }
+
+            m_goBackAction();
+
+            return true;
+        }
+
+		public void StartReading(bool readMenuName = true)
+		{
+			if (readMenuName)
+			{
+				Output(m_menuName);
+			}
+
+			ReadCurrentOption();
+        }
+
+        public void ReadCurrentOption()
+        {
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public void SetIndex(int index)
+        {
+            m_curOptionIdx = index;
+        }
+
+        internal string GetHelp()
+        {
+            if (m_options.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HELP(m_goBackAction != null);
+            }
+        }
+
+        public int GetNumItems()
+        {
+            return m_options.Count;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
new file mode 100644
index 0000000..061b95d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
@@ -0,0 +1,31 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleMultilineText : AccessibleItem
+    {
+        private List<string> m_lines;
+
+        internal AccessibleMultilineText(AccessibleComponent parent, List<string> lines) : base(parent)
+        {
+            m_lines = lines;
+        }
+
+        internal AccessibleMultilineText(AccessibleComponent parent, List<string> lines, int startReadingFromLine) : base(parent, startReadingFromLine)
+        {
+            m_lines = lines;
+        }
+
+        internal AccessibleMultilineText(AccessibleComponent parent, params string[] lines) : base(parent)
+        {
+            m_lines = new List<string>();
+            m_lines.AddRange(lines);
+        }
+
+        internal override List<string> GetLines()
+        {
+            return m_lines;
+        }
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
new file mode 100644
index 0000000..a2fd21e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
@@ -0,0 +1,26 @@
+﻿using System;
+
+namespace Accessibility
+{
+    static class AccessibleNotificationMgr
+    {
+        public static void OnCreateNotificationWithoutSound(Notification notification)
+        {
+            ReadNotification(notification);
+        }
+
+        public static void OnCreateNotificationWithSound(Notification notification)
+        {
+            if (!AccessibilityConfig.CAN_HEAR)
+            {
+                // Could look into doing something like this for deaf-blind support
+                ReadNotification(notification);
+            }
+        }
+
+        private static void ReadNotification(Notification notification)
+        {
+            AccessibilityMgr.OutputNotification(notification.speechUberText.Text);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
new file mode 100644
index 0000000..93ac5b0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
@@ -0,0 +1,600 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePlayDescriber
+    {
+        private static AccessiblePlayDescriber s_AccessiblePlayDescriber;
+
+        private HashSet<PowerTaskList> m_describedTaskLists = new HashSet<PowerTaskList>();
+
+        private int m_pendingReadings;
+
+        private AccessiblePlayDescriber() { }
+
+        internal static AccessiblePlayDescriber Get()
+        {
+            if (s_AccessiblePlayDescriber == null)
+            {
+                s_AccessiblePlayDescriber = new AccessiblePlayDescriber();
+            }
+
+            return s_AccessiblePlayDescriber;
+        }
+
+        internal void Reset()
+        {
+            m_describedTaskLists.Clear();
+        }
+
+        private bool ShouldCalloutTrigger(Entity entity)
+        {
+            if (entity == null)
+            {
+                return false;
+            }
+
+            if (entity.IsHero())
+            {
+                return false; // Don't think we need this since it just seems to be mission events
+            }
+
+            if (entity.IsCharacter() || entity.IsWeapon() || entity.IsSecret() || entity.IsQuest() || entity.IsQuestline() || entity.IsSideQuest() || entity.IsHeroPower())
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+		private bool ShouldOutputTrigger(Entity card)
+		{
+            if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+                return true;
+			}
+
+            // Battlegrounds exceptions
+            if (card.IsHeroPower() && AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return false;
+			}
+
+            return true;
+		}
+
+        internal string OnCardTriggered(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity();
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            // Some triggers (e.g. Battlegrounds Hero Powers in shop phase) are annoying
+            if (!ShouldOutputTrigger(card))
+			{
+                return null;
+			}
+
+            if (ShouldShowTriggeredBigCard(card, taskList))
+            {
+                return GetBigCardTriggeredText(card);
+            }
+
+            if (!ShouldCalloutTrigger(card))
+            {
+                return null;
+            }
+
+            var fullCardName = AccessibleSpeechUtils.GetFullNameInZone(card);
+
+            // Not really a play but the card itself may be useful if the player wants to read it
+            var play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_CARD_IN_ZONE_TRIGGERED, fullCardName);
+            return RegisterPlay(play);
+        }
+
+		private bool ShouldShowTriggeredBigCard(Entity card, PowerTaskList taskList)
+        {
+            if (PowerProcessor.ShouldShowTriggeredBigCard(card))
+            {
+                return true;
+            }
+
+            if (card.GetController() != null && card.IsControlledByOpposingSidePlayer())
+            {
+                // card.GetController() is needed due to potential NPEs in some triggers
+                // e.g. Baku the Mooneater
+                foreach (var task in taskList.GetTaskList())
+                {
+                    if (task.IsShowStartOfGameCard())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        internal string OnCardPlayed(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity();
+            var blockStart = taskList.GetBlockStart();
+
+            AccessibilityUtils.LogDebug($"OnCardPlayed taskList ID: {taskList.GetId()}");
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (PowerProcessor.ShouldShowPlayedBigCard(card, blockStart))
+            {
+                var text = GetBigCardPlayedText(card, taskList);
+
+                if (text.Length > 0)
+                {
+                    return text; // We ignore some things like hero powers 
+                }
+            }
+
+            bool isFriendlySide = card.IsControlledByFriendlySidePlayer();
+            var cardName = GetEntityName(card);
+            string play;
+
+            if (IsBlacklistedCard(card))
+			{
+                // e.g. BG cards such as "Drag to Buy, Refresh, etc"
+                return null;
+			}
+            else if (IsCardTrade(taskList))
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TRADED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_TRADED_CARD, cardName);
+                }
+            }
+            else if (card.IsMinion())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_SUMMONED_MINION, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION, cardName);
+                }
+            }
+            else if (card.IsWeapon())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_EQUIPPED_WEAPON, cardName);
+                }
+            }
+            else if (card.IsHeroPower())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_USED_HERO_POWER, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_USED_HERO_POWER, cardName);
+                }
+            }
+            else if (card.IsSecret())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET, cardName);
+                }
+                else
+                {
+                    var cardClass = GameStrings.GetClassName(card.GetClass());
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, cardClass);
+                }
+                // FIXME: not sure if this won't break
+            }
+            else
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD, cardName);
+                }
+            }
+
+            return RegisterPlay(play);
+        }
+
+		private bool IsBlacklistedCard(Entity card)
+		{
+            return AccessibleGameplayUtils.IsBattlegroundsSpecialCard(card);
+		}
+
+		private bool IsCardTrade(PowerTaskList taskList)
+        {
+            if (taskList == null || !taskList.IsOrigin() || !taskList.IsTradeBlock())
+            {
+                return false;
+            }
+
+            var source = taskList.GetSourceEntity();
+
+            if (source == null)
+            {
+				return false;
+            }
+
+            foreach (var task in taskList.GetTaskList())
+            {
+                if (task.IsCardTrade(source.GetEntityId()))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private string GetBigCardPlayedText(Entity card, PowerTaskList taskList)
+        {
+            var cardName = GetEntityName(card);
+            var cardText = card.GetCardTextBuilder().BuildCardTextInHand(card);
+            var isFriendlySide = card.IsControlledByFriendlySidePlayer();
+            string play;
+
+            if (IsCardTrade(taskList))
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TRADED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_TRADED_CARD, cardName);
+                }
+            }
+            else if (card.IsMinion())
+            {
+                var atk = card.GetATK();
+                var hp = card.GetHealth();
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD, cardName, atk, hp, cardText);
+                }
+                else
+                {
+                    if (!AccessibleCardUtils.HasHiddenStats(card))
+					{
+						play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD, cardName, atk, hp, cardText);
+					}
+                    else
+					{
+                        // e.g. BoH Valeera 08 (Silent Shadows)
+						play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD, cardName, "", "", cardText);
+					}
+				}
+            }
+            else if (card.IsSpell())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+            }
+            else if (card.IsHeroPower()) // This is tricky as it would fire after ptldescriber + we probably don't want to repeat this all the time
+            {
+                // Note: This wasn't being read but I think it's a good idea to do so since they're short anyways and can be read in the animation - experimenting
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD, cardName, cardText);
+                }
+            } 
+            else if (card.IsWeapon())
+            {
+                var atk = card.GetATK();
+                var durability = card.GetDurability();
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD, cardName, atk, durability, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD, cardName, atk, durability, cardText);
+                }
+            }
+            else if (card.IsSecret())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    var cardClass = GameStrings.GetClassName(card.GetClass());
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, cardClass);
+                }
+            }
+            else if (card.GetCardType() == TAG_CARDTYPE.ENCHANTMENT)
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+            }
+            else
+            {
+                Log.Accessibility.Print($"GetBigCardPlayedText unknown type: {card.GetName()} / type = {card.GetCardType()}");
+                return "";
+            }
+
+            return RegisterPlay(play);
+        }
+
+        private string GetBigCardTriggeredText(Entity card)
+        {
+            var cardName = GetEntityName(card);
+            var cardText = $"{card.GetCardTextBuilder().BuildCardTextInHand(card)}";
+            string play;
+
+            if (card.IsControlledByFriendlySidePlayer())
+            {
+                // This might be the one that shows up for things like random spells and whatnot - confirm this
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CARD_TRIGGERED, cardName);
+            }
+            else
+            {
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD, cardName, cardText);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        internal void OnBigCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardPlayed called with null taskList");
+            }
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return;
+            }
+
+            var text = GetBigCardPlayedText(card, taskList);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+        }
+
+        internal void OnBigCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardTriggered called with null curTaskList - dropping");
+            }
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return;
+            }
+
+            // Some triggers (e.g. Battlegrounds Hero Powers in shop phase) are annoying
+            if (!ShouldOutputTrigger(card))
+			{
+                return;
+			}
+
+            var text = GetBigCardTriggeredText(card);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+        }
+
+        internal string OnFatigue(PowerTaskList taskList)
+        {
+            var source = taskList.GetSourceEntity();
+
+            if (source == null)
+            {
+                Log.Accessibility.Print("Fatigue had null source");
+                return null;
+            }
+
+            var side = source.GetControllerSide();
+            string play;
+
+            if (side == Player.Side.FRIENDLY)
+            {
+                play = LocalizationUtils.Get(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK);
+            }
+            else
+            {
+                play = LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        internal List<string> OnCardsBurned(List<Entity> burnedCards)
+        {
+            var ret = new List<string>();
+
+            foreach(var card in burnedCards)
+            {
+                var cardName = GetEntityName(card);
+                string play;
+
+                if (card.IsControlledByFriendlySidePlayer())
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED, cardName);
+                }
+
+                ret.Add(RegisterPlay(play));
+            }
+
+            return ret;
+        }
+
+        internal void OnAttack(PowerTaskList taskList)
+        {
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+                BattlegroundsOnAttack(taskList);
+			}
+            else
+			{
+                NormalOnAttack(taskList);
+			}
+        }
+
+		internal void BattlegroundsOnAttack(PowerTaskList taskList)
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                if (taskList.GetAttacker().IsHero())
+				{
+                    AccessiblePowerTaskListDescriber.Get().OnBattlegroundsHeroAttackPhase();
+				}
+                else if (AccessibleGameplayUtils.ShouldNarrateBattlegroundsAttackPhase())
+				{
+                    NormalOnAttack(taskList);
+				}
+			}
+            else
+			{
+                NormalOnAttack(taskList);
+			}
+		}
+
+		private void NormalOnAttack(PowerTaskList taskList)
+		{
+            var text = GetAttackText(taskList);
+
+            if (text != null)
+            {
+                AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+            }
+		}
+
+		internal string GetAttackText(PowerTaskList taskList)
+        {
+            if (m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds() &&
+                (taskList.GetAttacker().IsHero() || !AccessibleGameplayUtils.ShouldNarrateBattlegroundsAttackPhase()))
+            {
+                return null;
+            }
+
+            var attacker = taskList.GetAttacker();
+            var defender = taskList.GetDefender();
+            var proposedDefender = taskList.GetProposedDefender();
+
+            string play;
+
+            if (proposedDefender != null && proposedDefender.GetEntityId() != defender.GetEntityId())
+            {
+                var attackerName = GetFullNameInZone(attacker);
+                var proposedDefenderName = GetFullNameInZone(proposedDefender);
+                var defenderName = GetFullNameInZone(defender);
+
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_ENTITY_ATTACKED_OTHER, attackerName, proposedDefenderName, defenderName);
+            } 
+            else
+            {
+                var attackerName = GetFullNameInZone(attacker);
+                var defenderName = GetFullNameInZone(defender);
+
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_ENTITY_ATTACKED, attackerName, defenderName);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        private void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPSGP Unblocking power processor");
+            m_pendingReadings--;
+        }
+
+        public bool IsBusy()
+        {
+            return m_pendingReadings > 0;
+        }
+
+        // History stuff
+        private string RegisterPlay(string action)
+        {
+            AccessibleHistoryMgr.Get().AddEntry(action);
+            return action;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayMakerUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayMakerUtils.cs
new file mode 100644
index 0000000..a1b3698
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayMakerUtils.cs
@@ -0,0 +1,30 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessiblePlayMakerUtils
+    {
+        #region Debugging
+
+        public static void DebugFSM(string name, PlayMakerFSM fsm)
+        {
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+            AccessibilityUtils.LogDebug($"Debugging FSM {name}");
+            AccessibilityUtils.LogDebug($"States:");
+            foreach (var state in fsm.FsmStates)
+			{
+                AccessibilityUtils.LogDebug($"--- {state.Name} - {state.Description}");
+			}
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
new file mode 100644
index 0000000..7a5feb5
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
@@ -0,0 +1,649 @@
+﻿using PegasusGame;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePowerTaskListDescriber
+    {
+        private AccessibleInGameState m_lastDescribedState;
+
+        private bool m_blocked;
+
+        private bool m_canSnapshot;
+
+        private bool m_waitingForYourTurnBanner;
+
+        private List<string> m_descriptionsWaitingForTurnChange = new List<string>();
+
+        private TAG_STEP m_prevStep;
+
+        private bool m_gameOfficiallyStarted;
+
+        private bool m_turnStarted;
+
+        private int m_numEndTurnAttempts;
+
+        private static AccessiblePowerTaskListDescriber s_instance;
+
+        // Battlegrounds
+        private bool m_inBattlegroundsHeroAttackPhase;
+
+        public static AccessiblePowerTaskListDescriber Get()
+		{
+            if (s_instance == null)
+			{
+                InitInstance();
+			}
+
+            return s_instance;
+		}
+
+		private static void InitInstance()
+		{
+			if (AccessibleGameplayUtils.IsFindingOrPlayingBattlegrounds())
+			{
+                s_instance = new AccessibleBattlegroundsPowerTaskListDescriber();
+			}
+            else
+			{
+                s_instance = new AccessiblePowerTaskListDescriber();
+			}
+		}
+
+		public void OnGameStart()
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug("PTL OnGameStart");
+
+                m_lastDescribedState = null;
+                m_canSnapshot = false;
+                m_waitingForYourTurnBanner = false;
+                m_descriptionsWaitingForTurnChange.Clear();
+                m_prevStep = TAG_STEP.INVALID;
+                m_gameOfficiallyStarted = false;
+                m_turnStarted = false;
+                m_numEndTurnAttempts = 0;
+
+                AccessiblePlayDescriber.Get().Reset();
+                AccessibleInGameState.Reset();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+		public void OnPowerTaskListStart(PowerTaskList taskList)
+        {
+            try
+            {
+                taskList.SetGlobalCompleteCallback(OnPowerTaskListEnd);
+
+                Network.HistBlockStart blockStart = taskList.GetBlockStart();
+                AccessibilityUtils.LogDebug($">>> Starting PowerTaskList.Id: {taskList.GetId()}. BlockType: {blockStart?.BlockType}");
+
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnPowerTaskListEnd(PowerTaskList taskList)
+        {
+            try
+            {
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+                AccessibilityUtils.LogDebug($">>> Ending PowerTaskList. Id: {taskList.GetId()}.");
+                AccessibilityUtils.LogDebug("SPS blocking power processor");
+                m_blocked = true;
+
+                var lines = new List<string>();
+
+                var canDescribe = true;
+
+                if (!GameHasOfficiallyStarted())
+                {
+                    canDescribe = false;
+                }
+
+                if (taskList.IsOrigin() && taskList.IsPlayBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardPlayed(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.FATIGUE))
+                {
+                    AccessibilityUtils.LogDebug("Fatigue");
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnFatigue(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.ATTACK))
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().GetAttackText(taskList));
+                    canDescribe = false;
+
+                    if ((taskList.GetAttacker()?.IsHero() ?? false) || (taskList.GetDefender()?.IsHero() ?? false))
+                    {
+                        canDescribe = true; // Describe state when a Hero is involved as dmg taken is more important there
+                    }
+                }
+
+                if (taskList.IsOrigin() && taskList.IsTriggerBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardTriggered(taskList));
+                }
+
+                var burnedCards = GetBurnedCards(taskList);
+                if (burnedCards.Count > 0)
+                {
+                    lines.AddRange(AccessiblePlayDescriber.Get().OnCardsBurned(burnedCards));
+                }
+
+                // Battlegrounds hack
+                canDescribe = OverrideCanDescribeIfNecessary(canDescribe);
+
+                SnapshotAndDescribeGameState(lines, taskList, canDescribe);
+            }
+            catch (Exception e)
+            {
+                m_blocked = false;
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+		private bool OverrideCanDescribeIfNecessary(bool canDescribe)
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return true;
+			}
+
+            return canDescribe;
+		}
+
+		private bool GameHasOfficiallyStarted()
+        {
+            if (!GameState.Get().IsGameCreated())
+            {
+                return false;
+            }
+
+            if (m_gameOfficiallyStarted)
+            {
+                return true;
+            }
+
+            // Tutorial games (no mulligan) must all go through one initial MAIN_READY step before they start (or so it seems)
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_READY)
+            {
+                m_gameOfficiallyStarted = true;
+            }
+
+            return m_gameOfficiallyStarted;
+        }
+
+        private static void AddIfNotNull(List<string> lines, string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                return;
+            }
+
+            lines.Add(text);
+        }
+
+        private static List<Entity> GetBurnedCards(PowerTaskList taskList)
+        {
+            var ret = new List<Entity>();
+
+            List<PowerTask> taskList2 = taskList.GetTaskList();
+            for (int i = 0; i < taskList2.Count; i++)
+            {
+                Network.PowerHistory power = taskList2[i].GetPower();
+                if (power.Type != Network.PowerType.META_DATA)
+                {
+                    continue;
+                }
+                Network.HistMetaData histMetaData = (Network.HistMetaData)power;
+                if (histMetaData.MetaType != HistoryMeta.Type.BURNED_CARD)
+                {
+                    continue;
+                }
+                if (histMetaData.Info.Count == 0)
+                {
+                    continue;
+                }
+
+                foreach (var entityId in histMetaData.Info)
+                {
+                    var entity = GameState.Get().GetEntity(entityId);
+
+                    if (entity != null)
+                    {
+                        ret.Add(entity);
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private void SnapshotAndDescribeGameState(List<string> lines, PowerTaskList taskList, bool canDescribe=true)
+        {
+            AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState canDescribe={canDescribe}");
+
+            var nextStep = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.NEXT_STEP);
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_END)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D1");
+
+                if (step != m_prevStep)
+				{
+                    // Battlegrounds-specific stuff to narrate Hero attacks
+					m_inBattlegroundsHeroAttackPhase = false;
+                    AccessibleGameplay.Get().OnMainStepEnd();
+				}
+
+				if (m_prevStep != step && m_turnStarted && IsRealEndTurn()) // IsRealEndTurn is because of Hemet Nesingwary and Illidan who break the game by ending the turn twice
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D2");
+
+                    if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+					{
+						lines.Add(LocalizedText.GAMEPLAY_TURN_ENDED);
+					}
+
+					OnTurnEnded();
+                    m_canSnapshot = true;
+                }
+            }
+            else if (step == TAG_STEP.MAIN_READY) // Allow trigger effects to be described before turn-related stuff
+            {
+                lines.AddRange(OnTurnChange());
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D3");
+                m_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START_TRIGGERS)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D4");
+                m_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D5");
+                m_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_ACTION && step != m_prevStep)
+			{
+				AccessibleGameplay.Get().OnMainActionStep();
+			}
+			else if (step == TAG_STEP.BEGIN_MULLIGAN)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D6");
+                m_canSnapshot = true;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn() && !m_turnStarted)
+                {
+                    // Start of game card (e.g. C'Thun) trigger during the mulligan and the banner comes first
+                    m_waitingForYourTurnBanner = true;
+                }
+            }
+            else if (m_prevStep == TAG_STEP.BEGIN_MULLIGAN && step != m_prevStep)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D7");
+                m_canSnapshot = false;
+            }
+
+            m_prevStep = step;
+
+            if (m_lastDescribedState == null)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D8");
+                m_canSnapshot = true; // Start snapshotting after game starts due to tutorial stuff
+
+                // Useful for e.g. handling reconnects in Battlegrounds
+                AccessibleGameplay.Get().OnFirstTaskListStart();
+            }
+
+            if (!m_canSnapshot)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D9");
+
+                if (!m_waitingForYourTurnBanner)
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D10");
+                    Output(lines);
+                }
+                else
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D11");
+                    m_descriptionsWaitingForTurnChange.AddRange(lines);
+                    m_blocked = false;
+                }
+                return;
+            }
+
+            var newState = AccessibleInGameState.GetCurrentState(taskList);
+
+            if (canDescribe) // TODO: Rethink this
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D12");
+                var description = AccessibleInGameState.DescribeDiff(taskList, m_lastDescribedState, newState);
+
+                AddIfNotNull(lines, description);
+                AccessibleHistoryMgr.Get().AddEntry(description);
+            }
+
+            var prevState = m_lastDescribedState;
+            m_lastDescribedState = newState;
+            var canOutputStateDiff = CanOutputStateDiff(taskList, prevState, newState);
+
+            if (canOutputStateDiff)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D13");
+                Output(lines);
+            }
+            else
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D14");
+                m_descriptionsWaitingForTurnChange.AddRange(lines);
+                m_blocked = false;
+            }
+
+            // Hack for Battlegrounds - see below
+            // Note: needs to be here so we don't read out things like "your opponent Hero became Bartender Bob etc" due to narration order
+            OnNarrationEnd(taskList, prevState, newState, canOutputStateDiff);
+        }
+
+		private void OnNarrationEnd(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState, bool hasOutputtedStateDiff)
+		{
+            // Necessary for Battlegrounds
+            // TODO: Refactor everything once we figure out the final narration interface for Battlegrounds
+            var opponentHeroChanged = AccessibleInGameState.HasOpponentHeroChanged(prevState, newState);
+
+            if (opponentHeroChanged)
+			{
+                AccessibleGameplay.Get().OnOpponentHeroChanged();
+			}
+
+            var anyHeroGainedAtk = AccessibleInGameState.HasAnyHeroGainedAtk(prevState, newState);
+
+            if (anyHeroGainedAtk)
+			{
+                AccessibleGameplay.Get().OnAnyHeroGainedAtk();
+			}
+
+            // Used for narrating permanent effects to Tarecgosa at the moment
+            // TODO: Refactor everything once the interface is settled
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                HandleNarrationEndForBattlegrounds(taskList, prevState, newState, hasOutputtedStateDiff);
+			}
+		}
+
+		private void HandleNarrationEndForBattlegrounds(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState, bool hasOutputtedStateDiff)
+		{
+            // Note: hasOutputtedStateDiff is used to prevent against describing the same state twice in an edge case where
+            // both the source card of a trigger and the target have permanent effects e.g. Tarecgosa gaining poison from a SI:Sefin
+            var battlegroundsGameplay = AccessibleGameplay.Get() as AccessibleBattlegroundsGameplay;
+
+            if (battlegroundsGameplay.IsInCombatPhase() && !hasOutputtedStateDiff)
+			{
+                var lines = BattlegroundsCardEffectInterpreter.GetTarecgosaDiffs(taskList, prevState, newState, battlegroundsGameplay.GetStateAtStartOfCombat());
+
+                if (lines.Count > 0)
+				{
+                    Output(lines);
+				}
+			}
+		}
+
+		private bool CanOutputStateDiff(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState)
+		{
+            // Hack for Battlegrounds while we don't refactor this entire thing
+            // Note: need to figure out how much is going to be narrated before we even consider refactoring
+            // As a starting point, describe everything within shop phase and leave everything out of combat phase until we get feedback from players
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+                return CanOutputStateDiffDuringBattlegrounds(taskList, prevState, newState);
+			}
+
+            return !m_waitingForYourTurnBanner;
+		}
+
+		private bool CanOutputStateDiffDuringBattlegrounds(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (GameState.Get().IsMulliganPhase())
+			{
+                // BG games start instantly for taskListDescriber
+                return false;
+			}
+
+			if (AccessibleInGameState.HasOpponentHeroChanged(before, after))
+			{
+				// Bartender Bob became X is sometimes delayed (i.e. after the recruit phase starts)
+				// Need to disable this or else we'll describe the tavern, your battlefield, hero powers, etc.
+				return false;
+			}
+
+			if (m_inBattlegroundsHeroAttackPhase)
+			{
+                if (AccessibleInGameState.HasAnyHeroLostAtk(before, after))
+				{
+                    // Don't narrate attacks lost when the game ends. There's also a few edge cases when playing vs players where this would happen
+                    return false;
+				}
+
+                if (AccessibleInGameState.HasAnyHeroRecoveredHealth(before, after))
+				{
+                    // Kel'Thuzad (i.e. ghost/dead players) causes your opponent's Hero to recover health at the end of the combat phase due to recovering back to 0
+                    return false;
+				}
+
+				// Output state as normal as soon as one Hero attacks to inform about attack, damage and narrate any potential secrets (e.g. ice blocks) etc.
+				return true;
+			}
+
+            if (AccessibleInGameState.HasPlayerReceivedCards(before, after))
+			{
+                // Output any received cards for cases such as Avenge(x): draw something, buddy meters, etc.
+                return true;
+			}
+
+            var battlegroundsGameplay = AccessibleGameplay.Get() as AccessibleBattlegroundsGameplay;
+
+            if (battlegroundsGameplay.IsInShopPhase())
+			{
+                return true;
+			}
+            else if (battlegroundsGameplay.IsInCombatPhase())
+			{
+                return BattlegroundsCardEffectInterpreter.ShouldOutputStateDiff(taskList, before, after);
+			}
+
+            return false;
+		}
+
+		private bool IsRealEndTurn()
+        {
+            m_numEndTurnAttempts++;
+
+            if (GameState.Get().GetGameEntity() is Tutorial_04 && m_numEndTurnAttempts == 3)
+            {
+                return false;
+            }
+            else if (GameState.Get().GetGameEntity() is Tutorial_05 && m_numEndTurnAttempts == 7)
+            {
+                return false;
+            }
+
+            return true;
+        }
+
+        private List<string> OnTurnChange()
+        {
+            var ret = new List<string>();
+
+            if (m_turnStarted)
+            {
+                return ret;
+            }
+
+            m_turnStarted = true;
+
+            if (GameState.Get().IsFriendlySidePlayerTurn())
+            {
+                m_waitingForYourTurnBanner = true;
+            }
+            else
+            {
+                if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+				{
+					ret.Add(LocalizedText.GAMEPLAY_OPPONENT_TURN);
+					DescribeInitialBoardStateIfNeeded(ret);
+				}
+			}
+
+            return ret;
+        }
+
+        internal void OnTurnStart()
+        {
+            m_waitingForYourTurnBanner = false;
+            m_turnStarted = true;
+
+            var descriptions = new List<string>();
+            descriptions.Add(LocalizedText.GAMEPLAY_YOUR_TURN);
+            descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TURN_START_READ_MANA, GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources()));
+            DescribeInitialBoardStateIfNeeded(descriptions);
+            descriptions.AddRange(m_descriptionsWaitingForTurnChange);
+            m_descriptionsWaitingForTurnChange.Clear();
+
+            Output(descriptions);
+        }
+
+        private static void DescribeInitialBoardStateIfNeeded(List<string> descriptions)
+        {
+            if (GameState.Get().GetTurn() != 1)
+            {
+                return;
+            }
+
+            // This is needed for some BoH such as Jaina 6 and Rexxar 3
+            var friendlySideMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCards();
+            if (friendlySideMinions.Count > 0)
+            {
+                var friendlySideMinionNames = AccessibleSpeechUtils.GetNames(friendlySideMinions);
+                descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD, friendlySideMinionNames));
+            }
+
+            var opposingSideMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCards();
+            if (opposingSideMinions.Count > 0)
+            {
+                var opposingSideMinionNames = AccessibleSpeechUtils.GetNames(opposingSideMinions);
+                descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD, opposingSideMinionNames));
+            }
+        }
+
+        private void Output(string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                m_blocked = false;
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"SPS Describing blocked task list: {text}");
+            AccessibilityMgr.OutputAndWait(text, OnOutputStart, OnOutputEnd);
+        }
+
+        private void Output(List<string> lines)
+        {
+            if (lines == null || lines.Count == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                m_blocked = false;
+            }
+            else
+            {
+                Output(AccessibleSpeechUtils.CombineLines(lines));
+            }
+        }
+
+		internal void OnBattlegroundsHeroAttackPhase()
+		{
+            m_inBattlegroundsHeroAttackPhase = true;
+		}
+
+		internal void OnBattlegroundsHeroAttackPhaseEnd()
+		{
+            m_inBattlegroundsHeroAttackPhase = false;
+		}
+
+		private void OnOutputStart()
+        {
+        }
+
+        private void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+            m_blocked = false;
+        }
+
+        public bool IsBusy()
+        {
+            return m_blocked;
+        }
+
+        #region Weapon stuff
+
+        private void OnTurnEnded()
+        {
+            var curPlayer = GameState.Get().GetCurrentPlayer();
+            var otherPlayer = GameState.Get().GetFirstOpponentPlayer(curPlayer);
+
+            if (curPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponSheathed(curPlayer.GetHero());
+            }
+
+            if (otherPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponUnsheathed(otherPlayer.GetHero());
+            }
+
+            m_turnStarted = false;
+
+            AccessibleGameplay.Get().OnTurnEnded();
+        }
+
+        internal void OnReconnected()
+        {
+            AccessibilityUtils.LogDebug("PTL OnReconnected");
+            m_gameOfficiallyStarted = true;
+            m_turnStarted = true;
+        }
+
+        #endregion
+
+		internal AccessibleInGameState GetLastDescribedState()
+		{
+            return m_lastDescribedState;
+		}
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs
new file mode 100644
index 0000000..1112ecd
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs
@@ -0,0 +1,30 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessiblePracticeAIButton : AccessibleItem
+    {
+        private readonly PracticeAIButton m_button;
+
+        internal AccessiblePracticeAIButton(AccessibleComponent parent, PracticeAIButton button) : base(parent)
+        {
+            m_button = button;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            // Name
+            ret.Add(m_button.m_name.Text);
+
+            // Undefeated label
+            if (m_button.m_questBang.activeInHierarchy)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs
new file mode 100644
index 0000000..133667b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs
@@ -0,0 +1,188 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuest : AccessibleItem
+    {
+        private readonly QuestDataModel m_questDataModel;
+
+        private readonly Hearthstone.Progression.QuestTile m_questTile;
+
+        internal AccessibleQuest(AccessibleComponent parent, QuestDataModel questDataModel, Hearthstone.Progression.QuestTile questTile=null) : base(parent)
+        {
+            m_questDataModel = questDataModel;
+            m_questTile = questTile;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_questDataModel.DisplayMode == Hearthstone.Progression.QuestManager.QuestTileDisplayMode.NEXT_QUEST_TIME)
+			{
+                return GetLinesForNextQuestTime();
+			}
+            else
+			{
+                return GetLinesForNormalQuestTile();
+			}
+        }
+
+		private List<string> GetLinesForNextQuestTime()
+		{
+            var ret = new List<string>();
+            ret.Add(m_questDataModel.TimeUntilNextQuest);
+			return ret;
+		}
+
+		private List<string> GetLinesForNormalQuestTile()
+		{
+            var ret = new List<string>();
+
+            if (m_questDataModel.Name?.Length > 0) // New quests don't have a name. Instead, they have the XP scroll at the top so we use GetRewards as the name
+            {
+                ret.Add(m_questDataModel.Name);
+            }
+
+            var rewards = GetRewards();
+
+            if (rewards.Length > 0)
+            {
+                ret.Add(rewards);
+            }
+
+            ret.Add(m_questDataModel.Description);
+
+            var progress = GetProgress();
+
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            if (CanAbandonQuest())
+			{
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_QUEST_LOG_ABANDON_QUEST, AccessibleKey.ABANDON_QUEST));
+			}
+
+            if (CanRerollQuest())
+			{
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_QUEST_LOG_REROLL_QUEST, AccessibleKey.REROLL_QUEST));
+			}
+
+            return ret;
+		}
+
+        internal override bool HandleAccessibleInput()
+		{
+            if (base.HandleAccessibleInput())
+            {
+                return true;
+            }
+            else if (AccessibleKey.REROLL_QUEST.IsPressed() && CanRerollQuest())
+			{
+				AccessibleWidgetUtils.ClickButton(GetRerollQuestButton());
+				return true;
+			}
+			else if (AccessibleKey.ABANDON_QUEST.IsPressed() && CanAbandonQuest())
+			{
+				AccessibleWidgetUtils.ClickButton(GetAbandonQuestButton());
+				return true;
+			}
+
+            return false;
+		}
+
+		private string GetRewards()
+        {
+            if (m_questDataModel.RewardTrackXp > 0) // New quests give XP as rewards instead of anything else
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_NO_NAME_XP_ONLY, m_questDataModel.RewardTrackXp);
+            }
+
+            var rewards = m_questDataModel.Rewards; // Non-XP quests give other rewards
+
+            if (rewards == null)
+            {
+                return "";
+            }
+
+            if (rewards.Description?.Length > 0)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, rewards.Description);
+            }
+
+            var rwds = new List<string>();
+            foreach (var rwd in rewards.Items)
+            {
+                rwds.Add(new AccessibleRewardItemDataModel(m_parent, rwd).GetLine(0));
+            }
+
+            var lst = AccessibleSpeechUtils.HumanizeList(rwds);
+
+            if (rewards.ChooseOne)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION, lst);
+            }
+
+            return lst;
+        }
+
+        private string GetProgress()
+        {
+            if (m_questDataModel.Quota == 0)
+            {
+                return "";
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, m_questDataModel.Progress, m_questDataModel.Quota);
+        }
+
+        public QuestDataModel GetQuestDataModel()
+		{
+            return m_questDataModel;
+		}
+
+        public Hearthstone.Progression.QuestTile GetQuestTile()
+		{
+            return m_questTile;
+		}
+
+        private bool CanAbandonQuest()
+		{
+            return GetAbandonQuestButton() != null;
+		}
+
+        private bool CanRerollQuest()
+		{
+            return GetRerollQuestButton() != null;
+		}
+
+		private PegUIElement GetAbandonQuestButton()
+		{
+            return GetAbandonOrRerollQuestButton("AbandonButton");
+		}
+
+		private PegUIElement GetRerollQuestButton()
+		{
+            return GetAbandonOrRerollQuestButton("RerollButton");
+		}
+
+        private PegUIElement GetAbandonOrRerollQuestButton(string buttonName)
+		{
+            if (m_questTile == null)
+			{
+                return null;
+			}
+
+            var buttonGO = AccessibleUnityUtils.GetChildObject(m_questTile.gameObject, $"Root/{buttonName}");
+            var button = AccessibleUnityUtils.GetComponent<PegUIElement>(buttonGO);
+
+            if (button == null || !button.isActiveAndEnabled)
+			{
+                return null;
+			}
+
+            return button;
+		}
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
new file mode 100644
index 0000000..040d6fc
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
@@ -0,0 +1,82 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuestTile : AccessibleItem
+    {
+        private readonly QuestTile m_quest;
+
+        internal AccessibleQuestTile(AccessibleComponent parent, QuestTile quest) : base(parent)
+        {
+            m_quest = quest;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_quest.m_questName.Text);
+            ret.Add(GetRewards());
+            ret.Add(m_quest.m_requirement.Text);
+
+            var progress = GetProgress();
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            return ret;
+        }
+
+        private string GetRewards()
+        {
+            var rewards = m_quest.m_quest.Rewards;
+
+            var rewardTexts = new List<string>();
+
+            foreach (var reward in rewards)
+            {
+                rewardTexts.Add(StringifyRewardType(reward.RewardType));
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, AccessibleSpeechUtils.HumanizeList(rewardTexts));
+        }
+
+        private string GetProgress()
+        {
+            var achievement = m_quest.m_quest;
+            if (achievement.MaxProgress > 1)
+            {
+                return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, achievement.Progress, achievement.MaxProgress);
+            }
+
+            return "";
+        }
+
+        private string StringifyRewardType(Reward.Type rewardType)
+        {
+            switch (rewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_DUST);
+                case Reward.Type.BOOSTER_PACK:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_PACK);
+                case Reward.Type.CARD:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD);
+                case Reward.Type.CARD_BACK:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_BACK);
+                case Reward.Type.GOLD:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_GOLD);
+                case Reward.Type.MOUNT:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT);
+                case Reward.Type.ARCANE_ORBS:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_ORBS);
+                case Reward.Type.MINI_SET:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MINI_SET);
+                default:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
new file mode 100644
index 0000000..69c6d17
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
@@ -0,0 +1,234 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Accessibility
+{
+    class AccessibleRewardData : AccessibleItem
+    {
+        internal RewardData RewardData { get; }
+
+        private List<string> m_cachedLines;
+
+        internal AccessibleRewardData(AccessibleComponent parent, RewardData rewardData) : base(parent)
+        {
+            RewardData = rewardData;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            switch (RewardData.RewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return GetLinesForArcaneDustReward();
+                case Reward.Type.BOOSTER_PACK:
+                    return GetLinesForBoosterPackReward();
+                case Reward.Type.GOLD:
+                    return GetLinesForGoldReward();
+                 case Reward.Type.CARD:
+                    return GetLinesForCardReward();
+                 case Reward.Type.CARD_BACK:
+                    return GetLinesForCardBackReward();
+                 case Reward.Type.MOUNT:
+                    return GetLinesForMountReward();
+                 case Reward.Type.ARCANE_ORBS:
+                    return GetLinesForArcaneOrbsReward();
+                 case Reward.Type.MINI_SET:
+                    return GetLinesForMiniSetReward();
+                 case Reward.Type.FORGE_TICKET:
+                    return GetLinesForForgeTicketReward();
+                 case Reward.Type.CRAFTABLE_CARD:
+                 case Reward.Type.CLASS_CHALLENGE:
+                 case Reward.Type.EVENT:
+                 case Reward.Type.RANDOM_CARD:
+                 case Reward.Type.BONUS_CHALLENGE:
+                 case Reward.Type.ADVENTURE_DECK:
+                 case Reward.Type.ADVENTURE_HERO_POWER:
+                 case Reward.Type.DECK:
+                 default:
+                    var ret = new List<string>();
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN));
+                    return ret;
+            }
+        }
+
+        private List<string> GetLinesForForgeTicketReward()
+        {
+            var ret = new List<string>();
+
+            ForgeTicketRewardData reward = (ForgeTicketRewardData)RewardData;
+
+            var numTickets = reward.Quantity;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_TICKETS, numTickets));
+            return ret;
+        }
+
+        private List<string> GetLinesForMiniSetReward()
+        {
+            var ret = new List<string>();
+
+            MiniSetRewardData reward = (MiniSetRewardData)RewardData;
+
+			MiniSetDbfRecord record = GameDbf.MiniSet.GetRecord(reward.MiniSetID);
+			int count = record.DeckRecord.Cards.Count;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_MINI_SET_WITH_N_CARDS, count));
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneOrbsReward()
+        {
+            var ret = new List<string>();
+
+            SimpleRewardData reward = (SimpleRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_ORBS, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForMountReward()
+        {
+            var ret = new List<string>();
+
+            MountRewardData reward = (MountRewardData)RewardData;
+
+            // Localizing this would be pointless
+            /*switch (reward.Mount)
+            {
+                case MountRewardData.MountType.HEROES_MAGIC_CARPET_CARD:
+                    ret.Add($"You got a Magic Carpet mount in Heroes of the Storm");
+                    break;
+                case MountRewardData.MountType.WOW_HEARTHSTEED:
+                    ret.Add($"You got a Hearthsteed mount in World of Warcraft");
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT));
+                    break;
+                default:
+                    break;
+
+            }*/
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT));
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneDustReward()
+        {
+            var ret = new List<string>();
+
+            ArcaneDustRewardData reward = (ArcaneDustRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForBoosterPackReward()
+        {
+            var ret = new List<string>();
+
+            BoosterPackRewardData reward = (BoosterPackRewardData)RewardData;
+
+            var numPacks = reward.Count;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, numPacks));
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetCardPackName(reward.Id), ret);
+
+            return ret;
+        }
+
+        private List<string> GetLinesForGoldReward()
+        {
+            var ret = new List<string>();
+
+            GoldRewardData reward = (GoldRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            CardRewardData reward = (CardRewardData)RewardData;
+
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(reward.CardID);
+            if (entityDef.IsHeroSkin())
+            {
+                return GetLinesForUnlockedHero(reward);
+            }
+            else
+            {
+                var ret = new List<string>();
+                var numCards = reward.Count;
+                var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, reward.Premium);
+                var cardClass = GameStrings.GetClassName(entityDef.GetClass());
+
+                if (entityDef.IsCoreCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CORE_CARD_FROM_CLASS, numCards, cardClass));
+                }
+                else
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CARD_FROM_CLASS, numCards, cardClass));
+                }
+
+                ret.AddRange(new AccessibleCollectibleCard(m_parent, collectibleCard, false).GetLines());
+
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForUnlockedHero(CardRewardData reward)
+        {
+            var ret = new List<string>();
+
+            var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, TAG_PREMIUM.NORMAL);
+            var heroName = collectibleCard.Name;
+            var className = GameStrings.GetClassName(DefLoader.Get().GetEntityDef(reward.CardID).GetClass());
+
+            if (reward.Premium == TAG_PREMIUM.GOLDEN)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_GOLDEN_HERO, heroName));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                return ret;
+            }
+            else if (GameUtils.IsVanillaHero(reward.CardID))
+            {
+                var numHeroes = AchieveManager.Get().NumDefaultHeroesUnlocked();
+                var numUnlockedHeroes = AchieveManager.Get().NumDefaultHeroesUnlocked();
+
+                ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_NEW_CLASS_UNLOCKED));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_UNLOCK_PROGRESS, numUnlockedHeroes, numHeroes));
+                return ret;
+            }
+            else
+            {
+                ret.Add(heroName);
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForCardBackReward()
+        {
+            var ret = new List<string>();
+
+            CardBackRewardData reward = (CardBackRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_BACK));
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
new file mode 100644
index 0000000..e277c6f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
@@ -0,0 +1,151 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleRewardItemDataModel : AccessibleItem
+    {
+        private RewardItemDataModel m_reward;
+
+        private List<string> m_cachedLines;
+
+        private bool m_includeRewardType; // Used to suppress redundant reward types in certain screens e.g. choosing hero skins in a "choose hero skin" menu
+
+        internal AccessibleRewardItemDataModel(AccessibleComponent parent, RewardItemDataModel reward, bool includeRewardType=true) : base(parent)
+        {
+            m_reward = reward;
+            m_includeRewardType = includeRewardType;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            switch (m_reward.ItemType)
+            {
+                case RewardItemType.BOOSTER:
+                    //return AsList($"{m_reward.Quantity} {m_reward.Booster.BoosterName} card pack{suffix}"); Would be hard to localize
+                    return GetLinesForCardPackReward();
+                case RewardItemType.DUST:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, m_reward.Quantity));
+                case RewardItemType.HERO_SKIN:
+                    return GetLinesForHeroSkinReward();
+                case RewardItemType.CARD_BACK:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_BACKS, m_reward.Quantity));
+                /*case RewardItemType.ADVENTURE_WING:
+                    return AsList($"{m_reward.Quantity} Adventure Wing{suffix}");*/
+                case RewardItemType.ARENA_TICKET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARENA_TICKETS, m_reward.Quantity));
+                /*case RewardItemType.RANDOM_CARD:
+                    return AsList($"{m_reward.Quantity} random card{suffix}");*/
+                case RewardItemType.RUNESTONES:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_RUNESTONES, m_reward.Quantity));
+                case RewardItemType.ARCANE_ORBS:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_ORBS, m_reward.Quantity));
+                case RewardItemType.ADVENTURE:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ADVENTURES, m_reward.Quantity));
+                case RewardItemType.CARD:
+                    return GetLinesForCardReward();
+                /*case RewardItemType.BATTLEGROUNDS_BONUS:
+                    return AsList($"{m_reward.Quantity} Battlegrounds bonus{bonusSuffix}");*/
+                case RewardItemType.TAVERN_BRAWL_TICKET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_TAVERN_BRAWL_TICKETS, m_reward.Quantity));
+                case RewardItemType.GOLD:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, m_reward.Quantity));
+                case RewardItemType.CUSTOM_COIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CUSTOM_COINS, m_reward.Quantity));
+                /*case RewardItemType.PROGRESSION_BONUS:
+                    return AsList($"{m_reward.Quantity} progression bonus{bonusSuffix}");*/
+                case RewardItemType.REWARD_TRACK_XP_BOOST:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_XP_BOOST, m_reward.Quantity));
+                case RewardItemType.MINI_SET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_MINI_SETS, m_reward.Quantity));
+                /*case RewardItemType.CARD_SUBSET:
+                    return AsList($"{m_reward.Quantity} Card subset{suffix}");
+                case RewardItemType.SELLABLE_DECK:
+                    return AsList($"{m_reward.Quantity} Sellable deck{suffix}");*/
+                case RewardItemType.BATTLEGROUNDS_HERO_SKIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS, m_reward.Quantity));
+                case RewardItemType.BATTLEGROUNDS_GUIDE_SKIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS, m_reward.Quantity));
+                default:
+                    var ret = new List<string>();
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN));
+                    return ret;
+            }
+        }
+
+        private List<string> GetLinesForHeroSkinReward()
+        {
+            var ret = new List<string>();
+
+            if (m_includeRewardType)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_HERO_SKINS, m_reward.Quantity));
+            }
+
+            var record = GameDbf.RewardItem.GetRecord(m_reward.AssetId);
+            var skinName = record.CardRecord.Name.GetString();
+            var className = GameStrings.GetClassName(GameUtils.GetTagClassFromCardDbId(record.Card));
+
+            if (skinName?.Length > 0)
+            {
+                ret.Add(skinName);
+            }
+
+            if (className?.Length > 0)
+            {
+                ret.Add(className);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForCardPackReward()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, m_reward.Quantity));
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetCardPackName((int)m_reward.Booster.Type), ret);
+
+            return ret;
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CARD, m_reward.Quantity));
+
+            var card = CollectionManager.Get().GetCard(m_reward.Card.CardId, m_reward.Card.Premium);
+            var accessibleCard = new AccessibleCollectibleCard(m_parent, card, false, true);
+
+            ret.AddRange(accessibleCard.GetLines());
+
+            return ret;
+        }
+
+        private List<string> AsList(string str)
+        {
+			var ret = new List<string>();
+			ret.Add(str);
+			return ret;
+        }
+
+        public RewardItemDataModel GetDataModel()
+        {
+            return m_reward;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
new file mode 100644
index 0000000..95f52a6
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
@@ -0,0 +1,35 @@
+﻿using System;
+using System.Collections.Generic;
+using static RewardBoxesDisplay;
+
+namespace Accessibility
+{
+    class AccessibleRewardPackage : AccessibleItem
+    {
+        internal RewardBoxData RewardBoxData { get; }
+
+        internal AccessibleRewardData RewardData { get; }
+
+        internal bool Open { get; set; }
+
+        internal AccessibleRewardPackage(AccessibleComponent parent, RewardBoxData rewardBoxData, RewardData rewardData) : base(parent)
+        {
+            RewardBoxData = rewardBoxData;
+            RewardData = new AccessibleRewardData(parent, rewardData);
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (!Open)
+            {
+                var ret = new List<string>();
+                ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_REWARD_PACKAGE));
+                return ret;
+            }
+            else
+            {
+                return RewardData.GetLines();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs
new file mode 100644
index 0000000..d960e73
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs
@@ -0,0 +1,11 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleScreen : AccessibleComponent
+    {
+        void HandleInput();
+
+        string GetHelp();
+
+        void OnGainedFocus();
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs
new file mode 100644
index 0000000..aa0cd2f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs
@@ -0,0 +1,48 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleScrollbarControl : AccessibleElement
+    {
+        private readonly ScrollbarControl m_scrollbar;
+
+        private Action m_onDone;
+
+        internal AccessibleScrollbarControl(AccessibleComponent parent, ScrollbarControl scrollbar, Action onDone) : base(parent)
+        {
+            m_scrollbar = scrollbar;
+            m_onDone = onDone;
+        }
+
+        public void HandleInput()
+        {
+			if (AccessibleKey.GLOBAL_LEFT.IsPressed())
+            {
+				Inc(-1);
+            }
+			else if (AccessibleKey.GLOBAL_RIGHT.IsPressed())
+            {
+				Inc(1);
+            }
+			else if (AccessibleKey.GLOBAL_BACK.IsPressed() || AccessibleKey.GLOBAL_CONFIRM.IsPressed())
+            {
+                m_onDone();
+            }
+        }
+
+        private void Inc(int sign)
+        {
+            float val = sign >= 0 ? 0.1f : -0.1f;
+
+            float target = m_scrollbar.GetValue() + val;
+
+            m_scrollbar.SetValue(target);
+            m_scrollbar.FireUpdateEvent();
+            m_scrollbar.FireFinishEvent();
+
+            Output(AccessibleSpeech.OPTIONS_SCROLLBAR_STATE(m_scrollbar.GetValue()));
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
new file mode 100644
index 0000000..96221e7
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
@@ -0,0 +1,319 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Runtime.CompilerServices;
+using static Accessibility.HSASpeech;
+
+namespace Accessibility
+{
+    public class AccessibleSpeech
+    {
+        #region Global
+        public static string PRESS_ENTER_TO_START => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM);
+        public static string PRESS_ENTER_TO_CONTINUE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+        public static string PRESS_CONFIRM_ONCE_DONE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_ONCE_DONE, AccessibleKey.CONFIRM);
+        public static string PRESS_BACK_ONCE_DONE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_ONCE_DONE, AccessibleKey.BACK);
+        public static string PRESS_BACK_TO_GO_BACK => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_GO_BACK, AccessibleKey.BACK);
+
+        public static HSASpeech PRESS_ENTER_TO_START_VOICE = CreateSpeech(L10N.Of(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to start");
+        #endregion
+
+        #region Menus
+        private static string MENU_HELP_NO_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HELP_NO_BACK_BUTTON, AccessibleKey.CONFIRM);
+        private static string MENU_HELP_WITH_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HELP_WITH_BACK_BUTTON, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        private static string MENU_HORIZONTAL_HELP_NO_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HORIZONTAL_HELP_NO_BACK_BUTTON, AccessibleKey.CONFIRM);
+        private static string MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        public static string MENU_HELP(bool hasBackButton) => hasBackButton ? MENU_HELP_WITH_BACK_BUTTON : MENU_HELP_NO_BACK_BUTTON;
+        public static string MENU_HORIZONTAL_HELP(bool hasBackButton) => hasBackButton ? MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON : MENU_HORIZONTAL_HELP_NO_BACK_BUTTON;
+        public static string MENU_OPTION(string optionName, int optionNumber, int optionsCount) => LocalizationUtils.Format(LocalizationKey.MENU_OPTION_FORMAT, optionName, optionNumber, optionsCount);
+        public static string MENU_NO_ITEMS_HELP => AccessibleSpeechUtils.CombineSentences(LocalizedText.MENU_NO_ITEMS, PRESS_BACK_TO_GO_BACK);
+        public static string OPTIONS_SCROLLBAR_STATE(float val) => $"{(int)Math.Round(val*100)}";
+        #endregion
+
+        #region Tutorial Progress Screen
+        public static HSASpeech TUTORIAL_WELCOME_BACK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_WELCOME_BACK), "Welcome back to the tutorial");
+        public static HSASpeech TUTORIAL_DEFEATED_HOGGER = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_HOGGER), "You've defeated Hogger");
+        public static HSASpeech TUTORIAL_DEFEATED_MILLHOUSE = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_MILLHOUSE), "You've defeated Millhouse Manastorm");
+        public static HSASpeech TUTORIAL_DEFEATED_CHO = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_CHO), "You've defeated Lorewalker Cho");
+        public static HSASpeech TUTORIAL_DEFEATED_MUKLA = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_MUKLA), "You've defeated King Mukla");
+        public static HSASpeech TUTORIAL_DEFEATED_NESINGWARY = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_NESINGWARY), "You've defeated Hemet Nesingwary");
+        public static HSASpeech TUTORIAL_DEFEATED_ILLIDAN = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_ILLIDAN), "You've defeated Illidan Stormrage");
+        public static HSASpeech TUTORIAL_NEXT_HOGGER = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_HOGGER), "Your next opponent is Hogger");
+        public static HSASpeech TUTORIAL_NEXT_MILLHOUSE = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_MILLHOUSE), "Your next opponent is Millhouse Manastorm");
+        public static HSASpeech TUTORIAL_NEXT_CHO = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_CHO), "Your next opponent is Lorewalker Cho");
+        public static HSASpeech TUTORIAL_NEXT_MUKLA = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_MUKLA), "Your next opponent is King Mukla");
+        public static HSASpeech TUTORIAL_NEXT_NESINGWARY = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_NESINGWARY), "Your next opponent is Hemet Nesingwary");
+        public static HSASpeech TUTORIAL_NEXT_ILLIDAN = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_ILLIDAN), "Your next and final opponent is Illidan Stormrage");
+        #endregion
+
+        #region Gameplay Help Speeches
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_HERO_HELP, AccessibleKey.SEE_PLAYER_HERO), $"Press {AccessibleKey.SEE_PLAYER_HERO.ToEnglishString()} to look at your hero");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_OPPONENT_HERO_HELP, AccessibleKey.SEE_OPPONENT_HERO), $"Press {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()} to look at your opponent's hero");
+        public static HSASpeech GAMEPLAY_READ_CARDS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARDS_HELP), "Use the up and down arrow keys to read cards");
+        public static HSASpeech GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CONFIRM_TO_ATTACK_TARGET, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack this target");
+
+        public static HSASpeech GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to summon this minion");
+
+        // General gameplay ones
+        public static HSASpeech GAMEPLAY_OPPONENT_TURN_VOICE = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_OPPONENT_TURN), $"Your opponent is playing");
+        public static HSASpeech GAMEPLAY_CONFIRM_END_TURN_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CONFIRM_END_TURN_HELP, AccessibleKey.CONFIRM, AccessibleKey.END_TURN), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} or {AccessibleKey.END_TURN.ToEnglishString()} to end your turn. Press any other key to cancel");
+        public static HSASpeech GAMEPLAY_SEE_VALID_OPTIONS = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_VALID_OPTIONS, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid options");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_HAND_HELP, AccessibleKey.SEE_PLAYER_HAND), $"Press {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at your hand");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_HAND_HELP, AccessibleKey.SEE_OPPONENT_HAND), $"Press {AccessibleKey.SEE_OPPONENT_HAND.ToEnglishString()} to count the cards in your opponent's hand");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_MINIONS_HELP, AccessibleKey.SEE_PLAYER_MINIONS), $"Press {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to look at your summoned minions");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP, AccessibleKey.SEE_OPPONENT_MINIONS), $"Press {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} to look at your opponent's minions");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_SECRETS_HELP, AccessibleKey.SEE_PLAYER_SECRETS), $"Press {AccessibleKey.SEE_PLAYER_SECRETS.ToEnglishString()} to look at your secrets");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP, AccessibleKey.SEE_OPPONENT_SECRETS), $"Press {AccessibleKey.SEE_OPPONENT_SECRETS.ToEnglishString()} to count your opponent's secrets");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_WEAPON_HELP, AccessibleKey.SEE_PLAYER_WEAPON), $"Press {AccessibleKey.SEE_PLAYER_WEAPON.ToEnglishString()} to read your weapon");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_WEAPON_HELP, AccessibleKey.SEE_OPPONENT_WEAPON), $"Press {AccessibleKey.SEE_OPPONENT_WEAPON.ToEnglishString()} to read your opponent's weapon");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP, AccessibleKey.SEE_PLAYER_HERO_POWER), $"Press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to read your hero power");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP, AccessibleKey.SEE_OPPONENT_HERO_POWER), $"Press {AccessibleKey.SEE_OPPONENT_HERO_POWER.ToEnglishString()} to read your opponent's hero power");
+        public static HSASpeech GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_PLAYER_DECK_HELP, AccessibleKey.SEE_PLAYER_DECK), $"Press {AccessibleKey.SEE_PLAYER_DECK.ToEnglishString()} to count the remaining cards in your deck");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_DECK_HELP, AccessibleKey.SEE_OPPONENT_DECK), $"Press {AccessibleKey.SEE_OPPONENT_DECK.ToEnglishString()} to count the remaining cards in your opponent's deck");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA_HELP, AccessibleKey.SEE_PLAYER_MANA), $"Press {AccessibleKey.SEE_PLAYER_MANA.ToEnglishString()} to read your mana");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_MANA_HELP, AccessibleKey.SEE_OPPONENT_MANA), $"Press {AccessibleKey.SEE_OPPONENT_MANA.ToEnglishString()} to read your opponent's mana");
+        public static HSASpeech GAMEPLAY_READ_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARD_HELP), "Use the up and down arrow keys to read this card");
+        public static HSASpeech GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARD_TOOLTIP_HELP, AccessibleKey.READ_TOOLTIP), $"Press {AccessibleKey.READ_TOOLTIP.ToEnglishString()} to get a description of this card's abilities");
+        public static HSASpeech GAMEPLAY_PLAY_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_PLAY_CARD_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to play this card");
+        public static HSASpeech GAMEPLAY_TRADE_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_TRADE_CARD_HELP, AccessibleKey.TRADE_CARD), $"Press {AccessibleKey.TRADE_CARD.ToEnglishString()} to trade this card");
+        public static HSASpeech GAMEPLAY_SUMMON_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SUMMON_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to summon this minion");
+        public static HSASpeech GAMEPLAY_CHOICE_MODE_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CHOICE_MODE_HELP, AccessibleKey.CONFIRM), $"Use the arrow keys to go through your options. Press {AccessibleKey.CONFIRM.ToEnglishString()} to choose one");
+        public static HSASpeech GAMEPLAY_CHOOSE_TARGET_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CHOOSE_TARGET_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.CONFIRM, AccessibleKey.BACK), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or the Zone keys to go through your targets. Press {AccessibleKey.CONFIRM.ToEnglishString()} to choose a target or {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_WITH_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with this minion");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_WITH_HERO_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with your hero");
+        public static HSASpeech GAMEPLAY_USE_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_USE_HERO_POWER_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to use your hero power");
+        public static HSASpeech GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_THROUGH_VALID_TARGETS, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to read through your valid targets");
+        public static HSASpeech GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_THIS_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack this minion");
+        public static HSASpeech GAMEPLAY_CANCEL_ATTACK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CANCEL_ATTACK_HELP, AccessibleKey.BACK), $"Press {AccessibleKey.BACK.ToEnglishString()} to cancel the attack");
+        public static HSASpeech GAMEPLAY_CANCEL_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CANCEL_HELP, AccessibleKey.BACK), $"Press {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP), $"Use the left and right arrow keys to choose a position for this minion");
+        public static HSASpeech GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_OPEN_HISTORY_LOG_HELP, AccessibleKey.SEE_HISTORY), $"Press {AccessibleKey.SEE_HISTORY.ToEnglishString()} to open the play history log");
+        public static HSASpeech GAMEPLAY_READ_HISTORY_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_HISTORY_HELP, AccessibleKey.BACK), $"Use the up and down arrow keys to read the play history. Press {AccessibleKey.BACK.ToEnglishString()} to close the history log");
+        public static HSASpeech GAMEPLAY_END_TURN_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_END_TURN_HELP, AccessibleKey.END_TURN), $"Press {AccessibleKey.END_TURN.ToEnglishString()} to end your turn");
+        #endregion
+
+        #region Tutorials
+        public static HSASpeech WELCOME_TO_HEARTHSTONE = CreateSpeech(L10N.Of(LocalizationKey.WELCOME_TO_HEARTHSTONE), "Welcome to Hearthstone");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_INTRO), $"I'll be teaching you how to play through a set of six tutorial games");
+        public static HSASpeech TUTORIAL_NARRATOR_HELP_KEYS = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_HELP_KEYS, AccessibleKey.HELP), $"If you ever feel lost, press {AccessibleKey.HELP.ToEnglishString()}. Even after the tutorial or when navigating menus, you can always use {AccessibleKey.HELP.ToEnglishString()} whenever you need help");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO_END = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_INTRO_END), "Alright, let's get on with it");
+        public static HSASpeech TUTORIAL_FREE_STARTING_PACK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_FREE_STARTING_PACK, AccessibleKey.CONFIRM), $"Here's a basic Mage pack of cards to get you started. Press {AccessibleKey.CONFIRM.ToEnglishString()} to open it");
+
+        public static HSASpeech TUTORIAL_NICE_WORK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_WORK), "Nice work");
+        public static HSASpeech TUTORIAL_NICE_JOB = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_JOB), "Nice job");
+        public static HSASpeech TUTORIAL_NICE_ONE = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_ONE), "Nice one");
+        public static HSASpeech TUTORIAL_GOOD_JOB = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_GOOD_JOB), "Good job");
+        public static HSASpeech TUTORIAL_YOU_GOT_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_YOU_GOT_IT), "You got it!");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_REMEMBER_HOW_TO_DO_IT), "Remember how to do it?");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_REMEMBER_HOW_TO_DO_THAT), "Remember how to do that?");
+        public static HSASpeech TUTORIAL_TRY_IT_OUT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_TRY_IT_OUT), "Try it out!");
+        public static HSASpeech TUTORIAL_ALL_RIGHT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ALL_RIGHT), "All right!");
+        public static HSASpeech TUTORIAL_LETS_LEARN_HOW = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_LETS_LEARN_HOW), "Let's learn how");
+        public static HSASpeech TUTORIAL_CAN_YOU_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_CAN_YOU_DO_IT), "Can you do it?");
+        public static HSASpeech TUTORIAL_THINK_YOU_CAN_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_THINK_YOU_CAN_DO_IT), "Think you can do it?");
+        public static HSASpeech TUTORIAL_GOT_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_GOT_IT), "Got it");
+
+        // General tutorial notifications
+        public static HSASpeech TUTORIAL_NO_ENDTURN_ATK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN_ATK), "Not yet! You can still attack");
+        public static HSASpeech TUTORIAL_NO_ENDTURN = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN), "Not yet! You have more cards to play!");
+        public static HSASpeech TUTORIAL_NO_ENDTURN_HP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN_HP, AccessibleKey.SEE_PLAYER_HERO_POWER), $"Not yet! Use your Hero Power. Press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to select it");
+
+        #region Hogger
+        public static HSASpeech TUTORIAL_HOGGER_START = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_START), $"Your first opponent is a gnoll named Hogger. You will be playing as the powerful mage Jaina Proudmoore");
+
+        // Notifications
+        public static HSASpeech TUTORIAL01_HELP_07 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL01_HELP_07), "Save that for the enemy!");
+        public static HSASpeech TUTORIAL01_HELP_08 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL01_HELP_08), "Ignore the puny gnoll and finish off Hogger");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_CARD_READ = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_FORCE_CARD_READ), $"Use the up and down arrow keys to read this card first");
+        public static HSASpeech TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_SUMMON_MINION_FIRST), $"Summon the minion you just got first");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST, AccessibleKey.SEE_OPPONENT_MINIONS), $"Use {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} and the arrow keys to read your opponent's minions first");
+
+        // Turn 2
+        public static HSASpeech TUTORIAL_HOGGER_2_0 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_0), $"When a turn starts, you always begin by drawing a card from your deck. Let's see the one we just drew");
+        public static HSASpeech TUTORIAL_HOGGER_2_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_1, AccessibleKey.SEE_PLAYER_HAND), $"Press  {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at the cards in your hand");
+        // Use the arrow keys to read this card
+        public static HSASpeech TUTORIAL_HOGGER_2_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2), $"Ok, so... This card is a minion named Murloc Raider");
+        public static HSASpeech TUTORIAL_HOGGER_2_2B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2B), $"Minions are creatures that you can summon onto the battlefield to fight for your Hero");
+        public static HSASpeech TUTORIAL_HOGGER_2_2D = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2D), $"This one costs 1 mana to summon and has 2 attack and 1 health");
+        public static HSASpeech TUTORIAL_HOGGER_2_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_3), $"Let's start by summoning this minion");
+        public static HSASpeech TUTORIAL_HOGGER_2_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_4, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_2_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_5, AccessibleKey.CONFIRM, AccessibleKey.BACK), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to confirm or {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech TUTORIAL_HOGGER_2_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_6), $"Minions must wait a turn to attack once they're summoned, so we have nothing left to do");
+        // Press E to end your turn
+
+        // Turn 3
+        public static HSASpeech TUTORIAL_HOGGER_3_0 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_0), "Your opponent's minion attacked your Hero so you took some damage");
+        public static HSASpeech TUTORIAL_HOGGER_3_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_1), "Let's see how much health we have left");
+        // Press V to look at your Hero
+        public static HSASpeech TUTORIAL_HOGGER_3_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_2), $"Use the up and down arrow keys to read your hero card");
+        public static HSASpeech TUTORIAL_HOGGER_3_2_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_2_HELP, AccessibleKey.SEE_PLAYER_HERO), $"Use {AccessibleKey.SEE_PLAYER_HERO.ToEnglishString()} and the arrow keys to find out how much health your Hero has");
+        public static HSASpeech TUTORIAL_HOGGER_3_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_3), $"If your Hero runs out of health, you lose. 28 health is still plenty though");
+        public static HSASpeech TUTORIAL_HOGGER_3_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_4, AccessibleKey.SEE_OPPONENT_HERO), $"Let's look at your opponent's hero now. Press {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_3_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_5), $"Can you find how much health he has?");
+        public static HSASpeech TUTORIAL_HOGGER_3_5_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_5_HELP), $"Use the up and down arrow keys to read your opponent's hero card");
+        // Ues the arrow keys to read cards
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_3_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_6), $"Once your opponent's Hero runs out of health, you win");
+        public static HSASpeech TUTORIAL_HOGGER_3_7 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_7), $"Let's carry on");
+
+        // Turn 4
+        public static HSASpeech TUTORIAL_HOGGER_4_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_1), $"Looks like you got another minion. Can you summon this one yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_1_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_1_HELP, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to summon your minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_2), $"When you already have minions on the battlefield, you can use the left and right arrow keys to select where the new minion will be placed");
+        // Try it out
+        public static HSASpeech TUTORIAL_HOGGER_4_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_4), $"You now have two minions on the battlefield. This one was just summoned so it must wait a turn to attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_5), "Let's learn how to navigate the battlefield");
+        // Press B to look at your summoned minions
+        public static HSASpeech TUTORIAL_HOGGER_4_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_6), $"Use the left and right arrow keys to navigate your minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_6_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_6_HELP, AccessibleKey.SEE_PLAYER_MINIONS), $"Use {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} and the arrow keys to navigate your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_8 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_8, AccessibleKey.SEE_OPPONENT_MINIONS), $"Let's look at your opponent's minions now. Press {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_4_9 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_9), $"Can you read this minion by yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_9_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_9_HELP), $"Use the up and down arrow keys to read your opponent's minions");
+        // You got it
+        public static HSASpeech TUTORIAL_HOGGER_4_10 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_10), $"Let's try to attack this minion now");
+        public static HSASpeech TUTORIAL_HOGGER_4_11 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_11), $"Select the Murloc Raider you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_4_11_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_11_HELP, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to get to your minion and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_12 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_12, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with this minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_13 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_13), $"Can you attack your opponent's minion?");
+        public static HSASpeech TUTORIAL_HOGGER_4_13_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_13_HELP, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to attack your opponent's minion");
+        // Press G to look at your opponent's minions and enter to attack
+        // Nice one
+        public static HSASpeech TUTORIAL_HOGGER_4_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_16), $"Both minions had 2 attack and 1 health so they killed each other");
+        public static HSASpeech TUTORIAL_HOGGER_4_17 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_17), $"Your other minion is still exhausted so there's nothing left to do. Remember how to end your turn?");
+
+        // Turn 6
+        public static HSASpeech TUTORIAL_HOGGER_6_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_1), $"Looks like you got another minion");
+        public static HSASpeech TUTORIAL_HOGGER_6_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_2), $"This means you have two possible options right now");
+        public static HSASpeech TUTORIAL_HOGGER_6_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_3), $"You can either summon the minion you just got, or use the one you summoned last turn to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_4, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.SEE_PLAYER_MINIONS), $"One way to do this would be using keys such as {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at your hand or {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to look at your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_6_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_5), $"However, there's an easier way to do it");
+        // Let's learn how
+        public static HSASpeech TUTORIAL_HOGGER_6_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_6, AccessibleKey.READ_NEXT_VALID_ITEM), $"Press {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_6_7 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_7), $"You're now looking at your first option, which would be to summon the minion you just got");
+        public static HSASpeech TUTORIAL_HOGGER_6_8 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_8, AccessibleKey.READ_NEXT_VALID_ITEM), $"Try pressing {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} again");
+        public static HSASpeech TUTORIAL_HOGGER_6_9 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_9), $"You're now looking at your second option, which would be to attack with the minion you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_6_10 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_10, AccessibleKey.READ_NEXT_VALID_ITEM), $"You can always use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid options, so make sure to remember this key!");
+        public static HSASpeech TUTORIAL_HOGGER_6_12 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_12), $"Alright. Let's begin by summoning the minion we just got");
+        // Can you do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_12_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_12_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to summon your minion");
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_6_13 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_13), $"Let's try to attack with our other minion now");
+        // Think you can do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_13_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_13_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to find your minion and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_14 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_14), $"You now have another choice to make. You can either attack one of your opponent's minions, or your opponent's hero himself");
+        public static HSASpeech TUTORIAL_HOGGER_6_15 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_15, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.SEE_OPPONENT_HERO), $"You can either use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid targets or select your target directly using {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} or {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_6_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_16), $"Go ahead and choose a target to attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_16_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_16_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        // Nice work
+        public static HSASpeech TUTORIAL_HOGGER_6_21 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_21), $"We're ready to end our turn!");
+
+        // Turn 8
+        public static HSASpeech TUTORIAL_HOGGER_8_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_8_1), $"I'll let you continue playing by yourself. Just let me know if you need anything");
+
+        #endregion
+
+        #region Millhouse
+        public static HSASpeech TUTORIAL_02_HELP_01 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_01), "You gain a Mana Crystal every turn");
+        public static HSASpeech TUTORIAL02_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_03), "Your used Mana Crystals refill each turn");
+        public static HSASpeech TUTORIAL02_HELP_06 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_06), "Get Millhouse!");
+        public static HSASpeech TUTORIAL02_HELP_07 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_07), "Expend your Mana each turn to crush this annoying gnome!");
+
+        public static HSASpeech TUTORIAL_RAID_LEADER_DESCRIPTION = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_RAID_LEADER_DESCRIPTION), "This minion has a power that lasts until he dies");
+        public static HSASpeech TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ARCANE_INTELLECT_DESCRIPTION), "You can have 10 cards in your hand");
+
+        // Turn 1
+        public static HSASpeech TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MILLHOUSE_SEE_MANA_HELP, AccessibleKey.SEE_PLAYER_MANA), $"Press {AccessibleKey.SEE_PLAYER_MANA.ToEnglishString()} at any time to see how much mana you have");
+        #endregion
+
+        #region Lorewalker Cho
+        public static HSASpeech TUTORIAL06_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_03), "Minions with Battlecry do something special when you summon them");
+        public static HSASpeech TUTORIAL_CHO_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_CHO_1), "This Voodoo Doctor healed your opponent's Hero");
+        public static HSASpeech TUTORIAL06_HELP_02 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_02), "When minions fight each other, they both take damage");
+        public static HSASpeech TUTORIAL06_HELP_04 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_04), "Kill enemy minions before they become a problem!");
+        #endregion
+
+        #region King Mukla
+        public static HSASpeech TUTORIAL_MUKLA_START = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START), "In this game, you'll see some cards with abilities you haven't seen before");
+        public static HSASpeech TUTORIAL_MUKLA_START_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START_B, AccessibleKey.READ_TOOLTIP), $"If you run into something you don't understand when reading a card such as Charge or Taunt, press {AccessibleKey.READ_TOOLTIP.ToEnglishString()} to get more information");
+        public static HSASpeech TUTORIAL_MUKLA_START_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START_C, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} whenever you're ready to start");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP), $"This gorilla your opponent just summoned has an ability named Taunt");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_B), $"Minions with Taunt must always be killed before you can attack anyone else");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_C), $"Taunt is an important ability as it can be used to protect your Hero");
+        #endregion
+
+        #region Nesingwary
+        public static HSASpeech TUTORIAL04_HELP_14 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_14), $"Welcome to the Jungle");
+        public static HSASpeech TUTORIAL04_HELP_15 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_15), $"Kill his minions or he'll overwhelm you!");
+        public static HSASpeech TUTORIAL04_HELP_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_16), $"Subdue minions with your hero power and spells!");
+        public static HSASpeech TUTORIAL04_HELP_02 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_02), $"Sheep it!");
+        public static HSASpeech TUTORIAL04_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_03), $"Save that for the Fen Creeper!");
+
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP), $"From now on, your Hero and your opponent's Hero will normally have a Hero Power");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_B), $"Every Hero has its own Hero Power and you can use it once per turn");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_C, AccessibleKey.SEE_PLAYER_HERO_POWER, AccessibleKey.SEE_OPPONENT_HERO_POWER), $"You can always press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to see your Hero Power and {AccessibleKey.SEE_OPPONENT_HERO_POWER.ToEnglishString()} to see your opponent's Hero Power");
+        // Try it out!
+        #endregion
+
+        #region Illidan
+        public static HSASpeech TUTORIAL05_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL05_HELP_03), $"This fight is totally not fair. Blame the terrible game designers");
+        public static HSASpeech TUTORIAL05_HELP_04 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL05_HELP_04), $"Your Taunt minions can protect you from attacks!");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP), $"It looks like your opponent equipped a weapon");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B), $"Weapons are special cards which can be equipped by heroes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C), $"Each weapon has some attack and some durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D), $"Once equipped, heroes can attack other characters during their turn");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E), $"Your opponent equipped Warglaive of Azzinoth: a weapon with 2 attack and 2 durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F), $"This means your opponent's Hero will have 2 attack during his turn, and will be able to attack any of your characters");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G), $"Mages don't often use weapons, but you'll be able to play with some later on once you've unlocked other classes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H, AccessibleKey.SEE_PLAYER_WEAPON, AccessibleKey.SEE_OPPONENT_WEAPON), $"You can press {AccessibleKey.SEE_PLAYER_WEAPON.ToEnglishString()} at any time to see your weapon or {AccessibleKey.SEE_OPPONENT_WEAPON.ToEnglishString()} to see your opponent's one");
+
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP), $"Hear that sound? Weapons lose durability every time their Hero attacks");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B), $"Once they reach 0 durability, they break and the Hero can no longer attack");
+        #endregion
+
+        #endregion
+
+        #region In-game "Tutorials"
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME), $"Every normal game starts with the mulligan phase");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B), $"In this phase, both players can replace cards in their starting hand with random ones from their deck");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use the arrow keys or {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your starting hand");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D, AccessibleKey.MULLIGAN_MARK_CARD), $"If you see a card you don't like, press {AccessibleKey.MULLIGAN_MARK_CARD.ToEnglishString()} to mark it for replacement");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E, AccessibleKey.CONFIRM), $"Once you've marked all cards you'd like to replace, press {AccessibleKey.CONFIRM.ToEnglishString()} to draw new ones and start the game");
+        #endregion
+
+        private static List<HSASpeech> s_speeches;
+        private static Dictionary<string, HSASpeech> s_speechDict;
+
+        private static HSASpeech CreateSpeech(L10N l10n, string value, [CallerMemberName] string key=null)
+        {
+            if (key == null)
+            {
+                throw new ArgumentException($"Invoked CreateSpeech in an invalid context");
+            }
+
+            var newSpeech = new HSASpeech(key, value, l10n);
+            if (s_speeches == null)
+            {
+                s_speeches = new List<HSASpeech>();
+            }
+
+            if (s_speechDict == null)
+            {
+                s_speechDict = new Dictionary<string, HSASpeech>();
+            }
+
+            if (s_speechDict.ContainsKey(key))
+            {
+                throw new ArgumentException($"Fatal error initializing accessible speeches. Found duplicate speech: {key}");
+            }
+
+            s_speeches.Add(newSpeech);
+            s_speechDict.Add(key, newSpeech);
+
+            return newSpeech;
+        }
+
+        public static List<HSASpeech> GetAllSpeeches()
+        {
+            return s_speeches;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
new file mode 100644
index 0000000..b67ff21
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
@@ -0,0 +1,453 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleSpeechMgr : MonoBehaviour
+    {
+        private static int MAX_GAME_SPEED_WPM = 10000;
+
+        class QueuedHSASpeech
+        {
+            internal HSASpeech Speech;
+            internal bool Interruptable;
+            internal Action OnFinishListener;
+
+            internal void OnFinish()
+            {
+                if (OnFinishListener != null)
+                {
+                    OnFinishListener();
+                }
+            }
+        }
+
+        private Queue<QueuedHSASpeech> m_queuedNarrations = new Queue<QueuedHSASpeech>();
+        private QueuedHSASpeech m_curNarration;
+
+        private Queue<QueuedText> m_queuedTexts = new Queue<QueuedText>();
+        private QueuedText m_curText;
+        private List<QueuedText> m_prevTexts = new List<QueuedText>();
+
+        private List<int> m_WPMSpeeds = new List<int>() { 100, 125, 150, 175, 200, 225, 250, 275, 300, MAX_GAME_SPEED_WPM };
+        private int m_curGameSpeed = 3; // Index based i.e. 150WPM
+        private int m_curCPS = CalcCPS(150);
+        private bool m_gameSpeedOptionLoaded;
+
+        private static int MAX_GAME_SPEED_CPS = CalcCPS(MAX_GAME_SPEED_WPM);
+
+        private void Update()
+        {
+            if (Input.anyKeyDown && m_curText != null)
+            {
+                InterruptTexts();
+            }
+
+            if (m_curText == null && m_curNarration == null)
+            {
+                if (m_queuedTexts.Count > 0)
+                {
+                    var nextText = m_queuedTexts.Dequeue();
+                    AccessibleSpeechOptimizer.OptimizeText(nextText, m_prevTexts);
+                    StartCoroutine(OutputText(nextText));
+                }
+                else if (m_queuedNarrations.Count > 0)
+                {
+                    StartCoroutine(Play(m_queuedNarrations.Dequeue()));
+                }
+            }
+        }
+
+        internal void InterruptTexts()
+        {
+            m_curText?.Interrupt();
+
+            while (m_queuedTexts.Count > 0)
+            {
+                var queuedText = m_queuedTexts.Dequeue();
+
+                if (queuedText != null && queuedText.IsNarration())
+                {
+                    return;
+                }
+                queuedText?.Interrupt();
+            }
+        }
+
+        internal void Narrate(bool interruptable, Action onFinish, params HSASpeech[] speeches)
+        {
+            if (IsSpeechAudioAvailable())
+            {
+                foreach (var speech in speeches)
+                {
+                    m_queuedNarrations.Enqueue(new QueuedHSASpeech()
+                    {
+                        Speech = speech,
+                        Interruptable = interruptable,
+                        OnFinishListener = onFinish,
+                    });
+                }
+            }
+            else
+            {
+                foreach (var speech in speeches)
+                {
+                    OutputNarrationAsText(speech.GetLocalizedText());
+                }
+            }
+        }
+
+        internal void InterruptNarrations()
+        {
+            var source = GetAudioSource();
+
+            if (m_curNarration != null)
+            {
+                if (m_curNarration.Interruptable)
+                {
+                    source?.Stop();
+                }
+                else
+                {
+                    return;
+                }
+            }
+
+            while (m_queuedNarrations.Count > 0 && m_queuedNarrations.Peek().Interruptable)
+            {
+                var s = m_queuedNarrations.Dequeue();
+                s?.OnFinish();
+            }
+        }
+
+        internal void InterruptTextSpeeches()
+        {
+            InterruptTexts();
+        }
+
+        private AudioSource GetAudioSource()
+        {
+            return GetComponent<AudioSource>();
+        }
+
+        internal IEnumerator Narrate(HSASpeech speech)
+        {
+            if (!IsSpeechAudioAvailable())
+            {
+                OutputNarrationAsText(speech.GetLocalizedText());
+                yield break;
+            }
+
+            InterruptNarrations();
+
+            var newSpeech = new QueuedHSASpeech
+            {
+                Interruptable = false,
+                Speech = speech
+            };
+
+            m_queuedNarrations.Enqueue(newSpeech);
+
+            while (m_curNarration != newSpeech)
+            {
+                yield return null;
+            }
+
+            while (m_curNarration == newSpeech)
+            {
+                yield return null;
+            }
+        }
+
+        private IEnumerator Play(QueuedHSASpeech speech)
+        {
+            if (speech == null)
+            {
+                yield break;
+            }
+
+            m_curNarration = speech;
+
+            var hsDir = Directory.GetCurrentDirectory();
+            AccessibilityUtils.LogDebug($"CurrentWorkDir: {hsDir}");
+            var speechFileName = speech.Speech.GetFileName();
+            AccessibilityUtils.LogDebug($"Play: {speechFileName}");
+            var speechPath = Path.Combine(hsDir, "Accessibility", "Speeches", speechFileName);
+
+            var uri = new Uri(speechPath);
+            string url = uri.AbsoluteUri;
+
+            WWW www = new WWW(url);
+            yield return www;
+
+            var source = GetAudioSource();
+            source.clip = www.GetAudioClip(false, false, AudioType.OGGVORBIS);
+            source.Play();
+            // TODO: Figure out a way to play with the Narrator volume
+            //SoundManager.Get().Play(source, new SoundDef() { m_IgnoreDucking = true }); Not quite
+            //SoundManager.Get().PlayOneShot(source, null);
+
+            while (source.isPlaying)
+            {
+                yield return null;
+            }
+
+            speech.OnFinish();
+            m_curNarration = null;
+        }
+
+        internal void CalibrateScreenReaderSpeed(KeyCode key)
+        {
+            StartCoroutine(Calibrate(key));
+        }
+
+        private IEnumerator Calibrate(KeyCode key)
+        {
+            var text1 = "Your turn.";
+            var text2 = "You draw Firelands.";
+            var text3 = "You draw Shadow Word: Death.";
+            var text4 = "Your River Crocolisk attacks your opponent's Gurubashi Berserker.";
+
+            yield return RunCalibrationTest(text1, key);
+            yield return RunCalibrationTest(text2, key);
+            yield return RunCalibrationTest(text3, key);
+            yield return RunCalibrationTest(text4, key);
+        }
+
+        private IEnumerator RunCalibrationTest(string text, KeyCode key)
+        {
+            ScreenReader.Output("Ready?");
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            var stopwatch = new Stopwatch();
+            stopwatch.Start();
+            ScreenReader.Output(text);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            stopwatch.Stop();
+
+            LogCalibrationTime(text, stopwatch.ElapsedMilliseconds);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+        }
+
+        private void LogCalibrationTime(string text, float elapsedMillis)
+        {
+            var cps = (1000 * text.Length) / elapsedMillis;
+            var numWords = NumWords(text);
+            var wpm = (1000*60 * numWords) / elapsedMillis;
+
+            AccessibilityUtils.LogDebug($"CPS: {cps} / WPM: {wpm} ({numWords} words in {elapsedMillis}ms) text: {text}");
+        }
+
+        private int NumWords(string text)
+        {
+            var ret = 1;
+
+            foreach (var c in text)
+            {
+                if (c == ' ')
+                {
+                    ret++;
+                }
+            }
+
+            return ret;
+        }
+
+        #region TTS
+
+        private IEnumerator OutputText(QueuedText text)
+        {
+            m_curText = text;
+
+            text.Play();
+
+            while (text.IsPlaying())
+            {
+                yield return null;
+            }
+
+            m_prevTexts.Add(m_curText);
+            m_curText = null;
+        }
+
+        internal void OutputTextAndWait(string text, Action onStart=null, Action onEnd=null)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            if (text.Length == 0)
+            {
+                if (onStart != null) onStart();
+                if (onEnd != null) onEnd();
+                return;
+            }
+
+            m_queuedTexts.Enqueue(new QueuedText(text, onStart, onEnd));
+        }
+
+        internal void OutputNarrationAsText(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, false, true, true));
+        }
+
+        internal void OutputText(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, false, false));
+        }
+
+        internal void OutputTextImmediately(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            InterruptTexts();
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, true, false));
+        }
+
+        internal void IncreaseSpeechRate()
+        {
+            IncWPM(1);
+        }
+
+        internal void DecreaseSpeechRate()
+        {
+            IncWPM(-1);
+        }
+
+        private void IncWPM(int inc)
+        {
+            if (!CanAdjustGameSpeed())
+			{
+                AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_SPEED_CANNOT_ADJUST_VS_PLAYERS));
+                return;
+			}
+
+            LoadGameSpeedOptionIfNecessary();
+
+            var curIndex = m_curGameSpeed - 1;
+            var targetIndex = curIndex + inc;
+
+            if (targetIndex < 0 || targetIndex >= m_WPMSpeeds.Count)
+            {
+                return;
+            }
+            else
+            {
+                m_curGameSpeed = targetIndex + 1;
+                UpdateCPS();
+                SaveGameSpeed();
+                var gameSpeedAdjustText = AccessibilityUtils.CurateText(LocalizationUtils.Format(LocalizationKey.GLOBAL_GAME_SPEED, m_curGameSpeed));
+                ScreenReader.Output(gameSpeedAdjustText);
+
+                foreach(var text in m_queuedTexts)
+                {
+                    text.UpdateSpeed();
+                }
+            }
+        }
+
+		private bool CanAdjustGameSpeed()
+		{
+            return !AccessibilityUtils.IsInPvPGame() && !AccessibleGameplayUtils.IsPlayingBattlegrounds();
+		}
+
+		private void SaveGameSpeed()
+        {
+            Options.Get().SetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+        }
+
+        private void UpdateCPS()
+        {
+            var wpm = m_WPMSpeeds[m_curGameSpeed - 1];
+            m_curCPS = CalcCPS(wpm);
+        }
+
+        private static int CalcCPS(int wpm)
+        {
+            return wpm * 6 / 60;
+        }
+
+        internal int GetCPS()
+        {
+            if (!CanAdjustGameSpeed())
+			{
+                return MAX_GAME_SPEED_CPS;
+			}
+
+            LoadGameSpeedOptionIfNecessary();
+
+            return m_curCPS;
+        }
+
+        private void LoadGameSpeedOptionIfNecessary()
+        {
+            if (!m_gameSpeedOptionLoaded)
+            {
+                m_gameSpeedOptionLoaded = true;
+
+                int gameSpeed = Options.Get().GetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+
+                int wpmIndex = gameSpeed - 1;
+                if (wpmIndex < 0 || wpmIndex >= m_WPMSpeeds.Count)
+                {
+                    SaveGameSpeed();
+                    return;
+                }
+
+                m_curGameSpeed = gameSpeed;
+                UpdateCPS();
+            }
+        }
+
+        #endregion
+
+        private bool IsSpeechAudioAvailable()
+        {
+            var locale = Localization.GetLocale();
+
+            if (locale == Locale.enUS || locale == Locale.enGB)
+            {
+                return true;
+            }
+
+            if (LocalizationUtils.HasKey(LocalizationKey.TUTORIAL_NARRATOR_INTRO))
+            {
+                return false; // Heuristic: if the narrator intro has been localized, we're distributing a version of HSA with the tutorial translated
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
new file mode 100644
index 0000000..d7d60b6
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
@@ -0,0 +1,265 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleSpeechOptimizer
+    {
+        // TODO: Think about this whole thing re: localization
+
+        public static void OptimizeText(QueuedText text, List<QueuedText> prevTexts)
+        {
+            try
+            {
+                if (text == null)
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndDiedText(text, prevTexts))
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndTookDamageText(text, prevTexts))
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Attack and Died
+
+        private static bool OptimizeAttackAndDiedText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneDied(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            attacker = CleanUpOrderIfNeeded(attacker);
+            defender = CleanUpOrderIfNeeded(defender);
+
+            if (EqualsIgnoreCase(text, $"{attacker} and {defender} died.") ||
+                EqualsIgnoreCase(text, $"{defender} and {attacker} died.") ||
+                EqualsIgnoreCase(text, "All minions died."))
+            {
+                var entityTypes = "minions";
+
+                if (IsHero(attacker) || IsHero(defender))
+                {
+                    entityTypes = "characters";
+                }
+
+                queuedText.UpdateText($"Both {entityTypes} died.");
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{attacker} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(attacker);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{defender} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(defender);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+
+            return false;
+        }
+        private static bool OptimizeAttackAndTookDamageText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneTookDamage(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            var aAndBTookNDamageMatch = Regex.Match(text, $@"{attacker} and {defender} took (.*) damage.");
+            string dmgTaken;
+
+            if (aAndBTookNDamageMatch.Success)
+            {
+                dmgTaken = aAndBTookNDamageMatch.Groups[1].Value;
+            }
+            else
+            {
+                var bAndATookNDamageMatch = Regex.Match(text, $@"{defender} and {attacker} took (.*) damage.");
+
+                if (!bAndATookNDamageMatch.Success)
+                {
+                    return false;
+                }
+                else
+                {
+                    dmgTaken = bAndATookNDamageMatch.Groups[1].Value;
+                }
+            }
+
+            var entityTypes = "minions";
+
+            if (IsHero(attacker) || IsHero(defender))
+            {
+                entityTypes = "characters";
+            }
+            queuedText.UpdateText($"Both {entityTypes} took {dmgTaken} damage.");
+
+            return true;
+        }
+
+        private static string CleanUpOrderIfNeeded(string fullEntityName)
+        {
+            var parts = fullEntityName.Split(' ');
+
+            if (parts.Length == 0)
+            {
+                return fullEntityName;
+            }
+
+            if (EqualsIgnoreCase(parts[0], "your"))
+            {
+                if (parts.Length >= 2 && EqualsIgnoreCase(parts[1], "opponent's"))
+                {
+
+                    if (parts.Length >= 3 && LocalizationUtils.IsOrdinalNumber(parts[2]))
+                    {
+                        return CreateNameWithoutOrder(parts, 2);
+                    }
+                }
+                else if (parts.Length >= 2 && LocalizationUtils.IsOrdinalNumber(parts[1]))
+                {
+                    return CreateNameWithoutOrder(parts, 1);
+                }
+            }
+
+            return fullEntityName;
+        }
+
+        private static string CreateNameWithoutOrder(string[] parts, int orderIndex)
+        {
+            var sb = new StringBuilder();
+
+            for (int i = 0; i < parts.Length; i++)
+            {
+                if (i != orderIndex)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(' ');
+                    }
+
+                    sb.Append(parts[i]);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string SimplifyEntityDiedText(string entity)
+        {
+            if (IsHero(entity))
+            {
+                return $"{entity} died.";
+            }
+            else if (IsOpponentEntity(entity))
+            {
+                return "Your opponent's minion died.";
+            }
+            else if (IsPlayerEntity(entity))
+            {
+                return "Your minion died.";
+            }
+
+            Log.Accessibility.PrintWarning($"Failed to simplify entity died text: {entity}");
+            return entity;
+        }
+
+        private static bool SomeoneDied(string text)
+        {
+            return Regex.Match(text, @"(.*) died.").Success;
+        }
+
+        private static bool SomeoneTookDamage(string text)
+        {
+            return Regex.Match(text, @"(.*) took .* damage.").Success;
+        }
+
+        #endregion
+
+        private static bool IsOpponentEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your opponent's ");
+        }
+
+        private static bool IsPlayerEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your ");
+        }
+
+        private static bool StartsWithIgnoreCase(string s1, string s2)
+        {
+            return s1.ToLowerInvariant().StartsWith(s2.ToLowerInvariant());
+        }
+
+        private static bool IsHero(string entity)
+        {
+            return EqualsIgnoreCase(entity, "Your hero") || EqualsIgnoreCase(entity, "Your opponent's hero");
+        }
+
+        private static bool EqualsIgnoreCase(string a, string b)
+        {
+            return a.Equals(b, StringComparison.InvariantCultureIgnoreCase);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
new file mode 100644
index 0000000..8e5bad6
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
@@ -0,0 +1,341 @@
+﻿using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class AccessibleSpeechUtils
+    {
+        internal static string GetFullName(Entity entity)
+        {
+            if (entity.IsControlledByFriendlySidePlayer())
+            {
+                return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME, GetName(entity));
+            }
+            else
+            {
+                return GetFullNameForOpponent(entity);
+            }
+        }
+
+		private static string GetFullNameForOpponent(Entity entity)
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME : LocalizationKey.GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME;
+			return LocalizationUtils.Format(key, GetName(entity));
+		}
+
+		internal static string GetFullNameInZone(Entity entity)
+        {
+            if (entity.GetZone() == TAG_ZONE.GRAVEYARD ||
+                entity.GetZone() == TAG_ZONE.INVALID ||
+                entity.GetZone() == TAG_ZONE.REMOVEDFROMGAME ||
+                entity.GetZone() == TAG_ZONE.SETASIDE)
+            {
+                return GetFullName(entity);
+            }
+
+            var entitiesInZone = new List<Entity>();
+
+            foreach (var card in entity.GetCard().GetZone()?.GetCards())
+            {
+                entitiesInZone.Add(card.GetEntity());
+            }
+
+            return GetFullNameInList(entity, entitiesInZone);
+        }
+
+        internal static string GetFullNameInList(Entity entity, List<Entity> entitiesInZone)
+        {
+            // TODO: entities are not necessarily in the same zone so there may be cases where this is confusing.. e.g. your X (in your hand) and your X (in your battlefield) did Y
+            // Haven't really run into anything yet so keeping it like this for now
+
+            int entityNum = 0;
+            int entityCount = 0;
+
+            foreach(var ent in entitiesInZone)
+            {
+                if (GetFullName(ent).Equals(GetFullName(entity)))
+                {
+                    entityCount++;
+                }
+
+                if (ent.GetEntityId() == entity.GetEntityId())
+                {
+                    entityNum = entityCount;
+                }
+            }
+
+            if (entityCount <= 1)
+            {
+                return GetFullName(entity);
+            }
+            else
+            {
+                var order = LocalizationUtils.GetOrdinalNumber(entityNum);
+                var entityName = GetName(entity);
+
+                if (entity.IsControlledByFriendlySidePlayer())
+                {
+                    return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST, order, entityName);
+                }
+                else
+                {
+                    return GetFullNameInListForOpponent(order, entityName);
+                }
+            }
+        }
+
+		private static string GetFullNameInListForOpponent(string order, string entityName)
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME_IN_LIST : LocalizationKey.GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST;
+			return LocalizationUtils.Format(key, order, entityName);
+		}
+
+		internal static string GetName(Entity entity)
+        {
+            if (entity.IsHero())
+            {
+                return GameStrings.GetCardTypeName(entity.GetCardType());
+            }
+            else if (entity.IsHeroPower())
+            {
+                return GameStrings.GetCardTypeName(entity.GetCardType());
+            }
+            else if (entity.GetCardType() == TAG_CARDTYPE.INVALID)
+            {
+                return LocalizedText.GLOBAL_CARD;
+            }
+            else
+			{
+                return GetEntityName(entity);
+			}
+        }
+
+		internal static string GetEntityName(Entity entity)
+		{
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+            {
+                return AccessibleCardUtils.GetInGameEntityNameWithPremium(entity);
+            }
+            else
+            {
+                return entity.GetName();
+            }
+		}
+
+		internal static string GetNames(List<Card> cards)
+        {
+            // Mostly used for mulligan (cards only i.e. no heroes)
+            var nameCounts = new Dictionary<string, int>();
+            var orderedCardNames = new List<string>(); // Could just create an insertion-order dictionary but whatever
+
+            foreach (var card in cards)
+            {
+                var cardName = GetEntityName(card.GetEntity());
+
+                if (nameCounts.ContainsKey(cardName))
+                {
+                    nameCounts[cardName]++;
+                }
+                else
+                {
+                    nameCounts.Add(cardName, 1);
+                    orderedCardNames.Add(cardName);
+                }
+            }
+
+            return HumanizeNames(orderedCardNames, nameCounts);
+        }
+
+        internal static string FormatZoneMovementText(List<string> cards, LocalizationKey singularKey, LocalizationKey pluralKey)
+		{
+            if (cards.Count == 0)
+			{
+                return null;
+			}
+
+            if (cards.Count == 1)
+            {
+                return LocalizationUtils.Format(singularKey, cards[0]);
+            }
+            else
+            {
+                var counts = new Dictionary<string, int>();
+                foreach (var card in cards)
+                {
+                    if (!counts.ContainsKey(card))
+                    {
+                        counts.Add(card, 1);
+                    }
+                    else
+                    {
+                        counts[card]++;
+                    }
+                }
+
+                var cardNames = HumanizeNames(cards, counts);
+
+                return LocalizationUtils.Format(pluralKey, cardNames);
+            }
+		}
+
+        internal static string HumanizeNames(List<string> orderedNames, Dictionary<string, int> nameCounts)
+        {
+            var separator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_SEPARATOR);
+            var finalSeparator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_FINAL_SEPARATOR);
+            var cardString = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+            var cardStringPlural = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD_PLURAL);
+
+            var sb = new StringBuilder();
+            int idx = 0;
+
+            orderedNames = GetDistinct(orderedNames);
+
+            foreach(var name in orderedNames)
+            {
+                if (idx > 0)
+                {
+                    if (idx < orderedNames.Count - 1)
+                    {
+                        sb.Append(separator);
+                    }
+                    else
+                    {
+                        sb.Append(finalSeparator);
+                    }
+                }
+
+                var curNameCount = nameCounts[name];
+
+                if (curNameCount > 1 && name.Equals(cardString))
+                {
+                    sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, curNameCount, cardStringPlural));
+                }
+                else
+                {
+                    sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, curNameCount, name));
+                }
+
+                idx++;
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetDistinct(List<string> elems)
+        {
+            var ret = new List<string>();
+            var handled = new HashSet<string>();
+
+            foreach(var elem in elems)
+            {
+                if (!handled.Contains(elem))
+                {
+                    ret.Add(elem);
+                    handled.Add(elem);
+                } 
+            }
+
+            return ret;
+        }
+
+        public static string HumanizeList(List<string> list)
+        {
+            var separator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_SEPARATOR);
+            var finalSeparator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_FINAL_SEPARATOR);
+
+            if (list.Count == 0)
+            {
+                return "";
+            }
+
+            if (list.Count == 1)
+            {
+                return list[0];
+            }
+            else
+            {
+                var sb = new StringBuilder();
+
+                for (int i = 0; i < list.Count - 1; i++)
+                {
+                    if (i != 0)
+                    {
+                        sb.Append(separator);
+                    }
+
+                    sb.Append(list[i]);
+                }
+
+                sb.Append(finalSeparator);
+                sb.Append(list[list.Count - 1]);
+
+                return sb.ToString();
+            }
+        }
+
+        internal static string CombineLines(List<string> lines)
+        {
+            var sentenceEndingChars = LocalizationUtils.Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+            var period = LocalizationUtils.Get(LocalizationKey.FORMATTING_PERIOD);
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (line.Length == 0)
+                {
+                    continue;
+                }
+
+                if (sb.Length > 0)
+                {
+                    if (!sentenceEndingChars.Contains(sb[sb.Length - 1]))
+                    {
+                        sb.Append(period);
+                    }
+
+                    sb.Append(" ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        internal static string CombineSentences(string a, string b)
+        {
+            var sentenceEndingChars = LocalizationUtils.Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+            var period = LocalizationUtils.Get(LocalizationKey.FORMATTING_PERIOD);
+
+            if (a.Length == 0)
+            {
+                return b;
+            }
+            else if (b.Length == 0)
+            {
+                return a;
+            }
+
+            var lastAChar = a[a.Length - 1];
+            if (sentenceEndingChars.Contains(lastAChar))
+            {
+                return $"{a} {b}";
+            }
+            else
+            {
+                return $"{a}{period} {b}";
+            }
+        }
+
+        internal static string CombineWordsWithComma(string a, string b)
+        {
+            return $"{a} ; {b}";
+        }
+
+        internal static string CombineWordsWithColon(string a, string b)
+        {
+            return $"{a}: {b}";
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleTraditionalCard.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTraditionalCard.cs
new file mode 100644
index 0000000..0039e39
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTraditionalCard.cs
@@ -0,0 +1,412 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleTraditionalCard : AccessibleCard
+    {
+        internal AccessibleTraditionalCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_card.GetEntity().IsHero())
+            {
+                return GetLinesForHero();
+            }
+            else if (m_card.GetEntity().IsHeroPower())
+            {
+                return GetLinesForHeroPower();
+            }
+            else if (m_card.GetEntity().IsWeapon())
+            {
+                return GetLinesForWeapon();
+            }
+            else if (m_card.GetEntity().IsQuest())
+            {
+                return GetLinesForQuest();
+            }
+            else if (m_card.GetEntity().IsSideQuest())
+            {
+                return GetLinesForSideQuest();
+            }
+            else if (m_card.GetEntity().IsQuestline())
+            {
+                return GetLinesForQuestline();
+            }
+            else if (m_card.GetEntity().IsSecret() && !m_card.GetEntity().IsControlledByFriendlySidePlayer())
+            {
+                return GetLinesForOpponentSecret();
+            }
+            else
+            {
+                return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            var zone = m_card.GetEntity().GetZone();
+
+            if (zone == TAG_ZONE.PLAY)
+            {
+                if (IsTurnBasedHero())
+                {
+                    // e.g. Some BoH missions which use x turns to hold out instead of attack/health
+                    return GetLinesForTurnBasedHeroInPlayZone();
+                }
+                else
+                {
+                    return GetLinesForHeroInPlayZone();
+                }
+            }
+            else
+            {
+                return GetLinesForHeroCard();
+            }
+        }
+
+        private bool IsTurnBasedHero()
+        {
+            if (!GameState.Get().GetGameEntity().IsTurnCounterBasedMission())
+            {
+                return false;
+            }
+
+            return m_card.GetEntity().IsControlledByOpposingSidePlayer();
+        }
+
+        private List<string> GetLinesForTurnBasedHeroInPlayZone()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            var missionEntity = GameState.Get().GetGameEntity() as MissionEntity;
+            lines.Add(missionEntity.GetTurnCounterText());
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroInPlayZone()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            try
+			{
+				if (AccessibilityUtils.IsInPvPGame())
+				{
+					lines.Add(m_card.GetController().GetName());
+					lines.Add(GameStrings.GetClassName(m_card.GetEntity().GetClass()));
+                    AddAvLinesForPlayer(m_card.GetController(), lines);
+				}
+			}
+            catch (Exception e)
+			{
+                AccessibilityUtils.LogFatalError(e);
+			}
+
+
+			return lines;
+        }
+
+		private void AddAvLinesForPlayer(Player player, List<string> lines)
+		{
+            var factionId = player.GetTag(GAME_TAG.AVFACTION);
+
+            if (factionId == 1)
+			{
+                lines.Add(LocalizationUtils.Get(LocalizationKey.GLOBAL_HORDE));
+			}
+            else if (factionId == 2)
+			{
+                lines.Add(LocalizationUtils.Get(LocalizationKey.GLOBAL_ALLIANCE));
+			}
+
+			AccessibleCardUtils.AddLineIfExists(NameBanner.GetRankNameForSide(player.GetSide()), lines);
+		}
+
+		private List<string> GetLinesForHeroCard()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+            lines.Add(AccessibleCardUtils.GetCost(m_card));
+            lines.Add(GetCardType());
+
+            var armor = m_card.GetEntity().GetArmor();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            try
+            {
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(m_card.GetEntity().GetCardId()));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForWeapon()
+        {
+            var isWielded = m_card.GetZone()?.GetType() == typeof(ZoneWeapon);
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (!isWielded)
+            {
+                lines.Add(AccessibleCardUtils.GetCost(m_card));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetResources(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            if (!isWielded)
+            {
+                lines.Add(GetCardType());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            var zone = m_card.GetEntity().GetZone();
+            var isInPlayZone = zone == TAG_ZONE.PLAY;
+            var isInSecretZone = zone == TAG_ZONE.SECRET;
+            var shouldReadCost = !isInPlayZone && !isInSecretZone;
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (shouldReadCost)
+            {
+                lines.Add(AccessibleCardUtils.GetCost(m_card));
+            }
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                if (isInPlayZone)
+                {
+                    var effects = GetEffects();
+                    if (effects.Length > 0)
+                    {
+                        resources = $"{resources} {effects}";
+                    }
+                }
+
+                lines.Add(resources);
+            }
+            else if (isInPlayZone)
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetRace(), lines); // Handles spell school as well
+
+            if (!isInPlayZone)
+            {
+                lines.Add(GetCardType());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForQuest()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+            lines.AddRange(GetQuestReward());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForSideQuest()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForQuestline()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestlinePart(), lines);
+            lines.AddRange(GetQuestlineProgress());
+            lines.AddRange(GetQuestReward());
+            AccessibleCardUtils.AddLineIfExists(GetNextQuestlinePart(), lines);
+
+            return lines;
+        }
+
+        private string GetQuestProgress()
+        {
+            return AccessibleCardUtils.GetQuestProgressLine(m_card.GetEntity());
+        }
+
+        private string GetQuestlinePart()
+        {
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return "";
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return "";
+            }
+
+            if (questlineProgressUI.m_QuestDetailTextLeft.gameObject.activeSelf)
+            {
+                return questlineProgressUI.m_QuestDetailTextLeft.Text;
+            }
+
+            return "";
+        }
+
+        private string GetNextQuestlinePart()
+        {
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return "";
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return "";
+            }
+
+            if (questlineProgressUI.m_QuestDetailTextRight.gameObject.activeSelf)
+            {
+                return questlineProgressUI.m_QuestDetailTextRight.Text;
+            }
+
+            return "";
+        }
+
+        private List<string> GetQuestlineProgress()
+        {
+            var ret = new List<string>();
+
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return ret;
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return ret;
+            }
+
+            var req1Text = questlineProgressUI.m_QuestRequirementText1.Text;
+            var req2Text = questlineProgressUI.m_QuestRequirementText2.Text;
+            var req3Text = questlineProgressUI.m_QuestRequirementText3.Text;
+
+            if (questlineProgressUI.m_QuestRequirementText1.gameObject.activeSelf && req1Text != null && req1Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req1Text, questlineProgressUI.m_RequirementCheckmark1));
+            }
+
+            if (questlineProgressUI.m_QuestRequirementText2.gameObject.activeSelf && req2Text != null && req2Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req2Text, questlineProgressUI.m_RequirementCheckmark2));
+            }
+
+            if (questlineProgressUI.m_QuestRequirementText3.gameObject.activeSelf && req3Text != null && req3Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req3Text, questlineProgressUI.m_RequirementCheckmark3));
+            }
+
+            return ret;
+        }
+
+        private string FormatQuestlineRequirementText(string reqText, GameObject reqCheckmark)
+        {
+            if (reqCheckmark.activeInHierarchy)
+            {
+                return $"{reqText} {LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED)}";
+            }
+            else
+            {
+                return $"{reqText} {LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED)}";
+            }
+        }
+
+        private List<string> GetQuestReward()
+        {
+            var rewardCardId = AccessibleCardUtils.GetRewardCardIDFromQuestCardID(m_card.GetEntity());
+
+            if (rewardCardId == null)
+            {
+                return new List<string>();
+            }
+
+            return AccessibleCardUtils.GetQuestRewardCardLines(rewardCardId);
+        }
+
+        private string GetRarity()
+        {
+            return AccessibleCardUtils.GetRarity(m_card.GetEntity().GetEntityDef());
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
new file mode 100644
index 0000000..17662cd
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
@@ -0,0 +1,151 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleTutorialProgressScreen : AccessibleScreen
+    {
+        private static AccessibleTutorialProgressScreen s_instance = new AccessibleTutorialProgressScreen();
+
+        internal static AccessibleTutorialProgressScreen Get()
+        {
+            return s_instance;
+        }
+
+        private enum AccessibleTutorialProgressScreenState {
+            READY_TO_START,
+            WAITING_FOR_ANIMATIONS
+        }
+
+        private AccessibleTutorialProgressScreenState m_curState;
+
+        private HeroCoin m_nextOpponentCoin;
+
+        public void OnStartTutorial()
+        {
+            AccessibilityMgr.SetScreen(this);
+            AccessibilityMgr.Output(this, LocalizedText.TUTORIAL_LOADING_TUTORIAL);
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed() && m_curState == AccessibleTutorialProgressScreenState.READY_TO_START)
+            {
+                m_nextOpponentCoin.TriggerRelease();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case AccessibleTutorialProgressScreenState.READY_TO_START:
+                    return AccessibleSpeech.PRESS_ENTER_TO_START;
+                default:
+                    return "";
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+        }
+
+        public void OnDefeatedOpponent(HeroCoin heroCoin)
+        {
+            try
+            {
+                AccessibilityMgr.SetScreen(this);
+
+                var missionId = heroCoin.GetMissionId();
+                ScenarioDbId scenario = (ScenarioDbId)missionId;
+
+                HSASpeech speech = null;
+
+                switch (scenario)
+                {
+                    case ScenarioDbId.TUTORIAL_HOGGER:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_HOGGER;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MILLHOUSE:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_MILLHOUSE;
+                        break;
+                    case ScenarioDbId.TUTORIAL_CHO:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_CHO;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MUKLA:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_MUKLA;
+                        break;
+                    case ScenarioDbId.TUTORIAL_NESINGWARY:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_NESINGWARY;
+                        break;
+                    case ScenarioDbId.TUTORIAL_ILLIDAN:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_ILLIDAN;
+                        break;
+                }
+
+                if (speech != null)
+                {
+                    AccessibilityMgr.NarrateAndWait(speech);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnNextOpponent(HeroCoin heroCoin)
+        {
+            try
+            {
+                AccessibilityMgr.SetScreen(this);
+                m_nextOpponentCoin = heroCoin;
+
+                var missionId = heroCoin.GetMissionId();
+                ScenarioDbId scenario = (ScenarioDbId)missionId;
+
+                HSASpeech speech = null;
+
+                switch (scenario)
+                {
+                    case ScenarioDbId.TUTORIAL_HOGGER:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_HOGGER;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MILLHOUSE:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_MILLHOUSE;
+                        break;
+                    case ScenarioDbId.TUTORIAL_CHO:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_CHO;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MUKLA:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_MUKLA;
+                        break;
+                    case ScenarioDbId.TUTORIAL_NESINGWARY:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_NESINGWARY;
+                        break;
+                    case ScenarioDbId.TUTORIAL_ILLIDAN:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_ILLIDAN;
+                        break;
+                }
+
+                if (speech != null)
+                {
+                    AccessibilityMgr.NarrateAndWait(speech);
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE, () => m_curState = AccessibleTutorialProgressScreenState.READY_TO_START);
+                }
+                else
+                {
+                    Log.Accessibility.PrintWarning($"Failed to describe next tutorial. Unknown tutorial missionID: {scenario}");
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    m_curState = AccessibleTutorialProgressScreenState.READY_TO_START;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs
new file mode 100644
index 0000000..b2f7644
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs
@@ -0,0 +1,9 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleUI : AccessibleComponent
+    {
+        void HandleAccessibleInput();
+
+        string GetAccessibleHelp();
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
new file mode 100644
index 0000000..0306ff0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
@@ -0,0 +1,137 @@
+﻿using UnityEngine;
+
+public class AccessibleUnityInput : IInput
+{
+	private Vector3 m_mousePosition;
+	private bool[] m_buttonIsDown = new bool[3];
+	private bool[] m_buttonWasDown = new bool[3];
+
+	private static AccessibleUnityInput s_instance;
+
+	private static bool m_enabled = true;
+
+	private AccessibleUnityInput() { }
+
+	public static AccessibleUnityInput Get()
+    {
+		if (s_instance == null)
+        {
+			s_instance = new AccessibleUnityInput();
+        }
+
+		return s_instance;
+    }
+
+	public bool GetMousePosition(out Vector3 position)
+	{
+		position = m_mousePosition;
+		return m_enabled;
+	}
+
+	public Vector3 GetMousePosition()
+	{
+		return m_mousePosition;
+	}
+
+	public bool GetAnyKey(out bool value)
+	{
+		value = Input.anyKey;
+		return m_enabled;
+	}
+
+	public bool GetAnyKeyDown(out bool value)
+	{
+		value = Input.anyKeyDown;
+		return m_enabled;
+	}
+
+	public bool GetKey(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKey(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyDown(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyDown(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyUp(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyUp(keycode);
+		return m_enabled;
+	}
+
+	public bool GetMouseButton(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButton on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonDown(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonDown on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = !m_buttonWasDown[button] && m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonUp(int button, out bool value)
+	{
+        if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonUp on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonWasDown[button] && !m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	internal void SetMousePosition(Vector3 pos)
+    {
+		m_mousePosition = pos;
+    }
+
+	// Must only be called once per frame per button!
+	internal void SetMouseButtonDown(int button, bool isDown)
+    {
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to SetMouseButtonDown on invalid button {button}");
+			return;
+        }
+
+		m_buttonWasDown[button] = m_buttonIsDown[button];
+		m_buttonIsDown[button] = isDown;
+    }
+
+	internal void ToggleEnabled()
+    {
+		m_enabled = !m_enabled;
+    }
+
+	private bool IsValidButton(int button)
+    {
+		return button >= 0 && button <= 2;
+    }
+
+	internal bool Enabled
+    {
+		get { return m_enabled;  }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityUtils.cs
new file mode 100644
index 0000000..2c0b3c8
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityUtils.cs
@@ -0,0 +1,109 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleUnityUtils
+    {
+        public static GameObject GetChildObject(GameObject go, string childObjectName)
+        {
+            if (go == null)
+            {
+                AccessibilityUtils.LogFatalError($"AccessibleUnityUtils.GetChildObject(null, {childObjectName})");
+                return null;
+            }
+            var childObjectTransform = go.transform.Find(childObjectName);
+
+            if (childObjectTransform == null)
+            {
+                AccessibilityUtils.LogFatalError($"AccessibleUnityUtils.GetChildObject({go.name}, {childObjectName}) returned null transform");
+                return null;
+            }
+
+            return childObjectTransform.gameObject;
+        }
+
+        #region Debugging
+
+        public static void DebugGameObject(GameObject go)
+        {
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+            AccessibilityUtils.LogDebug($"Debugging GameObject");
+            AccessibilityUtils.LogDebug($"name: {GetObjectNameWithComponents(go)}");
+
+            AccessibilityUtils.LogDebug($"childCount: {go.transform.childCount}");
+            DebugChildren(go, 1);
+        }
+
+        private static string GetObjectNameWithComponents(GameObject go)
+        {
+            var sb = new StringBuilder();
+
+            sb.Append(go.name);
+
+            var components = go.GetComponents(typeof(Component));
+
+            if (components.Length > 0)
+            {
+                sb.Append(" (");
+                for (int i = 0; i < components.Length; i++)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(", ");
+                    }
+                    sb.Append(components[i].GetType());
+                }
+                sb.Append(")");
+            }
+
+            return sb.ToString();
+        }
+
+        private static void DebugChildren(GameObject go, int depth)
+        {
+            for (int i = 0; i < go.transform.childCount; i++)
+            {
+                var child = go.transform.GetChild(i).gameObject;
+                var indent = new string('-', depth*3);
+                AccessibilityUtils.LogDebug($"{indent} {GetObjectNameWithComponents(child)}");
+
+                DebugChildren(child, depth + 1);
+            }
+        }
+
+        internal static T GetComponent<T>(GameObject go)
+        {
+            var component = go.GetComponent<T>();
+
+            if (component == null)
+            {
+                AccessibilityUtils.LogFatalError($"AccessibleUnityUtils.GetComponent<T>({go.name}) was null");
+                return default;
+            }
+
+            return component;
+        }
+
+        internal static List<GameObject> GetChildren(GameObject go)
+        {
+            var ret = new List<GameObject>();
+
+            for (int i = 0; i < go.transform.childCount; i++)
+            {
+                ret.Add(go.transform.GetChild(i).gameObject);
+            }
+
+            return ret;
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleWidgetUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleWidgetUtils.cs
new file mode 100644
index 0000000..2189930
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleWidgetUtils.cs
@@ -0,0 +1,164 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleWidgetUtils
+    {
+        public static PegUIElement GetPegUIElement(GameObject go, string childObjectName)
+        {
+            if (go == null)
+			{
+                return null;
+			}
+
+            var childObject = AccessibleUnityUtils.GetChildObject(go, childObjectName);
+            if (childObject == null)
+            {
+                return null;
+            }
+
+            var ret = childObject.GetComponent<PegUIElement>();
+            if (ret == null)
+            {
+                AccessibilityUtils.LogFatalError($"GetPegUIElement({go.name}, {childObjectName}): object exists but doesn't have an attachedPegUIElement");
+            }
+
+            return ret;
+        }
+
+        public static PegUIElement GetPegUIElement(Widget widget, string childObjectName)
+        {
+            return GetPegUIElement(GetGameObject(widget), childObjectName);
+        }
+
+		public static GameObject GetChildObject(Widget widget, string childObjectName)
+		{
+            return AccessibleUnityUtils.GetChildObject(GetGameObject(widget), childObjectName);
+		}
+
+		public static WidgetInstance GetWidgetInstance(GameObject go, string childObjectName)
+        {
+            return AccessibleUnityUtils.GetChildObject(go, childObjectName).GetComponent<WidgetInstance>();
+        }
+
+        public static void ClickButton(PegUIElement button)
+        {
+            if (button == null)
+            {
+                AccessibilityUtils.LogFatalError("AccessibleWidgetUtils.ClickButton(null)");
+                return;
+            }
+
+            button.TriggerPress();
+            button.TriggerRelease();
+        }
+
+        public static void TriggerButtonClicked(Widget widget)
+        {
+            widget.TriggerEvent("BUTTON_CLICKED");
+        }
+
+        internal static UberText GetUberText(GameObject go, string childObjectName)
+        {
+            return AccessibleUnityUtils.GetChildObject(go, childObjectName).GetComponent<UberText>();
+        }
+
+        internal static UberText GetUberText(PegUIElement element, string childObjectName)
+        {
+            return GetUberText(element.gameObject, childObjectName);
+        }
+
+        internal static void DebugWidgetEventListener(string eventName)
+        {
+            AccessibilityUtils.LogDebug($"DebugWidgetEventListener({eventName})");
+            AccessibilityUtils.LogDebug(Environment.StackTrace);
+        }
+
+        public static void DebugWidget(string friendlyName, Widget widget)
+        {
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+
+            var widgetType = widget.GetType();
+
+            AccessibilityUtils.LogDebug($"Debugging widget: {friendlyName}");
+            AccessibilityUtils.LogDebug($"Widget type: {widgetType}");
+
+            if (widgetType == typeof(WidgetInstance))
+            {
+                DebugWidgetInstance(widget as WidgetInstance);
+            }
+            else if (widgetType == typeof(WidgetTemplate))
+            {
+                DebugWidgetTemplate(widget as WidgetTemplate);
+            }
+        }
+
+        private static void DebugWidgetInstance(WidgetInstance widget)
+        {
+            AccessibilityUtils.LogDebug($"m_prefabInstance: {widget.m_prefabInstance}");
+            AccessibilityUtils.LogDebug($"Widget: {widget.Widget}");
+            AccessibilityUtils.LogDebug($"m_prefabInstance.Instance: {widget.m_prefabInstance.Instance}");
+            AccessibilityUtils.LogDebug($"m_prefabInstance.Owner: {widget.m_prefabInstance.Owner}");
+            AccessibilityUtils.LogDebug($"m_prefabInstance.Prefab: {widget.m_prefabInstance.Prefab}");
+
+            DebugWidgetTemplate(widget.Widget);
+
+            AccessibilityUtils.DebugGameObject(GetGameObject(widget));
+        }
+
+        private static void DebugWidgetTemplate(WidgetTemplate widgetTemplate)
+        {
+            AccessibilityUtils.LogDebug("Debugging WidgetTemplate");
+            AccessibilityUtils.LogDebug($"name: {widgetTemplate.name}");
+
+            DebugDataContext(widgetTemplate.DataContext);
+
+            AccessibilityUtils.DebugGameObject(GetGameObject(widgetTemplate));
+        }
+
+        private static GameObject GetGameObject(Widget widget)
+		{
+            var widgetType = widget.GetType();
+
+            if (widgetType == typeof(WidgetInstance))
+            {
+                return (widget as WidgetInstance).m_prefabInstance.Instance;
+            }
+            else if (widgetType == typeof(WidgetTemplate))
+            {
+				return widget.gameObject;
+            }
+
+            AccessibilityUtils.LogFatalError($"AccessibleWidgetUtils.GetGameObject - Unknown widget type: {widgetType}");
+            return widget.gameObject;
+		}
+
+        private static void DebugDataContext(DataContext dataContext)
+        {
+            AccessibilityUtils.LogDebug($"Debugging DataContext");
+
+            var dataModels = dataContext.GetDataModels();
+
+            foreach(var dataModel in dataModels)
+            {
+                DebugDataModel(dataModel);
+            }
+        }
+
+        private static void DebugDataModel(IDataModel dataModel)
+        {
+            AccessibilityUtils.LogDebug("Debugging Data Model");
+            AccessibilityUtils.LogDebug($"DisplayName: {dataModel.DataModelDisplayName}");
+            AccessibilityUtils.LogDebug($"DataModelId: {dataModel.DataModelId}");
+            AccessibilityUtils.LogDebug($"Properties.Length: {dataModel.Properties.Length}");
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsCard.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsCard.cs
new file mode 100644
index 0000000..087515d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsCard.cs
@@ -0,0 +1,308 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsCard : AccessibleCard
+    {
+		internal AccessibleBattlegroundsCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+		internal override List<string> GetLines()
+		{
+            if (m_card.GetEntity().IsHero())
+            {
+                return GetLinesForHero();
+            }
+            else if (m_card.GetEntity().IsHeroPower())
+            {
+                return GetLinesForHeroPower();
+            }
+            else if (m_card.GetEntity().IsSecret())
+            {
+                if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+				{
+                    return GetLinesForSpell();
+				}
+                else
+				{
+					return GetLinesForOpponentSecret();
+				}
+			}
+            else if (m_card.GetEntity().IsSpell())
+			{
+                return GetLinesForSpell();
+			}
+            else
+            {
+                return GetLinesForNormalCard();
+            }
+		}
+
+		private List<string> GetLinesForBuddyMeter()
+		{
+            var ret = new List<string>();
+
+            var heroCard = GameState.Get().GetFriendlySidePlayer().GetHero();
+
+			var progress = heroCard.GetTag(GAME_TAG.BACON_HERO_BUDDY_PROGRESS);
+            ret.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_BUDDY_METER, progress));
+
+            ret.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(heroCard.GetCardId()));
+
+            return ret;
+		}
+
+		private List<string> GetLinesForSpell()
+		{
+            // Recruitment Map -> Spell -> 3 gold -> description
+            // Note: Handles player secrets as well
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (!AccessibleCardUtils.IsCostHidden(m_card))
+			{
+                lines.Add(AccessibleCardUtils.GetCost(m_card));
+			}
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(GetCardType(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetRace(), lines); // Handles spell school as well
+
+            return lines;
+		}
+
+		private List<string> GetLinesForNormalCard()
+        {
+            // (Golden) Tarecgosa -> x atk x health -> description -> Dragon -> Tier 3 -> Minion (handles buddy as well if necessary)
+
+            var zone = m_card.GetEntity().GetZone();
+            var isInPlayZone = zone == TAG_ZONE.PLAY;
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeaderWithRarity());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                if (isInPlayZone)
+                {
+                    var effects = GetEffects();
+                    if (effects.Length > 0)
+                    {
+                        resources = $"{resources} {effects}";
+                    }
+                }
+
+                lines.Add(resources);
+            }
+            else if (isInPlayZone)
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(GetRace(), lines); // Handles spell school as well
+
+            lines.Add(GetTier());
+
+            AccessibleCardUtils.AddLineIfExists(GetCardType(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            if (IsControlledByTavernBob())
+			{
+                return GetLinesForTavernBob();
+			}
+
+			return GetLinesForHeroInPlayZone();
+		}
+
+		private List<string> GetLinesForChooseHero()
+		{
+            var lines = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            lines.Add(entity.GetName());
+
+            var armor = entity.GetArmor();
+
+            if (armor > 0)
+			{
+                lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+			}
+
+            try
+			{
+                var cardId = entity.GetCardId();
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(cardId));
+                lines.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(cardId));
+			}
+            catch (Exception e)
+			{
+                AccessibilityUtils.LogFatalError(e);
+			}
+
+            return lines;
+		}
+
+		private List<string> GetLinesForHeroInPlayZone()
+        {
+            if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+			{
+                return GetLinesForPlayerHero();
+			}
+            else
+			{
+                return GetLinesForOpponentHero();
+			}
+        }
+
+		private List<string> GetLinesForOpponentHero()
+		{
+            // Opponent's Hero -> AFK -> Tier 3 -> x health -> <player name>
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            lines.Add(FormatTier(m_card.GetEntity().GetTag(GAME_TAG.PLAYER_TECH_LEVEL)));
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+			if (AccessibilityUtils.IsInPvPGame())
+			{
+				lines.Add(m_card.GetController().GetName());
+			}
+
+			return lines;
+		}
+
+		private List<string> GetLinesForPlayerHero()
+		{
+            // Your Hero -> Tier 3 -> x health -> AFK -> <player name>
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            lines.Add(GetControllerTier());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+			if (AccessibilityUtils.IsInPvPGame())
+			{
+				lines.Add(m_card.GetController().GetName());
+			}
+
+			return lines;
+		}
+
+		private List<string> GetLinesForTavernBob()
+        {
+            var lines = new List<string>();
+
+            lines.Add(GetFriendlySidePlayerTier());
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+			return lines;
+        }
+
+		private string GetControllerTier()
+		{
+            return GetPlayerTier(m_card.GetController());
+		}
+
+        private string GetFriendlySidePlayerTier()
+		{
+            return GetPlayerTier(GameState.Get().GetFriendlySidePlayer());
+
+		}
+
+		private string GetPlayerTier(Player player)
+		{
+            return FormatTier(player.GetTag(GAME_TAG.PLAYER_TECH_LEVEL));
+		}
+
+        private string GetTier()
+		{
+            return FormatTier(m_card.GetEntity().GetTag(GAME_TAG.TECH_LEVEL));
+		}
+
+        private string FormatTier(int tier)
+		{
+            return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER, tier);
+		}
+
+        private bool IsControlledByTavernBob()
+		{
+            return AccessibleGameplayUtils.IsInBattlegroundsShopPhase() && !m_card.GetEntity().IsControlledByFriendlySidePlayer();
+		}
+
+		private List<string> GetHeaderWithRarity()
+		{
+            if (!m_card.GetEntity().IsMinion())
+			{
+                return GetHeader();
+			}
+
+            var ret = new List<string>();
+
+            ret.Add(AccessibleCardUtils.GetInGameCardNameWithPremium(m_card));
+
+            AddTrailingHeader(ret);
+
+            return ret;
+		}
+
+        // Used for quickly describing the opponent's board when combat phase starts
+        public string GetMinionSummary()
+		{
+            var name = AccessibleCardUtils.GetInGameCardNameWithPremium(m_card);
+
+            var effects = GetEffectsNotInEntityDef();
+            var resources = GetResources();
+
+            return $"{name} {resources} {effects}";
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsChooseHeroCard.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsChooseHeroCard.cs
new file mode 100644
index 0000000..5b00128
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsChooseHeroCard.cs
@@ -0,0 +1,43 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsChooseHeroCard : AccessibleBattlegroundsCard
+    {
+		internal AccessibleBattlegroundsChooseHeroCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+		internal override List<string> GetLines()
+		{
+            var ret = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            ret.Add(entity.GetName());
+
+            var armor = entity.GetArmor();
+
+            if (armor > 0)
+			{
+                ret.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+			}
+
+            try
+			{
+                var cardId = entity.GetCardId();
+                ret.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(cardId));
+                ret.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(cardId));
+			}
+            catch (Exception e)
+			{
+                AccessibilityUtils.LogFatalError(e);
+			}
+
+            return ret;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsGameplay.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsGameplay.cs
new file mode 100644
index 0000000..6862443
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsGameplay.cs
@@ -0,0 +1,1549 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    // TODO: See all players list (start with mine inc. ranking)
+    // TODO: Chenvaala hero power meter
+
+    class AccessibleBattlegroundsGameplay : AccessibleGameplay
+    {
+        private bool m_refreshingTavern;
+
+        private bool m_freezingTavern;
+        private bool m_unfreezingTavern;
+
+        private bool m_tavernFrozen;
+
+        private bool m_upgradingTavern;
+
+        private bool m_movingMinion;
+        private bool m_movingMinionWaitingForHold; // Used to prevent "Sell?" while we wait for the minion to be held
+
+        private bool m_buyingMinion;
+        private bool m_sellingMinion;
+
+        private bool m_isShopPhase;
+        private bool m_isCombatPhase;
+
+        private bool m_hasAnyPlayerWonThisPhase; // Used to output ties when no player won a combat phase
+
+        private bool m_wasShopPhasePopupShown; // Used for reconnects
+
+        private AccessibleInGameState m_lastDescribedState; // Used for storing the state of the board (i.e. Entity clones) at the start of a combat phase
+
+        private int m_numPlayersAlive; // Used for saying x players died at the start of recruit phase
+
+		internal override void OnBattlegroundsCombatPhasePopupShown()
+		{
+            ResetStateBetweenPhases();
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE));
+            StopReadingCard();
+		}
+
+		private void OnBattlegroundsCombatPhaseStart()
+		{
+            if (m_isCombatPhase)
+			{
+                // Kel'Thuzad would read twice as Bob transforms into the real Hero first and into Kel'Thuzad afterwards
+                return;
+			}
+
+            m_isCombatPhase = true;
+            m_hasAnyPlayerWonThisPhase = false;
+            m_lastDescribedState = AccessiblePowerTaskListDescriber.Get().GetLastDescribedState();
+
+			var opponent = GameState.Get().GetOpposingSidePlayer();
+
+			var opponentHero = opponent.GetHero();
+            var opponentTier = GetOpponentTavernTier(opponent);
+            var opponentHealth = GetOpponentHealth(opponent);
+            var opponentArmor = GetOpponentArmor(opponent);
+            var opponentBattlefield = opponent.GetBattlefieldZone();
+            var opponentMinions = opponentBattlefield.GetCards();
+            var numOpponentMinions = opponentBattlefield.GetCardCount();
+
+			var opponentHeroName = opponentHero.GetName();
+
+            if (IsOpponentDead(opponent))
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_AGAINST_DEAD_PLAYER,
+                    opponentHeroName
+				));
+			}
+            else if (opponentArmor > 0)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_INCLUDE_ARMOR,
+                    opponentTier, opponentHeroName, opponentHealth, numOpponentMinions, opponentArmor
+				));
+			}
+			else
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE,
+                    opponentTier, opponentHeroName, opponentHealth, numOpponentMinions
+			    ));
+			}
+
+            ReadOpponentMinions(opponentMinions);
+		}
+
+		private int GetOpponentHealth(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetCurrentHealth();
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetCurrentHealth();
+			}
+		}
+
+		private int GetOpponentArmor(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetArmor();
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetArmor();
+			}
+		}
+
+		private int GetOpponentTavernTier(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetRealTimePlayerTechLevel();
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetRealTimePlayerTechLevel();
+			}
+		}
+
+		private bool IsOpponentDead(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetCurrentHealth() <= 0;
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetCurrentHealth() <= 0;
+			}
+		}
+
+		private void ReadOpponentMinions(List<Card> opponentMinions)
+		{
+            var minionSummaries = new List<string>();
+
+			foreach (var card in opponentMinions)
+			{
+                var accessibleCard = new AccessibleBattlegroundsCard(this, card);
+
+                minionSummaries.Add(accessibleCard.GetMinionSummary());
+			}
+
+            AccessibilityMgr.Output(this, AccessibleSpeechUtils.HumanizeList(minionSummaries));
+		}
+
+		internal override void OnBattlegroundsShopPhasePopupShown()
+		{
+            m_isCombatPhase = false;
+            m_isShopPhase = false;
+            m_tavernFrozen = false;
+
+            // Prevent your opponent's hero became Bob speeches
+            AccessiblePowerTaskListDescriber.Get().OnBattlegroundsHeroAttackPhaseEnd();
+
+            if (!m_wasShopPhasePopupShown)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE));
+
+                var numPlayersAlive = AccessibleBattlegroundsLeaderboardMgr.Get().GetNumPlayersAlive();
+
+                if (numPlayersAlive < m_numPlayersAlive)
+				{
+                    var numPlayersDied = m_numPlayersAlive - numPlayersAlive;
+					AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_DIED, numPlayersDied));
+					AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_REMAINING, numPlayersAlive));
+				}
+
+                m_numPlayersAlive = numPlayersAlive;
+			}
+
+			m_wasShopPhasePopupShown = true;
+            StopReadingCard();
+		}
+
+		private void OnBattlegroundsShopPhaseStart()
+		{
+            m_isShopPhase = true;
+			var player = GameState.Get().GetFriendlySidePlayer();
+
+            if (player != null)
+			{
+                // Reconnects start before the player is set
+				var gold = player.GetNumAvailableResources();
+                var tavernTier = GetTavernTier(player);
+
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE_START_DESCRIBE, tavernTier, gold));
+			}
+
+            // Read Bob's minions
+			var bob = GameState.Get().GetOpposingSidePlayer();
+            var minionsForSale = bob.GetBattlefieldZone().GetCards();
+
+            if (minionsForSale.Count > 0)
+            {
+                var minionNames = new List<string>();
+
+                foreach (var minion in minionsForSale)
+				{
+                    minionNames.Add(AccessibleSpeechUtils.GetEntityName(minion.GetEntity()));
+				}
+
+                var newMinionsInShopMessage = AccessibleSpeechUtils.FormatZoneMovementText(minionNames,
+                    LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN,
+                    LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN
+				);
+
+                AccessibilityMgr.Output(this, newMinionsInShopMessage);
+            }
+		}
+
+        private void ResetState()
+		{
+            m_freezingTavern = false;
+            m_unfreezingTavern = false;
+            m_refreshingTavern = false;
+            m_upgradingTavern = false;
+            m_movingMinion = false;
+            m_movingMinionWaitingForHold = false;
+            m_buyingMinion = false;
+            m_sellingMinion = false;
+		}
+
+		internal override void ReadPlayerResources()
+		{
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int availableGold = player.GetNumAvailableResources();
+            int totalGold = player.GetTag(GAME_TAG.RESOURCES);
+
+            if (availableGold != totalGold)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_CURRENT_AND_TOTAL, availableGold, totalGold));
+            }
+            else
+            {
+                ReadAvailablePlayerResources();
+            }
+		}
+
+		private void ReadAvailablePlayerResources()
+		{
+            int curGold = GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources();
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD, curGold));
+		}
+
+		private void ReadRemainingPlayerResources()
+		{
+            int curGold = GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources();
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_REMAINING_GOLD, curGold));
+		}
+
+		public override void HandleInput()
+        {
+            if (GameState.Get() == null || InputManager.Get() == null)
+            {
+                // Game hasn't even started yet
+                return;
+            }
+
+            if (GameState.Get().IsMulliganPhase())
+			{
+                m_curPhase = AccessibleGamePhase.MULLIGAN;
+			}
+            else if (GameState.Get().IsGameOver())
+            {
+                m_curPhase = AccessibleGamePhase.GAME_OVER;
+            }
+            else if (GameState.Get().IsGameCreated())
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+            }
+            else
+            {
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                HandleTooltipReading();
+            }
+
+            if (m_curPhase == AccessibleGamePhase.PLAYING)
+			{
+                HandleInGameInput();
+			}
+            else if (m_curPhase == AccessibleGamePhase.MULLIGAN)
+			{
+                HandleChooseHeroInput();
+			}
+        }
+
+        private void HandleInGameInput()
+        {
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+
+                if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+				{
+                    OnBattlegroundsShopPhaseStart();
+				}
+                else if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+				{
+                    OnBattlegroundsCombatPhaseStart();
+				}
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+                AccessiblePowerTaskListDescriber.Get().OnReconnected();
+            }
+
+            UpdateState();
+
+            try
+            {
+                UpdateMousePosition();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                HandleShopPhaseInput();
+			}
+            else if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                HandleCombatPhaseInput();
+			}
+        }
+
+		private void UpdateMousePosition()
+		{
+            if (m_heldCard != null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead != null)
+            {
+                MoveMouseToCard(m_cardBeingRead.GetCard());
+            }
+
+            // Note: We can't hide the mouse ever or refreshes etc will stop working
+		}
+
+		private void HandleShopPhaseInput()
+		{
+            HandleGeneralShopPhaseInput();
+
+            // Handle virtual queries first so we can smoothly click a different key to cancel by reading something else simultaneously
+            if (m_upgradingTavern && HandleUpgradingTavern())
+			{
+                return;
+			}
+            else if (m_freezingTavern && HandleFreezingTavern())
+			{
+                return;
+			}
+            else if (m_unfreezingTavern && HandleUnfreezingTavern())
+			{
+                return;
+			}
+            else if (m_refreshingTavern && HandleRefreshTavern())
+			{
+                return;
+			}
+
+            switch(m_curState)
+            {
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleMainOptionMode();
+                    return;
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    HandleCheckStatusKeys();
+                    HandleSubOptionMode();
+                    return;
+                case AccessibleGameState.CHOICE_MODE:
+                    HandleCheckStatusKeys();
+                    HandleChoiceMode();
+                    return;
+                case AccessibleGameState.TARGET_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleTargetMode();
+                    return;
+                case AccessibleGameState.SUMMONING_MINION:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleSummoningMinion();
+                    // TODO: Check base file to see what this is HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.BUYING_MINION:
+                    HandleCheckStatusKeys();
+                    HandleBuyingMinion();
+                    return;
+                case AccessibleGameState.SELLING_MINION:
+                    HandleCheckStatusKeys();
+                    HandleSellingMinion();
+                    return;
+                case AccessibleGameState.MOVING_MINION:
+                    HandleCheckStatusKeys();
+                    HandleMovingMinion();
+                    return;
+                case AccessibleGameState.PLAYING_CARD:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandlePlayingCard();
+                    return;
+                case AccessibleGameState.READING_LEADERBOARD:
+                    HandleReadLeaderboardInput();
+                    return;
+                default:
+                    return;
+            }
+		}
+
+        protected override void HandleCheckStatusKeys()
+        {
+            base.HandleCheckStatusKeys();
+
+            if (AccessibleKey.BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS.IsPressed())
+            {
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadNextOpponent();
+            }
+            else if (AccessibleKey.BATTLEGROUNDS_READ_MY_STATS.IsPressed())
+			{
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadMyself();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS_TO_END.IsPressed())
+            {
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadNextOpponentToEnd();
+            }
+            else if (AccessibleKey.BATTLEGROUNDS_READ_MY_STATS_TO_END.IsPressed())
+			{
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadMyselfToEnd();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_LEADERBOARD.IsPressed())
+			{
+                AccessibleBattlegroundsLeaderboardMgr.Get().StartReadingLeaderboard();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_RACES_IN_GAME.IsPressed())
+			{
+                ReadRacesInGame();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_HERO_BUDDY.IsPressed())
+			{
+                ReadHeroBuddy();
+			}
+        }
+
+		internal AccessibleInGameState GetStateAtStartOfCombat()
+		{
+            return m_lastDescribedState;
+		}
+
+		private void ReadHeroBuddy()
+		{
+            var heroBuddyCard = TB_BaconShop.GetHeroBuddyCard(Player.Side.FRIENDLY);
+
+            if (heroBuddyCard == null)
+			{
+                return;
+			}
+
+            m_cardBeingRead = new AccessibleBattlegroundsHeroBuddyCard(this, heroBuddyCard);
+            m_curZone = heroBuddyCard.GetZone();
+            m_cardBeingRead.ReadLine();
+		}
+
+		private void ReadRacesInGame()
+		{
+            var racesInGame = TB_BaconShop.GetAvailableRacesText();
+
+			if (racesInGame != null)
+			{
+				AccessibilityMgr.Output(this, racesInGame);
+			}
+		}
+
+		private void HandleGeneralShopPhaseInput()
+		{
+            if (AccessibleKey.END_TURN.IsPressed())
+			{
+                var secondsRemaining = TurnTimer.Get().GetSecondsRemaining();
+
+                if (secondsRemaining > 0)
+				{
+					AccessibilityUtils.OutputSecondsRemaining(secondsRemaining);
+				}
+			}
+		}
+
+		private void HandleBuyingMinion()
+		{
+            AccessibleInputMgr.MoveMouseTo(GameState.Get().GetFriendlySidePlayer().GetHeroCard());
+
+            HandleForcedConfirmOrCancel(ConfirmActionByClicking, CancelActionWithHeldCard);
+		}
+
+		private void HandleSellingMinion()
+		{
+            AccessibleInputMgr.MoveMouseTo(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+
+            HandleForcedConfirmOrCancel(ConfirmActionByClicking, CancelActionWithHeldCard);
+		}
+
+		private bool HandleFreezingTavern()
+		{
+            return HandleSmoothConfirmOrCancel(ForceFreezeOrUnfreezeTavern, ResetState, AccessibleKey.FREEZE_TAVERN);
+		}
+
+		private bool HandleUnfreezingTavern()
+		{
+            return HandleSmoothConfirmOrCancel(ForceFreezeOrUnfreezeTavern, ResetState, AccessibleKey.FREEZE_TAVERN);
+		}
+
+		private bool HandleUpgradingTavern()
+		{
+            return HandleSmoothConfirmOrCancel(ForceUpgradeTavern, ResetState, AccessibleKey.UPGRADE_TAVERN);
+		}
+
+		internal bool IsInShopPhase()
+		{
+            return m_isShopPhase;
+		}
+
+		internal bool IsInCombatPhase()
+		{
+            return m_isCombatPhase;
+		}
+
+		private bool HandleRefreshTavern()
+		{
+			return HandleSmoothConfirmOrCancel(ForceRefreshTavern, ResetState, AccessibleKey.REFRESH_TAVERN);
+		}
+
+		private bool HandleReadLeaderboardInput()
+		{
+            return AccessibleBattlegroundsLeaderboardMgr.Get().HandleAccessibleInput();
+		}
+
+        private void ConfirmActionByClicking()
+		{
+			ResetState();
+			AccessibleInputMgr.ClickLeftMouseButton();
+		}
+        
+        private void CancelActionWithHeldCard()
+		{
+            ResetState();
+            AccessibleInputMgr.ClickRightMouseButton();
+		}
+
+		private void HandleForcedConfirmOrCancel(Action confirmAction, Action cancelAction, bool includeSpaceAsWell=false)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed() ||
+                (includeSpaceAsWell && AccessibleKey.SPACE.IsPressed()))
+            {
+                confirmAction();
+			}
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+                cancelAction();
+            }
+        }
+
+		private bool HandleSmoothConfirmOrCancel(Action confirmAction, Action cancelAction, AccessibleKey originalKey)
+        {
+            // Note: OriginalKey is used to make it so e.g. pressing U twice forces a tavern upgrade the same way that U+Enter would as players
+            // are used to this due to the end turn behaviour
+            if (AccessibleKey.CONFIRM.IsPressed() || originalKey.IsPressedDown())
+            {
+                confirmAction();
+                return true;
+			}
+            else if (AccessibleKey.CONFIRM.IsPressedDown())
+			{
+                // No-op as we need to cancel on Up, not Down
+			}
+			else if (Input.anyKeyDown)
+            {
+                cancelAction();
+            }
+
+            return false;
+        }
+
+		private void HandleCombatPhaseInput()
+		{
+			HandleCardReadingInput();
+			HandleCheckStatusKeys();
+			HandleZoneInput();
+			HandleValidOptionsSelectionInput();
+			HandleZoneSelection();
+		}
+
+		private void UpdateState()
+		{
+            try
+            {
+                UpdateCardBeingReadState();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            m_heldCard = InputManager.Get().GetHeldCard();
+            m_playerTurn = GameState.Get().IsFriendlySidePlayerTurn();
+
+            ResetChoiceCardsIfNecessary();
+            ReadStateAfterClosingLeaderboardIfNecessary();
+
+            if (m_heldCard == null)
+            {
+                m_movingMinion = false;
+            }
+            else if (m_movingMinionWaitingForHold)
+			{
+                m_movingMinionWaitingForHold = false;
+                m_movingMinion = true;
+			}
+
+            m_prevState = m_curState;
+            m_prevResponseMode = m_curResponseMode;
+            m_curResponseMode = GameState.Get().GetResponseMode();
+
+            // Proper states
+            if (!m_playerTurn)
+            {
+                m_curState = AccessibleGameState.WAITING;
+            } 
+            else if (AccessibleBattlegroundsLeaderboardMgr.Get().IsReadingLeaderboard())
+            {
+                m_curState = AccessibleGameState.READING_LEADERBOARD;
+            }
+            else if (m_heldCard != null)
+            {
+                if (m_heldCard.GetEntity().IsMinion())
+                {
+                    var entity = m_heldCard.GetEntity();
+                    var zone = entity.GetZone();
+
+                    if (zone == TAG_ZONE.PLAY)
+					{
+                        if (entity.IsControlledByFriendlySidePlayer() && m_movingMinion)
+						{
+                            m_curState = AccessibleGameState.MOVING_MINION;
+						}
+                        else if (entity.IsControlledByFriendlySidePlayer() && m_sellingMinion)
+						{
+							m_curState = AccessibleGameState.SELLING_MINION;
+
+                            if (m_curState != m_prevState)
+							{
+                                var minionName = AccessibleSpeechUtils.GetEntityName(entity);
+								AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_SELL_MINION, minionName));
+							}
+						}
+                        else if (m_buyingMinion)
+						{
+							m_curState = AccessibleGameState.BUYING_MINION;
+
+                            if (m_curState != m_prevState)
+							{
+                                var minionName = AccessibleSpeechUtils.GetEntityName(entity);
+								AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_BUY_MINION, minionName));
+							}
+						}
+					}
+                    else
+					{
+						m_curState = AccessibleGameState.SUMMONING_MINION;
+					}
+                }
+                else if (GameState.Get().IsInMainOptionMode())
+                {
+                    m_curState = AccessibleGameState.PLAYING_CARD;
+                }
+            }
+            else if (GameState.Get().IsInMainOptionMode())
+            {
+				m_curState = AccessibleGameState.MAIN_OPTION_MODE;
+			}
+			else if (GameState.Get().IsInSubOptionMode())
+            {
+                m_curState = AccessibleGameState.SUB_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                m_curState = AccessibleGameState.CHOICE_MODE;
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                m_curState = AccessibleGameState.TARGET_MODE;
+            } 
+            else
+            {
+                // Normally happens in between turns (i.e. after button press but before response) due to network time
+                m_curState = AccessibleGameState.UNKNOWN;
+            }
+		}
+
+		private void ReadStateAfterClosingLeaderboardIfNecessary()
+		{
+            if (m_prevState == m_curState || m_prevState != AccessibleGameState.READING_LEADERBOARD)
+			{
+                return;
+			}
+
+            if (m_cardBeingRead != null)
+			{
+                // Reread zone regardless
+                var card = m_cardBeingRead.GetCard();
+				ReadZoneChangeIfNecessary(card, null, card.GetZone(), true);
+				m_cardBeingRead.Reset();
+                var speech = m_cardBeingRead.GetLine(0);
+
+				if (ShouldReadCardAsList(card))
+				{
+					var zonePos = card.GetZone().FindCardPos(card); // card.GetZonePosition() isn't trustworthy. Wasn't working for secrets
+					AccessibilityMgr.Output(this, AccessibleSpeech.MENU_OPTION(speech, zonePos, card.GetZone().GetCardCount()));
+				}
+                else
+				{
+                    AccessibilityMgr.Output(this, speech);
+				}
+			}
+		}
+
+		private void OnCombatPhaseCombatEnded()
+		{
+            if (m_hasAnyPlayerWonThisPhase)
+			{
+                // Heroes gain atk twice (one for tavern tier and one for all minions)
+                return;
+			}
+
+			m_hasAnyPlayerWonThisPhase = true;
+
+			var numPlayerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount();
+            var numOpponentMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardCount();
+
+            if (numPlayerMinions > numOpponentMinions)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_PLAYER_WON, numPlayerMinions));
+			}
+            else if (numOpponentMinions > numPlayerMinions)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_OPPONENT_WON, numOpponentMinions));
+			}
+
+            // Note: ties are narrated in OnMainStepEnd as we have no proper way of knowing before then i.e. OnCombatPhaseCombatEnded is not invoked if no Hero launches
+            // an attack
+		}
+
+		protected override void ReadOpponentZoneName()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_ZONE_MINIONS_FOR_SALE));
+			}
+			else
+			{
+                base.ReadOpponentZoneName();
+			}
+		}
+
+		protected override void ReadOpponentMinionsEmpty()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_SEE_ZONE_MINIONS_FOR_SALE_EMPTY));
+			}
+            else
+			{
+                base.ReadOpponentMinionsEmpty();
+			}
+		}
+
+        protected override void SeePlayerWeapon()
+        {
+            // TODO: Buddy meter
+        }
+
+        protected override void SeeOpponentWeapon()
+        {
+            // TODO: Buddy meter
+        }
+
+        private void HandleMainOptionMode()
+        {
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection();
+
+            if (AccessibleKey.FREEZE_TAVERN.IsPressedDown())
+			{
+                QueryFreezeOrUnfreezeTavern();
+			}
+            else if (AccessibleKey.FORCE_FREEZE_TAVERN.IsPressed())
+			{
+                ForceFreezeOrUnfreezeTavern();
+			}
+            else if (AccessibleKey.UPGRADE_TAVERN.IsPressedDown())
+			{
+                QueryUpgradeTavern();
+			}
+            else if (AccessibleKey.FORCE_UPGRADE_TAVERN.IsPressed())
+			{
+                ForceUpgradeTavern();
+			}
+            else if (AccessibleKey.REFRESH_TAVERN.IsPressedDown())
+			{
+                QueryRefreshTavern();
+			}
+            else if (AccessibleKey.FORCE_REFRESH_TAVERN.IsPressed())
+			{
+                ForceRefreshTavern();
+			}
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                ClickCard();
+            }
+            else if (AccessibleKey.SPACE.IsPressed())
+			{
+                ClickCardForMoving();
+			}
+        }
+
+        private void ClickCard()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+			ResetState();
+
+            var entity = m_cardBeingRead.GetCard().GetEntity();
+
+            if (entity.GetZone() == TAG_ZONE.PLAY)
+			{
+				if (entity.IsControlledByFriendlySidePlayer())
+				{
+					m_sellingMinion = true;
+				}
+                else
+				{
+					m_buyingMinion = true;
+				}
+			}
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+		private void ClickButtonCard(Card card)
+		{
+            StopReadingCard();
+            AccessibleInputMgr.Click(card);
+		}
+
+        private void ClickCardForMoving()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+			var card = m_cardBeingRead.GetCard();
+
+            var playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (card.GetZone() != playerBattlefield || playerBattlefield.GetCardCount() <= 1)
+			{
+                return;
+			}
+
+			ResetState();
+
+            m_movingMinionWaitingForHold = true;
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+		private void QueryRefreshTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var refreshButtonCard = GetGameState().GetRefreshButtonCard();
+
+            if (!refreshButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_refreshingTavern = true;
+            var refreshCost = refreshButtonCard.GetEntity().GetCost();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_REFRESH_TAVERN_FOR_N_GOLD, refreshCost));
+		}
+
+		private void ForceRefreshTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var refreshButtonCard = GetGameState().GetRefreshButtonCard();
+            ClickButtonCard(refreshButtonCard);
+		}
+
+		private void QueryFreezeOrUnfreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            if (IsTavernFrozen())
+			{
+                QueryUnfreezeTavern();
+			}
+            else
+			{
+                QueryFreezeTavern();
+			}
+		}
+
+		private bool IsTavernFrozen()
+		{
+            return m_tavernFrozen;
+		}
+
+		private void ForceFreezeOrUnfreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var freezeButton = GetGameState().GetFreezeButtonCard();
+
+            ClickButtonCard(freezeButton);
+		}
+
+		private void QueryUnfreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var freezeButtonCard = GetGameState().GetFreezeButtonCard();
+
+            if (!freezeButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_unfreezingTavern = true;
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_UNFREEZE_TAVERN));
+		}
+
+		private void QueryFreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var freezeButtonCard = GetGameState().GetFreezeButtonCard();
+
+            if (!freezeButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_freezingTavern = true;
+            var freezeCost = freezeButtonCard.GetEntity().GetCost();
+
+            if (freezeCost == 0)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN));
+			}
+            else
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN_FOR_N_GOLD, freezeCost));
+			}
+		}
+
+		private void QueryUpgradeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var upgradeButtonCard = GetGameState().GetTavernUpgradeButtonCard();
+
+            if (!upgradeButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_upgradingTavern = true;
+            var upgradeCost = upgradeButtonCard.GetEntity().GetCost();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_UPGRADE_TAVERN_FOR_N_GOLD, upgradeCost));
+		}
+
+		private void ForceUpgradeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var upgradeButtonCard = GetGameState().GetTavernUpgradeButtonCard();
+            ClickButtonCard(upgradeButtonCard);
+		}
+
+		private TB_BaconShop GetGameState()
+		{
+            return GameState.Get().GetGameEntity() as TB_BaconShop;
+		}
+
+		protected override void Reset()
+		{
+            base.Reset();
+
+            ResetState();
+		}
+
+		protected override bool IsSeeOpponentHeroPressed()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+				return AccessibleKey.SEE_OPPONENT_HERO.IsPressed();
+			}
+            else
+			{
+                return AccessibleKey.SEE_TAVERN.IsPressed();
+			}
+		}
+
+		protected override bool IsSeePlayerHeroPowerPressed()
+		{
+            return AccessibleKey.BATTLEGROUNDS_SEE_PLAYER_HERO_POWER.IsPressed();
+		}
+
+		protected override bool IsSeeOpponentHeroPowerPressed()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                return AccessibleKey.BATTLEGROUNDS_SEE_OPPONENT_HERO_POWER.IsPressed();
+			}
+
+            // No-op in shop phase
+            return false;
+		}
+
+		internal override void OnFreezeOrUnfreezeEvent()
+		{
+            // TODO: Figure out a better way of handling this
+            m_tavernFrozen = !m_tavernFrozen;
+		}
+
+        #region Moving Minions
+
+        private int m_movePos;
+
+        private void HandleMovingMinion()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+			// TODO: Disable key if only 1 minion -> don't allow shortcuts either
+
+			if (m_prevState != AccessibleGameState.MOVING_MINION)
+			{
+                m_movePos = 0;
+                var startPos = m_heldCard.GetZonePosition();
+				QueryMovingPosition(startPos);
+			}
+
+			HandleMovingPositionInput();
+
+			if (m_movePos == playerMinions.GetLastPos())
+			{
+				MoveMouseToRightOfZone(playerMinions);
+			}
+			else if (m_movePos == 1)
+			{
+				MoveMouseToLeftOfZone(playerMinions);
+			}
+			else
+			{
+				var prevMinion = playerMinions.GetCardAtPos(m_movePos - 1);
+				var nextMinion = playerMinions.GetCardAtPos(m_movePos);
+				var pos = prevMinion.transform.position + (nextMinion.transform.position - prevMinion.transform.position) / 2;
+				AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+			}
+
+			HandleForcedConfirmOrCancel(ConfirmActionByClicking, CancelActionWithHeldCard, true);
+        }
+
+        private void HandleMovingPositionInput()
+        {
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                QueryMovingPosition(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                QueryMovingPosition(1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+			{
+                m_movePos = 1;
+                QueryMovingPosition(0);
+			}
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+			{
+				var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+				var lastPos = playerMinions.GetLastPos();
+                m_movePos = lastPos;
+                QueryMovingPosition(0);
+			}
+            else
+			{
+				int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+                if (numKeyPressed.HasValue)
+				{
+					var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+					var lastPos = playerMinions.GetLastPos();
+
+                    m_movePos = Math.Min(lastPos, numKeyPressed.Value);
+                    QueryMovingPosition(0);
+				}
+			}
+		}
+
+        private void QueryMovingPosition(int inc)
+        {
+            var prevMovePos = m_movePos;
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var lastPos = playerMinions.GetLastPos();
+
+            m_movePos += inc;
+
+            if (m_movePos > lastPos)
+            {
+                m_movePos = lastPos;
+            }
+            else if (m_movePos < 1)
+            {
+                m_movePos = 1;
+            }
+
+            if (inc != 0 && prevMovePos == m_movePos)
+            {
+                return;
+            }
+
+            if (m_movePos == lastPos)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_LAST_POSITION));
+            }
+            else if (m_movePos == 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_FIRST_POSITION));
+            }
+            else
+            {
+                var prevMinion = playerMinions.GetCardAtPos(m_movePos - 1);
+                var nextMinion = playerMinions.GetCardAtPos(m_movePos);
+                var prevMinionName = GetPreferredCardName(prevMinion);
+                var nextMinionName = GetPreferredCardName(nextMinion);
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_BETWEEN, prevMinionName, nextMinionName));
+            }
+        }
+        #endregion
+
+        protected override string GetPreferredCardName(Card card)
+		{
+            return AccessibleCardUtils.GetInGameCardNameWithPremium(card);
+		}
+
+        protected override void MoveMouseToCard(Card card)
+        {
+            if (card.GetZone()?.GetType() == typeof(ZoneHand))
+            {
+				// Note: Unlike in a game of traditional Hearthstone, we can't trust mousedOver as when Bob is speaking or highlighting certain
+				// buttons (e.g. in the tutorial) the cards will have their input disabled which messes with mouse over state
+				// Bit of a mess but not a whole lot we can do about it
+				if (!IsMousedOver(card))
+                {
+                    // Note: All of this code was added to trace a rare edge case some players have fallen into with cards such as shadowstep.
+                    // I haven't been able to reproduce so far but I think the bug has something to do with a NPE somewhere in the actor/manaObject chain
+                    // TODO: Clean all of this up once the bug is detected/fixed
+                    try
+					{
+                        var mousedOverCard = GetMousedOverCardRegardlessOfInput();
+
+                        if (mousedOverCard != null && mousedOverCard.GetZone() is ZonePlay)
+						{
+                            // In Battlegrounds, lists of effects can get large enough to the point that it covers cards in hand so we need to hide the tooltip
+                            // or we won't be able to hover the card in hand
+                            mousedOverCard.HideTooltip();
+						}
+
+						AccessibleInputMgr.MoveMouseTo(card.GetActor().m_manaObject.transform);
+					}
+					catch (Exception e)
+					{
+                        AccessibilityUtils.LogFatalError(e);
+                        AccessibilityUtils.LogFatalError($"card.GetActor(): {card.GetActor()}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject: {card.GetActor()?.m_manaObject}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject?.transform: {card.GetActor()?.m_manaObject?.transform}");
+                        AccessibilityUtils.LogFatalError($"card.GetEntity()?.GetCardId(): {card.GetEntity()?.GetCardId()}");
+
+                        if (card.GetActor() != null)
+						{
+                            if (card.GetActor().m_attackObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_attackObject.transform);
+                            else if (card.GetActor().m_healthObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_healthObject.transform);
+                            else AccessibilityUtils.LogFatalError("Unable to recover - Aborting MoveMouseToCard");
+						}
+                    }
+				}
+            }
+            else
+            {
+                AccessibleInputMgr.MoveMouseTo(card);
+            }
+        }
+
+		private bool IsMousedOver(Card card)
+		{
+            return GetMousedOverCardRegardlessOfInput() == card;
+		}
+
+        private Card GetMousedOverCardRegardlessOfInput()
+		{
+            return InputManager.Get().m_mousedOverCardRegardlessOfInput;
+		}
+
+		private int GetTavernTier(Player player)
+		{
+            return player.GetTag(GAME_TAG.PLAYER_TECH_LEVEL);
+		}
+
+		private int GetHeroTavernTier(Entity hero)
+		{
+            // Opponent sets this in Hero
+            return hero.GetTag(GAME_TAG.PLAYER_TECH_LEVEL);
+		}
+
+		internal override void OnOpponentHeroChanged()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+				OnBattlegroundsCombatPhaseStart();
+			}
+		}
+
+		internal override void OnAnyHeroGainedAtk()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                OnCombatPhaseCombatEnded();
+			}
+		}
+
+		internal override void OnPlayerAvailableResourcesChanged(int before, int after)
+		{
+            if (m_isShopPhase)
+			{
+                if (after > before)
+				{
+					ReadAvailablePlayerResources();
+				}
+                else
+				{
+					ReadRemainingPlayerResources();
+				}
+			}
+		}
+
+		private void ResetStateBetweenPhases()
+		{
+            m_wasShopPhasePopupShown = false;
+            m_isShopPhase = false;
+            m_isCombatPhase = false;
+            AccessibleBattlegroundsLeaderboardMgr.Get().StopReadingLeaderboard();
+		}
+
+		internal override void OnFirstTaskListStart()
+		{
+            OnBattlegroundsShopPhasePopupShown(); // Not really shown for reconnects, but..
+		}
+
+		internal override void OnMainActionStep()
+		{
+            // We're guaranteed to have gold etc. refreshed when MAIN_ACTION starts
+            if (!m_isShopPhase && m_wasShopPhasePopupShown)
+			{
+                OnBattlegroundsShopPhaseStart();
+			}
+		}
+
+		internal override void OnMainStepEnd()
+		{
+            if (m_isCombatPhase)
+			{
+                if (!m_hasAnyPlayerWonThisPhase)
+				{
+					AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_TIED));
+				}
+			}
+
+            m_isCombatPhase = false;
+		}
+
+        #region Mulligan i.e. Choose Hero
+
+        private bool m_confirmingHero;
+
+        private bool m_waitingForOpponentsToChooseHero;
+
+        private string m_prevWaitingText; // Used for reading x players ready whenever a new player becomes ready
+
+		private void HandleChooseHeroInput()
+        {
+            if (m_accessibleMulliganCards == null)
+            {
+                return; // yield
+            }
+
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+            }
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (m_waitingForOpponentsToChooseHero)
+				{
+                    ReadNumberOfReadyPlayers(true);
+				}
+                else if (m_confirmingHero)
+                {
+                    m_mulliganConfirmButton.TriggerRelease();
+                }
+                else
+                {
+                    var focusedCard = m_accessibleMulliganCards.GetItemBeingRead();
+                    AccessibleInputMgr.MoveMouseTo(focusedCard.GetCard());
+                    AccessibleInputMgr.ClickLeftMouseButton();
+
+                    m_confirmingHero = true;
+                    AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PRESS_ENTER_TO_CONFIRM_OR_BACKSPACE_TO_CANCEL);
+                }
+            }
+            else if (AccessibleKey.BACK.IsPressed() && m_confirmingHero)
+			{
+                m_confirmingHero = false;
+                m_accessibleMulliganCards.StartReading();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_RACES_IN_GAME.IsPressed())
+			{
+                ReadRacesInGame();
+			}
+            else if (AccessibleKey.END_TURN.IsPressed())
+			{
+                MulliganManager.Get().m_mulliganTimer?.OutputSecondsRemaining();
+			}
+            else if (!m_confirmingHero && !m_waitingForOpponentsToChooseHero)
+            {
+                m_accessibleMulliganCards.HandleAccessibleInput();
+                AccessibleInputMgr.MoveMouseTo(m_accessibleMulliganCards.GetItemBeingRead().GetCard());
+            }
+
+            // Re-read banner everytime a new player becomes ready while waiting for the game to start
+            if (m_waitingForOpponentsToChooseHero)
+			{
+                ReadNumberOfReadyPlayers();
+			}
+        }
+
+		internal override void OnEnterMultiplayerWaitingArea(List<Card> startingCards, string mulliganBannerText, string mulliganBannerSubtitleText, NormalButton confirmButton)
+		{
+            ReadRacesInGame();
+
+            if (mulliganBannerText != null) AccessibilityMgr.Output(this, mulliganBannerText);
+            if (mulliganBannerSubtitleText != null) AccessibilityMgr.Output(this, mulliganBannerSubtitleText);
+
+            try
+            {
+                m_mulliganConfirmButton = confirmButton;
+
+                var accessibleCards = new List<AccessibleCard>(startingCards.Count);
+                startingCards.ForEach(c => accessibleCards.Add(new AccessibleBattlegroundsChooseHeroCard(this, c)));
+
+                m_accessibleMulliganCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+                m_accessibleMulliganCards.StartReading();
+                m_prevWaitingText = null;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+		}
+
+		public override void EndMulligan()
+		{
+            m_waitingForOpponentsToChooseHero = false;
+            m_confirmingHero = false;
+            m_accessibleMulliganCards = null;
+            m_mulliganConfirmButton = null;
+
+            TransitionFromMulliganToGame();
+		}
+
+        public override void WaitingForOpponentToFinishMulligan()
+        {
+            ReadNumberOfReadyPlayers();
+
+            m_confirmingHero = false;
+            m_waitingForOpponentsToChooseHero = true;
+        }
+
+		private void ReadNumberOfReadyPlayers(bool forceRead=false)
+		{
+            var tbBaconShop = GetGameState();
+            var playersReady = tbBaconShop.CountPlayersFinishedMulligan();
+            var playersInGame = tbBaconShop.CountPlayersInGame();
+            var waitingText = LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_MULLIGAN_PLAYERS_READY, playersReady, playersInGame);
+
+            if (m_prevWaitingText != waitingText || forceRead)
+			{
+				AccessibilityMgr.Output(this, waitingText);
+			}
+
+            m_prevWaitingText = waitingText;
+		}
+
+        #endregion
+
+        #region Help
+
+        protected override string GetMulliganHelp()
+        {
+            return m_accessibleMulliganCards?.GetHelp(false);
+        }
+
+        protected override string GetMainOptionModeHelp()
+        {
+            if (!m_isShopPhase)
+			{
+                // Don't think this can even happen to be honest
+                return "";
+			}
+
+            // Keep it simple since most players would rather look at the commands online anyways. Contextual help as in traditional Hearthstone is not worth
+            // the complexity
+
+            var lines = new List<string>();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_HELP, AccessibleKey.SEE_PLAYER_MANA));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_TAVERN_INFORMATION_HELP, AccessibleKey.SEE_TAVERN));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_HERO_BUDDY_HELP, AccessibleKey.BATTLEGROUNDS_READ_HERO_BUDDY));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_NEXT_OPPONENT_STATS_HELP, AccessibleKey.BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_MY_STATS_HELP, AccessibleKey.BATTLEGROUNDS_READ_MY_STATS));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_LEADERBOARD_HELP, AccessibleKey.BATTLEGROUNDS_READ_LEADERBOARD));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_RACES_IN_GAME_HELP, AccessibleKey.BATTLEGROUNDS_READ_RACES_IN_GAME));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP, AccessibleKey.BATTLEGROUNDS_SEE_PLAYER_HERO_POWER));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING, AccessibleKey.END_TURN));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE, AccessibleKey.UPGRADE_TAVERN, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE, AccessibleKey.FREEZE_TAVERN, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN, AccessibleKey.FREEZE_TAVERN, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.SPACE));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM));
+
+            return AccessibleSpeechUtils.CombineLines(lines);
+        }
+
+        protected override string GetOpponentTurnHelp()
+        {
+            // No-op
+            return "";
+        }
+
+        public override string GetHelp()
+        {
+            var gameEntity = GameState.Get().GetGameEntity();
+            if (gameEntity is TB_BaconShop_Tutorial)
+			{
+                return ((TB_BaconShop_Tutorial)gameEntity).GetHelp();
+			}
+
+            return base.GetHelp();
+        }
+
+        #endregion
+
+        #region Not used in BGs
+
+        internal override void ReadOpponentResources()
+		{
+			// No-op
+		}
+
+        internal override void ReadOpponentHand()
+		{
+			// No-op
+		}
+
+		internal override void ReadPlayerDeck()
+		{
+			// No-op
+		}
+
+		internal override void ReadOpponentDeck()
+		{
+			// No-op
+		}
+
+		#endregion
+	}
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsHeroBuddyCard.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsHeroBuddyCard.cs
new file mode 100644
index 0000000..9595e1e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsHeroBuddyCard.cs
@@ -0,0 +1,28 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsHeroBuddyCard : AccessibleBattlegroundsCard
+    {
+		internal AccessibleBattlegroundsHeroBuddyCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+		internal override List<string> GetLines()
+		{
+            var ret = new List<string>();
+
+            var heroCard = GameState.Get().GetFriendlySidePlayer().GetHero();
+
+			var progress = heroCard.GetTag(GAME_TAG.BACON_HERO_BUDDY_PROGRESS);
+            ret.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_BUDDY_METER, progress));
+
+            ret.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(heroCard.GetCardId()));
+
+            return ret;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsLeaderboardMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsLeaderboardMgr.cs
new file mode 100644
index 0000000..27a82f3
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsLeaderboardMgr.cs
@@ -0,0 +1,147 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsLeaderboardMgr
+    {
+		private static AccessibleBattlegroundsLeaderboardMgr s_instance;
+
+		private bool m_readingLeaderboard;
+
+        private AccessibleListOfItems<AccessiblePlayerLeaderboardCard> m_accessibleCards;
+
+		internal static AccessibleBattlegroundsLeaderboardMgr Get()
+		{
+			if (s_instance == null)
+			{
+				s_instance = new AccessibleBattlegroundsLeaderboardMgr();
+			}
+
+			return s_instance;
+		}
+
+        public void ReadNextOpponent()
+		{
+			var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+			StartReadingLeaderboard(GetTileIndex(nextOpponentTile));
+		}
+
+		public void ReadMyself()
+		{
+			var myTile = PlayerLeaderboardManager.Get().GetMyTile();
+			StartReadingLeaderboard(GetTileIndex(myTile));
+		}
+
+        public void ReadNextOpponentToEnd()
+		{
+            ReadCard(PlayerLeaderboardManager.Get().GetNextOpponentTile());
+		}
+
+        public void ReadMyselfToEnd()
+		{
+            ReadCard(PlayerLeaderboardManager.Get().GetMyTile());
+		}
+
+		private static void ReadCard(PlayerLeaderboardCard card)
+		{
+			if (card == null)
+			{
+				return;
+			}
+
+			AccessibleInputMgr.MoveMouseTo(card);
+            var accessibleCard = new AccessiblePlayerLeaderboardCard(AccessibleGameplay.Get(), card);
+            accessibleCard.ReadAllLines();
+		}
+
+		internal int GetNumPlayersAlive()
+		{
+			var tiles = PlayerLeaderboardManager.Get().m_playerTiles;
+
+			int ret = 0;
+
+			foreach(var tile in tiles)
+			{
+				if (tile?.m_playerHeroEntity.GetRealTimeRemainingHP() > 0)
+				{
+					ret++;
+				}
+			}
+
+			return ret;
+		}
+
+		internal bool HandleAccessibleInput()
+		{
+            if (AccessibleKey.BATTLEGROUNDS_READ_LEADERBOARD.IsPressed() && !m_readingLeaderboard)
+            {
+                StartReadingLeaderboard();
+                return true;
+            }
+            else if (AccessibleKey.BACK.IsPressed() && m_readingLeaderboard)
+            {
+                StopReadingLeaderboard();
+				AccessibleInputMgr.HideMouse();
+                return true;
+            }
+			else if (m_readingLeaderboard)
+			{
+				AccessibleInputMgr.MoveMouseTo(m_accessibleCards.GetItemBeingRead().GetCard());
+
+				return m_accessibleCards.HandleAccessibleInput();
+			}
+
+            return false;
+		}
+
+		internal void StartReadingLeaderboard(int fromIndex=0)
+        {
+            var tiles = PlayerLeaderboardManager.Get().m_playerTiles;
+
+            if (tiles == null || tiles.Count == 0)
+			{
+                return;
+			}
+
+            var accessibleCards = new List<AccessiblePlayerLeaderboardCard>();
+
+            foreach (var tile in tiles)
+			{
+                accessibleCards.Add(new AccessiblePlayerLeaderboardCard(AccessibleGameplay.Get(), tile));
+			}
+
+            m_accessibleCards = new AccessibleListOfItems<AccessiblePlayerLeaderboardCard>(AccessibleGameplay.Get(), accessibleCards);
+            m_readingLeaderboard = true;
+
+            m_accessibleCards.StartReadingFromIndex(fromIndex);
+        }
+
+		internal void StopReadingLeaderboard()
+		{
+			m_readingLeaderboard = false;
+		}
+
+		internal bool IsReadingLeaderboard()
+		{
+			return m_readingLeaderboard;
+		}
+
+		private int GetTileIndex(PlayerLeaderboardCard tile)
+		{
+            var tiles = PlayerLeaderboardManager.Get().m_playerTiles;
+
+			for (int i = 0; i < tiles.Count; i++)
+			{
+				var t = tiles[i];
+
+				if (t == tile)
+				{
+					return i;
+				}
+			}
+
+			return 0; // Allow StartReading to fail gracefully
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPowerTaskListDescriber.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPowerTaskListDescriber.cs
new file mode 100644
index 0000000..24f90ee
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPowerTaskListDescriber.cs
@@ -0,0 +1,12 @@
+﻿using PegasusGame;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsPowerTaskListDescriber : AccessiblePowerTaskListDescriber
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardCard.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardCard.cs
new file mode 100644
index 0000000..5e37de9
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardCard.cs
@@ -0,0 +1,154 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static FriendListFrame;
+
+namespace Accessibility
+{
+    class AccessiblePlayerLeaderboardCard : AccessibleItem
+    {
+        private readonly PlayerLeaderboardCard m_card;
+
+        internal AccessiblePlayerLeaderboardCard(AccessibleComponent parent, PlayerLeaderboardCard card) : base(parent)
+        {
+            m_card = card;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            AccessibleCardUtils.AddLineIfExists(GetName(), ret);
+            AccessibleCardUtils.AddLineIfExists(GetPosition(), ret);
+            AddHealthAndArmorLines(ret);
+            AccessibleCardUtils.AddLineIfExists(GetTavernTier(), ret);
+            AccessibleCardUtils.AddLineIfExists(GetRacesText(), ret);
+            AccessibleCardUtils.AddLineIfExists(GetTriplesText(), ret);
+
+            AddCombatInfoLines(ret);
+
+            return ret;
+        }
+
+		private void AddCombatInfoLines(List<string> ret)
+		{
+            var playerId = m_card.m_playerHeroEntity.GetTag(GAME_TAG.PLAYER_ID);
+            var combatHistory = PlayerLeaderboardManager.Get().GetRecentCombatHistoryForPlayer(playerId);
+
+            if (combatHistory == null || combatHistory.Count == 0)
+			{
+                return;
+			}
+
+            var lastCombat = combatHistory[combatHistory.Count - 1];
+            var winStreak = lastCombat.winStreak;
+            var winStreakLabel = GameStrings.Get("GAMEPLAY_BACON_WIN_STREAK_ICON");
+            ret.Add(AccessibleSpeechUtils.CombineWordsWithColon(winStreakLabel, winStreak.ToString()));
+
+            var lastCombatToRead = Math.Max(0, combatHistory.Count - PlayerLeaderboardRecentCombatsPanel.MAX_VISIBLE_COMBATS_PER_PANEL);
+
+            for (int i = combatHistory.Count - 1; i >= lastCombatToRead; i--)
+			{
+                var combat = combatHistory[i];
+                var combatSummary = FormatCombatSummary(combat);
+                AccessibleCardUtils.AddLineIfExists(combatSummary, ret);
+			}
+        }
+
+		private string FormatCombatSummary(PlayerLeaderboardRecentCombatsPanel.RecentCombatInfo combat)
+		{
+            var opponentTile = PlayerLeaderboardManager.Get().GetTileForPlayerId(combat.opponentId);
+
+            if (opponentTile == null)
+			{
+                // Can happen at the start of the game and during the tutorial
+                AccessibilityUtils.LogDebug($"Attempted to format combat against null opponent. ownerId={combat.ownerId} opponentId={combat.opponentId} isDefeated={combat.isDefeated}");
+                return null;
+			}
+
+            var opponentHeroName = opponentTile.GetHeroName();
+
+            if (combat.damageTarget == combat.ownerId)
+			{
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TOOK_DAMAGE, combat.damage, opponentHeroName);
+			}
+            else if (combat.damageTarget == combat.opponentId)
+			{
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_DEALT_DAMAGE, combat.damage, opponentHeroName);
+			}
+            else
+			{
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TIED, opponentHeroName);
+			}
+		}
+
+		private string GetName()
+		{
+            var playerId = m_card.m_playerHeroEntity.GetTag(GAME_TAG.PLAYER_ID);
+            var playerName = GameState.Get().GetGameEntity().GetBestNameForPlayer(playerId);
+            var asHeroText = GameStrings.Format("GAMEPLAY_BACON_ALTERNATE_PLAYER_NAME", m_card.GetHeroName());
+
+            return $"{playerName} {asHeroText}";
+		}
+
+		private string GetPosition()
+		{
+            var place = m_card?.m_playerHeroEntity?.GetRealTimePlayerLeaderboardPlace() ?? 0;
+
+            return TB_BaconShop.GetPlaceString(place);
+		}
+
+		private void AddHealthAndArmorLines(List<string> ret)
+		{
+            var heroEntity = m_card.m_playerHeroEntity;
+
+            if (heroEntity == null)
+			{
+                return;
+			}
+
+            // Note: Kel'Thuzad sometimes has negative health for a while which is just weird
+            var health = Math.Max(0, heroEntity.GetCurrentHealth());
+
+			ret.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, health));
+
+			var armor = heroEntity.GetArmor();
+
+			if (armor > 0)
+			{
+				ret.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+			}
+		}
+
+		private string GetTavernTier()
+		{
+            var tier = m_card?.m_playerHeroEntity?.GetRealTimePlayerTechLevel();
+
+            if (tier == 0)
+			{
+                return "";
+			}
+
+			return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER, tier);
+		}
+
+		private string GetRacesText()
+		{
+            return m_card.m_recentCombatsPanel?.m_accessibleRacesCounter;
+		}
+
+		private string GetTriplesText()
+		{
+            var triples = PlayerLeaderboardCard.GetPlayerTriples(m_card.m_playerHeroEntity);
+            var triplesCreatedLabel = LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARD_STATS_PLAYER_TRIPLES_CREATED);
+
+            return AccessibleSpeechUtils.CombineWordsWithColon(triplesCreatedLabel, triples.ToString());
+        }
+
+        internal PlayerLeaderboardCard GetCard()
+		{
+            return m_card;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/BattlegroundsCardEffectInterpreter.cs b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/BattlegroundsCardEffectInterpreter.cs
new file mode 100644
index 0000000..2881273
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Battlegrounds/BattlegroundsCardEffectInterpreter.cs
@@ -0,0 +1,282 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    public class BattlegroundsCardEffectInterpreter
+    {
+        private static HashSet<string> s_relevantAvengerCards = new HashSet<string>() {
+			"BG21_009", "BG21_009_G", "BG21_030", "BG21_030_G", "BG21_031", "BG21_031_G",
+			"BG22_HERO_002_Buddy", "BG22_HERO_002_Buddy_G", "BG22_HERO_003_Buddy", "BG22_HERO_003_Buddy_G"
+		};
+
+		private static HashSet<string> s_relevantTriggerCards = new HashSet<string>()
+		{
+			"BGS_110", "BGS_111", "BGS_204", "BG21_024", "BG21_024_G", "BG20_HERO_100_Buddy", "BG20_HERO_100_Buddy_G", "BG22_HERO_305_Buddy", "BG22_HERO_305_Buddy_G",
+			"BG20_HERO_100p"
+		};
+
+		private static HashSet<string> s_tarecgosas = new HashSet<string>()
+		{
+			"BG21_015", "BG21_015_G"
+		};
+
+		// Used by regression tests only
+		internal static bool AreAllBGCardsAccountedFor(HashSet<string> cardIdsWithPermanentlyEffects)
+		{
+			var superSet = new HashSet<string>();
+			foreach (var elem in s_relevantAvengerCards) superSet.Add(elem);
+			foreach (var elem in s_relevantTriggerCards) superSet.Add(elem);
+			foreach (var elem in s_tarecgosas) superSet.Add(elem);
+
+			var ret = true;
+
+			foreach (var cardId in cardIdsWithPermanentlyEffects)
+			{
+				if (!superSet.Contains(cardId))
+				{
+					ret = false;
+					AccessibilityUtils.LogDebug($"Found unhandled BG cardID with permanently effect: {cardId}");
+				}
+			}
+
+			foreach (var cardId in superSet)
+			{
+				if (!cardIdsWithPermanentlyEffects.Contains(cardId))
+				{
+					ret = false;
+					AccessibilityUtils.LogDebug($"Found outdated BG cardID with permanently effect (no longer needed): {cardId}");
+				}
+			}
+
+			return ret;
+		}
+
+		internal static bool ShouldOutputStateDiff(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+		{
+			if (!IsFriendlyPlayerTriggerEffect(taskList))
+			{
+				return false;
+			}
+
+			var sourceEntityId = taskList.GetSourceEntity().GetEntityId();
+			var sourceEntityCardId = taskList.GetSourceEntity().GetCardId();
+
+			// Not all minions trigger in the same task as their underlying effects e.g. BG buddies trigger in a previous task
+			if (s_relevantAvengerCards.Contains(sourceEntityCardId) && HasAvengeTriggered(before, after, sourceEntityId))
+			{
+				return true;
+			}
+
+			return s_relevantTriggerCards.Contains(sourceEntityCardId);
+		}
+
+		private static bool HasAvengeTriggered(AccessibleInGameState before, AccessibleInGameState after, int entityId)
+		{
+			var beforeEntity = before.GetEntity(entityId);
+			var afterEntity = after.GetEntity(entityId);
+
+			if (beforeEntity == null || afterEntity == null )
+			{
+				return false;
+			}
+
+			var avengeTotal = afterEntity.GetTag(GAME_TAG.SCORE_VALUE_1);
+
+			var beforeCurAvenge = beforeEntity.GetTag(GAME_TAG.SCORE_VALUE_2);
+			var afterCurAvenge = afterEntity.GetTag(GAME_TAG.SCORE_VALUE_2);
+
+			if (afterCurAvenge > 0 && afterCurAvenge == avengeTotal)
+			{
+				// Note: The actual trigger will come after
+				// The order is SCORE_VALUE_2 set to SCORE_VALUE_1 and in a future task list SCORE_VALUE_2 set to 0
+				return true;
+			}
+			else if (afterCurAvenge == 0 && beforeCurAvenge == avengeTotal)
+			{
+				// We're in the task that actually applies the effects on the other minions
+				return true;
+			}
+
+			return false;
+		}
+
+		private static bool IsFriendlyPlayerTriggerEffect(PowerTaskList taskList)
+		{
+			if (taskList == null)
+			{
+				return false;
+			}
+
+			if (!taskList.IsTriggerBlock())
+			{
+				return false;
+			}
+
+			var sourceEntity = taskList.GetSourceEntity();
+
+			if (sourceEntity == null)
+			{
+				return false;
+			}
+
+			if (!sourceEntity.IsControlledByFriendlySidePlayer())
+			{
+				// Don't output opponent buffs to reduce noise since not all would always be that interesting
+				// Could be useful for Tarecgosas and SI:Sefins maybe in a 1v1 scenario at the end of the game but we'll wait for feedback
+				return false;
+			}
+
+			return true;
+		}
+
+		internal static List<string> GetTarecgosaDiffs(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState, AccessibleInGameState stateAtStartOfCombatPhase)
+		{
+			var ret = new List<string>();
+
+			if (!IsFriendlyPlayerTriggerEffect(taskList))
+			{
+				return ret;
+			}
+
+			if (AccessibleInGameState.WasAnyPlayerMinionBuffedOrDebuffed(prevState, newState, s_tarecgosas))
+			{
+				var tarecgosasAfter = GetTarecgosas(newState);
+				var tarecgosasBefore = GetTarecgosas(prevState);
+				var tarecgosasAtStartOfCombatPhase = GetTarecgosas(stateAtStartOfCombatPhase);
+
+				var tarecgosaLines = GetTarecgosaLines(tarecgosasAtStartOfCombatPhase, tarecgosasBefore, tarecgosasAfter);
+
+				if (tarecgosaLines.Count > 0)
+				{
+					var triggerSource = AccessibleSpeechUtils.GetEntityName(taskList.GetSourceEntity());
+
+					ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CARD_TRIGGERED, triggerSource));
+					ret.AddRange(tarecgosaLines);
+				}
+			}
+
+			return ret;
+		}
+
+		private static List<string> GetTarecgosaLines(List<Entity> tarecgosasAtStartOfCombatPhase, List<Entity> tarecgosasBefore, List<Entity> tarecgosasAfter)
+		{
+			var ret = new List<string>();
+
+			var socTarecgosasById = new Dictionary<int, Entity>();
+			var beforeTarecgosasById = new Dictionary<int, Entity>();
+
+			tarecgosasAtStartOfCombatPhase.ForEach(t => socTarecgosasById.Add(t.GetEntityId(), t));
+			tarecgosasBefore.ForEach(t => beforeTarecgosasById.Add(t.GetEntityId(), t));
+
+			foreach(var tarecgosa in tarecgosasAfter)
+			{
+				var entityId = tarecgosa.GetEntityId();
+
+				if (socTarecgosasById.ContainsKey(entityId) && beforeTarecgosasById.ContainsKey(entityId))
+				{
+					var diff = GetTarecgosaDiff(socTarecgosasById[entityId], beforeTarecgosasById[entityId], tarecgosa);
+
+					if (diff != null && diff.Length > 0)
+					{
+						var tarecgosaName = AccessibleSpeechUtils.GetFullNameInZone(tarecgosa);
+						ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT, tarecgosaName, diff));
+					}
+				}
+			}
+
+			return ret;
+		}
+
+		private static string GetTarecgosaDiff(Entity soc, Entity before, Entity after)
+		{
+			var lines = new List<string>();
+
+			if (after.GetCurrentHealth() <= 0)
+			{
+				return null;
+			}
+
+			if (HasTransformed(before, after))
+			{
+				// Normal to Golden Tarecgosas would be covered by this
+				lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TRANSFORMED, AccessibleSpeechUtils.GetEntityName(after)));
+				return AccessibleSpeechUtils.HumanizeList(lines);
+			}
+
+			var gainedDescriptions = new List<string>();
+
+			// Effects
+			var gainedDivineShield = after.HasDivineShield() && !before.HasDivineShield() && !before.HasDivineShield();
+			var gainedWindfury = after.HasWindfury() && !before.HasWindfury() && !before.HasWindfury();
+			var gainedTaunt = after.HasTaunt() && !before.HasTaunt() && !soc.HasTaunt();
+			var gainedReborn = after.HasReborn() && !before.HasReborn() && !soc.HasReborn();
+			var becamePoisonous = after.IsPoisonous() && !before.IsPoisonous() && !before.IsPoisonous();
+			// TODO: Think about deathrattles as those would be considerably harder (does N'Zoth's fish become permanent?)
+
+			if (gainedDivineShield) gainedDescriptions.Add(LocalizedText.GLOBAL_DIVINE_SHIELD);
+			if (gainedWindfury) gainedDescriptions.Add(LocalizedText.GLOBAL_WINDFURY);
+			if (gainedTaunt) gainedDescriptions.Add(LocalizedText.GLOBAL_TAUNT);
+			if (gainedReborn) gainedDescriptions.Add(LocalizedText.GLOBAL_REBORN);
+			if (becamePoisonous) lines.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS));
+
+			// Stats
+			var atkDiff = after.GetATK() - before.GetATK();
+			var healthDiff = after.GetHealth() - before.GetHealth();
+
+			if (atkDiff > 0) gainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, atkDiff));
+			if (healthDiff > 0) gainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, healthDiff));
+
+			// Group everything together
+			var groupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(gainedDescriptions);
+
+			if (groupedGainedDescriptions.Length > 0)
+			{
+				lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_GAINED_STATS, groupedGainedDescriptions));
+			}
+
+			return AccessibleSpeechUtils.HumanizeList(lines);
+		}
+
+		private static bool HasTransformed(Entity before, Entity after)
+		{
+			if (before == null || after == null)
+			{
+				return false;
+			}
+
+			var beforeName = AccessibleSpeechUtils.GetEntityName(before);
+			var afterName = AccessibleSpeechUtils.GetEntityName(after);
+
+			return !beforeName.Equals(afterName);
+		}
+
+		private static List<Entity> GetTarecgosas(AccessibleInGameState state)
+		{
+			var ret = new List<Entity>();
+
+			foreach(var minion in state.GetPlayerMinions())
+			{
+				if (IsTarecgosa(minion))
+				{
+					ret.Add(minion);
+				}
+			}
+
+			return ret;
+		}
+
+		private static bool IsTarecgosa(Entity minion)
+		{
+			if (minion == null)
+			{
+				return false;
+			}
+
+			return s_tarecgosas.Contains(minion.GetCardId());
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs b/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
new file mode 100644
index 0000000..9c8bbf1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
@@ -0,0 +1,449 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    public class CardEffectInterpreter
+    {
+        private static HashSet<string> friendlyCards = new HashSet<string>() { "AT_002", "AT_006", "AT_009", "AT_010", "AT_013", "AT_015", "AT_016", "AT_018", "AT_019", "AT_019e", "AT_024", "AT_028", "AT_029", "AT_031", "AT_033", "AT_035", "AT_035t", "AT_037b", "AT_038", "AT_039", "AT_040", "AT_041", "AT_042", "AT_043", "AT_046", "AT_047", "AT_048", "AT_049", "AT_053", "AT_054", "AT_055", "AT_057", "AT_058", "AT_060", "AT_061", "AT_062", "AT_066", "AT_068", "AT_069", "AT_072", "AT_073", "AT_074", "AT_076", "AT_077", "AT_079", "AT_082", "AT_083", "AT_084", "AT_089", "AT_090", "AT_091", "AT_096", "AT_099", "AT_100", "AT_104", "AT_108", "AT_111", "AT_112", "AT_113", "AT_115", "AT_115e", "AT_118", "AT_119", "AT_127", "AT_128", "AT_132", "AT_132_SHAMANa", "AT_132_SHAMANe", "AT_132_WARLOCKa", "AT_132_WARLOCKb", "AT_133", "AV_101", "AV_107", "AV_109", "AV_113", "AV_113p", "AV_113t2", "AV_113t3", "AV_113t7", "AV_113t8", "AV_113t9", "AV_116", "AV_119", "AV_124", "AV_130", "AV_136t", "AV_139", "AV_147", "AV_201", "AV_203p", "AV_203pe", "AV_203po", "AV_204", "AV_205", "AV_205a", "AV_205p", "AV_205pb", "AV_206p", "AV_207", "AV_207p", "AV_211", "AV_213", "AV_215", "AV_226", "AV_244", "AV_256", "AV_258p2", "AV_258pt", "AV_258t", "AV_258t2", "AV_260", "AV_264", "AV_268", "AV_269", "AV_269e", "AV_277", "AV_281", "AV_282", "AV_282t2", "AV_282t4", "AV_283", "AV_284", "AV_290", "AV_292", "AV_293", "AV_293e", "AV_294", "AV_295", "AV_295a", "AV_295b", "AV_296e", "AV_309", "AV_316hp", "AV_316t4", "AV_317", "AV_323", "AV_326", "AV_328", "AV_329", "AV_330", "AV_331e", "AV_333", "AV_334", "AV_336", "AV_336e", "AV_337", "AV_338", "AV_339", "AV_340", "AV_341", "AV_342", "AV_343", "AV_344", "AV_360", "AV_400", "AV_405", "AV_565", "AV_657", "AV_660", "AV_661", "AV_664", "AV_710", "AV_COIN1", "AV_COIN2", "BAR_021", "BAR_025", "BAR_026", "BAR_030", "BAR_031", "BAR_034", "BAR_034t", "BAR_034t2", "BAR_037", "BAR_038", "BAR_041", "BAR_042", "BAR_060", "BAR_061", "BAR_063", "BAR_065", "BAR_070", "BAR_072", "BAR_073", "BAR_077", "BAR_079t10", "BAR_079t10b", "bar_079t10c", "BAR_079t11", "BAR_079t15", "BAR_079t15b", "BAR_079t15c", "BAR_080", "BAR_081", "BAR_308", "BAR_309", "BAR_310", "BAR_318", "BAR_321", "BAR_323", "BAR_324", "BAR_325", "BAR_326", "BAR_327", "BAR_328", "BAR_329", "BAR_330", "BAR_533", "BAR_534", "BAR_535", "BAR_537e", "BAR_539", "BAR_540", "BAR_542", "BAR_546", "BAR_549", "BAR_550", "BAR_551", "BAR_552e", "BAR_552o", "BAR_721t", "BAR_751", "BAR_812", "BAR_841", "BAR_842", "BAR_842t", "BAR_842t2", "BAR_843", "BAR_854e", "BAR_873", "BAR_880", "BAR_880t", "BAR_880t2", "BAR_881", "BAR_888", "BAR_891", "BAR_891t", "BAR_891t2", "BAR_896", "BAR_914", "BAR_914t", "BAR_914t2", "BAR_915", "BAR_919t", "BAR_COIN1", "BAR_COIN2", "BAR_COIN3", "BCON_004", "BCON_012", "BCON_015", "BCON_016", "BCON_024", "BG19_010", "BG19_010_G", "BG20_100", "BG20_100_G", "BG20_101", "BG20_101_G", "BG20_105", "BG20_105_G", "BG20_201", "BG20_201_G", "BG20_204", "BG20_210", "BG20_210_G", "BG20_303", "BG20_303_G", "BG20_GEM", "BG20_GEMt", "BG20_HERO_100p", "BG20_HERO_102p", "BG20_HERO_102pe", "BG20_HERO_102pe_Buddy", "BG20_HERO_201_Buddy", "BG20_HERO_201_Buddy_G", "BG20_HERO_201p", "BG20_HERO_201p2", "BG20_HERO_202pt", "BG20_HERO_242p", "BG20_HERO_283_Buddy", "BG20_HERO_283_Buddy_G", "BG20_HERO_283p_t2", "BG20_HERO_666p_t0", "BG20_HERO_666p_t3a", "BG20_HERO_666p_t3b", "BG20_HERO_666p_t3c", "BG20_HERO_666p_t3d", "BG20_HERO_666p_t4a", "BG20_HERO_666p_t4b", "BG20_HERO_666p_t4c", "BG20_HERO_666p_t4d", "BG20_HERO_666p_t5a", "BG20_HERO_666p_t5b", "BG20_HERO_666p_t5c", "BG20_HERO_666p_t5d", "BG20_HERO_666p_t6a", "BG20_HERO_666p_t6b", "BG20_HERO_666p_t6c", "BG20_HERO_666p_t6d", "BG21_000", "BG21_000_G", "BG21_000_Ge", "BG21_000e", "BG21_001", "BG21_001_G", "BG21_002", "BG21_002_G", "BG21_003", "BG21_003_G", "BG21_005", "BG21_005_G", "BG21_006", "BG21_006_G", "BG21_007", "BG21_007_G", "BG21_009", "BG21_009_G", "BG21_010", "BG21_010_G", "BG21_013", "BG21_013_G", "BG21_017", "BG21_017_G", "BG21_021", "BG21_021_G", "BG21_024", "BG21_024_G", "BG21_025", "BG21_025_G", "BG21_029", "BG21_029_G", "BG21_038", "BG21_038_G", "BG21_040", "BG21_HERO_000_Buddy", "BG21_HERO_000_Buddy_G", "BG21_HERO_000p", "BG21_HERO_000p2", "BG21_HERO_000p3", "BG21_HERO_010_Buddy_G", "BG21_HERO_010p", "BG21_HERO_020p", "BG21_HERO_030p", "BG21_HERO_030pe", "BG22_HERO_001p_t1", "BG22_HERO_001p_t1_s", "BG22_HERO_001p_t1e", "BG22_HERO_001p_t2", "BG22_HERO_001p_t2_s", "BG22_HERO_001p_t3_s", "BG22_HERO_002_Buddy", "BG22_HERO_002_Buddy_G", "BG22_HERO_002p", "BG22_HERO_003_Buddy", "BG22_HERO_003_Buddy_G", "BG22_HERO_003p", "BG22_HERO_305_Buddy", "BG22_HERO_305_Buddy_G", "BGS_001", "BGS_006", "BGS_009", "BGS_010", "BGS_012", "BGS_014", "BGS_017", "BGS_018", "BGS_020", "BGS_021", "BGS_023", "BGS_024", "BGS_025", "BGS_028", "BGS_030", "BGS_031", "BGS_036", "BGS_038", "BGS_040", "BGS_044", "BGS_046t", "BGS_048", "BGS_053", "BGS_056", "BGS_061", "BGS_066", "BGS_069", "BGS_071", "BGS_079", "BGS_080", "BGS_082", "BGS_083", "BGS_105", "BGS_112", "BGS_121", "BGS_123", "BGS_128", "BGS_200", "BGS_202", "BGS_204", "BGS_Treasures_000", "BGS_Treasures_001", "BGS_Treasures_004", "BGS_Treasures_007", "BGS_Treasures_009", "BGS_Treasures_010", "BGS_Treasures_011", "BGS_Treasures_012", "BGS_Treasures_013", "BGS_Treasures_015", "BGS_Treasures_016", "BGS_Treasures_018", "BGS_Treasures_019", "BGS_Treasures_020", "BGS_Treasures_026", "BGS_Treasures_028", "BGS_Treasures_032", "BOM_003p", "BOM_01_ArrivalInOrgrimmar_01s", "BOM_01_Brukan_01p", "BOM_01_Brukan_08t", "BOM_01_Dawngrasp_04t", "BOM_01_ForTheHorde_05s", "BOM_01_Golem_05p", "BOM_01_Guff_02t", "BOM_01_Guff_03p2", "BOM_01_Guff_04p2", "BOM_01_Guff_05p2", "BOM_01_Guff_06p2", "BOM_01_Guff_07p2", "BOM_01_HezrulBloodmark_02p", "BOM_01_IshaAwak_04p", "BOM_01_Plaguemaw_03p", "BOM_01_PrideOfTheFrostwolves_0", "BOM_01_StrengthAndHonor_05s_Copy", "BOM_01_Tamsin_03t", "BOM_01_Tamsin_04p3", "BOM_01_Tamsin_05p3", "BOM_01_Tamsin_06p3", "BOM_01_Tamsin_07p3", "BOM_02_AWildAnimal_01s", "BOM_02_Garona_008hb", "BOM_02_Kargal_01p", "BOM_02_Octobot_07p", "BOM_02_OneCoin_01s", "BOM_02_SludgeBeast_03p", "BOM_02_TavishSharesHisLoot_01s", "BOM_02_TavishTamesABeast_01s", "BOM_02_ThreeCoins_01s", "BOM_02_TwoCoins_01s", "BOM_02_Whirleygig_04p", "BOM_02_Xyrella_01p1", "BOM_02_Xyrella_01p2", "BOM_02_XyrellasPrayer_06s", "BOM_03_Anacondra_06p", "BOM_03_AngryTreant_01p", "BOM_03_Barak_03p", "BOM_03_Dawngrasp_02p", "BOM_03_Guff_01p", "BOM_03_Guff_08p", "BOM_03_GuffTrips_01s", "BOM_03_Mutanus_07p", "BOM_03_Party_05p", "BOM_03_RestAndRelaxation_03s", "BOM_03_Rokara_02p", "BOM_03_Smythe_04p", "BOM_03_Snapjaw_04s", "BOM_03_Tamsin_08t", "BOM_03_Vapos_02p", "BOM_04_Aquarrior_006t", "BOM_04_BurningBladeSummoner_005t", "BOM_04_Cariel_005p", "BOM_04_Cariel_006p", "BOM_04_Kurtrus_001p4", "BOM_04_Tamsin_008p", "BOM_04_TamsinsPerfume_008s", "BOM_04_Tavish_005p", "BOM_04_Tavish_006p", "BOM_04_Xyrella_005p", "BOM_04_Xyrella_006p", "BOM_05_Bolvar_007hb", "BOM_05_Bolvar_007p", "BOM_05_Guff_004p", "BOM_05_Guff_03t", "BOM_05_Rokara_004p", "BOM_05_Tamsin_001p", "BOM_05_Tamsin_002p", "BOM_05_Tamsin_004p", "BOM_06_Anetheron_006p", "BOM_06_Cariel_002p", "BOM_06_Cariel_003p", "BOM_06_Cariel_004p", "BOM_06_Cariel_005p", "BOM_06_Cariel_005p2", "BOM_06_Cariel_006p", "BOM_06_Cariel_006p2", "BOM_06_Cariel_007p", "BOM_06_Cariel_008p", "BOM_06_CarielsHealing_006s", "BOM_06_Kurtrus_006t", "BOM_06_Monstrosity_007p", "BOM_06_SummonInfernal_005s", "BOM_06_Tamsin_008p", "BOM_06_YoungSisters_001s", "BOM_06_YoungTamsin_001p", "BOM_07_Aquarrior_006t", "BOM_07_Roadboar_001t", "BOM_07_Scabbs_Bob_001p", "BOM_07_Scabbs_Cariel_005p", "BOM_07_Scabbs_Cariel_006p", "BOM_07_Scabbs_Cariel_007p", "BOM_07_Scabbs_Dawngrasp_003t", "BOM_07_Scabbs_EdwinVanCleef_008p", "BOM_07_Scabbs_Hogger_003p", "BOM_07_Scabbs_Kurtrus_005p", "BOM_07_Scabbs_Kurtrus_006p", "BOM_07_Scabbs_Kurtrus_007p", "BOM_07_Scabbs_MrSmite_006p3", "BOM_07_Scabbs_Sneed_005p", "BOM_07_Scabbs_Sneed_005pe", "BOM_07_Scabbs_Tavish_005p", "BOM_07_Scabbs_Tavish_006p", "BOM_07_Scabbs_Tavish_007p", "BOM_07_Scallywag_001t", "BOM_08_CallPet_004s", "BOM_08_Guff_003t", "BOM_08_Guff_008t", "BOM_08_Kodobane_004t", "BOM_08_Mida_008t", "BOM_08_Rokara_008t", "BOM_08_Scabbs_002t", "BOM_08_Scabbs_003t", "BOM_08_Scabbs_005t", "BOM_08_Scabbs_008t", "BOM_08_Simulacrum_004s", "BOM_08_Tavish_Drekthar_006p", "BOM_08_Tavish_Kazakusan_008p", "BOM_08_Tavish_Tavish_001p", "BOM_08_Tavish_Tavish_002p", "BOM_08_Tavish_Tavish_003p", "BOM_08_Tavish_Tavish_004p", "BOM_08_Tavish_Tavish_005p", "BOM_08_Tavish_Tavish_006p", "BOM_08_Tavish_Tavish_007p", "BOM_08_Tavish_Tavish_008p", "BOM_08_Tracking_004s", "BOM_08_Xyrella_002t", "BOM_08_Xyrella_003t", "BOM_08_Xyrella_008t", "BOM_09_Brukan_001p", "BOM_09_Brukan_002p", "BOM_09_Brukan_004p", "BOM_09_Brukan_005p", "BOM_09_Brukan_006p", "BOM_09_Guff_003p", "BOM_09_Guff_006t", "BOM_09_Guff_008t", "BOM_09_Ichman_003p", "BOM_09_Primalist_005p", "BOM_09_Rokara_006t", "BOM_09_Rokara_008t", "BOM_09_Scabbs_008t", "BOM_09_Supplies_004t", "BOM_09_Tamsin_001p", "BOM_09_Vanndar_007p", "BOM_09_Xyrella_008t", "BOT_034", "BOT_038", "BOT_042", "BOT_054", "BOT_066", "BOT_067", "BOT_069", "BOT_079", "BOT_083", "BOT_084", "BOT_087", "BOT_093", "BOT_099", "BOT_101", "BOT_107", "BOT_218", "BOT_219", "BOT_219t", "BOT_224", "BOT_226", "BOT_234", "BOT_238p2", "BOT_238p4", "BOT_238p6", "BOT_242", "BOT_243", "BOT_254", "BOT_256", "BOT_258e", "BOT_263", "BOT_267", "BOT_270", "BOT_280", "BOT_283", "BOT_286", "BOT_288", "BOT_291", "BOT_299", "BOT_312", "BOT_312e", "BOT_401", "BOT_402", "BOT_404", "BOT_407", "BOT_411e", "BOT_411e2", "BOT_413", "BOT_419", "BOT_420", "BOT_422", "BOT_422a", "BOT_422b", "BOT_423", "BOT_429", "BOT_431", "BOT_433", "BOT_435", "BOT_436", "BOT_437", "BOT_438", "BOT_438e", "BOT_443", "BOT_444", "BOT_444e", "BOT_445", "BOT_451", "BOT_507", "BOT_508", "BOT_509", "BOT_511", "BOT_517", "BOT_521", "BOT_529", "BOT_532", "BOT_533", "BOT_535", "BOT_537", "BOT_539", "BOT_562", "BOT_565", "BOT_567", "BOT_568", "BOT_573", "BOT_576", "BOT_600", "BOT_700", "BOT_700e", "BOT_908", "BOT_909", "BOT_910", "BOT_912", "BOT_913", "BOTA_203", "BOTA_207", "BOTA_211", "BOTA_231", "BOTA_231e", "BOTA_232", "BOTA_241", "BRM_001", "BRM_006", "BRM_007", "BRM_012", "BRM_017", "BRM_018", "BRM_018e", "BRM_019", "BRM_022", "BRM_026", "BRM_027", "BRM_028", "BRM_030", "BRMA_01", "BRMA01_4", "BRMA02_2", "BRMA02_2_2_TB", "BRMA02_2_2c_TB", "BRMA02_2H", "BRMA04_4", "BRMA04_4H", "BRMA06_2", "BRMA06_2H", "BRMA06_2H_TB", "BRMA09_2", "BRMA09_2_TB", "BRMA09_2H", "BRMA09_3", "BRMA09_3H", "BRMA09_4", "BRMA09_4H", "BRMA09_5", "BRMA09_5H", "BRMA10_3", "BRMA10_3H", "BRMA11_2H", "BRMA11_2H_2_TB", "BRMA12_2", "BRMA12_2H", "BRMA15_3", "BRMA17_5", "BRMA17_5_TB", "BRMA17_5H", "BRMC_84", "BRMC_87", "BRMC_92", "BRMC_93", "BRMC_95h", "BRMC_95he", "BRMC_96", "BRMC_99", "BT_003", "BT_006", "BT_008", "BT_009", "BT_010", "BT_014", "BT_018", "BT_019t", "BT_021", "BT_022", "BT_024", "BT_025", "BT_025e", "BT_035", "BT_036", "BT_042", "BT_101", "BT_109", "BT_113", "BT_115", "BT_124", "BT_128", "BT_129", "BT_130", "BT_132", "BT_135", "BT_136t", "BT_136ta", "BT_136tb", "BT_142", "BT_155", "BT_159", "BT_160", "BT_160e", "BT_163", "BT_173", "BT_175", "BT_175t", "BT_188", "BT_190", "BT_198", "BT_202", "BT_203", "BT_210", "BT_210t", "BT_212", "BT_213", "BT_214", "BT_249", "BT_252", "BT_253", "BT_256", "BT_257", "BT_292", "BT_300", "BT_302", "BT_304", "BT_306", "BT_309t", "BT_321", "BT_341", "BT_352", "BT_407", "BT_416", "BT_416e", "BT_427", "BT_480", "BT_481", "BT_486", "BT_488", "BT_491", "BT_509", "BT_512", "BT_702", "BT_703", "BT_707", "BT_709", "BT_713", "BT_720", "BT_721", "BT_726", "BT_728", "BT_735", "BT_752", "BT_753", "BT_761", "BT_814", "BT_922", "BT_COIN", "BTA_01p", "BTA_03", "BTA_05", "BTA_06", "BTA_07", "BTA_08", "BTA_09", "BTA_12", "BTA_15", "BTA_16", "BTA_BOSS_03p", "BTA_BOSS_07s4", "BTA_BOSS_10t", "BTA_BOSS_12p", "BTA_BOSS_13p", "BTA_BOSS_14p", "BTA_BOSS_16p", "BTA_BOSS_16s", "BTA_BOSS_16t2", "BTA_BOSS_16te3", "BTA_BOSS_22p", "BTA_BOSS_24t", "BTA_BOSS_25p", "BTA_BOSS_26s", "CFM_026", "CFM_061", "CFM_062", "CFM_063", "CFM_064", "CFM_067", "CFM_095", "CFM_120", "CFM_305", "CFM_308", "CFM_308a", "CFM_310", "CFM_312", "CFM_313", "CFM_315", "CFM_316", "CFM_321", "CFM_334", "CFM_336", "CFM_338", "CFM_343", "CFM_344", "CFM_602", "CFM_602a", "CFM_602b", "CFM_604", "CFM_605", "CFM_606", "CFM_610", "CFM_611", "CFM_614", "CFM_616", "CFM_619", "CFM_620", "CFM_621t10", "CFM_621t17", "CFM_621t20", "CFM_621t22", "CFM_621t23", "CFM_621t24", "CFM_621t26", "CFM_621t28", "CFM_621t3", "CFM_621t30", "CFM_621t31", "CFM_621t32", "CFM_621t37", "CFM_621t38", "CFM_621t39", "CFM_621t6", "CFM_621t8", "CFM_621t9", "CFM_626", "CFM_630", "CFM_639", "CFM_643", "CFM_648", "CFM_649", "CFM_650", "CFM_651", "CFM_654", "CFM_659", "CFM_660", "CFM_661", "CFM_663", "CFM_668", "CFM_668t", "CFM_668t2", "CFM_669", "CFM_672", "CFM_685", "CFM_691", "CFM_694", "CFM_713", "CFM_715", "CFM_717", "CFM_750", "CFM_752", "CFM_753", "CFM_754", "CFM_755", "CFM_800", "CFM_806", "CFM_811", "CFM_816", "CFM_852", "CFM_853", "CFM_902", "CFM_905", "CFM_940", "CORE_AT_047", "CORE_AT_055", "CORE_AT_061", "CORE_BOT_083", "CORE_BOT_420", "CORE_BOT_533", "CORE_BT_035", "CORE_BT_036", "CORE_BT_416", "CORE_BT_427", "CORE_BT_480", "CORE_BT_491", "CORE_CS2_009", "CORE_CS2_013", "CORE_CS2_023", "CORE_CS2_039", "CORE_CS2_045", "CORE_CS2_073", "CORE_CS2_074", "CORE_CS2_077", "CORE_CS2_088", "CORE_CS2_089", "CORE_CS2_092", "CORE_CS2_117", "CORE_CS2_188", "CORE_DS1_184", "CORE_EX1_004", "CORE_EX1_011", "CORE_EX1_012", "CORE_EX1_014", "CORE_EX1_046", "CORE_EX1_059", "CORE_EX1_084", "CORE_EX1_093", "CORE_EX1_096", "CORE_EX1_103", "CORE_EX1_110", "CORE_EX1_130", "CORE_EX1_145", "CORE_EX1_158", "CORE_EX1_160", "CORE_EX1_164", "CORE_EX1_165", "CORE_EX1_169", "CORE_EX1_178", "CORE_EX1_188", "CORE_EX1_189", "CORE_EX1_190", "CORE_EX1_193", "CORE_EX1_194", "CORE_EX1_195", "CORE_EX1_248", "CORE_EX1_287", "CORE_EX1_289", "CORE_EX1_294", "CORE_EX1_362", "CORE_EX1_506", "CORE_EX1_509", "CORE_EX1_534", "CORE_EX1_554", "CORE_EX1_571", "CORE_EX1_573", "CORE_EX1_575", "CORE_EX1_611", "CORE_EX1_623", "CORE_FP1_007", "CORE_FP1_011", "CORE_FP1_020", "CORE_GIL_191", "CORE_GIL_828", "CORE_GVG_053", "CORE_ICC_026", "CORE_ICC_809", "CORE_KAR_009", "CORE_KAR_065", "CORE_KAR_069", "CORE_LOE_012", "CORE_NEW1_018", "CORE_NEW1_026", "CORE_OG_047", "CORE_OG_070", "CORE_OG_241", "CORE_OG_273", "CORE_TRL_243", "CORE_UNG_020", "CRED_02", "CRED_04", "CRED_09", "CRED_103", "CRED_106", "CRED_107", "CRED_109", "CRED_11", "CRED_110", "CRED_111", "CRED_115", "CRED_12", "CRED_13", "CRED_20", "CRED_25", "CRED_28", "CRED_37", "CRED_41", "CRED_51", "CRED_53", "CRED_57", "CRED_59", "CRED_74", "CRED_75", "CRED_77", "CRED_79", "CRED_80", "CRED_82", "CRED_89", "CRED_90", "CRED_91", "CRED_92", "CRED_94", "CRED_95", "CRED_99", "CS1h_001_H1", "CS1h_001_H1_AT_132", "CS1h_001_H2", "CS1h_001_H2_AT_132", "CS1h_001_H3", "CS2_003", "CS2_004", "CS2_004_Puzzle", "CS2_005", "CS2_007", "CS2_009", "CS2_011", "CS2_013", "CS2_013t", "CS2_023", "CS2_027", "CS2_038", "CS2_039", "CS2_041", "CS2_045", "CS2_046", "CS2_049_H1", "CS2_049_H1_AT_132", "CS2_049_H2", "CS2_049_H2_AT_132", "CS2_049_H3", "CS2_049_H3_AT_132", "CS2_049_H4", "CS2_049_H4_AT_132", "CS2_049_H5", "CS2_053", "CS2_053e", "CS2_056_H1", "CS2_056_H2", "CS2_056_H3", "CS2_058", "CS2_059", "CS2_073", "CS2_074", "CS2_077", "CS2_087", "CS2_088", "CS2_089", "CS2_092", "CS2_101_H1", "CS2_101_H1_AT_132", "CS2_101_H2", "CS2_101_H2_AT_132", "CS2_101_H3", "CS2_101_H3_AT_132", "CS2_101_H4", "CS2_102_H1", "CS2_102_H1_AT_132", "CS2_102_H2", "CS2_102_H2_AT_132", "CS2_102_H3", "CS2_102_H3_AT_132", "CS2_102_H4", "CS2_102_H4_AT_132", "CS2_103", "CS2_104", "CS2_105", "CS2_117", "CS2_147", "CS2_151", "CS2_188", "CS2_196", "CS2_226", "CS2_236", "CS2_237", "CS3_005", "CS3_008e", "CS3_009", "CS3_012e", "CS3_015", "CS3_017", "CS3_024", "CS3_028", "CS3_029", "CS3_033", "CS3_034", "DAL_007", "DAL_008", "DAL_010", "DAL_040", "DAL_049", "DAL_059", "DAL_060", "DAL_062", "DAL_064", "DAL_070", "DAL_077", "DAL_078", "DAL_087", "DAL_088", "DAL_095", "DAL_141", "DAL_141ts", "DAL_146", "DAL_147", "DAL_163", "DAL_256", "DAL_256ts", "DAL_350b", "DAL_351", "DAL_351ts", "DAL_352", "DAL_354", "DAL_355", "DAL_357", "DAL_376", "DAL_377", "DAL_378", "DAL_378ts", "DAL_400", "DAL_413", "DAL_415", "DAL_416", "DAL_422", "DAL_432", "DAL_433", "DAL_544", "DAL_550", "DAL_553", "DAL_554", "DAL_558", "DAL_560", "DAL_563", "DAL_565", "DAL_568", "DAL_568ts", "DAL_570", "DAL_575", "DAL_578", "DAL_579p", "DAL_581", "DAL_582", "DAL_582t", "DAL_587", "DAL_589", "DAL_602", "DAL_604", "DAL_607", "DAL_608", "DAL_609", "DAL_613", "DAL_710", "DAL_710e", "DAL_720", "DAL_721", "DAL_724", "DAL_727", "DAL_729", "DAL_731", "DAL_733", "DAL_736", "DAL_739", "DAL_741", "DAL_743", "DAL_747", "DAL_752", "DAL_773", "DAL_774", "DAL_799", "DAL_COIN", "DALA_702", "DALA_703", "DALA_704", "DALA_705", "DALA_707", "DALA_708", "DALA_711", "DALA_716", "DALA_717", "DALA_719", "DALA_721", "DALA_725", "DALA_727", "DALA_733", "DALA_736", "DALA_737", "DALA_738", "DALA_740ts5", "DALA_741", "DALA_741e", "DALA_743", "DALA_747e", "DALA_829t", "DALA_854", "DALA_854e", "DALA_854e2", "DALA_902", "DALA_905", "DALA_907", "DALA_908", "DALA_910", "DALA_913", "DALA_BOSS_03p", "DALA_BOSS_03px", "DALA_BOSS_03t3", "DALA_BOSS_03t4", "DALA_BOSS_04p", "DALA_BOSS_05p", "DALA_BOSS_06p", "DALA_BOSS_06px", "DALA_BOSS_09p", "DALA_BOSS_09px", "DALA_BOSS_14p", "DALA_BOSS_14px", "DALA_BOSS_16p", "DALA_BOSS_16px", "DALA_BOSS_18p", "DALA_BOSS_18px", "DALA_BOSS_25t", "DALA_BOSS_27p", "DALA_BOSS_30p", "DALA_BOSS_31p", "DALA_BOSS_31px", "DALA_BOSS_32p", "DALA_BOSS_34p", "DALA_BOSS_37p", "DALA_BOSS_37px", "DALA_BOSS_38p", "DALA_BOSS_38px", "DALA_BOSS_38t", "DALA_BOSS_39p", "DALA_BOSS_41p", "DALA_BOSS_41px", "DALA_BOSS_42p", "DALA_BOSS_42px", "DALA_BOSS_44p", "DALA_BOSS_44px", "DALA_BOSS_46p", "DALA_BOSS_46px", "DALA_BOSS_47p", "DALA_BOSS_47px", "DALA_BOSS_51p", "DALA_BOSS_52p", "DALA_BOSS_52px", "DALA_BOSS_53p", "DALA_BOSS_53px", "DALA_BOSS_55p", "DALA_BOSS_55px", "DALA_BOSS_56p", "DALA_BOSS_60p", "DALA_BOSS_60px", "DALA_BOSS_62p", "DALA_BOSS_66p", "DALA_BOSS_67p", "DALA_BOSS_68p", "DALA_BOSS_68px", "DALA_BOSS_69p", "DALA_BOSS_69px", "DALA_BOSS_71p", "DALA_BOSS_71px", "DALA_BOSS_73p", "DALA_BOSS_73px", "DALA_BOSS_74p", "DALA_BOSS_74px", "DALA_BOSS_75p", "DALA_Druid_HP1", "DALA_Druid_HP2", "DALA_Hunter_HP1", "DALA_Hunter_HP2", "DALA_Paladin_HP1", "DALA_Paladin_HP2", "DALA_Priest_HP1", "DALA_Priest_HP2", "DALA_Shaman_HP2", "DALA_Warlock_HP2", "DALA_Warrior_HP2", "DED_002", "DED_003", "DED_005", "DED_009", "DED_500", "DED_504", "DED_505", "DED_506", "DED_508", "DED_510", "DED_511", "DED_512", "DED_514", "DED_514e", "DED_516", "DED_524", "DMF_002", "DMF_004t1", "DMF_004t2", "DMF_053", "DMF_055", "DMF_056", "DMF_057e", "DMF_057o", "DMF_058", "DMF_058e", "DMF_058o", "DMF_061", "DMF_061a", "DMF_061b", "DMF_061t", "DMF_064", "DMF_065t", "DMF_069", "DMF_073", "DMF_075", "DMF_080", "DMF_083", "DMF_084", "DMF_086", "DMF_088", "DMF_089", "DMF_090", "DMF_090t", "DMF_091", "DMF_100", "DMF_104", "DMF_105", "DMF_105t", "DMF_106", "DMF_107", "DMF_109", "DMF_111", "DMF_113", "DMF_119", "DMF_121", "DMF_122", "DMF_123", "DMF_124", "DMF_124t", "DMF_125", "DMF_163", "DMF_184", "DMF_186", "DMF_186a", "DMF_189", "DMF_194", "DMF_195", "DMF_202", "DMF_219", "DMF_223", "DMF_224", "DMF_224e", "DMF_229", "DMF_235", "DMF_236", "DMF_237", "DMF_238", "DMF_244", "DMF_244t", "DMF_247", "DMF_249", "DMF_254t5", "DMF_511e", "DMF_512", "DMF_513", "DMF_514", "DMF_514t", "DMF_515", "DMF_516", "DMF_517", "DMF_520", "DMF_523", "DMF_525", "DMF_526", "DMF_526a", "DMF_530", "DMF_531", "DMF_534", "DMF_703", "DMF_703t", "DMF_704", "DMF_706", "DMF_707", "DMF_709", "DMF_730", "DMF_730t", "DMF_732", "DMF_733", "DMF_734", "DMF_734e", "DMF_COIN1", "DMF_COIN2", "DRG_008", "DRG_010", "DRG_019", "DRG_020", "DRG_024", "DRG_028", "DRG_030", "DRG_031", "DRG_033", "DRG_035", "DRG_036", "DRG_036t", "DRG_049", "DRG_051", "DRG_052", "DRG_054", "DRG_060", "DRG_064", "DRG_070", "DRG_071", "DRG_072", "DRG_074", "DRG_075", "DRG_077", "DRG_084", "DRG_086", "DRG_091", "DRG_099", "DRG_099t2", "DRG_099t3", "DRG_102", "DRG_104", "DRG_107", "DRG_202", "DRG_207", "DRG_208", "DRG_215", "DRG_217", "DRG_224", "DRG_225", "DRG_226", "DRG_229", "DRG_233", "DRG_235", "DRG_235e", "DRG_238p", "DRG_238p3", "DRG_238p4", "DRG_238p5", "DRG_250", "DRG_251", "DRG_254", "DRG_255", "DRG_258", "DRG_270", "DRG_270t1", "DRG_270t2", "DRG_301", "DRG_302", "DRG_302e", "DRG_308", "DRG_308e", "DRG_311", "DRG_311a", "DRG_311b", "DRG_312", "DRG_313", "DRG_314", "DRG_315", "DRG_317", "DRG_318", "DRG_320", "DRG_320t", "DRG_323", "DRG_324", "DRG_401", "DRG_401e", "DRG_402", "DRG_610", "DRG_610t2", "DRG_610t3", "DRG_620", "DRG_620t2", "DRG_620t3", "DRG_650", "DRG_650t2", "DRG_650t3", "DRG_COIN", "DRGA_002", "DRGA_011ts5", "DRGA_01q", "DRGA_099t3", "DRGA_BOSS_02t", "DRGA_BOSS_02t3", "DRGA_BOSS_02tt", "DRGA_BOSS_03p", "DRGA_BOSS_03p_H", "DRGA_BOSS_03t", "DRGA_BOSS_03t2", "DRGA_BOSS_05p", "DRGA_BOSS_05p_H", "DRGA_BOSS_05t", "DRGA_BOSS_06t2", "DRGA_BOSS_07t", "DRGA_BOSS_08p", "DRGA_BOSS_08p_H", "DRGA_BOSS_08t", "DRGA_BOSS_08t2", "DRGA_BOSS_09p", "DRGA_BOSS_09p_H", "DRGA_BOSS_09t2", "DRGA_BOSS_11p", "DRGA_BOSS_11p_H", "DRGA_BOSS_11t", "DRGA_BOSS_12p", "DRGA_BOSS_12p_H", "DRGA_BOSS_12t", "DRGA_BOSS_13p", "DRGA_BOSS_13p_H", "DRGA_BOSS_15p", "DRGA_BOSS_18p", "DRGA_BOSS_18p_H", "DRGA_BOSS_21p", "DRGA_BOSS_21t2", "DRGA_BOSS_22p", "DRGA_BOSS_22p_H", "DRGA_BOSS_25p", "DRGA_BOSS_25p_H", "DRGA_BOSS_27p", "DRGA_BOSS_27p_H", "DRGA_BOSS_29p", "DRGA_BOSS_30p", "DRGA_BOSS_30p_H", "DRGA_BOSS_30t2", "DRGA_BOSS_30t4", "DRGA_BOSS_30t6", "DRGA_BOSS_30t7", "DRGA_BOSS_31p", "DRGA_BOSS_31p_H", "DRGA_BOSS_31p2", "DRGA_BOSS_35p", "DRGA_BOSS_36p", "DRGA_BOSS_37p", "DRGA_BOSS_38p", "DS1_055", "DS1_070", "DS1_184", "EX1_004", "EX1_011", "EX1_012", "EX1_014", "EX1_014t", "EX1_015", "EX1_019", "EX1_025", "EX1_043", "EX1_046", "EX1_058", "EX1_059", "EX1_076", "EX1_084", "EX1_089", "EX1_093", "EX1_096", "EX1_103", "EX1_110", "EX1_112", "EX1_116", "EX1_128", "EX1_130", "EX1_131", "EX1_132", "EX1_136", "EX1_145", "EX1_145e", "EX1_145o", "EX1_155", "EX1_155a", "EX1_155b", "EX1_158", "EX1_158e", "EX1_160", "EX1_160a", "EX1_160b", "EX1_164", "EX1_164a", "EX1_164b", "EX1_165", "EX1_169", "EX1_178", "EX1_180", "EX1_181", "EX1_182", "EX1_183", "EX1_184", "EX1_188", "EX1_189", "EX1_190", "EX1_191", "EX1_192", "EX1_193", "EX1_194", "EX1_195", "EX1_196", "EX1_244", "EX1_248", "EX1_284", "EX1_287", "EX1_289", "EX1_294", "EX1_295", "EX1_316", "EX1_317", "EX1_339", "EX1_345", "EX1_349", "EX1_350", "EX1_354", "EX1_355", "EX1_362", "EX1_363", "EX1_365", "EX1_366", "EX1_371", "EX1_379", "EX1_392", "EX1_409", "EX1_506", "EX1_509", "EX1_533", "EX1_534", "EX1_538", "EX1_549", "EX1_554", "EX1_556", "EX1_562", "EX1_570", "EX1_571", "EX1_572", "EX1_573", "EX1_573a", "EX1_573b", "EX1_575", "EX1_577", "EX1_583", "EX1_584", "EX1_587", "EX1_590", "EX1_597", "EX1_606", "EX1_611", "EX1_613", "EX1_614", "EX1_621", "EX1_623", "EX1_tk33", "EX1_tk33_2_TB", "FB_Annoyo_001", "FB_BuildABrawl001a", "FB_BuildABrawl001c", "FB_BuildABrawl001c_ench", "FB_BuildABrawl002a", "FB_BuildABrawl002a_ench", "FB_BuildABrawl002b", "FB_BuildABrawl002b_ench", "FB_BuildABrawl002c", "FB_BuildABrawl003b", "FB_Champs_CS2_013", "FB_Champs_CS2_073", "FB_Champs_CS2_188", "FB_Champs_DAL_736", "FB_Champs_EX1_164", "FB_Champs_EX1_165", "FB_Champs_EX1_169", "FB_Champs_EX1_556", "FB_Champs_EX1_571", "FB_Champs_FP1_028", "FB_Champs_ICC_221", "FB_Champs_ICC_466", "FB_Champs_ICC_705", "FB_Champs_LOOT_080", "FB_Champs_LOOT_080t2", "FB_Champs_LOOT_080t3", "FB_Champs_LOOT_093", "FB_Champs_LOOT_306", "FB_Champs_LOOT_333", "FB_Champs_LOOT_539", "FB_Champs_NEW1_008", "FB_Champs_NEW1_008a", "FB_Champs_NEW1_008b", "FB_Champs_UNG_067", "FB_ELO002", "FB_ELO002_copy", "FB_ELO002a_copy", "FB_ELO002a_ench_copy", "FB_ELO002c", "FB_ELO002c_copy", "FB_ELO002c_ench", "FB_ELO002c_ench_copy", "FB_LK001", "FB_LK002", "FB_LK006", "FB_RagRaid_DeckRefresh", "FB_RagRaid_Draw", "FB_RagRaid_InnkeeperReset", "FB_SPT_Annoyo_HP", "FB_SPT_Annoyo_HP_0", "FB_SPT_Annoyo_HP_1", "FB_Toki_Boss_mental", "FB_Toki_BossSpell_01", "FB_Toki_IncreaseHealth", "FB_Toki_Quest", "FB_Toki_SummonParadoxes", "FB_Toki_TimePortal_Reload", "FB_Toki2_Hero", "FP1_001", "FP1_002", "FP1_003", "FP1_007", "FP1_011", "FP1_012", "FP1_013", "FP1_014", "FP1_015", "FP1_018", "FP1_020", "FP1_023", "FP1_028", "GAME_005", "GIL_116", "GIL_118", "GIL_128", "GIL_145", "GIL_188", "GIL_190", "GIL_191", "GIL_198", "GIL_203", "GIL_507", "GIL_508", "GIL_513", "GIL_531", "GIL_537", "GIL_548", "GIL_553", "GIL_557", "GIL_571", "GIL_577", "GIL_578", "GIL_580", "GIL_581", "GIL_584", "GIL_586", "GIL_607", "GIL_608", "GIL_616", "GIL_616t", "GIL_620", "GIL_637", "GIL_646", "GIL_653", "GIL_661", "GIL_663", "GIL_664", "GIL_665", "GIL_667", "GIL_677", "GIL_682", "GIL_683", "GIL_696", "GIL_803", "GIL_805", "GIL_813", "GIL_815", "GIL_816", "GIL_819", "GIL_827", "GIL_828", "GIL_833", "GIL_835", "GIL_836", "GIL_902", "GIL_903", "GILA_400p", "GILA_401", "GILA_410", "GILA_411", "GILA_412", "GILA_500p2", "GILA_503e", "GILA_506", "GILA_506t", "GILA_513", "GILA_610", "GILA_802", "GILA_806", "GILA_811", "GILA_816a", "GILA_816b", "GILA_816c", "GILA_817", "GILA_818", "GILA_819", "GILA_824", "GILA_825", "GILA_825e", "GILA_827", "GILA_850b", "GILA_852a", "GILA_852b", "GILA_852c", "GILA_853b", "GILA_903", "GILA_906", "GILA_BOSS_20p", "GILA_BOSS_21p", "GILA_BOSS_31p", "GILA_BOSS_32p", "GILA_BOSS_35p", "GILA_BOSS_37e2", "GILA_BOSS_37p", "GILA_BOSS_37t", "GILA_BOSS_38p", "GILA_BOSS_40p", "GILA_BOSS_43p", "GILA_BOSS_43t", "GILA_BOSS_48p", "GILA_BOSS_49t", "GILA_BOSS_52p", "GILA_BOSS_52p2", "GILA_BOSS_55p", "GILA_BOSS_57t", "GILA_BOSS_58p", "GILA_BOSS_60p", "GILA_BOSS_60t", "GILA_BOSS_99t", "GILA_BOSS_99t2", "GILA_BOSS_99t3", "GVG_003", "GVG_005", "GVG_010", "GVG_011", "GVG_012", "GVG_014", "GVG_017", "GVG_022", "GVG_023", "GVG_025", "GVG_026", "GVG_027", "GVG_028t", "GVG_029", "GVG_030", "GVG_031", "GVG_032", "GVG_032a", "GVG_033", "GVG_034", "GVG_035", "GVG_036", "GVG_039", "GVG_041", "GVG_041b", "GVG_042", "GVG_043", "GVG_046", "GVG_048", "GVG_053", "GVG_055", "GVG_056", "GVG_057", "GVG_059", "GVG_060", "GVG_061", "GVG_062", "GVG_069", "GVG_078", "GVG_082", "GVG_083", "GVG_092", "GVG_096", "GVG_097", "GVG_102", "GVG_104", "GVG_105", "GVG_107", "GVG_110", "GVG_114", "GVG_115", "GVG_116", "GVG_117", "GVG_118", "HERO_01bp", "HERO_01bp2", "HERO_01dbp", "HERO_01dbp2", "HERO_01fbp", "HERO_01fbp2", "HERO_01obp", "HERO_01obp2", "HERO_01qbp", "HERO_01qbp2", "HERO_02bp", "HERO_02bp2", "HERO_02fbp", "HERO_02fbp2", "HERO_02mbp", "HERO_02mbp2", "HERO_04bp", "HERO_04bp2", "HERO_04ebp", "HERO_04ebp2", "HERO_04fbp", "HERO_04fbp2", "HERO_04fbp3", "HERO_04lbp", "HERO_04lbp2", "HERO_07bp", "HERO_07bp2", "HERO_07dbp", "HERO_07dbp2", "HERO_07ebp", "HERO_07ebp2", "HERO_09bp", "HERO_09bp2", "HERO_09dbp", "HERO_09dbp2", "ICC_018", "ICC_019", "ICC_025", "ICC_026", "ICC_027", "ICC_028", "ICC_029", "ICC_034", "ICC_039", "ICC_047a", "ICC_050", "ICC_052", "ICC_054", "ICC_056", "ICC_065", "ICC_069", "ICC_079", "ICC_082", "ICC_086", "ICC_089", "ICC_091", "ICC_092", "ICC_093", "ICC_094", "ICC_200", "ICC_201", "ICC_206", "ICC_207", "ICC_210", "ICC_213", "ICC_215", "ICC_221", "ICC_235", "ICC_257", "ICC_281", "ICC_289", "ICC_314", "ICC_314t1", "ICC_314t2", "ICC_314t4", "ICC_314t7", "ICC_415", "ICC_450", "ICC_466", "ICC_467", "ICC_702", "ICC_705", "ICC_801", "ICC_807", "ICC_808", "ICC_809", "ICC_810", "ICC_812", "ICC_823", "ICC_827", "ICC_827p", "ICC_829p", "ICC_831", "ICC_832", "ICC_832a", "ICC_832b", "ICC_832p", "ICC_833", "ICC_835", "ICC_838", "ICC_854", "ICC_900", "ICC_904", "ICC_912", "ICCA01_004", "ICCA01_009", "ICCA05_002p", "ICCA06_002p", "ICCA08_002p", "ICCA08_027", "KAR_004", "KAR_005", "KAR_009", "KAR_010", "KAR_021", "KAR_025", "KAR_026", "KAR_029", "KAR_030a", "KAR_044", "KAR_057", "KAR_061", "KAR_062", "KAR_065", "KAR_069", "KAR_075", "KAR_077", "KAR_091", "KAR_094", "KAR_095", "KAR_114", "KAR_204", "KAR_205", "KAR_702", "KAR_710", "KAR_A01_02", "KAR_A02_06", "KAR_A02_06H", "KAR_A02_09", "KAR_A02_09H", "KAR_A02_10", "KAR_A02_11", "KAR_A02_13", "KAR_A02_13H", "KAR_A10_05", "KAR_A10_06", "KAR_A10_22", "KARA_00_02", "KARA_00_02H", "KARA_00_04", "KARA_00_04H", "KARA_00_07", "KARA_00_09", "KARA_00_11", "KARA_06_03hp", "KARA_06_03hpheroic", "KARA_07_03", "KARA_07_03heroic", "KARA_07_05", "KARA_07_05heroic", "KARA_07_06", "KARA_07_06heroic", "KARA_07_07", "KARA_07_07heroic", "KARA_07_08", "KARA_07_08heroic", "KARA_08_02", "KARA_08_02H", "KARA_08_04", "KARA_09_03", "KARA_09_03heroic", "KARA_09_05", "KARA_09_05heroic", "KARA_13_02", "KARA_13_02H", "KARA_13_12", "KARA_13_12H", "KARA_13_13", "KARA_13_13H", "KARA_13_23", "LETL_001P5_01", "LETL_001P5_02", "LETL_001P5_03", "LETL_001P5_04", "LETL_001P5_05", "LETL_002P2_01", "LETL_002P2_02", "LETL_002P2_03", "LETL_002P2_03e2", "LETL_002P2_04", "LETL_002P2_05", "LETL_002P4_01", "LETL_002P4_02", "LETL_002P4_03", "LETL_002P4_04", "LETL_002P4_05", "LETL_002P5_01", "LETL_002P5_02", "LETL_002P5_03", "LETL_002P5_04", "LETL_002P5_05", "LETL_002P7_02", "LETL_002P7_03", "LETL_002P7_04", "LETL_002P7_05", "LETL_003P1e", "LETL_004P1_01", "LETL_004P1_02", "LETL_004P1_03", "LETL_004P1_04", "LETL_004P1_05", "LETL_009P9_01", "LETL_009P9_02", "LETL_009P9_03", "LETL_009P9_04", "LETL_009P9_05", "LETL_012P4_01", "LETL_012P4_02", "LETL_012P4_03", "LETL_012P4_04", "LETL_012P4_05", "LETL_012P7_01", "LETL_012P7_02", "LETL_012P7_03", "LETL_012P7_04", "LETL_012P7_05", "LETL_014P6_01", "LETL_014P6_02", "LETL_014P6_03", "LETL_014P6_04", "LETL_014P6_05", "LETL_019E2_01", "LETL_019E2_02", "LETL_019E2_03", "LETL_019E2_04", "LETL_019P1_01", "LETL_019P1_02", "LETL_019P1_03", "LETL_019P1_04", "LETL_019P1_05", "LETL_020P6_01", "LETL_020P6_02", "LETL_020P6_03", "LETL_020P6_04", "LETL_020P6_05", "LETL_021P1_01", "LETL_021P1_02", "LETL_021P1_03", "LETL_021P1_04", "LETL_021P1_05", "LETL_022P1_01", "LETL_022P1_01m", "LETL_022P1_02", "LETL_022P1_02m", "LETL_022P1_03", "LETL_022P1_03m", "LETL_024E2_04", "LETL_024E2e", "LETL_024P2_01", "LETL_024P2_01t", "LETL_024P2_01t2", "LETL_024P2_02", "LETL_024P2_02t", "LETL_024P2_02t2", "LETL_024P2_03", "LETL_024P2_03t", "LETL_024P2_03t2", "LETL_024P2_04", "LETL_024P2_04t", "LETL_024P2_04t2", "LETL_024P2_05", "LETL_024P2_05t", "LETL_024P2_05t2", "LETL_024P3_01", "LETL_024P3_02", "LETL_024P3_03", "LETL_024P3_04", "LETL_024P3_05", "LETL_025P7_01", "LETL_025P7_02", "LETL_025P7_03", "LETL_027P3_01", "LETL_027P3_01m", "LETL_027P3_02", "LETL_027P3_02m", "LETL_027P3_03", "LETL_027P3_03m", "LETL_027P3_04", "LETL_027P3_04m", "LETL_027P3_05", "LETL_027P3_05m", "LETL_029P11_01", "LETL_029P11_02", "LETL_029P11_03", "LETL_029P12_01", "LETL_029P12_02", "LETL_029P12_03", "LETL_029P12_04", "LETL_029P12_05", "LETL_032P4_01", "LETL_032P4_02", "LETL_032P4_03", "LETL_032P4_04", "LETL_032P4_05", "LETL_032P5_01", "LETL_032P5_02", "LETL_032P5_03", "LETL_032P5_04", "LETL_032P5_05", "LETL_034P1_01", "LETL_034P1_01e", "LETL_034P1_02", "LETL_034P1_02e", "LETL_034P1_03", "LETL_034P1_03e", "LETL_034P1_04", "LETL_034P1_04e", "LETL_034P1_T_01", "LETL_034P1_T_02", "LETL_034P1_T_03", "LETL_034P1_T_04", "LETL_034P3_01", "LETL_034P3_02", "LETL_034P3_03", "LETL_034P3_04", "LETL_034P3_05", "LETL_036P4_01", "LETL_036P4_02", "LETL_036P4_03", "LETL_037P2_01", "LETL_037P2_02", "LETL_037P2_03", "LETL_037P2_04", "LETL_037P2_05", "LETL_040P5_02", "LETL_040P5_03", "LETL_040P5_04", "LETL_040P9_01", "LETL_040P9_02", "LETL_040P9_03", "LETL_040P9_04", "LETL_040P9_05", "LETL_1020_01", "LETL_1052_01", "LETL_1061_01", "LETL_1100_01", "LETL_1100_02", "LETL_1100_03", "LETL_1100_04", "LETL_1100_05", "LETL_1101_01", "LETL_1101_02", "LETL_1101_03", "LETL_1101_04", "LETL_1101_05", "LETL_1105_01", "LETL_1109_01", "LETL_1109e", "LETL_1115_01", "LETL_1128_01", "LETL_1128_02", "LETL_1129", "LETL_1132", "LETL_1138_01", "LETL_1138_01m", "LETL_1138_02", "LETL_1138_02m", "LETL_1138_03", "LETL_1138_03m", "LETL_1138_04", "LETL_1138_04m", "LETL_1138_05", "LETL_1138_05m", "LETL_220_01", "LETL_220_02", "LETL_220_03", "LETL_220_04", "LETL_220_05", "LETL_224_01", "LETL_224_02", "LETL_224_03", "LETL_224_04", "LETL_224_05", "LETL_233_01", "LETL_233_02", "LETL_233_03", "LETL_233_04", "LETL_233_05", "LETL_250_01", "LETL_250_02", "LETL_250_03", "LETL_250_04", "LETL_250_05", "LETL_253_01", "LETL_253_02", "LETL_253_03", "LETL_253_04", "LETL_253_T_01", "LETL_253_T_02", "LETL_253_T_03", "LETL_253_T_04", "LETL_253e", "LETL_258_01", "LETL_258_02", "LETL_258_03", "LETL_258_04", "LETL_258_05", "LETL_263_01", "LETL_263_01x", "LETL_263_01y", "LETL_263_01z", "LETL_263_02", "LETL_263_02x", "LETL_263_02y", "LETL_263_02z", "LETL_263_03", "LETL_263_03x", "LETL_263_03y", "LETL_263_03z", "LETL_263_04", "LETL_263_04x", "LETL_263_04y", "LETL_263_04z", "LETL_263_05", "LETL_263_05x", "LETL_263_05y", "LETL_263_05z", "LETL_266_01", "LETL_266_02", "LETL_266_03", "LETL_266_04", "LETL_266_T_01", "LETL_266_T_02", "LETL_266_T_03", "LETL_266_T_04", "LETL_266e", "LETL_274_01", "LETL_274_02", "LETL_274_03", "LETL_274_04", "LETL_274_05", "LETL_276_01", "LETL_276_02", "LETL_276_03", "LETL_276_04", "LETL_276_05", "LETL_279_01", "LETL_279_02", "LETL_279_03", "LETL_279_04", "LETL_280_01", "LETL_280_02", "LETL_280_03", "LETL_280_04", "LETL_280_05", "LETL_309_01", "LETL_309_02", "LETL_309_03", "LETL_309_04", "LETL_309_05", "LETL_318_01", "LETL_318_02", "LETL_318_03", "LETL_318_04", "LETL_318_05", "LETL_319_01", "LETL_319_02", "LETL_319_03", "LETL_319_04", "LETL_319_05", "LETL_330_01", "LETL_330_02", "LETL_330_03", "LETL_330_04", "LETL_330_05", "LETL_342_01", "LETL_342_02", "LETL_342_03", "LETL_342_04", "LETL_342_05", "LETL_391_01", "LETL_391_02", "LETL_391_03", "LETL_391_04", "LETL_391_05", "LETL_391e", "LETL_406_01", "LETL_406_02", "LETL_406_03", "LETL_406_04", "LETL_406_05", "LETL_407_01", "LETL_407_02", "LETL_407_03", "LETL_407_04", "LETL_407_05", "LETL_409_01", "LETL_409_02", "LETL_409_03", "LETL_409_04", "LETL_409_05", "LETL_411_01", "LETL_411_02", "LETL_411_03", "LETL_411e2", "LETL_413_01", "LETL_413_02", "LETL_413_03", "LETL_413_04", "LETL_413_05", "LETL_430_01", "LETL_430_02", "LETL_430_03", "LETL_430_04", "LETL_430_05", "LETL_436_04", "LETL_440_01", "LETL_440_02", "LETL_440_03", "LETL_440_04", "LETL_440_05", "LETL_441_01", "LETL_441_02", "LETL_441_03", "LETL_441_04", "LETL_441_05", "LETL_460_01", "LETL_460_02", "LETL_460_03", "LETL_460_04", "LETL_460_05", "LETL_461_01", "LETL_461_01x", "LETL_461_01y", "LETL_461_02", "LETL_461_02x", "LETL_461_02y", "LETL_461_03", "LETL_461_03x", "LETL_461_03y", "LETL_462_01", "LETL_462_02", "LETL_462_03", "LETL_462_04", "LETL_462_05", "LETL_472_01y", "LETL_472_02y", "LETL_472_03y", "LETL_472_04y", "LETL_472_05y", "LETL_511_01", "LETL_511_02", "LETL_511_03", "LETL_511_04", "LETL_511_05", "LETL_511e", "LETL_514_01", "LETL_517_01", "LETL_517_02", "LETL_517_03", "LETL_518_01", "LETL_518_02", "LETL_518_03", "LETL_519_01", "LETL_519_02", "LETL_519_03", "LETL_530_01", "LETL_530_02", "LETL_530_03", "LETL_530_04", "LETL_530_05", "LETL_531_01", "LETL_531_01e", "LETL_533_01", "LETL_533_02", "LETL_533_03", "LETL_533_04", "LETL_533_05", "LETL_533e", "LETL_537_01", "LETL_538_01", "LETL_539_01", "LETL_539_02", "LETL_539_03", "LETL_539_04", "LETL_539_05", "LETL_542_01", "LETL_657_01", "LETL_657_02", "LETL_657_03", "LETL_657_04", "LETL_657e", "LETL_680_01", "LETL_680_02", "LETL_680_03", "LETL_680_04", "LETL_707_01", "LETL_707_02", "LETL_707_03", "LETL_707_04", "LETL_707e", "LETL_754_01", "LETL_754_02", "LETL_754_03", "LETL_754_04", "LETL_754_05", "LETL_755_01", "LETL_755_02", "LETL_755_03", "LETL_755_04", "LETL_755_05", "LETL_773_01", "LETL_773_02", "LETL_773_03", "LETL_773_04", "LETL_773_05", "LETL_812P2_01", "LETL_812P5", "LETL_816P2_01", "LETL_817P1_01", "LETL_817P3_01", "LETL_818P2_01", "LETL_818P3_01", "LETL_822P2_01", "LETL_823P3_01", "LETL_823P3_05", "LETL_824H2", "LETL_824H3", "LETL_824P2_01", "LETL_824P2_04", "LETL_828P1_02", "LETL_828P1_05", "LETL_831P1_03", "LETL_831P1_05", "LETL_832P1_01", "LETL_833H3", "LETL_8342P4", "LETL_8342P5", "LETL_836H", "LETL_837_1", "LETL_837_3", "LETL_838H2", "LETL_839P1_01", "LETL_839P1_03", "LETL_839P2_01", "LETL_839P2_03", "LETL_841H", "LETL_841H_Heroic", "LETL_844H3", "LETL_845P2_04", "LETL_845P2_05", "LETL_845P5_01", "LETL_847P1_01", "LETL_848H", "LETL_848H_Heroic", "LETL_848P6_03", "LETL_848P6_04", "LETL_850P1_01", "LETL_850P1_02", "LETL_851H2", "LETL_852P1", "LETL_852P4", "LETL_853P2_01", "LETL_853P2_02", "LETL_854P2_01", "LETL_856P1_01", "LETL_857P2_01", "LETL_859P2", "LETL_860P2", "LETL_860P2_05", "LETL_901", "LETL_903P1_01", "LETL_903P1_02", "LETL_904_01", "LETL_904_02", "LETL_904_03", "LETL_905_01", "LETL_905_02", "LETL_905_03", "LETL_906", "LETL_908_01", "LETL_908_02", "LETL_908_03", "LETL_909_01", "LETL_909_02", "LETL_909_03", "LETL_910", "LETL_912_01", "LETL_912_02", "LETL_912_03", "LETL_914", "LETL_917_01", "LETL_917_02", "LETL_917_03", "LETL_917_04", "LETL_917_05", "LETL_919_01", "LETL_919_02", "LETL_919_03", "LETL_919_04", "LETL_919_05", "LETL_920_01", "LETL_920_02", "LETL_920_03", "LETL_920_04", "LETL_920_05", "LETL_922_01", "LETL_922_02", "LETL_922_03", "LETL_922_04", "LETL_922_05", "LETL_923_01", "LETL_923_02", "LETL_923_03", "LETL_923_04", "LETL_923_05", "LETL_926_01", "LETL_926_02", "LETL_926_03", "LETL_926_04", "LETL_926_05", "LETL_928_01", "LETL_928_02", "LETL_928_03", "LETL_928_04", "LETL_928_05", "LETL_929_01", "LETL_929_02", "LETL_929_03", "LETL_929_04", "LETL_929_05", "LETL_935_01", "LETL_938_01", "LETL_947_01", "LETL_952_01", "LETL_952_02", "LETL_952_03", "LETL_952_04", "LETL_952_05", "LETL_964_01", "LETL_964_02", "LETL_964_03", "LETL_964_04", "LETL_964_05", "LETL_974_01", "LETL_976_01", "LETL_985_01", "LETL_985_02", "LETL_985_03", "LETL_985_04", "LETL_985_05", "LETL_985e", "LETLT_001_01", "LETLT_002_01", "LETLT_003_01", "LETLT_004_01", "LETLT_005_01", "LETLT_011_01", "LETLT_022_02", "LETLT_023_02", "LETLT_025_02", "LETLT_027_02", "LETLT_032_02", "LETLT_033_02", "LETLT_034_02", "LETLT_036_02", "LETLT_037_02", "LETLT_037_03", "LETLT_038_03", "LETLT_038_04m_01p", "LETLT_038_04m_02p", "LETLT_038_04m_03p", "LETLT_038_04m_04p", "LETLT_038_04m_05p", "LETLT_052_02", "LETLT_055_03", "LETLT_056_03", "LETLT_058_02", "LETLT_072p1_01", "LETLT_072p2_01", "LETLT_075_01", "LETLT_081_03", "LETLT_081_03e", "LETLT_082_03", "LETLT_088_03", "LETLT_101_01", "LETLT_101_02", "LETLT_105_02", "LETLT_107_02", "LETLT_108_02", "LETLT_109_02", "LETLT_112_02", "LETLT_113_02", "LETLT_116_01", "LETLT_118_02", "LETLT_120_02", "LETLT_122_03", "LOE_007", "LOE_009", "LOE_012", "LOE_017", "LOE_019", "LOE_019t", "LOE_019t2", "LOE_024t", "LOE_026", "LOE_039", "LOE_050", "LOE_061", "LOE_079", "LOE_086", "LOE_089", "LOE_105", "LOE_105e", "LOE_110", "LOE_113", "LOE_115", "LOE_115a", "LOE_115b", "LOE_118", "LOE_118e", "LOEA_01", "LOEA_01H", "LOEA02_02", "LOEA02_02h", "LOEA02_03", "LOEA02_04", "LOEA02_05", "LOEA02_06", "LOEA02_10", "LOEA04_28a", "LOEA04_28b", "LOEA04_29a", "LOEA04_29b", "LOEA05_02", "LOEA05_02a", "LOEA05_02h", "LOEA05_02ha", "LOEA05_03", "LOEA05_03h", "LOEA06_02", "LOEA06_02h", "LOEA06_03", "LOEA06_03h", "LOEA07_26", "LOEA07_28", "LOEA09_2", "LOEA09_2H", "LOEA09_3", "LOEA09_3b", "LOEA09_3c", "LOEA09_3d", "LOEA09_3H", "LOEA10_2", "LOEA10_2H", "LOEA10_5", "LOEA10_5H", "LOEA12_2", "LOEA12_2H", "LOEA13_2", "LOEA13_2H", "LOEA15_2", "LOEA15_2H", "LOEA16_12", "LOEA16_13", "LOEA16_15", "LOEA16_18", "LOEA16_18H", "LOEA16_19", "LOEA16_20", "LOEA16_22", "LOEA16_22H", "LOEA16_23", "LOEA16_23H", "LOEA16_24", "LOEA16_24H", "LOEA16_25", "LOEA16_25H", "LOEA16_26", "LOEA16_26H", "LOEA16_3", "LOEA16_7", "LOOT_008", "LOOT_026", "LOOT_026e", "LOOT_033", "LOOT_047", "LOOT_054", "LOOT_054b", "LOOT_054c", "LOOT_054d", "LOOT_056", "LOOT_062", "LOOT_064", "LOOT_064t1", "LOOT_064t2", "LOOT_069", "LOOT_079", "LOOT_080", "LOOT_080t2", "LOOT_080t3", "LOOT_088", "LOOT_091", "LOOT_091t1", "LOOT_091t2", "LOOT_093", "LOOT_103", "LOOT_103t1", "LOOT_103t2", "LOOT_104", "LOOT_106", "LOOT_106t", "LOOT_108", "LOOT_131", "LOOT_144", "LOOT_152", "LOOT_153", "LOOT_154", "LOOT_161", "LOOT_165", "LOOT_167", "LOOT_170", "LOOT_184", "LOOT_187", "LOOT_203", "LOOT_203t2", "LOOT_203t3", "LOOT_204", "LOOT_209", "LOOT_210", "LOOT_211", "LOOT_214", "LOOT_217", "LOOT_233", "LOOT_278", "LOOT_278t1", "LOOT_278t2", "LOOT_278t3", "LOOT_278t4", "LOOT_285", "LOOT_285t", "LOOT_285t3", "LOOT_285t4", "LOOT_286t1", "LOOT_286t2", "LOOT_286t3", "LOOT_286t4", "LOOT_291", "LOOT_306", "LOOT_309", "LOOT_314", "LOOT_329", "LOOT_333", "LOOT_344", "LOOT_344e", "LOOT_351", "LOOT_353", "LOOT_357", "LOOT_357l", "LOOT_368", "LOOT_370", "LOOT_373", "LOOT_375", "LOOT_380", "LOOT_383", "LOOT_388", "LOOT_392", "LOOT_394", "LOOT_398", "LOOT_412", "LOOT_413", "LOOT_414", "LOOT_415", "LOOT_415t1", "LOOT_415t2", "LOOT_415t3", "LOOT_415t4", "LOOT_415t5", "LOOT_420", "LOOT_500", "LOOT_506", "LOOT_507", "LOOT_507t", "LOOT_507t2", "LOOT_511", "LOOT_516", "LOOT_518", "LOOT_519", "LOOT_520", "LOOT_521", "LOOT_526", "LOOT_529", "LOOT_534", "LOOT_535", "LOOT_539", "LOOT_540", "LOOT_541", "LOOT_541t", "LOOT_542", "LOOT_998h", "LOOT_998j", "LOOT_998k", "LOOTA_104", "LOOTA_800", "LOOTA_813", "LOOTA_816", "LOOTA_817", "LOOTA_820", "LOOTA_823", "LOOTA_836", "LOOTA_837", "LOOTA_838", "LOOTA_841", "LOOTA_842b", "LOOTA_BOSS_04p", "LOOTA_BOSS_10p", "LOOTA_BOSS_110", "LOOTA_BOSS_12p", "LOOTA_BOSS_15p", "LOOTA_BOSS_18p", "LOOTA_BOSS_22p", "LOOTA_BOSS_22t", "LOOTA_BOSS_24p", "LOOTA_BOSS_26p5", "LOOTA_BOSS_26p8", "LOOTA_BOSS_27p", "LOOTA_BOSS_31p", "LOOTA_BOSS_36p", "LOOTA_BOSS_37p", "LOOTA_BOSS_40p", "LOOTA_BOSS_41p", "LOOTA_BOSS_42p", "LOOTA_BOSS_45p", "LOOTA_BOSS_46p", "LOOTA_BOSS_48p", "LOOTA_BOSS_49p", "LT21_003_01", "LT21_003_02", "LT21_003_03", "LT21_003_04", "LT21_003_05", "LT21_013_001", "LT21_013_002", "LT21_013_003", "LT21_013_004", "LT21_013_005", "LT21_014_001", "LT21_014_002", "LT21_014_003", "LT21_014_004", "LT21_014_005", "LT21_019_01", "LT21_019_02", "LT21_019_03", "LT21_019_04", "LT21_019_05", "LT21_020_01", "LT21_020_02", "LT21_020_03", "LT21_020_04", "LT21_020_05", "LT21_05E2_01", "LT21_05E2_02", "LT21_05E2_03", "LT21_05E2_04", "LT21_05P1_01", "LT21_05P1_02", "LT21_05P1_03", "LT21_05P1_04", "LT21_05P1_05", "LT21_05P2_01", "LT21_05P2_01mB", "LT21_05P2_01mC", "LT21_05P2_02", "LT21_05P2_02mB", "LT21_05P2_02mC", "LT21_05P2_03", "LT21_05P2_03mB", "LT21_05P2_03mC", "LT21_05P2_04", "LT21_05P2_04mB", "LT21_05P2_04mC", "LT21_05P2_05", "LT21_05P2_05mB", "LT21_05P2_05mC", "LT21_07P1_01", "LT21_07P1_02", "LT21_07P1_03", "LT21_07P1_04", "LT21_07P1_05", "LT22_002E1_01", "LT22_002E1_02", "LT22_002E1_03", "LT22_002E1_04", "LT22_002E3_01", "LT22_002E3_02", "LT22_002E3_03", "LT22_002E3_04", "LT22_006P3_01", "LT22_006P3_02", "LT22_006P3_03", "LT22_006P3_04", "LT22_006P3_05", "LT22_007E3_01", "LT22_007E3_02", "LT22_007E3_03", "LT22_007E3_04", "LT22_007P3_01", "LT22_007P3_02", "LT22_007P3_03", "LT22_007P3_04", "LT22_007P3_05", "LT22_008P2_01", "LT22_008P2_02", "LT22_008P2_03", "LT22_008P2_04", "LT22_008P2_05", "LT22_009P2_01", "LT22_009P2_02", "LT22_009P2_03", "LT22_009P2_04", "LT22_009P2_05", "LT22_009P3_01", "LT22_009P3_02", "LT22_009P3_03", "LT22_009P3_04", "LT22_009P3_05", "LT22_010P2_01", "LT22_010P2_02", "LT22_010P2_03", "LT22_010P2_04", "LT22_010P2_05", "LT22_012P2_01", "LT22_012P2_02", "LT22_012P2_03", "LT22_012P2_04", "LT22_012P2_05", "LT22_012P3_01", "LT22_012P3_02", "LT22_012P3_03", "LT22_012P3_04", "LT22_012P3_05", "LT22_014P3a_01", "LT22_014P3a_02", "LT22_014P3a_03", "LT22_014P3a_04", "LT22_014P3a_05", "Mekka2", "Mekka3", "NAX1_04", "NAX11_04", "NAX12_04", "NAX13_02", "NAX13_03", "NAX1h_04", "NAX6_03t", "NAX8_02", "NAX8_02H", "NAX8_02H_TB", "NAX8_03", "NAX8_04", "NAX8_05", "NAX9_06", "NAX9_07", "NEW1_008", "NEW1_008a", "NEW1_008b", "NEW1_009", "NEW1_014", "NEW1_016", "NEW1_018", "NEW1_024", "NEW1_026", "NEW1_031", "NEW1_036", "NEW1_037", "NEW1_040", "OG_006", "OG_006b", "OG_023", "OG_026", "OG_031", "OG_042", "OG_045", "OG_047", "OG_047a", "OG_047b", "OG_048", "OG_051", "OG_070", "OG_072", "OG_073", "OG_080", "OG_080b", "OG_080d", "OG_080e", "OG_087", "OG_090", "OG_094", "OG_101", "OG_102", "OG_104", "OG_109", "OG_113", "OG_114", "OG_118", "OG_122", "OG_133", "OG_134", "OG_147", "OG_156", "OG_158", "OG_195", "OG_195a", "OG_195b", "OG_198", "OG_202", "OG_202a", "OG_202b", "OG_207", "OG_211", "OG_216", "OG_221", "OG_222", "OG_223", "OG_229", "OG_234", "OG_241", "OG_249", "OG_255", "OG_256", "OG_267", "OG_272", "OG_273", "OG_276", "OG_281", "OG_283", "OG_284", "OG_286", "OG_291", "OG_292", "OG_293", "OG_309", "OG_310", "OG_311", "OG_313", "OG_316", "OG_318", "OG_320", "OG_323", "OG_330", "OG_335", "OG_337", "OG_339", "ONY_001", "ONY_003", "ONY_004", "ONY_005ta10", "ONY_005ta12", "ONY_005ta2", "ONY_005ta5", "ONY_005ta8", "ONY_005tb12", "ONY_005tb2", "ONY_005tb5", "ONY_005tb7", "ONY_005tb7e", "ONY_005tb9", "ONY_005tc6", "ONY_008", "ONY_009", "ONY_012", "ONY_012e", "ONY_016", "ONY_016t", "ONY_016t2", "ONY_017", "ONY_018t", "ONY_019", "ONY_021", "ONY_022", "ONY_023", "ONY_025", "ONY_027", "ONY_028", "ONY_028t", "ONY_029", "ONY_030", "ONY_031", "ONY_033", "ONY_034", "PART_001", "PART_003", "PART_004", "PART_006", "PART_007", "PCVPDR_SCH_Paladint1", "PRO_001", "PRO_001a", "PRO_001c", "Prologue_Azshara", "Prologue_CenariusHP", "Prologue_ChaosStrike", "Prologue_Maiev", "Prologue_ManaBurn", "Prologue_MoongladePortal", "Prologue_Ravencrest", "Prologue_Sorcerer", "PVPDR_022", "PVPDR_036", "PVPDR_AV_Neutralp1", "PVPDR_AV_Neutralp2", "PVPDR_AV_Neutralp2m1", "PVPDR_AV_Neutralp3p1", "PVPDR_AV_Neutralp3p2", "PVPDR_AV_Neutralp3p2e1", "PVPDR_AV_Neutralp6", "PVPDR_AV_Neutralp6p1", "PVPDR_AV_Neutralp6p2", "PVPDR_AV_Neutralp6p2e1", "PVPDR_AV_Neutralp6p3", "PVPDR_AV_Neutralt1", "PVPDR_AV_Neutralt11", "PVPDR_AV_Neutralt12", "PVPDR_AV_Neutralt12t1", "PVPDR_AV_Neutralt2", "PVPDR_AV_Neutralt3", "PVPDR_AV_Neutralt4", "PVPDR_AV_Neutralt5", "PVPDR_AV_Neutralt6", "PVPDR_AV_Neutralt6t1", "PVPDR_AV_Neutralt7", "PVPDR_AV_Neutralt9", "PVPDR_AV_Passive03", "PVPDR_AV_Passive03e1", "PVPDR_AV_Passive04", "PVPDR_AV_Passive04e1", "PVPDR_AV_Passive15", "PVPDR_AV_Passive15e1", "PVPDR_AV_Passive16", "PVPDR_AV_Passive16e1", "PVPDR_AV_Passive23", "PVPDR_AV_Passive23e1", "PVPDR_AV_Passive24e1", "PVPDR_AV_Passive28", "PVPDR_AV_Passive28e1", "PVPDR_AV_Passive31", "PVPDR_AV_Passive31e1", "PVPDR_AV_Passive32", "PVPDR_AV_Passive32e1", "PVPDR_AV_Passive35", "PVPDR_AV_Passive35e1", "PVPDR_AV_Passive36", "PVPDR_AV_Passive36e1", "PVPDR_BAR_Passive01", "PVPDR_BAR_Passive01e1", "PVPDR_BAR_Passive04", "PVPDR_BAR_Passive04e1", "PVPDR_BAR_Passive07", "PVPDR_BAR_Passive07e1", "PVPDR_BAR_Passive08", "PVPDR_BAR_Passive08e1", "PVPDR_BAR_Passive11", "PVPDR_BAR_Passive11e1", "PVPDR_BAR_Passive15", "PVPDR_BAR_Passive15e1", "PVPDR_BAR_Passive17", "PVPDR_BAR_Passive17e1", "PVPDR_BAR_Passive22", "PVPDR_BAR_Passive22e1", "PVPDR_BAR_Passive25", "PVPDR_BAR_Passive25e1", "PVPDR_BAR_Passive28", "PVPDR_DMF_Hunterp1", "PVPDR_DMF_Huntert2", "PVPDR_DMF_Magep1", "PVPDR_DMF_Paladinp1", "PVPDR_DMF_Paladint2", "PVPDR_DMF_Priestt2", "PVPDR_DMF_Shamant2", "PVPDR_DMF_Warlockp1", "PVPDR_DMF_Warlockt3", "PVPDR_DMF_Warriorp1", "PVPDR_DMF_Warriort1", "PVPDR_DMF_Warriort2", "PVPDR_GUEST_Diablop1", "PVPDR_GUEST_Diablop3", "PVPDR_GUEST_Diablot1", "PVPDR_GUEST_Diablot3e", "PVPDR_GUEST_Diablot5", "PVPDR_GUEST_Diablot6", "PVPDR_GUEST_Diablot6s4", "PVPDR_LOOT_SmartyPants", "PVPDR_SCH_Active03", "PVPDR_SCH_Active08", "PVPDR_SCH_Active11", "PVPDR_SCH_Active14", "PVPDR_SCH_Active17e1", "PVPDR_SCH_Active19", "PVPDR_SCH_Active19e1", "PVPDR_SCH_Active23", "PVPDR_SCH_Active28", "PVPDR_SCH_Active28s1", "PVPDR_SCH_Active28s2", "PVPDR_SCH_Active30", "PVPDR_SCH_Active31", "PVPDR_SCH_Active31s1", "PVPDR_SCH_Active31s2", "PVPDR_SCH_Active34", "PVPDR_SCH_Active35", "PVPDR_SCH_Active35s1", "PVPDR_SCH_Active35s2", "PVPDR_SCH_Active38", "PVPDR_SCH_Active46", "PVPDR_SCH_Active47", "PVPDR_SCH_Active50", "PVPDR_SCH_Active60", "PVPDR_SCH_DemonHunterp1", "PVPDR_SCH_DemonHuntert2", "PVPDR_SCH_Druidp3", "PVPDR_SCH_Druidp3s1", "PVPDR_SCH_Druidp3s3", "PVPDR_SCH_Druidt1s2", "PVPDR_SCH_Druidt2", "PVPDR_SCH_Druidt5", "PVPDR_SCH_Druidt6", "PVPDR_SCH_Huntert2", "PVPDR_SCH_Maget5e", "PVPDR_SCH_Paladinp1", "PVPDR_SCH_Paladint1", "PVPDR_SCH_Passive05", "PVPDR_SCH_Passive05e1", "PVPDR_SCH_Passive12", "PVPDR_SCH_Passive16", "PVPDR_SCH_Passive22", "PVPDR_SCH_Passive22e", "PVPDR_SCH_Passive32", "PVPDR_SCH_Passive32e", "PVPDR_SCH_Passive34", "PVPDR_SCH_Passive34e", "PVPDR_SCH_Priestp1", "PVPDR_SCH_Roguet1", "PVPDR_SCH_Roguet2", "PVPDR_SCH_Shamanp1", "PVPDR_SCH_Shamant2", "PVPDR_SCH_Warlockp3", "PVPDR_SCH_Warlockt2", "PVPDR_SCH_Warlockt5", "PVPDR_SCH_Warriort1", "PVPDR_SW_Passive_01", "PVPDR_SW_Passive_01e1", "PVPDR_SW_Passive_06", "PVPDR_SW_Passive_06e1", "PVPDR_SW_Passive_09", "PVPDR_SW_Passive20", "PVPDR_YOP_Active01", "PVPDR_YOP_Active02", "PVPDR_YOP_DemHun", "PVPDR_YOP_DemonHunterP1", "PVPDR_YOP_DemonHuntert2", "PVPDR_YOP_HunterT1", "PVPDR_YOP_LocPriT1", "PVPDR_YOP_MageT3", "PVPDR_YOP_PriestP1", "PVPDR_YOP_PriestP1m1", "PVPDR_YOP_PriestT2", "PVPDR_YOP_RogMagT1", "PVPDR_YOP_RogueP1", "PVPDR_YOP_ShamanT1", "PVPDR_YOP_ShamanT2", "PVPDR_YOP_WarPalT1", "PVPDR_YOP_WarriorP1", "PVPDR_YOP_WarriorT1", "SCH_120", "SCH_126", "SCH_133", "SCH_136", "SCH_138", "SCH_142", "SCH_149", "SCH_157", "SCH_158", "SCH_158e", "SCH_160", "SCH_162", "SCH_181", "SCH_182", "SCH_199t10", "SCH_199t11", "SCH_199t12", "SCH_199t13", "SCH_199t15", "SCH_199t18", "SCH_199t19", "SCH_199t21", "SCH_199t23", "SCH_199t24", "SCH_199t25", "SCH_199t26", "SCH_199t27", "SCH_199t28", "SCH_199t3", "SCH_199t5", "SCH_199t6", "SCH_199t7", "SCH_199t8", "SCH_199t9", "SCH_224", "SCH_230", "SCH_231", "SCH_232", "SCH_233", "SCH_233e", "SCH_234", "SCH_237", "SCH_237e", "SCH_242", "SCH_243", "SCH_244", "SCH_245", "SCH_247", "SCH_250", "SCH_252", "SCH_259t", "SCH_270", "SCH_270e", "SCH_273", "SCH_300", "SCH_300e", "SCH_302", "SCH_305", "SCH_307t", "SCH_311", "SCH_317", "SCH_333", "SCH_333e", "SCH_337", "SCH_340", "SCH_350", "SCH_351", "SCH_352", "SCH_353", "SCH_354", "SCH_356", "SCH_357", "SCH_422", "SCH_426", "SCH_427", "SCH_507", "SCH_507e", "SCH_522", "SCH_523", "SCH_524", "SCH_525", "SCH_530", "SCH_532", "SCH_533", "SCH_537", "SCH_600", "SCH_603", "SCH_606", "SCH_607b", "SCH_609", "SCH_610", "SCH_612", "SCH_612a", "SCH_612b", "SCH_615", "SCH_617", "SCH_623", "SCH_700", "SCH_702", "SCH_703", "SCH_705", "SCH_706", "SCH_707", "SCH_708", "SCH_709", "SCH_710", "SCH_711", "SCH_714", "Story_01_ArcaneKeysmith", "Story_01_ArchimondeHP", "Story_01_Bigglesworth", "Story_01_BookofRunes", "Story_01_CobaltSpellkin", "Story_01_FeralSpirit", "Story_01_GrayCat", "Story_01_JainaMidHP", "Story_01_JainaMidHP2", "Story_01_JainaMidHP3", "Story_01_LibramofWisdom", "Story_01_ThrallHP", "Story_01_Upgrade", "Story_01_VoltaicBurst", "Story_02_BeastCompanion", "Story_02_BloodmaulBrute", "Story_02_Burgle", "Story_02_Cairne", "Story_02_DaelinHP", "Story_02_EVILCableRat", "Story_02_EVILMiscreant", "Story_02_GorgromHP", "Story_02_HenchClanBurglar", "Story_02_Intimidation", "Story_02_Marshspawn", "Story_02_QuilboarHP", "Story_02_RexxarMidHP", "Story_02_RexxarMidHP2", "Story_02_RexxarMidHP3", "Story_02_RexxarWarHP", "Story_02_TeachersPet", "Story_02_Warship", "Story_02_WinkFox", "Story_03_Baine", "Story_03_ChargedDoomhammer", "Story_03_CorruptGarroshHP", "Story_03_DivineBell", "Story_03_GarroshHP", "Story_03_GarroshHP2", "Story_03_GeyahHP", "Story_03_JainaHP", "Story_03_Karnuk", "Story_03_MightofHellscream", "Story_03_RehgarHP", "Story_03_Rexxar", "Story_03_Runespear", "Story_03_ThrallMinion", "Story_03_TrickTotem", "Story_03_YShaarjsPower", "Story_04_AlonsusHP", "Story_04_ArthasHP", "Story_04_ArthasMinion", "Story_04_DarknessBeckons", "Story_04_DivertForces", "Story_04_DragonRoar", "Story_04_FinalStand", "Story_04_Frostmourne", "Story_04_HolyWrath", "Story_04_IcebladeHP", "Story_04_Jaina", "Story_04_KelThuzad", "Story_04_KingTerenas", "Story_04_LibramofCompassion", "Story_04_LibramofHoliness", "Story_04_MalGanisHP", "Story_04_SaurfangHP", "Story_04_TimeOut", "Story_04_UnbrokenFaith", "Story_05_AllianceCommander", "Story_05_AllianceCommanderts", "Story_05_AnduinYoungHP", "Story_05_AnduinYoungHP2", "Story_05_Apotheosis", "Story_05_Bananas", "Story_05_FaithsDefender", "Story_05_FaithsDefenderts", "Story_05_HighPriestRohan", "Story_05_JourneyBelow", "Story_05_LightProphecy", "Story_05_Lorthemar", "Story_05_MassResurrection", "Story_05_Mekkatorque", "Story_05_MercifulHeart", "Story_05_MetalBrew", "Story_05_MoiraHP", "Story_05_Nathanos", "Story_05_RepairBot", "Story_05_SaurfangHP", "Story_05_SolvetheRiddles", "Story_05_StewardofScrolls", "Story_05_TownCrier", "Story_05_UndercityHuckster", "Story_05_VarianMinion", "Story_06_CleverDisguise", "Story_06_Daerion_03p", "Story_06_EbonGryphon", "Story_06_FelFuror", "Story_06_FutureGladiator", "Story_06_HastyBlade", "Story_06_Helka_02p", "Story_06_JainaMinion", "Story_06_Kathranatir", "Story_06_Kingslayers", "Story_06_LoGosh", "Story_06_ManaWyrm", "Story_06_NoMercy", "Story_06_Rehgar_01p", "Story_06_RehgarMinion", "Story_06_ShadyBusiness", "Story_06_Steeldancer", "Story_06_ThistleDagger", "Story_06_ToxicVial", "Story_06_TrickTotem", "Story_06_Valeera_03p", "Story_06_Valeera_04p", "Story_06_Valeera_06p", "Story_06_Valeera_09p", "Story_06_Varian", "Story_06_WandThief", "Story_06_Wrathion", "Story_06_Wyvern", "Story_07_Archimonde_005p", "Story_07_AthleticStudies", "Story_07_Blackmoore_001p", "Story_07_CallWarchief", "Story_07_CapturedCrocolisk", "Story_07_DrekThar_002p", "Story_07_DrekTharMinion", "Story_07_EarthenMight", "Story_07_ElementalGathering", "Story_07_EventheOdds", "Story_07_FireSpiritWolf", "Story_07_FocusingIrisSpell", "Story_07_Garrosh_008p", "Story_07_Jaina_007p", "Story_07_Kalecgos", "Story_07_PepTalk", "Story_07_RegenerativeBlood", "Story_07_SpiritofAirt", "Story_07_SpiritofEartht", "Story_07_SpiritoftheWildt", "Story_07_SpiritofWatert", "Story_07_Taretha", "Story_07_TarethasMemory", "Story_07_TarethasMemorye", "Story_07_Thrall_006p", "Story_07_Thrall_007p", "Story_07_Warmaster", "Story_07_WildElemental", "Story_07_WildSpiritWolf", "Story_07_Ysera", "Story_08_AncientofWind", "Story_08_AncientofWindta", "Story_08_AncientofWindtb", "Story_08_ArchdruidsBlessing", "Story_08_Archimonde_004p", "Story_08_Cenarius_001p", "Story_08_CenariusMinion", "Story_08_DarnassianNightsaber", "Story_08_EmeraldExplorer", "Story_08_Fertilize", "Story_08_ForestOwl", "Story_08_Gibberling", "Story_08_Guidance", "Story_08_Malfurion_007p", "Story_08_Malfurion_008p", "Story_08_MalfurionBear", "Story_08_MalfurionBear_001p", "Story_08_MalfurionCat", "Story_08_MalfurionCat_001p", "Story_08_Naisha", "Story_08_NatureStudies", "Story_08_Planting", "Story_08_Powershifting", "Story_08_PriestessMaiev", "Story_08_PriestessMaievFake", "Story_08_TyrandePriestess", "Story_08_UndercityHuckster", "Story_08_WellofEternity", "Story_08_WildStag", "Story_09_AnimatedBroomstick", "Story_09_CacheofCash", "Story_09_CurseofWeakness", "Story_09_DragonEggPuzzle", "Story_09_ElekkGrazer", "Story_09_FelLordBetrug", "Story_09_FiendishCircle", "Story_09_FontofPower", "Story_09_Guldan_001p", "Story_09_Guldan_002p", "Story_09_HandofGuldan", "Story_09_Helboar", "Story_09_HoardingDragon", "Story_09_HungryDragon", "Story_09_PrimordialProtector", "Story_09_PrimordialStudies", "Story_09_RavenFamiliar", "Story_09_RingToss", "Story_09_RingTosst", "Story_09_SenseDemons", "Story_09_ServantofKalimos", "Story_09_ShadowCouncil", "Story_09_ShadowCouncil_Puzzle", "Story_09_ShadowreaverWarlock", "Story_09_Soularium", "Story_09_Soulwringer", "Story_09_SpiritJailer", "Story_09_TerongorShaman", "Story_09_ViciousFelhound", "Story_09_VioletWurm", "Story_09_ZuluhedMinion", "Story_10_BloodElfAllies", "Story_10_BrokenAllies", "Story_10_BrothersStormrage_004", "Story_10_FatesDemand", "Story_10_GreaterMyrmidon", "Story_10_Illidan_003p", "Story_10_Illidan_004p", "Story_10_Illidan_005p", "Story_10_Illidan_006p", "Story_10_Illidan_008p", "Story_10_IllidariStudies", "Story_10_KaldoreiMemories", "Story_10_LadyVashj2", "Story_10_LordofOutland", "Story_10_Malfurion_004p", "Story_10_MoargPainsmith", "Story_10_MurgulReaver", "Story_10_NagaAllies", "Story_10_NagaMyrmidon", "Story_10_ParasiticShadowfiend", "Story_10_PrimordialStudies", "Story_10_SecondSlice", "Story_10_ShadowStrike", "Story_10_SkullofGuldanSpell", "Story_10_SummonShadowDemons", "Story_10_Tranquility", "Story_10_TwinSlice", "Story_10_UnleashedTerrorguard", "Story_10_Velas_004p", "Story_10_VengefulCryptLord", "Story_10_WardensDetermination", "SW_001e", "SW_006", "SW_021", "SW_023", "SW_024", "SW_026", "SW_028", "SW_028t2", "SW_028t5", "SW_028t6", "SW_029", "SW_030", "SW_031", "SW_031t", "SW_031t2", "SW_034", "SW_035", "SW_036", "SW_039t3", "SW_041", "SW_042", "SW_045", "SW_049", "SW_052", "SW_052t", "SW_052t2", "SW_052t6", "SW_054", "SW_056", "SW_059", "SW_060", "SW_064", "SW_065", "SW_067", "SW_068", "SW_069", "SW_070", "SW_076", "SW_079e4", "SW_079e5", "SW_079t", "SW_079te", "SW_081", "SW_085", "SW_086", "SW_087", "SW_087e", "SW_087e2", "SW_087t", "SW_091", "SW_091t", "SW_091t3", "SW_093", "SW_094", "SW_095", "SW_097t", "SW_114", "SW_305", "SW_307", "SW_310", "SW_313", "SW_313t", "SW_313t2", "SW_315", "SW_316", "SW_316e", "SW_320", "SW_322t", "SW_322t2", "SW_400", "SW_405", "SW_411", "SW_418", "SW_418e2", "SW_422", "SW_422a", "SW_422b", "SW_428", "SW_428t", "SW_428t2", "SW_428t4", "SW_429", "SW_432", "SW_432e", "SW_433", "SW_433t", "SW_433t2", "SW_433t3", "SW_434", "SW_437", "SW_437e", "SW_439", "SW_439t", "SW_440", "SW_443", "SW_443e", "SW_450", "SW_450t", "SW_450t2", "SW_455", "SW_457", "SW_458", "SW_458e", "SW_462", "SW_462e", "SW_463", "SW_COIN1", "SW_COIN2", "TB_006", "TB_007", "TB_01_BOM_Mercs_Cariel_001p", "TB_01_BOM_Mercs_Kurtrus_001p", "TB_01_BOM_Mercs_Scabbs_001p", "TB_01_BOM_Mercs_Xyrella_001p", "TB_011", "TB_207_BagOfSpells", "TB_207_MaskedBall", "TB_207CatacombQ", "TB_207masterChest", "TB_3Wishes_Spell", "TB_3Wishes_Spell_2", "TB_Bacon_Secrets_01", "TB_Bacon_Secrets_02", "TB_Bacon_Secrets_04", "TB_Bacon_Secrets_05", "TB_Bacon_Secrets_07", "TB_Bacon_Secrets_08", "TB_Bacon_Secrets_10", "TB_Bacon_Secrets_11", "TB_Bacon_Secrets_12", "TB_Bacon_Secrets_13", "TB_BaconShop_HERO_10_Buddy", "TB_BaconShop_HERO_10_Buddy_G", "TB_BaconShop_HERO_16_Buddy", "TB_BaconShop_HERO_16_Buddy_G", "TB_BaconShop_HERO_18_Buddy", "TB_BaconShop_HERO_18_Buddy_G", "TB_BaconShop_HERO_22_Buddy", "TB_BaconShop_HERO_22_Buddy_G", "TB_BaconShop_HERO_23_Buddy", "TB_BaconShop_HERO_23_Buddy_G", "TB_BaconShop_HERO_27_Buddy", "TB_BaconShop_HERO_27_Buddy_G", "TB_BaconShop_HERO_28_Buddy", "TB_BaconShop_HERO_28_Buddy_G", "TB_BaconShop_HERO_34_Buddy", "TB_BaconShop_HERO_34_Buddy_G", "TB_BaconShop_HERO_35_Buddy_t2", "TB_BaconShop_HERO_35_Buddy_t3", "TB_BaconShop_HERO_35_Buddy_t6t", "TB_BaconShop_HERO_37_Buddy", "TB_BaconShop_HERO_38_Buddy", "TB_BaconShop_HERO_38_Buddy_G", "TB_BaconShop_HERO_40_Buddy", "TB_BaconShop_HERO_40_Buddy_G", "TB_BaconShop_HERO_50_Buddy_G", "TB_BaconShop_HERO_56_Buddy", "TB_BaconShop_HERO_56_Buddy_G", "TB_BaconShop_HERO_64_Buddy", "TB_BaconShop_HERO_64_Buddy_G", "TB_BaconShop_HERO_74_Buddy", "TB_BaconShop_HERO_74_Buddy_G", "TB_BaconShop_HERO_75_Buddy", "TB_BaconShop_HERO_75_Buddy_G", "TB_BaconShop_HERO_76_Buddy", "TB_BaconShop_HERO_76_Buddy_G", "TB_BaconShop_HERO_92_Buddy", "TB_BaconShop_HERO_92_Buddy_G", "TB_BaconShop_HERO_94_Buddy", "TB_BaconShop_HERO_94_Buddy_G", "TB_BaconShop_HERO_95_Buddy", "TB_BaconShop_HERO_95_Buddy_G", "TB_BaconShop_HP_001", "TB_BaconShop_HP_008a", "TB_BaconShop_HP_010", "TB_BaconShop_HP_011", "TB_BaconShop_HP_017", "TB_BaconShop_HP_017e", "TB_BaconShop_HP_018", "TB_BaconShop_HP_020", "TB_BaconShop_HP_024", "TB_BaconShop_HP_036", "TB_BaconShop_HP_037a", "TB_BaconShop_HP_038", "TB_BaconShop_HP_038t", "TB_BaconShop_HP_039", "TB_BaconShop_HP_040", "TB_BaconShop_HP_041", "TB_BaconShop_HP_041a", "TB_BaconShop_HP_041b", "TB_BaconShop_HP_041c", "TB_BaconShop_HP_041d", "TB_BaconShop_HP_041f", "TB_BaconShop_HP_041g", "TB_BaconShop_HP_041h", "TB_BaconShop_HP_041i", "TB_BaconShop_HP_047t", "TB_BaconShop_HP_050", "TB_BaconShop_HP_051", "TB_BaconShop_HP_057", "TB_BaconShop_HP_064", "TB_BaconShop_HP_072", "TB_BaconShop_HP_076", "TB_BaconShop_HP_080", "TB_BaconShop_HP_084", "TB_BaconShop_HP_085", "TB_BaconShop_HP_086", "TB_BaconShop_HP_087t", "TB_BaconShop_HP_101", "TB_BaconShop_HP_101t2", "TB_BaconShop_HP_103", "TB_BaconShop_HP_106", "TB_BaconShop_HP_107", "TB_BaconShop_Triples_01", "TB_BaconUps_002", "TB_BaconUps_003", "TB_BaconUps_004", "TB_BaconUps_006", "TB_BaconUps_009", "TB_BaconUps_011", "TB_BaconUps_014", "TB_BaconUps_019", "TB_BaconUps_025", "TB_BaconUps_026", "TB_BaconUps_027", "TB_BaconUps_030", "TB_BaconUps_031", "TB_BaconUps_032", "TB_BaconUps_032e", "TB_BaconUps_034", "TB_BaconUps_035", "TB_BaconUps_039", "TB_BaconUps_040", "TB_BaconUps_041", "TB_BaconUps_042", "TB_BaconUps_044", "TB_BaconUps_049", "TB_BaconUps_050", "TB_BaconUps_051", "TB_BaconUps_052", "TB_BaconUps_059", "TB_BaconUps_061", "TB_BaconUps_062", "TB_BaconUps_063", "TB_BaconUps_064", "TB_BaconUps_066", "TB_BaconUps_068", "TB_BaconUps_069", "TB_BaconUps_070", "TB_BaconUps_072", "TB_BaconUps_073", "TB_BaconUps_074", "TB_BaconUps_077", "TB_BaconUps_080", "TB_BaconUps_082", "TB_BaconUps_083", "TB_BaconUps_084", "TB_BaconUps_085", "TB_BaconUps_086", "TB_BaconUps_087", "TB_BaconUps_089", "TB_BaconUps_090", "TB_BaconUps_093", "TB_BaconUps_100", "TB_BaconUps_106", "TB_BaconUps_108", "TB_BaconUps_112", "TB_BaconUps_113", "TB_BaconUps_120", "TB_BaconUps_121", "TB_BaconUps_123", "TB_BaconUps_124", "TB_BaconUps_130", "TB_BaconUps_132t", "TB_BaconUps_137", "TB_BaconUps_138", "TB_BaconUps_139", "TB_BaconUps_140", "TB_BaconUps_141", "TB_BaconUps_142", "TB_BaconUps_144", "TB_BaconUps_145", "TB_BaconUps_152", "TB_BaconUps_154", "TB_BaconUps_162", "TB_BaconUps_165", "TB_Baconups_203", "TB_BaconUps_207", "TB_BaconUps_250", "TB_BaconUps_256", "TB_BaconUps_258", "TB_BaconUps_303", "TB_BaconUps_304", "TB_BaconUps_308", "TB_BaconUps_320", "TB_BBR3_BOSS_02p", "TB_BBR3_Boss_04p", "TB_BBR3_BOSS_05p", "TB_BBR3_BOSS_07p", "TB_BBR3_BOSS_09p", "TB_BlingBrawl_Blade1e", "TB_BossRumble_001hp", "TB_BossRumble_002hp", "TB_BossRumble_003hp", "TB_BRMA10_3H", "TB_Champs_EX1_145", "TB_Champs_EX1_145e", "TB_Champs_EX1_145o", "TB_CheaterChess_Black", "TB_Chupacabran_HP", "TB_CoOpBossSpell_3", "TB_CoOpBossSpell_4", "TB_CoOpv3_003", "TB_CoOpv3_009", "TB_CoOpv3_010", "TB_Coopv3_101", "TB_Coopv3_102", "TB_Coopv3_102b", "TB_Coopv3_104", "TB_Coopv3_104_NewClasses", "TB_DiscoverMyDeck_Discovery", "TB_DK_Guldan", "TB_DK_Jaina", "TB_DK_Malfurion", "TB_DK_Valeera", "TB_DK_Valeera_HP", "TB_EVILBRM_BoomHeroPower", "TB_EVILBRM_GarrSummon", "TB_EVILBRM_LOOTA_813", "TB_EVILBRM_OnyxiaHeroPower", "TB_EVILBRM_RafaamHeroPower", "TB_EVILBRM_RafaamHeroPower2", "tb_Fairytalecard_01", "tb_Fairytalecard_02e", "tb_Fairytalecard_03", "tb_Fairytalecard_04", "tb_Fairytalecard_05", "tb_Fairytalecard_06", "tb_Fairytalecard_07", "TB_Firefest2_003", "TB_Firefest2a", "TB_Firefest2b", "TB_Firefest2c", "TB_Firefest2d", "TB_FullCannonV3", "TB_FW_DrBoomMega", "TB_FW_ImbaTron", "TB_FW_OmegaMax", "TB_GiftExchange_Treasure", "TB_GiftExchange_Treasure_Spell", "TB_GiftReceiptSpell", "TB_HeadlessHorseman_003", "TB_HeadlessHorseman_004", "TB_HeadlessHorseman_HP5", "TB_HeadlessHorseman_HP6", "TB_HeadlessHorseman_s001a", "TB_HeadlessHorseman_s001b", "TB_HeadlessHorseman_s001c", "TB_HeadlessHorseman_s001d", "TB_Henchmania_ChuH", "TB_Henchmania_DiscoverA", "TB_Henchmania_DiscoverAe", "TB_Henchmania_DiscoverC", "TB_Henchmania_MyraH", "TB_Ignoblegarden1", "TB_Ignoblegarden2", "TB_Ignoblegarden2e", "TB_KaraPortal_001", "TB_KaraPortal_002", "TB_KaraPortal_003", "TB_KoboldGiftMinion", "TB_KT_AnubarakHP", "TB_KTRAF_1", "TB_KTRAF_10", "TB_KTRAF_101", "TB_KTRAF_2", "TB_KTRAF_3", "TB_KTRAF_4", "TB_KTRAF_6", "TB_KTRAF_HP_KT_3", "TB_KTRAF_HP_RAF3", "TB_KTRAF_HP_RAF4", "TB_KTRAF_HP_RAF5", "TB_LEAGUE_REVIVAL_BrannAIHp", "TB_LEAGUE_REVIVAL_FinleyChest", "TB_LEAGUE_REVIVAL_TekahnAIHp", "TB_LEAGUE_REVIVAL_TerravisHp", "TB_LOEA13_2", "TB_Lunar_Dog", "TB_Lunar_DogE", "TB_Lunar_DogEe", "TB_Lunar_Dragon", "TB_Lunar_DragonE", "TB_Lunar_Monkey", "TB_Lunar_MonkeyE", "TB_Lunar_Ox", "TB_Lunar_OxE", "TB_Lunar_Pig", "TB_Lunar_PigE", "TB_Lunar_Rabbit", "TB_Lunar_RabbitE", "TB_Lunar_Rat", "TB_Lunar_RatE", "TB_Lunar_Snake", "TB_Lunar_SnakeE", "TB_Lunar_Tiger", "TB_Lunar_TigerE", "TB_MammothParty_302", "TB_Marin_001", "TB_MechWar_Boss1_HeroPower", "TB_MP_02e", "TB_Noblegarden_005", "TB_Noblegarden_006", "TB_PickYourFate_11b", "TB_PickYourFate_4_EnchMinion", "TB_PickYourFate_6", "TB_Presents_001", "TB_Presents_002", "TB_Presents_003", "TB_ReturningPlayer_HoundmastHP", "TB_RoadToNR_Finley_HP", "TB_RoadToNR_OrgrimmarHP", "TB_RoadToNR_RenoHP", "TB_SC20_001a", "TB_SC20_001b", "TB_SC20_001c", "TB_SC20_002", "TB_SC20_003", "TB_SC20_004", "TB_SPT_BossHeroPower", "TB_SPT_DALA_BossHeroPower", "TB_SPT_DALA_Minion1", "TB_SPT_DALA_Minion3", "TB_SPT_DPromoHP", "TB_SPT_DPromoSecre8", "TB_SPT_DPromoSecret1", "TB_SPT_DPromoSecret10", "TB_SPT_DPromoSecret2", "TB_SPT_DPromoSecret3", "TB_SPT_DPromoSecret4", "TB_SPT_DPromoSecret5", "TB_SPT_DPromoSecret6", "TB_SPT_DPromoSecret9", "TB_SPT_DPromoSpell2", "TB_SPT_DPromoSpellBovine1", "TB_SPT_DPromoSpellPortal2", "TB_SPT_Minion1", "TB_SPT_Minion3", "TB_SPT_MTH_BossHeroPower", "TB_SPT_MTH_Minion1", "TB_SPT_MTH_Minion3", "TB_Superfriends001e", "TB_Superfriends002e", "TB_TagTeam_Warlock", "TB_TempleOutrun_DALA_719", "TB_TempleOutrun_Lazul_HP", "TB_TempleOutrun_Lazul_HP3", "TB_TempleOutrun_Treasure_Reno1", "TB_ThunderdomeWeaponC", "TB_ThunderdomeWeaponD", "TB_ThunderdomeWeaponF", "TBA01_5", "TBA01_6", "TBST_003", "TBST_004", "TBUD_1", "TOT_030", "TOT_030t1", "TOT_030t2", "TOT_030t3", "TOT_056", "TOT_067", "TOT_069", "TOT_102", "TOT_103", "TOT_107", "TOT_108", "TOT_111", "TOT_112", "TOT_204", "TOT_308", "TOT_313", "TOT_316", "TOT_320", "TOT_330", "TOT_334", "TOT_341", "TOT_343", "TOT_345", "TRL_010", "TRL_015", "TRL_020", "TRL_057", "TRL_058", "TRL_058e", "TRL_071", "TRL_074", "TRL_077", "TRL_082", "TRL_082e", "TRL_096", "TRL_097", "TRL_119", "TRL_124", "TRL_126", "TRL_128", "TRL_131", "TRL_151", "TRL_156", "TRL_232", "TRL_243", "TRL_244", "TRL_247", "TRL_254", "TRL_254a", "TRL_254b", "TRL_255", "TRL_259", "TRL_260", "TRL_302", "TRL_304", "TRL_305", "TRL_306", "TRL_307", "TRL_310", "TRL_310e", "TRL_318", "TRL_324", "TRL_329", "TRL_339", "TRL_349", "TRL_351", "TRL_362", "TRL_363", "TRL_400", "TRL_405", "TRL_503", "TRL_504", "TRL_506", "TRL_507", "TRL_509", "TRL_509t", "TRL_517", "TRL_520", "TRL_521", "TRL_523", "TRL_525", "TRL_527", "TRL_528", "TRL_531", "TRL_537", "TRL_541", "TRL_542", "TRL_566", "TRL_900", "TRL_901", "TRLA_105", "TRLA_106", "TRLA_115", "TRLA_116", "TRLA_121", "TRLA_122", "TRLA_123", "TRLA_125", "TRLA_127", "TRLA_130", "TRLA_134", "TRLA_135", "TRLA_139", "TRLA_140", "TRLA_144", "TRLA_148", "TRLA_150", "TRLA_151", "TRLA_156", "TRLA_159", "TRLA_161", "TRLA_163", "TRLA_164", "TRLA_165", "TRLA_166", "TRLA_169", "TRLA_170", "TRLA_172", "TRLA_173", "TRLA_176", "TRLA_178", "TRLA_180", "TRLA_184", "TRLA_186", "TRLA_188", "TRLA_192", "TRLA_807", "TRLA_807e2", "TRLA_809", "TRLA_809e2", "tt_010", "TU4c_006", "TU4c_008", "TU4e_002", "TU4f_004", "TU5_CS2_023", "TU5_CS2_147", "TU5_CS2_196", "TU5_DS1_055", "TU5_EX1_011", "TU5_EX1_015", "ULD_131", "ULD_134", "ULD_135", "ULD_135a", "ULD_135b", "ULD_136", "ULD_140", "ULD_140p", "ULD_143", "ULD_145", "ULD_152", "ULD_154", "ULD_155", "ULD_155p", "ULD_156", "ULD_160", "ULD_167", "ULD_171", "ULD_174", "ULD_177", "ULD_178", "ULD_178a", "ULD_178a2", "ULD_178a3", "ULD_178a4", "ULD_182", "ULD_183", "ULD_186", "ULD_189", "ULD_191", "ULD_195", "ULD_196", "ULD_197", "ULD_208", "ULD_209", "ULD_209t", "ULD_212", "ULD_215", "ULD_216", "ULD_217", "ULD_229", "ULD_231", "ULD_236", "ULD_250", "ULD_253", "ULD_256", "ULD_258", "ULD_262", "ULD_265", "ULD_266", "ULD_268", "ULD_270", "ULD_273", "ULD_276", "ULD_285", "ULD_286", "ULD_286t", "ULD_291", "ULD_292", "ULD_292a", "ULD_292b", "ULD_304", "ULD_309", "ULD_326", "ULD_327", "ULD_328", "ULD_413", "ULD_429", "ULD_430", "ULD_431", "ULD_431p", "ULD_433", "ULD_433p", "ULD_438", "ULD_439", "ULD_500", "ULD_616", "ULD_702", "ULD_705", "ULD_711", "ULD_711p3", "ULD_712", "ULD_713", "ULD_715", "ULD_716", "ULD_719", "ULD_720", "ULD_724", "ULD_724p", "ULD_726", "ULD_727", "ULD_COIN", "ULDA_001", "ULDA_002", "ULDA_003", "ULDA_004", "ULDA_004e", "ULDA_008", "ULDA_012", "ULDA_013", "ULDA_014", "ULDA_015", "ULDA_016", "ULDA_018", "ULDA_020", "ULDA_021", "ULDA_023", "ULDA_039", "ULDA_040", "ULDA_045t", "ULDA_111", "ULDA_116", "ULDA_117", "ULDA_203", "ULDA_205", "ULDA_301", "ULDA_302", "ULDA_303", "ULDA_304", "ULDA_305", "ULDA_307", "ULDA_307ts", "ULDA_402", "ULDA_402e", "ULDA_405", "ULDA_406", "ULDA_407", "ULDA_502", "ULDA_504", "ULDA_507", "ULDA_601", "ULDA_602", "ULDA_603", "ULDA_604", "ULDA_606", "ULDA_607", "ULDA_701e2", "ULDA_712", "ULDA_801t", "ULDA_804t", "ULDA_BOSS_01p", "ULDA_BOSS_01px", "ULDA_BOSS_02p", "ULDA_BOSS_02px", "ULDA_BOSS_03p", "ULDA_BOSS_04p", "ULDA_BOSS_04px", "ULDA_BOSS_07p", "ULDA_BOSS_08p", "ULDA_BOSS_08px", "ULDA_BOSS_09p", "ULDA_BOSS_11p", "ULDA_BOSS_12p", "ULDA_BOSS_12px", "ULDA_BOSS_13p", "ULDA_BOSS_15p", "ULDA_BOSS_15px", "ULDA_BOSS_16e", "ULDA_BOSS_17e", "ULDA_BOSS_17p", "ULDA_BOSS_17px", "ULDA_BOSS_19p", "ULDA_BOSS_19px", "ULDA_BOSS_21p", "ULDA_BOSS_25p", "ULDA_BOSS_27px", "ULDA_BOSS_31p", "ULDA_BOSS_31px", "ULDA_BOSS_32p", "ULDA_BOSS_36p", "ULDA_BOSS_36px", "ULDA_BOSS_37p1", "ULDA_BOSS_39m", "ULDA_BOSS_39p3", "ULDA_BOSS_39px3", "ULDA_BOSS_40p3", "ULDA_BOSS_41p", "ULDA_BOSS_41px", "ULDA_BOSS_42e", "ULDA_BOSS_42e2", "ULDA_BOSS_42p", "ULDA_BOSS_42px", "ULDA_BOSS_43p", "ULDA_BOSS_43px", "ULDA_BOSS_47p", "ULDA_BOSS_48p", "ULDA_BOSS_49p", "ULDA_BOSS_49px", "ULDA_BOSS_55p", "ULDA_BOSS_56p", "ULDA_BOSS_62p", "ULDA_BOSS_66p", "ULDA_BOSS_66px", "ULDA_BOSS_70p", "ULDA_BOSS_70px", "ULDA_BOSS_71p", "ULDA_BOSS_71px", "ULDA_BOSS_77p", "ULDA_BOSS_77px", "ULDA_BOSS_79p", "ULDA_Brann_HP3", "ULDA_Elise_HP1", "ULDA_Elise_HP2", "ULDA_Finley_HP1", "ULDA_Finley_HP2", "ULDA_Finley_HP3", "UNG_002", "UNG_010", "UNG_011", "UNG_020", "UNG_022", "UNG_024", "UNG_028", "UNG_029", "UNG_030", "UNG_032", "UNG_037", "UNG_057", "UNG_060", "UNG_063", "UNG_065t", "UNG_067", "UNG_072", "UNG_073", "UNG_075", "UNG_076", "UNG_078", "UNG_082", "UNG_083", "UNG_086", "UNG_088", "UNG_089", "UNG_100", "UNG_101", "UNG_103", "UNG_108", "UNG_109", "UNG_111t1", "UNG_116", "UNG_201", "UNG_208", "UNG_211b", "UNG_800", "UNG_809", "UNG_816", "UNG_823", "UNG_829", "UNG_829t2", "UNG_830", "UNG_832", "UNG_836", "UNG_843", "UNG_845", "UNG_846", "UNG_851", "UNG_851t1", "UNG_854", "UNG_856", "UNG_900", "UNG_907", "UNG_912", "UNG_913", "UNG_914", "UNG_915", "UNG_916", "UNG_917", "UNG_917t1", "UNG_920", "UNG_920t1", "UNG_920t2", "UNG_922", "UNG_922t1", "UNG_923", "UNG_925", "UNG_926", "UNG_927", "UNG_934", "UNG_937", "UNG_938", "UNG_940", "UNG_942", "UNG_942t", "UNG_948", "UNG_952", "UNG_952e", "UNG_954", "UNG_954t1", "UNG_957", "UNG_960", "UNG_961", "UNG_962", "UNG_963", "UNG_999t2", "UNG_999t2e", "VAN_CS2_003", "VAN_CS2_004", "VAN_CS2_005", "VAN_CS2_007", "VAN_CS2_009", "VAN_CS2_011", "VAN_CS2_013", "VAN_CS2_023", "VAN_CS2_027", "VAN_CS2_038", "VAN_CS2_039", "VAN_CS2_041", "VAN_CS2_045", "VAN_CS2_046", "VAN_CS2_053", "VAN_CS2_059", "VAN_CS2_073", "VAN_CS2_074", "VAN_CS2_077", "VAN_CS2_087", "VAN_CS2_088", "VAN_CS2_089", "VAN_CS2_092", "VAN_CS2_102_H3", "VAN_CS2_103", "VAN_CS2_103_Puzzle", "VAN_CS2_104", "VAN_CS2_105", "VAN_CS2_117", "VAN_CS2_147", "VAN_CS2_151", "VAN_CS2_188", "VAN_CS2_196", "VAN_CS2_226", "VAN_CS2_236", "VAN_CS2_237", "VAN_DS1_055", "VAN_DS1_070", "VAN_DS1_184", "VAN_EX1_004", "VAN_EX1_011", "VAN_EX1_012", "VAN_EX1_014", "VAN_EX1_015", "VAN_EX1_019", "VAN_EX1_025", "VAN_EX1_043", "VAN_EX1_046", "VAN_EX1_058", "VAN_EX1_059", "VAN_EX1_076", "VAN_EX1_084", "VAN_EX1_089", "VAN_EX1_093", "VAN_EX1_096", "VAN_EX1_103", "VAN_EX1_110", "VAN_EX1_112", "VAN_EX1_116", "VAN_EX1_128", "VAN_EX1_130", "VAN_EX1_131", "VAN_EX1_132", "VAN_EX1_136", "VAN_EX1_145", "VAN_EX1_145e", "VAN_EX1_145o", "VAN_EX1_155", "VAN_EX1_158", "VAN_EX1_158e", "VAN_EX1_160", "VAN_EX1_160a", "VAN_EX1_160b", "VAN_EX1_164", "VAN_EX1_164a", "VAN_EX1_164b", "VAN_EX1_165", "VAN_EX1_169", "VAN_EX1_178", "VAN_EX1_244", "VAN_EX1_248", "VAN_EX1_284", "VAN_EX1_287", "VAN_EX1_289", "VAN_EX1_294", "VAN_EX1_295", "VAN_EX1_316", "VAN_EX1_317", "VAN_EX1_339", "VAN_EX1_345", "VAN_EX1_349", "VAN_EX1_350", "VAN_EX1_354", "VAN_EX1_355", "VAN_EX1_362", "VAN_EX1_363", "VAN_EX1_365", "VAN_EX1_366", "VAN_EX1_371", "VAN_EX1_379", "VAN_EX1_392", "VAN_EX1_409", "VAN_EX1_506", "VAN_EX1_533", "VAN_EX1_534", "VAN_EX1_538", "VAN_EX1_549", "VAN_EX1_554", "VAN_EX1_556", "VAN_EX1_562", "VAN_EX1_570", "VAN_EX1_571", "VAN_EX1_572", "VAN_EX1_573", "VAN_EX1_573a", "VAN_EX1_573b", "VAN_EX1_575", "VAN_EX1_577", "VAN_EX1_583", "VAN_EX1_584", "VAN_EX1_587", "VAN_EX1_590", "VAN_EX1_597", "VAN_EX1_606", "VAN_EX1_611", "VAN_EX1_613", "VAN_EX1_614", "VAN_EX1_621", "VAN_EX1_623", "VAN_EX1_tk33", "VAN_HERO_01bp", "VAN_HERO_01bp2", "VAN_HERO_02bp", "VAN_HERO_02bp2", "VAN_HERO_04bp", "VAN_HERO_04bp2", "VAN_HERO_07bp", "VAN_HERO_07bp2", "VAN_HERO_09bp", "VAN_HERO_09bp2", "VAN_NEW1_008", "VAN_NEW1_008a", "VAN_NEW1_008b", "VAN_NEW1_009", "VAN_NEW1_014", "VAN_NEW1_016", "VAN_NEW1_018", "VAN_NEW1_024", "VAN_NEW1_026", "VAN_NEW1_031", "VAN_NEW1_036", "VAN_NEW1_037", "VAN_NEW1_040", "VAN_PRO_001", "VAN_PRO_001c", "VAN_tt_010", "WC_003", "WC_005", "WC_007", "WC_008", "WC_013", "WC_016", "WC_026", "WC_027", "WC_028", "WC_030", "WC_032", "WC_033", "WC_034", "WC_036", "WC_803", "WC_805", "YOD_001", "YOD_001b", "YOD_001c", "YOD_001ts", "YOD_004", "YOD_005", "YOD_005ts", "YOD_012", "YOD_012ts", "YOD_013", "YOD_015", "YOD_016", "YOD_017", "YOD_023", "YOD_024", "YOD_025", "YOD_026", "YOD_028", "YOD_029", "YOD_035", "YOD_038", "YOD_041", "YOD_043", "YOP_001", "YOP_001e", "YOP_003", "YOP_003t", "YOP_004", "YOP_005", "YOP_009", "YOP_010", "YOP_011", "YOP_015", "YOP_015t", "YOP_017", "YOP_018", "YOP_018e", "YOP_019", "YOP_022", "YOP_024", "YOP_024t", "YOP_025", "YOP_026", "YOP_029", "YOP_030", "YOP_031", "YOP_032", "YOP_034" };
+        private static HashSet<string> unfriendlyCards = new HashSet<string>() { "AT_001", "AT_004", "AT_005", "AT_012", "AT_022", "AT_023", "AT_025", "AT_030", "AT_036", "AT_037", "AT_037a", "AT_044", "AT_050", "AT_050t", "AT_051", "AT_056", "AT_059", "AT_063", "AT_063t", "AT_064", "AT_078", "AT_081", "AT_094", "AT_103", "AT_105", "AT_106", "AT_110", "AT_122", "AT_123", "AT_130", "AT_131", "AT_132_HUNTER_H1", "AV_108", "AV_113t1", "AV_114", "AV_131", "AV_132", "AV_133", "AV_138", "AV_200p2", "AV_202p", "AV_203", "AV_207p2", "AV_212", "AV_218", "AV_222", "AV_224", "AV_250", "AV_251", "AV_255", "AV_257t", "AV_258pt3", "AV_258pt4", "AV_258t3", "AV_258t4", "AV_259", "AV_266", "AV_267", "AV_282t", "AV_282t3", "AV_282t5", "AV_285", "AV_312", "AV_313", "AV_315", "AV_316", "AV_322", "AV_324", "AV_331", "AV_704", "BAR_024", "BAR_027", "BAR_032", "BAR_044", "BAR_044t", "BAR_044t2", "BAR_069", "BAR_071", "BAR_078", "BAR_079t12", "BAR_079t12c", "BAR_079t13", "BAR_079t13b", "BAR_079t13c", "BAR_305", "BAR_306", "BAR_311", "BAR_314", "BAR_314t", "BAR_314t2", "BAR_315", "BAR_316", "BAR_319", "BAR_319t", "BAR_319t2", "BAR_320", "BAR_334", "BAR_536", "BAR_536t", "BAR_536t2", "BAR_538", "BAR_541", "BAR_547", "BAR_705", "BAR_745", "BAR_748", "BAR_750", "BAR_801", "BAR_840", "BAR_845", "BAR_879", "BAR_879t", "BAR_888t", "BAR_910", "BAR_911", "BAR_913", "BAR_916", "BCON_008", "BCON_021", "BG20_202", "BG20_202_G", "BG20_HERO_282p", "BG20_HERO_666p_t1a", "BG20_HERO_666p_t1b", "BG20_HERO_666p_t1c", "BG20_HERO_666p_t1d", "BG21_023", "BG21_023_G", "BG22_HERO_001p_t4", "BG22_HERO_001p_t4_s", "BGS_002", "BGS_004", "BGS_032", "BGS_055", "BGS_077", "BGS_Treasures_003", "BGS_Treasures_014", "BGS_Treasures_014e", "BGS_Treasures_034", "BOM_01_Brukan_02p1", "BOM_01_Brukan_03p1", "BOM_01_Brukan_04p1", "BOM_01_Brukan_05p1", "BOM_01_Brukan_06p1", "BOM_01_Brukan_07p1", "BOM_01_Dawngrasp_05p4", "BOM_01_Dawngrasp_06p4", "BOM_01_Dawngrasp_07p4", "BOM_01_Feegly_07p", "BOM_01_Twinbraid_06p", "BOM_02_Serena_02p", "BOM_02_TavishFiresAShot_01s", "BOM_02_Trixie_05p", "BOM_03_Brukan_02p", "BOM_03_Dawngrasp_08t", "BOM_03_PowerOfLove_08s", "BOM_03_Tamsin_02p", "BOM_03_ThunderBluff_01t", "BOM_04_Dawngrasp_006p", "BOM_04_HurlGlaive_002s", "BOM_04_Samuro_001p", "BOM_04_Sarilus_004p", "BOM_04_Scabbs_005p", "BOM_04_Scabbs_006p", "BOM_05_Brukan_004p", "BOM_05_HooktuskCannon_002t", "BOM_05_MemoryBurn_08s", "BOM_05_Xyrella_006p2", "BOM_06_Anetheron_005p", "BOM_06_Anetheron_005p2", "BOM_06_CarrionSwarm_005s1e1", "BOM_06_Kurtrus_006t2e1", "BOM_06_SniperTavish_004t", "BOM_07_Scabbs_Brukan_006t", "BOM_07_Scabbs_Brukan_007t", "BOM_07_Scabbs_Brukan_008t", "BOM_07_Scabbs_Cariel_008t", "BOM_07_Scabbs_Dawngrasp_006t", "BOM_07_Scabbs_Dawngrasp_007t", "BOM_07_Scabbs_Dawngrasp_008t", "BOM_07_Scabbs_Guff_006t", "BOM_07_Scabbs_Guff_007t", "BOM_07_Scabbs_Guff_008t", "BOM_07_Scabbs_Kurtrus_008t", "BOM_07_Scabbs_Prestor_002p", "BOM_07_Scabbs_Rokara_006t", "BOM_07_Scabbs_Rokara_007t", "BOM_07_Scabbs_Rokara_008t", "BOM_07_Scabbs_Tavish_008t", "BOM_07_Scabbs_Xyrella_005p", "BOM_07_Scabbs_Xyrella_006p", "BOM_07_Scabbs_Xyrella_007p", "BOM_07_Scabbs_Xyrella_008t", "BOM_08_Brukan_003t", "BOM_08_Brukan_008t", "BOM_08_Dawngrasp_003t", "BOM_08_Dawngrasp_008t", "BOM_08_KillCommand_004s", "BOM_08_Tavish_Galvangar_005p", "BOM_08_Tavish_Rokara_003p", "BOM_09_Brukan_007p", "BOM_09_Brukan_008p", "BOM_09_Dawngrasp_006t", "BOM_09_Dawngrasp_008t", "BOM_09_Fight_002_Lethal", "BOM_09_KnockOff_007s", "BOM_09_Lokholar_006p", "BOM_09_Rokara_003p", "BOM_09_Snivvle_004p", "BOM_09_Tamsin_008hb", "BOM_09_Tamsin_008p", "BOT_031", "BOT_033", "BOT_104", "BOT_107e", "BOT_222", "BOT_238p1", "BOT_238p3", "BOT_245", "BOT_246", "BOT_251", "BOT_251e", "BOT_257", "BOT_308", "BOT_447", "BOT_448", "BOT_453", "BOT_540", "BOT_544", "BOT_558", "BOT_601", "BOT_907", "BOTA_101", "BOTA_202", "BOTA_212", "BOTA_223", "BOTA_229", "BOTA_235", "BOTA_240", "BOTA_244", "BOTA_702", "BOTA_BOSS_20p4", "BRM_002", "BRM_003", "BRM_005", "BRM_008", "BRM_010", "BRM_011", "BRM_013", "BRM_015", "BRM_016", "BRM_027p", "BRM_027pH", "BRM_030t", "BRM_034", "BRMA03_2", "BRMA04_2", "BRMA04_3", "BRMA04_3H", "BRMA05_2", "BRMA05_2H", "BRMA05_3", "BRMA05_3e", "BRMA05_3H", "BRMA05_3He", "BRMA07_2", "BRMA07_2_2_TB", "BRMA07_2_2c_TB", "BRMA07_2H", "BRMA07_3", "BRMA08_3", "BRMA09_6", "BRMA11_3", "BRMA12_8", "BRMA13_5", "BRMA13_8", "BRMA14_5", "BRMA14_5H", "BRMA16_3", "BRMA16_4", "BRMA17_4", "BRMC_100", "BRMC_100e", "BRMC_91", "BT_002", "BT_011", "BT_020", "BT_026", "BT_072", "BT_100", "BT_106", "BT_109t", "BT_110", "BT_114", "BT_117", "BT_126", "BT_134", "BT_196", "BT_199", "BT_205", "BT_230", "BT_233", "BT_235", "BT_291", "BT_354", "BT_355", "BT_429", "BT_429p", "BT_429p2", "BT_490", "BT_493", "BT_514", "BT_601", "BT_714", "BT_717", "BT_722", "BT_723", "BT_724", "BT_729", "BT_732", "BT_740", "BT_801", "BT_937", "BTA_13", "BTA_BOSS_01p", "BTA_BOSS_05p", "BTA_BOSS_07s2", "BTA_BOSS_10p", "BTA_BOSS_10p2", "BTA_BOSS_15s", "BTA_BOSS_17p", "BTA_BOSS_19p", "BTA_BOSS_19s", "BTA_BOSS_20p", "BTA_BOSS_20t", "BTA_BOSS_21p", "BTA_BOSS_22s", "BTA_BOSS_22t", "BTA_BOSS_24p", "BTA_BOSS_25s", "CFM_021", "CFM_065", "CFM_094", "CFM_335", "CFM_341", "CFM_603", "CFM_608", "CFM_609", "CFM_621t16", "CFM_621t18", "CFM_621t2", "CFM_621t21", "CFM_621t25", "CFM_621t29", "CFM_621t33", "CFM_621t4", "CFM_621t5", "CFM_623", "CFM_646", "CFM_647", "CFM_657", "CFM_662", "CFM_667", "CFM_690", "CFM_693", "CFM_696", "CFM_707", "CFM_716", "CFM_751", "CFM_855", "CFM_900", "CORE_BOT_453", "CORE_BRM_013", "CORE_BT_235", "CORE_BT_801", "CORE_CS1_112", "CORE_CS1_130", "CORE_CS2_029", "CORE_CS2_032", "CORE_CS2_033", "CORE_CS2_042", "CORE_CS2_062", "CORE_CS2_064", "CORE_CS2_072", "CORE_CS2_075", "CORE_CS2_076", "CORE_CS2_093", "CORE_CS2_108", "CORE_CS2_181", "CORE_CS2_189", "CORE_CS2_203", "CORE_DS1_185", "CORE_EX1_005", "CORE_EX1_049", "CORE_EX1_066", "CORE_EX1_082", "CORE_EX1_134", "CORE_EX1_144", "CORE_EX1_186", "CORE_EX1_197", "CORE_EX1_198", "CORE_EX1_238", "CORE_EX1_246", "CORE_EX1_249", "CORE_EX1_259", "CORE_EX1_275", "CORE_EX1_302", "CORE_EX1_304", "CORE_EX1_309", "CORE_EX1_312", "CORE_EX1_319", "CORE_EX1_382", "CORE_EX1_391", "CORE_EX1_400", "CORE_EX1_407", "CORE_EX1_410", "CORE_EX1_603", "CORE_EX1_610", "CORE_EX1_617", "CORE_EX1_619", "CORE_EX1_622", "CORE_EX1_625", "CORE_GIL_801", "CORE_GVG_076", "CORE_ICC_055", "CORE_UNG_817", "CRED_10", "CRED_118", "CRED_32", "CRED_44", "CRED_60", "CRED_67", "CRED_83", "CS1_112", "CS1_113", "CS1_129", "CS1_130", "CS1_130_Puzzle", "CS2_008", "CS2_012", "CS2_022", "CS2_024", "CS2_025", "CS2_026", "CS2_028", "CS2_029", "CS2_031", "CS2_032", "CS2_033", "CS2_034_H1", "CS2_034_H1_AT_132", "CS2_034_H2", "CS2_034_H2_AT_132", "CS2_034_H3", "CS2_034_H3_AT_132", "CS2_034_H4", "CS2_037", "CS2_042", "CS2_057", "CS2_061", "CS2_062", "CS2_063", "CS2_064", "CS2_072", "CS2_075", "CS2_076", "CS2_084", "CS2_093", "CS2_094", "CS2_108", "CS2_114", "CS2_141", "CS2_150", "CS2_181", "CS2_189", "CS2_203", "CS2_233", "CS2_234", "CS3_002", "CS3_003", "CS3_016", "CS3_027", "CS3_031", "CS3_036", "DAL_009", "DAL_011", "DAL_030", "DAL_039", "DAL_052", "DAL_065", "DAL_071", "DAL_173", "DAL_177", "DAL_177ts", "DAL_182", "DAL_350", "DAL_350a", "DAL_366", "DAL_366t1", "DAL_366t2", "DAL_366t3", "DAL_366t4", "DAL_371", "DAL_373", "DAL_373ts", "DAL_539", "DAL_577", "DAL_577ts", "DAL_605", "DAL_606", "DAL_614", "DAL_615", "DAL_716", "DAL_723", "DAL_728", "DAL_769", "DAL_775", "DALA_706", "DALA_712", "DALA_713", "DALA_714", "DALA_714a", "DALA_714b", "DALA_714c", "DALA_720", "DALA_724", "DALA_726", "DALA_740ts4", "DALA_865", "DALA_865e", "DALA_865e2", "DALA_901", "DALA_903", "DALA_914", "DALA_BOSS_01p", "DALA_BOSS_01px", "DALA_BOSS_03t", "DALA_BOSS_03t2", "DALA_BOSS_08p", "DALA_BOSS_08px", "DALA_BOSS_12p", "DALA_BOSS_12px", "DALA_BOSS_13p", "DALA_BOSS_19p", "DALA_BOSS_19px", "DALA_BOSS_22p", "DALA_BOSS_22px", "DALA_BOSS_23p", "DALA_BOSS_23px", "DALA_BOSS_29p", "DALA_BOSS_45p", "DALA_BOSS_45px", "DALA_BOSS_47t", "DALA_BOSS_48t", "DALA_BOSS_50p", "DALA_BOSS_50px", "DALA_BOSS_51t2", "DALA_BOSS_56e", "DALA_BOSS_58p", "DALA_BOSS_59t2", "DALA_BOSS_59t3", "DALA_BOSS_63p", "DALA_BOSS_63px", "DALA_BOSS_64p", "DALA_BOSS_64px", "DALA_BOSS_70p", "DALA_BOSS_70px", "DALA_Mage_HP1", "DALA_Mage_HP2", "DALA_Rogue_HP2", "DALA_Shaman_HP1", "DALA_Warlock_HP1", "DALA_Warrior_HP1", "DED_001", "DED_007", "DED_502", "DED_507", "DED_517", "DED_518", "DED_521", "DED_523", "DH_Prologue_CS2_057", "DH_Prologue_EX1_277", "DMF_004t4", "DMF_004t5", "DMF_054", "DMF_054t", "DMF_057", "DMF_066", "DMF_071", "DMF_101", "DMF_101t", "DMF_103", "DMF_108", "DMF_110", "DMF_115", "DMF_116", "DMF_117", "DMF_117t", "DMF_117t2", "DMF_174", "DMF_174t", "DMF_187", "DMF_191", "DMF_221", "DMF_225", "DMF_227", "DMF_254t3", "DMF_254t4", "DMF_254t7", "DMF_518", "DMF_519", "DMF_522", "DMF_529", "DMF_700", "DMF_701", "DMF_701t", "DMF_702", "DREAM_02", "DREAM_04", "DREAM_05", "DRG_006", "DRG_022", "DRG_023", "DRG_037", "DRG_062", "DRG_067", "DRG_069", "DRG_078", "DRG_081", "DRG_095", "DRG_099t1", "DRG_099t4", "DRG_106", "DRG_201", "DRG_204", "DRG_205", "DRG_206", "DRG_213", "DRG_219", "DRG_223", "DRG_246", "DRG_247", "DRG_248", "DRG_249", "DRG_255t2", "DRG_256", "DRG_257", "DRG_270t11", "DRG_270t4", "DRG_270t5", "DRG_270t6", "DRG_270t7", "DRG_270t8", "DRG_270t9", "DRG_304", "DRG_307", "DRG_321", "DRG_500", "DRG_660", "DRG_660t2", "DRG_660t3", "DRGA_004", "DRGA_011ts4", "DRGA_06", "DRGA_099t4", "DRGA_BOSS_04p", "DRGA_BOSS_04t", "DRGA_BOSS_05t2", "DRGA_BOSS_05t3", "DRGA_BOSS_05t4", "DRGA_BOSS_05t5", "DRGA_BOSS_06p", "DRGA_BOSS_06p_H", "DRGA_BOSS_07p", "DRGA_BOSS_07p4", "DRGA_BOSS_09t", "DRGA_BOSS_10p", "DRGA_BOSS_10p_H", "DRGA_BOSS_13t", "DRGA_BOSS_15t2", "DRGA_BOSS_16p", "DRGA_BOSS_16p2", "DRGA_BOSS_20p", "DRGA_BOSS_20p_H", "DRGA_BOSS_20t", "DRGA_BOSS_21t", "DRGA_BOSS_22t2", "DRGA_BOSS_22t3", "DRGA_BOSS_24p", "DRGA_BOSS_24p_H", "DRGA_BOSS_30t", "DRGA_BOSS_30t2t", "DRGA_BOSS_30t3", "DRGA_BOSS_30t5", "DRGA_BOSS_32p", "DRGA_BOSS_32p_H", "DRGA_BOSS_33t", "DS1_183", "DS1_185", "DS1_233", "DS1h_292_H1", "DS1h_292_H1_AT_132", "DS1h_292_H2", "DS1h_292_H3", "DS1h_292_H3_AT_132", "EX1_002", "EX1_005", "EX1_029", "EX1_029_Puzzle", "EX1_048", "EX1_049", "EX1_057", "EX1_066", "EX1_082", "EX1_091", "EX1_102", "EX1_124", "EX1_126", "EX1_129", "EX1_133", "EX1_134", "EX1_137", "EX1_144", "EX1_154", "EX1_154a", "EX1_154b", "EX1_161", "EX1_166", "EX1_166a", "EX1_166b", "EX1_173", "EX1_179", "EX1_186", "EX1_197", "EX1_198", "EX1_238", "EX1_241", "EX1_245", "EX1_246", "EX1_249", "EX1_251", "EX1_259", "EX1_275", "EX1_277", "EX1_278", "EX1_279", "EX1_283", "EX1_298", "EX1_301", "EX1_302", "EX1_303", "EX1_304", "EX1_308", "EX1_309", "EX1_312", "EX1_313", "EX1_319", "EX1_320", "EX1_332", "EX1_334", "EX1_360", "EX1_382", "EX1_384", "EX1_391", "EX1_400", "EX1_407", "EX1_408", "EX1_410", "EX1_537", "EX1_539", "EX1_544", "EX1_558", "EX1_578", "EX1_581", "EX1_593", "EX1_594", "EX1_596", "EX1_603", "EX1_607", "EX1_609", "EX1_610", "EX1_617", "EX1_619", "EX1_622", "EX1_624", "EX1_625", "EX1_625t", "EX1_625t2", "EX1_626", "FB_Champs_CS2_084", "FB_Champs_CS2_108", "FB_Champs_CS2_233", "FB_Champs_EX1_005", "FB_Champs_EX1_029", "FB_Champs_EX1_166", "FB_Champs_EX1_246", "FB_Champs_EX1_308", "FB_Champs_EX1_619", "FB_Champs_LOOT_017", "FB_Champs_NEW1_019", "FB_Duelers_Endl", "FB_ELO002a", "FB_ELO002a_ench", "FB_ELO002b", "FB_ELO002b_copy", "FB_ELO002b_ench", "FB_ELO002b_ench_copy", "FB_IKC_SetupYes", "FB_Juggernaut_Bomb_Effect", "FB_Juggernaut_MinionEnchant", "FB_LK_ClearBoard", "FB_LK005", "FB_LK007p", "FB_LK011", "FB_LKStats001d", "FB_RagRaid_Amulet", "FB_RagRaid_DestroyEverything", "FB_RagRaid_DoubleBlast", "FB_Toki_Boss_Minion1", "FB_Toki_do_auto", "FB_Toki_TimePortalSpell", "FP1_006", "FP1_019", "FP1_021", "FP1_024", "FP1_025", "FP1_026", "GIL_000", "GIL_117", "GIL_124", "GIL_134", "GIL_147", "GIL_504", "GIL_506", "GIL_515", "GIL_518", "GIL_543", "GIL_583", "GIL_600", "GIL_614", "GIL_614e2", "GIL_622", "GIL_648", "GIL_654", "GIL_687", "GIL_693", "GIL_694", "GIL_801", "GIL_825", "GILA_500h4", "GILA_500p2t", "GILA_501", "GILA_503", "GILA_508", "GILA_510", "GILA_600h2", "GILA_601", "GILA_803", "GILA_804", "GILA_820", "GILA_821a", "GILA_821b", "GILA_821c", "GILA_900h2", "GILA_904", "GILA_910", "GILA_BOSS_22p", "GILA_BOSS_23p", "GILA_BOSS_24t", "GILA_BOSS_26t", "GILA_BOSS_27p", "GILA_BOSS_27t", "GILA_BOSS_29p", "GILA_BOSS_29t", "GILA_BOSS_33p", "GILA_BOSS_35t", "GILA_BOSS_36p", "GILA_BOSS_41t", "GILA_BOSS_42p", "GILA_BOSS_44p", "GILA_BOSS_49t2", "GILA_BOSS_51p", "GILA_BOSS_54p", "GILA_BOSS_55t2", "GILA_BOSS_56p", "GILA_BOSS_57p", "GILA_BOSS_59p", "GILA_BOSS_61t3", "GILA_BOSS_62p", "GILA_BOSS_66p", "GILA_BOSS_68p", "GILA_BOSS_68t", "GVG_001", "GVG_002", "GVG_004", "GVG_007", "GVG_008", "GVG_009", "GVG_015", "GVG_019", "GVG_020", "GVG_038", "GVG_045", "GVG_047", "GVG_050", "GVG_052", "GVG_072", "GVG_073", "GVG_074", "GVG_075", "GVG_076", "GVG_090", "GVG_099", "GVG_101", "GVG_108", "GVG_110t", "GVG_120", "HERO_05bp", "HERO_05bp2", "HERO_05dbp", "HERO_05dbp2", "HERO_08bp", "HERO_08bp2", "HERO_08dbp", "HERO_08dbp2", "HERO_08ebp", "HERO_08ebp2", "HERO_08fbp", "HERO_08fbp2", "HERO_08fbp3", "HERO_08lbp", "HERO_08lbp2", "HERO_08tbp", "HERO_08tbp2", "ICC_021", "ICC_041", "ICC_047", "ICC_047b", "ICC_047t", "ICC_047t2", "ICC_049", "ICC_051", "ICC_055", "ICC_058", "ICC_064", "ICC_075", "ICC_078", "ICC_085", "ICC_088", "ICC_099", "ICC_214", "ICC_233", "ICC_236", "ICC_238", "ICC_244", "ICC_244e", "ICC_314t3", "ICC_314t5", "ICC_314t6", "ICC_314t8", "ICC_468", "ICC_469", "ICC_481", "ICC_481p", "ICC_701", "ICC_802", "ICC_828", "ICC_830", "ICC_830p", "ICC_831p", "ICC_833h", "ICC_833t", "ICC_834h", "ICC_836", "ICC_837", "ICC_849", "ICC_903", "ICC_910", "ICCA01_011", "ICCA04_002", "ICCA04_008p", "ICCA04_011p", "ICCA05_004p", "ICCA05_021", "ICCA06_004", "ICCA06_005", "ICCA07_008", "ICCA08_024", "ICCA08_025", "ICCA08_026", "ICCA08_028", "ICCA08_030p", "KAR_013", "KAR_041", "KAR_073", "KAR_076", "KAR_092", "KAR_A10_01", "KAR_A10_02", "KAR_A10_03", "KAR_A10_04", "KAR_A10_09", "KAR_A10_10", "KAR_A10_33", "KARA_04_02hp", "KARA_08_03", "KARA_08_03H", "KARA_08_05", "KARA_08_05H", "KARA_09_06", "KARA_09_06heroic", "KARA_09_07", "KARA_09_07heroic", "KARA_12_03", "KARA_12_03H", "KARA_13_11", "LETL_000_02", "LETL_001P9_01", "LETL_001P9_02", "LETL_001P9_03", "LETL_001P9_04", "LETL_001P9_05", "LETL_003P4_01", "LETL_003P4_02", "LETL_003P4_03", "LETL_003P4_04", "LETL_003P4_05", "LETL_005P3_01", "LETL_005P3_02", "LETL_005P3_03", "LETL_005P3_04", "LETL_005P3_05", "LETL_005P4_01", "LETL_005P4_02", "LETL_005P4_03", "LETL_005P4_04", "LETL_005P4_05", "LETL_005P8_01", "LETL_005P8_02", "LETL_005P8_03", "LETL_005P8_04", "LETL_005P8_05", "LETL_006P8_01", "LETL_006P8_02", "LETL_006P8_03", "LETL_006P8_04", "LETL_006P8_05", "LETL_006P9_01", "LETL_006P9_02", "LETL_006P9_03", "LETL_006P9_04", "LETL_006P9_05", "LETL_007P4_01", "LETL_007P4_02", "LETL_007P4_03", "LETL_007P4_04", "LETL_007P4_05", "LETL_008P11_01", "LETL_008P11_02", "LETL_008P11_03", "LETL_008P9_01", "LETL_008P9_02", "LETL_008P9_03", "LETL_009P6_01", "LETL_009P6_02", "LETL_009P6_03", "LETL_009P6_04", "LETL_009P6_05", "LETL_010P2_01", "LETL_010P2_02", "LETL_010P2_03", "LETL_010P2_04", "LETL_010P2_05", "LETL_011P2_01", "LETL_011P2_02", "LETL_011P2_03", "LETL_012P6_01", "LETL_012P6_02", "LETL_012P6_03", "LETL_012P6_04", "LETL_012P6_05", "LETL_014P1_01", "LETL_014P1_02", "LETL_014P1_03", "LETL_014P1_04", "LETL_014P1_05", "LETL_014P2_01", "LETL_014P2_02", "LETL_014P2_03", "LETL_014P2_04", "LETL_014P2_05", "LETL_014P3_01", "LETL_014P3_02", "LETL_014P3_03", "LETL_014P3_04", "LETL_014P3_05", "LETL_015P9_01", "LETL_015P9_02", "LETL_015P9_03", "LETL_015P9_04", "LETL_015P9_05", "LETL_017P1_01", "LETL_017P1_02", "LETL_017P1_03", "LETL_017P1_04", "LETL_017P1_05", "LETL_017P2_01", "LETL_017P2_02", "LETL_017P2_03", "LETL_017P2_04", "LETL_017P2_05", "LETL_017P6_01", "LETL_017P6_02", "LETL_017P6_03", "LETL_017P6_04", "LETL_017P6_05", "LETL_017P7_01", "LETL_017P7_02", "LETL_017P7_03", "LETL_017P7_04", "LETL_017P7_05", "LETL_018P10_01", "LETL_018P10_02", "LETL_018P10_03", "LETL_018P7_01", "LETL_018P7_02", "LETL_018P7_03", "LETL_018P7_04", "LETL_018P7_05", "LETL_018P9_01", "LETL_018P9_02", "LETL_018P9_03", "LETL_019P2_01", "LETL_019P2_02", "LETL_019P2_03", "LETL_019P2_04", "LETL_019P2_05", "LETL_019P3_01", "LETL_019P3_02", "LETL_019P3_03", "LETL_019P3_04", "LETL_019P3_05", "LETL_019P6_01", "LETL_019P6_02", "LETL_019P6_03", "LETL_019P6_04", "LETL_019P6_05", "LETL_021P5_01", "LETL_021P5_02", "LETL_021P5_03", "LETL_022P4_01", "LETL_022P4_02", "LETL_022P4_03", "LETL_022P4_04", "LETL_022P4_05", "LETL_022P7_01", "LETL_022P7_02", "LETL_022P7_03", "LETL_027P2_01", "LETL_027P2_02", "LETL_027P2_03", "LETL_027P2_04", "LETL_027P2_05", "LETL_027P6_01", "LETL_027P6_02", "LETL_027P6_03", "LETL_027P6_04", "LETL_027P6_05", "LETL_027P7_01", "LETL_027P7_02", "LETL_027P7_03", "LETL_028P11_01", "LETL_028P11_02", "LETL_028P11_03", "LETL_028P11_04", "LETL_028P11_05", "LETL_028P9_01", "LETL_028P9_02", "LETL_028P9_03", "LETL_028P9_04", "LETL_028P9_05", "LETL_029P10_01", "LETL_029P10_02", "LETL_029P10_03", "LETL_029P10_04", "LETL_029P10_05", "LETL_029P5_01", "LETL_029P5_02", "LETL_029P5_03", "LETL_029P5_04", "LETL_029P5_05", "LETL_029P6_01", "LETL_029P6_02", "LETL_029P6_03", "LETL_029P6_04", "LETL_029P6_05", "LETL_030P3_01", "LETL_030P3_02", "LETL_030P3_03", "LETL_030P3_04", "LETL_030P3_05", "LETL_030P4_01", "LETL_030P4_02", "LETL_030P4_03", "LETL_030P4_04", "LETL_030P4_05", "LETL_030P6_01", "LETL_030P6_02", "LETL_030P6_03", "LETL_030P6_04", "LETL_030P6_05", "LETL_030P6e", "LETL_031P2_01", "LETL_031P2_02", "LETL_031P2_03", "LETL_031P2_04", "LETL_031P2_05", "LETL_031P4_01", "LETL_031P4_02", "LETL_031P4_03", "LETL_031P4_04", "LETL_031P4_05", "LETL_031P7_01", "LETL_031P7_02", "LETL_031P7_03", "LETL_031P7_04", "LETL_031P7_05", "LETL_032P6_01", "LETL_032P6_02", "LETL_032P6_03", "LETL_032P6_04", "LETL_032P6_05", "LETL_033P2_01", "LETL_033P2_02", "LETL_033P2_03", "LETL_033P2_04", "LETL_033P2_05", "LETL_039P8_01", "LETL_039P8_02", "LETL_039P8_03", "LETL_039P8_04", "LETL_039P8_05", "LETL_040P3_01", "LETL_040P3_02", "LETL_040P3_03", "LETL_040P3_04", "LETL_040P3_05", "LETL_040P8_01", "LETL_040P8_02", "LETL_040P8_03", "LETL_1021_01", "LETL_1023_01", "LETL_1024_01", "LETL_1055_01", "LETL_1060_01", "LETL_1060_02", "LETL_1060_03", "LETL_1060_04", "LETL_1060_05", "LETL_1062_01", "LETL_1063_01", "LETL_1063_02", "LETL_1063_03", "LETL_1063_04", "LETL_1063_05", "LETL_1073_01", "LETL_1073_02", "LETL_1073_03", "LETL_1073_04", "LETL_1073_05", "LETL_1074_01", "LETL_1074_02", "LETL_1074_03", "LETL_1074_04", "LETL_1074_05", "LETL_1075_01", "LETL_1075_02", "LETL_1075_03", "LETL_1075_04", "LETL_1075_05", "LETL_1076_01", "LETL_1076_02", "LETL_1076_03", "LETL_1076_04", "LETL_1076_05", "LETL_1077_01", "LETL_1077_02", "LETL_1077_03", "LETL_1077_04", "LETL_1077_05", "LETL_1078_01", "LETL_1078_02", "LETL_1078_03", "LETL_1078_04", "LETL_1078_05", "LETL_1079_01", "LETL_1079_02", "LETL_1079_03", "LETL_1079_04", "LETL_1079_05", "LETL_1080_01", "LETL_1080_02", "LETL_1080_03", "LETL_1080_04", "LETL_1080_05", "LETL_1102_01", "LETL_1102_02", "LETL_1104_01", "LETL_1106_01", "LETL_1106_02", "LETL_1106_03", "LETL_1106_04", "LETL_1106_05", "LETL_1116_01", "LETL_1116_02", "LETL_1116_03", "LETL_1116_04", "LETL_1116_05", "LETL_1134", "LETL_222_01", "LETL_222_02", "LETL_222_03", "LETL_222_04", "LETL_222_05", "LETL_225_01", "LETL_225_02", "LETL_225_03", "LETL_225_04", "LETL_225_05", "LETL_234_01", "LETL_234_02", "LETL_234_03", "LETL_234_04", "LETL_234_05", "LETL_236_01", "LETL_236_02", "LETL_236_03", "LETL_236_04", "LETL_236_05", "LETL_237_01", "LETL_237_02", "LETL_237_03", "LETL_237_04", "LETL_237_05", "LETL_240_01", "LETL_240_02", "LETL_240_03", "LETL_242_01", "LETL_242_02", "LETL_242_03", "LETL_242_04", "LETL_242_05", "LETL_246_01", "LETL_246_02", "LETL_246_03", "LETL_246_04", "LETL_246_05", "LETL_251_01", "LETL_251_02", "LETL_251_03", "LETL_251_04", "LETL_251_05", "LETL_257_01", "LETL_257_02", "LETL_257_03", "LETL_257_04", "LETL_257_05", "LETL_262_01", "LETL_262_02", "LETL_262_03", "LETL_262_04", "LETL_262_05", "LETL_270_01", "LETL_270_02", "LETL_270_03", "LETL_290_01", "LETL_290_02", "LETL_290_03", "LETL_290_04", "LETL_290_05", "LETL_292_01", "LETL_292_02", "LETL_292_03", "LETL_292_04", "LETL_292_05", "LETL_293_01", "LETL_293_02", "LETL_293_03", "LETL_293_04", "LETL_300_01", "LETL_300_02", "LETL_300_03", "LETL_300_04", "LETL_300_05", "LETL_301_01", "LETL_301_02", "LETL_301_03", "LETL_301_04", "LETL_301_05", "LETL_302_01", "LETL_302_02", "LETL_302_03", "LETL_302_04", "LETL_302_05", "LETL_306_01", "LETL_306_02", "LETL_306_03", "LETL_306_04", "LETL_306_05", "LETL_307_01", "LETL_307_02", "LETL_307_03", "LETL_307_04", "LETL_307_05", "LETL_310_01", "LETL_310_02", "LETL_310_03", "LETL_311_01", "LETL_311_02", "LETL_311_03", "LETL_311e", "LETL_317_01", "LETL_317_02", "LETL_317_03", "LETL_317_04", "LETL_317_05", "LETL_320_01", "LETL_320_02", "LETL_320_03", "LETL_320_04", "LETL_320_05", "LETL_324_01", "LETL_324_02", "LETL_324_03", "LETL_324_04", "LETL_324_05", "LETL_328_01", "LETL_328_02", "LETL_328_03", "LETL_328_04", "LETL_328_05", "LETL_331_01", "LETL_331_02", "LETL_331_03", "LETL_331_04", "LETL_331_05", "LETL_332_01a", "LETL_332_01b", "LETL_332_02a", "LETL_332_02b", "LETL_332_03a", "LETL_332_03b", "LETL_332_04a", "LETL_332_04b", "LETL_332_05a", "LETL_332_05b", "LETL_336_01", "LETL_336_02", "LETL_336_03", "LETL_336_04", "LETL_336_05", "LETL_340_01", "LETL_340_02", "LETL_340_03", "LETL_340_04", "LETL_340_05", "LETL_373_01", "LETL_373_02", "LETL_373_03", "LETL_396_01", "LETL_396_02", "LETL_396_03", "LETL_396_04", "LETL_396_05", "LETL_403_01", "LETL_403_02", "LETL_403_03", "LETL_403_04", "LETL_403_05", "LETL_404_01", "LETL_404_02", "LETL_404_03", "LETL_404_04", "LETL_404_05", "LETL_408_01", "LETL_408_02", "LETL_408_03", "LETL_408_04", "LETL_408_05", "LETL_412_01", "LETL_412_02", "LETL_412_03", "LETL_412_04", "LETL_412_05", "LETL_414_01", "LETL_414_02", "LETL_414_03", "LETL_414_04", "LETL_414_05", "LETL_420_01", "LETL_420_02", "LETL_420_03", "LETL_420_04", "LETL_420_05", "LETL_431_01", "LETL_431_02", "LETL_431_03", "LETL_431_04", "LETL_431_05", "LETL_432_01", "LETL_432_02", "LETL_432_03", "LETL_432_04", "LETL_432_05", "LETL_450_01", "LETL_450_02", "LETL_450_03", "LETL_450_04", "LETL_450_05", "LETL_451_01", "LETL_451_02", "LETL_451_03", "LETL_451_04", "LETL_451_05", "LETL_463_01", "LETL_463_02", "LETL_463_03", "LETL_463_04", "LETL_463_05", "LETL_470_01", "LETL_470_02", "LETL_470_03", "LETL_470_04", "LETL_470_05", "LETL_471_01", "LETL_471_02", "LETL_471_03", "LETL_471_04", "LETL_471_05", "LETL_472_01", "LETL_472_01x", "LETL_472_02", "LETL_472_02x", "LETL_472_03", "LETL_472_03x", "LETL_472_04", "LETL_472_04x", "LETL_472_05", "LETL_472_05x", "LETL_480_01x", "LETL_480_01y", "LETL_480_01z", "LETL_480_02x", "LETL_480_02y", "LETL_480_02z", "LETL_480_03x", "LETL_480_03y", "LETL_480_03z", "LETL_480_04x", "LETL_480_04y", "LETL_480_04z", "LETL_480_05x", "LETL_480_05y", "LETL_480_05z", "LETL_507_01", "LETL_507_02", "LETL_507_03", "LETL_507_04", "LETL_507_05", "LETL_507e", "LETL_516_01", "LETL_516_02", "LETL_516_03", "LETL_516_04", "LETL_516e", "LETL_527_01", "LETL_527_02", "LETL_527_03", "LETL_527_04", "LETL_527_05", "LETL_532_01", "LETL_535_05", "LETL_546_01", "LETL_546_02", "LETL_547_01", "LETL_547_02", "LETL_550_01", "LETL_550_02", "LETL_550_03", "LETL_550_04", "LETL_550_05", "LETL_552_01", "LETL_552_02", "LETL_552_03", "LETL_552_04", "LETL_552_05", "LETL_553_01", "LETL_553_02", "LETL_553_03", "LETL_553_04", "LETL_553_05", "LETL_555_01", "LETL_555_02", "LETL_555_03", "LETL_555_04", "LETL_555_05", "LETL_634_01", "LETL_634_02", "LETL_634_03", "LETL_634_04", "LETL_670_02", "LETL_670_03", "LETL_670_04", "LETL_670e", "LETL_759_01", "LETL_759_02", "LETL_759_03", "LETL_759_04", "LETL_759_05", "LETL_760_01", "LETL_760_02", "LETL_760_03", "LETL_760_04", "LETL_760_05", "LETL_761_01", "LETL_761_02", "LETL_761_03", "LETL_761_04", "LETL_761_05", "LETL_762_01", "LETL_762_02", "LETL_762_03", "LETL_762_04", "LETL_762_05", "LETL_763_01", "LETL_763_02", "LETL_763_03", "LETL_763_04", "LETL_763_05", "LETL_764_01", "LETL_764_02", "LETL_764_03", "LETL_764_04", "LETL_764_05", "LETL_765_01", "LETL_765_02", "LETL_765_03", "LETL_765_04", "LETL_765_05", "LETL_766_01", "LETL_766_02", "LETL_766_03", "LETL_766_04", "LETL_766_05", "LETL_768_01", "LETL_768_02", "LETL_768_03", "LETL_768_04", "LETL_768_05", "LETL_771_01", "LETL_771_02", "LETL_771_03", "LETL_771_04", "LETL_771_5", "LETL_772_01", "LETL_772_02", "LETL_772_03", "LETL_772_04", "LETL_772_05", "LETL_774_01", "LETL_774_02", "LETL_774_03", "LETL_774_04", "LETL_774_05", "LETL_774e", "LETL_812P4_01", "LETL_813_01", "LETL_815P1_01", "LETL_815P1_02", "LETL_815P2_01", "LETL_815P2_02", "LETL_816P1_01", "LETL_816P1_03", "LETL_818P1_01", "LETL_820P1_01", "LETL_820P1_02", "LETL_820P2_01", "LETL_820P2_02", "LETL_820P4_01", "LETL_820P4_01m", "LETL_821H3", "LETL_821P1_01", "LETL_821P1_02", "LETL_821P1_04", "LETL_821P2_01", "LETL_822P1_01", "LETL_822P1_03", "LETL_823P1_01", "LETL_823P1_03", "LETL_823P2_01", "LETL_823P4_01", "LETL_823P4_02", "LETL_823P4_03", "LETL_823P4_04", "LETL_823P4_05", "LETL_824P3_02", "LETL_824P3_02_4", "LETL_828P2_01", "LETL_828P2_03", "LETL_828P3_01", "LETL_829P1_02", "LETL_829P1_05", "LETL_830P1_01", "LETL_830P1_03", "LETL_830P2_01", "LETL_830P2_03", "LETL_831H2", "LETL_832H", "LETL_832P3_03", "LETL_832P3_04", "LETL_835P1_01", "LETL_835P1_02", "LETL_835P2_01", "LETL_835P2_03", "LETL_837H", "LETL_838P1_03", "LETL_838P1_04", "LETL_839P1_01t", "LETL_839P1_03t", "LETL_840He", "LETL_842P1_01", "LETL_842P1_02", "LETL_843P3_02", "LETL_844P1_01", "LETL_844P2_01", "LETL_845P1_01", "LETL_845P3_04", "LETL_845P3_05", "LETL_845P4_04", "LETL_845P4_05", "LETL_846H", "LETL_846P3_01", "LETL_847P2_01", "LETL_847P2_02", "LETL_847P3_01", "LETL_847P3_02", "LETL_847P4_01", "LETL_847P4_02", "LETL_848P1_01", "LETL_849P2_04", "LETL_849P2_05", "LETL_849P4_04", "LETL_849P4_05", "LETL_852P2", "LETL_852P3", "LETL_855P1_04", "LETL_855P1_05", "LETL_858P1_01", "LETL_859P1", "LETL_859P3", "LETL_903P2_01", "LETL_903P2_02", "LETL_930_01", "LETL_930_02", "LETL_930_03", "LETL_930_04", "LETL_930_05", "LETL_931_01", "LETL_933_01", "LETL_933_02", "LETL_933_03", "LETL_933_04", "LETL_933_05", "LETL_933e", "LETL_934_01", "LETL_936_01", "LETL_936_02", "LETL_936_03", "LETL_936_04", "LETL_936_05", "LETL_936e", "LETL_949_01", "LETL_950_01", "LETL_950_02", "LETL_950_03", "LETL_950_04", "LETL_950_05", "LETL_951_01", "LETL_951_02", "LETL_951_03", "LETL_951_04", "LETL_951_05", "LETL_956_01", "LETL_956_02", "LETL_956_03", "LETL_956_04", "LETL_956_05", "LETL_960_01", "LETL_960_02", "LETL_960_03", "LETL_960_04", "LETL_960_05", "LETL_965_01", "LETL_965_02", "LETL_965_03", "LETL_965_04", "LETL_965_05", "LETL_975_01", "LETL_979_01", "LETL_NPC_Attack_Fireball", "LETLT_006_01", "LETLT_007_01", "LETLT_008_01", "LETLT_021_01", "LETLT_031_02", "LETLT_037_04", "LETLT_038_02", "LETLT_041_02", "LETLT_048_02e", "LETLT_050_03", "LETLT_055_02", "LETLT_056_02", "LETLT_059_02", "LETLT_060_01", "LETLT_060_03", "LETLT_060_03e", "LETLT_074p1_01", "LETLT_076p1_01", "LETLT_081_02", "LETLT_083_02", "LETLT_083_03", "LETLT_084_02", "LETLT_091_01", "LETLT_091_02", "LETLT_100_03", "LETLT_101_03", "LETLT_103_02", "LETLT_103_03", "LETLT_106_03", "LETLT_111_02", "LOE_002", "LOE_002t", "LOE_016", "LOE_021", "LOE_027", "LOE_046", "LOE_104", "LOE_111", "LOEA01_12", "LOEA01_12h", "LOEA04_25", "LOEA04_25h", "LOEA06_04", "LOEA06_04h", "LOEA07_18", "LOEA07_20", "LOEA07_29", "LOEA09_6", "LOEA09_6H", "LOEA09_9", "LOEA09_9H", "LOEA15_3", "LOEA15_3H", "LOEA16_10", "LOEA16_11", "LOEA16_4", "LOEA16_6", "LOEA16_8", "LOEA16_9", "LOOT_013", "LOOT_014", "LOOT_017", "LOOT_043", "LOOT_043t2", "LOOT_043t3", "LOOT_051", "LOOT_051t1", "LOOT_051t2", "LOOT_060", "LOOT_077", "LOOT_101", "LOOT_111", "LOOT_118", "LOOT_122", "LOOT_132", "LOOT_150", "LOOT_172", "LOOT_278t4e", "LOOT_285t2", "LOOT_347", "LOOT_358", "LOOT_364", "LOOT_389", "LOOT_410", "LOOT_415t6", "LOOT_417", "LOOT_503", "LOOT_503t", "LOOT_503t2", "LOOT_504", "LOOT_504t", "LOOT_522", "LOOT_998l", "LOOTA_102", "LOOTA_805", "LOOTA_806", "LOOTA_811", "LOOTA_826", "LOOTA_827", "LOOTA_842", "LOOTA_843", "LOOTA_BOSS_05p", "LOOTA_BOSS_06p", "LOOTA_BOSS_09p", "LOOTA_BOSS_11p", "LOOTA_BOSS_13p", "LOOTA_BOSS_20p", "LOOTA_BOSS_21p", "LOOTA_BOSS_23p", "LOOTA_BOSS_25p", "LOOTA_BOSS_26p2", "LOOTA_BOSS_26p3", "LOOTA_BOSS_26p4", "LOOTA_BOSS_26p6", "LOOTA_BOSS_26p7", "LOOTA_BOSS_28p", "LOOTA_BOSS_29p", "LOOTA_BOSS_30p", "LOOTA_BOSS_39p", "LOOTA_BOSS_44p", "LOOTA_BOSS_47p", "LOOTA_BOSS_49t2", "LOOTA_BOSS_51p", "LOOTA_BOSS_53p", "LOOTA_BOSS_99t", "LT21_002_01", "LT21_002_02", "LT21_002_03", "LT21_002_04", "LT21_002_05", "LT21_015_001", "LT21_015_002", "LT21_015_003", "LT21_015_004", "LT21_015_005", "LT21_02P3_01", "LT21_02P3_02", "LT21_02P3_03", "LT21_02P3_04", "LT21_02P3_05", "LT21_05P2_01mA", "LT21_05P2_02mA", "LT21_05P2_03mA", "LT21_05P2_04mA", "LT21_05P2_05mA", "LT21_05P3_01", "LT21_05P3_02", "LT21_05P3_03", "LT21_05P3_04", "LT21_05P3_05", "LT21_07P2_01", "LT21_07P2_02", "LT21_07P2_03", "LT21_07P2_04", "LT21_07P2_05", "LT21_07P3_01", "LT21_07P3_02", "LT21_07P3_03", "LT21_07P3_04", "LT21_07P3_05", "LT22_002E3mP", "LT22_002P1_01", "LT22_002P1_02", "LT22_002P1_03", "LT22_002P1_04", "LT22_002P1_05", "LT22_002P2_01", "LT22_002P2_02", "LT22_002P2_03", "LT22_002P2_04", "LT22_002P2_05", "LT22_002P3_01", "LT22_002P3_02", "LT22_002P3_03", "LT22_002P3_04", "LT22_002P3_05", "LT22_002P3a_01", "LT22_002P3a_02", "LT22_002P3a_03", "LT22_002P3a_04", "LT22_002P3a_05", "LT22_002P3b_01", "LT22_002P3b_02", "LT22_002P3b_03", "LT22_002P3b_04", "LT22_002P3b_05", "LT22_004P2_01", "LT22_004P2_02", "LT22_004P2_03", "LT22_004P2_04", "LT22_004P2_05", "LT22_004P3_01", "LT22_004P3_02", "LT22_004P3_03", "LT22_004P3_04", "LT22_004P3_05", "LT22_005P1_01", "LT22_005P1_02", "LT22_005P1_03", "LT22_005P1_04", "LT22_005P1_05", "LT22_005P2_01", "LT22_005P2_02", "LT22_005P2_03", "LT22_005P2_04", "LT22_005P2_05", "LT22_005P3_01", "LT22_005P3_02", "LT22_005P3_03", "LT22_005P3_04", "LT22_005P3_05", "LT22_007P1_01", "LT22_007P1_02", "LT22_007P1_03", "LT22_007P1_04", "LT22_007P1_05", "LT22_008E2e", "LT22_009P1_01", "LT22_009P1_02", "LT22_009P1_03", "LT22_009P1_04", "LT22_009P1_05", "LT22_010P1_01", "LT22_010P1_02", "LT22_010P1_03", "LT22_010P1_04", "LT22_010P1_05", "LT22_010P3_01", "LT22_010P3_02", "LT22_010P3_03", "LT22_010P3_04", "LT22_010P3_05", "LT22_012P3e", "LT22_014P2_01", "LT22_014P2_02", "LT22_014P2_03", "LT22_014P2_04", "LT22_014P2_05", "LT22_014P3b_01", "LT22_014P3b_02", "LT22_014P3b_03", "LT22_014P3b_04", "LT22_014P3b_05", "Mission_ForceDrawInOrder", "NAX1_05", "NAX10_03", "NAX10_03H", "NAX11_02", "NAX11_02H", "NAX11_02H_2_TB", "NAX12_02", "NAX12_02H", "NAX12_02H_2_TB", "NAX12_02H_2c_TB", "NAX14_02", "NAX14_04", "NAX15_02", "NAX15_02H", "NAX15_04", "NAX15_04H", "NAX3_02", "NAX3_02_TB", "NAX3_02H", "NAX3_03", "NAX4_05", "NAX5_02", "NAX5_02H", "NAX6_02", "NAX6_02H", "NAX6_03", "NAX6_04", "NAX7_03", "NAX7_03H", "NAX8_03t", "NAX8_04t", "NAX8_05t", "NAXM_001", "NAXM_002", "NEW1_003", "NEW1_004", "NEW1_005", "NEW1_007", "NEW1_007a", "NEW1_007b", "NEW1_017", "NEW1_019", "NEW1_020", "NEW1_030", "NEW1_041", "OG_027", "OG_033", "OG_061", "OG_080c", "OG_080f", "OG_081", "OG_083", "OG_085", "OG_086", "OG_100", "OG_116", "OG_120", "OG_149", "OG_151", "OG_161", "OG_162", "OG_176", "OG_179", "OG_206", "OG_239", "OG_254", "OG_279", "OG_280", "OG_282", "OG_314", "OG_328", "ONY_005ta1", "ONY_005ta13", "ONY_005ta3", "ONY_005ta4", "ONY_005ta6", "ONY_005ta7", "ONY_005tb14", "ONY_005tb4", "ONY_005tc1", "ONY_005tc2", "ONY_005tc7", "ONY_006", "ONY_007", "ONY_010", "ONY_011", "ONY_013", "ONY_014", "ONY_018", "ONY_018t2", "ONY_026", "ONY_032", "ONY_035", "PART_002", "PART_005", "PRO_001b", "Prologue_Captain", "Prologue_ChaosNova", "Prologue_Jarod", "Prologue_MannorothHP", "Prologue_UnstableEnergy3", "Prologue_XaviusHP", "PVPDR_035", "PVPDR_042", "PVPDR_AV_Neutralp3", "PVPDR_AV_Neutralp3p3", "PVPDR_AV_Neutralp4", "PVPDR_AV_Neutralp5", "PVPDR_BAR_Passive10", "PVPDR_BAR_Passive10e1", "PVPDR_BAR_Passive19", "PVPDR_BAR_Passive19e1", "PVPDR_BAR_Passive21", "PVPDR_BAR_Passive21e1", "PVPDR_BAR_Passive23", "PVPDR_BAR_Passive23e1", "PVPDR_BAR_Passive26", "PVPDR_BAR_Passive26e1", "PVPDR_BAR_Passive27", "PVPDR_BAR_Passive27e1", "PVPDR_DMF_Druidp1", "PVPDR_DMF_Roguet2", "PVPDR_GUEST_Diablop2", "PVPDR_GUEST_Diablot2", "PVPDR_GUEST_Diablot3", "PVPDR_GUEST_Diablot4", "PVPDR_SCH_Active02", "PVPDR_SCH_Active07", "PVPDR_SCH_Active17", "PVPDR_SCH_Active25", "PVPDR_SCH_Active39", "PVPDR_SCH_Active39s1", "PVPDR_SCH_Active39s2", "PVPDR_SCH_Active42", "PVPDR_SCH_Active43", "PVPDR_SCH_Active44", "PVPDR_SCH_Active52", "PVPDR_SCH_Active54", "PVPDR_SCH_Active55", "PVPDR_SCH_Active57", "PVPDR_SCH_Active61", "PVPDR_SCH_Hunterp1", "PVPDR_SCH_Magep3", "PVPDR_SCH_Maget5", "PVPDR_SCH_Passive15a1", "PVPDR_SCH_Passive23", "PVPDR_SCH_Passive23e", "PVPDR_SCH_Passive39", "PVPDR_SCH_Passive39e", "PVPDR_SCH_Priestt1", "PVPDR_SCH_Warlockt4", "PVPDR_SCH_Warriorp1", "PVPDR_SCH_Warriort2", "PVPDR_YOP_DruidP1", "PVPDR_YOP_DruidT1", "PVPDR_YOP_MageP1", "PVPDR_YOP_MageP1m1", "PVPDR_YOP_MageT1t", "PVPDR_YOP_PaladinT3", "PVPDR_YOP_PriestT1", "PVPDR_YOP_PriestT1e1", "PVPDR_YOP_RogueT1", "SCH_199t2", "SCH_199t29", "SCH_235", "SCH_236", "SCH_239", "SCH_241", "SCH_248", "SCH_253", "SCH_271", "SCH_276", "SCH_307", "SCH_313", "SCH_348", "SCH_355", "SCH_509", "SCH_512", "SCH_514", "SCH_517", "SCH_521", "SCH_526", "SCH_535", "SCH_604", "SCH_607", "SCH_607a", "SCH_701", "SCH_704", "Story_01_AethasHP", "Story_01_ArthasHP", "Story_01_GarroshHP", "Story_01_Iceball", "Story_01_JainaHP", "Story_01_JainaHP2", "Story_01_JainaYoungHP", "Story_01_JainaYoungHP2", "Story_01_JainaYoungHP3", "Story_01_LordaeronAttendant", "Story_01_Shandris", "Story_01_TheramoreGates", "Story_01_TheramoreGuard", "Story_01_WaterElemental", "Story_01_WaterElemental2", "Story_02_BlackhandHP", "Story_02_DarkscaleHP", "Story_02_GronnTrap", "Story_02_Haratha", "Story_02_KulTiranGuard", "Story_02_LeoroxxHP", "Story_02_MishaHP", "Story_02_Monsoon", "Story_02_RexxarHP", "Story_02_RexxarMidHP4", "Story_02_Spirit", "Story_02_StuffedSack", "Story_02_WoundedFootman", "Story_03_AnduinHP", "Story_03_CairneHP", "Story_03_CorruptGarrosh", "Story_03_ElementalRift", "Story_03_EvenTotem", "Story_03_FireElementalHP", "Story_03_FreshPerspective", "Story_03_GarroshArmadaHP", "Story_03_OddTotem", "Story_03_Saurfang", "Story_03_ZarzhetHP", "Story_04_BlademasterHP", "Story_04_DarkPortalHP", "Story_04_FightTrainer", "Story_04_GuldanReinforcements", "Story_04_IcebladeWeapon", "Story_04_LibramofJustice", "Story_04_RadiantLightspawn", "Story_04_UtherHP3", "Story_04_UtherHP4", "Story_04_WallsLordaeron", "Story_04_YoungUtherHP", "Story_05_Alleria", "Story_05_AncientBrewmaster", "Story_05_AnduinHP", "Story_05_AnduinHP2", "Story_05_ForbiddenWords", "Story_05_JadeWarlord", "Story_05_JainaHP", "Story_05_JainaMinion", "Story_05_MarkedShot", "Story_05_MonkeyKingHP", "Story_05_UntamedAmbertail", "Story_05_VarianHP", "Story_05_VelenHP", "Story_05_WarMachine", "Story_05_YouthfulBrewmaster", "Story_06_AssassinsTraining", "Story_06_Broll", "Story_06_ChoGall_07p", "Story_06_GaronaShadow", "Story_06_Lilian", "Story_06_SanguineStrike", "Story_06_SilentShadow", "Story_06_SilentShadow2", "Story_06_SilentShadow3", "Story_06_SilentShadow4", "Story_06_Stasia_05p", "Story_06_Taoshi", "Story_06_TessGreymane", "Story_06_Tethys", "Story_06_Upheaval", "Story_06_Valeera_07p", "Story_06_Valeera_08p", "Story_06_Vendellin_04p", "Story_07_Deathwing_006p", "Story_07_Deathwing_006p2", "Story_07_Deathwing_006p3", "Story_07_Devastate", "Story_07_FeverPitch", "Story_07_HideousAmalgamation", "Story_07_Jaina_007p2", "Story_07_Mannoroth_004p", "Story_07_RouseRabble", "Story_07_SpiritofFire", "Story_07_SpiritofFiret", "Story_08_ArchdruidsRage", "Story_08_CorruptingRage", "Story_08_Hopelessness", "Story_08_Illidan_005p", "Story_08_Keeper", "Story_08_KeeperCorrupt", "Story_08_Mannoroth_002p", "Story_08_NightmareDemon", "Story_08_Nordrassil", "Story_08_Ragnaros_007p", "Story_08_Saurfang", "Story_08_Tyrande", "Story_08_WayofArchdruid", "Story_08_Weeding", "Story_09_AbyssalEnforcer", "Story_09_BlastcrystalPotion", "Story_09_BloodclawDragon", "Story_09_CouncilNecrolyte", "Story_09_DarkestHour", "Story_09_DemonfirePuzzle", "Story_09_DrainSoul", "Story_09_DreadInfernal", "Story_09_Duskbreaker", "Story_09_EnsnareSoul", "Story_09_FelfirePotion", "Story_09_Felrattler", "Story_09_FlameImp", "Story_09_ForgottenShaman", "Story_09_ForgottenShaman2", "Story_09_ForgottenWarrior", "Story_09_GrimoireofSacrifice", "Story_09_Guldan_005p", "Story_09_Guldan_006p", "Story_09_Guldan_007p", "Story_09_Guldan_008p", "Story_09_HarvestSoul", "Story_09_HellfirePuzzle", "Story_09_Hysteria", "Story_09_KilroggMinion", "Story_09_Lethal", "Story_09_MortalCoilPuzzle", "Story_09_Nerzhul_003p", "Story_09_PowerofGuldan", "Story_09_RainofFire", "Story_09_RaiseDead", "Story_09_Riftcleaver", "Story_09_RitualofDoom", "Story_09_SchoolSpirits", "Story_09_SerpentshrinePortal", "Story_09_Shadowbolt", "Story_09_SoulRend", "Story_09_SoulShear", "Story_09_SuspiciousElemental", "Story_09_Terongor", "Story_09_TombGuardian_008p", "Story_09_TormentSoul", "Story_09_VulgarHomunculus", "Story_09_WeakenedElemental", "Story_10_Akama", "Story_10_Akama_008p", "Story_10_Anubarak_006p", "Story_10_FesteringGhoul", "Story_10_FlameCrash", "Story_10_IcecrownObelisk", "Story_10_LadyVashj", "Story_10_Magtheridon_005p", "Story_10_PoisonTreant", "Story_10_SkullofGuldan", "Story_10_StolenVengeance", "Story_10_SulkingImp", "Story_10_Tichondrius_002p", "SW_012", "SW_027", "SW_028t", "SW_032", "SW_039", "SW_039t", "SW_040", "SW_043", "SW_046", "SW_052t4", "SW_072", "SW_078", "SW_079e6", "SW_079t3", "SW_079t3e", "SW_084", "SW_088", "SW_089", "SW_090", "SW_107", "SW_108", "SW_108t", "SW_110", "SW_311", "SW_311t", "SW_321", "SW_322", "SW_412", "SW_417", "SW_433t3a", "SW_441", "SW_442", "SW_445", "SW_452", "SW_460", "TB_008", "TB_01_BOM_Mercs_Dawngrasp_001p", "TB_01_BOM_Mercs_Guff_001p", "TB_BaconShop_HERO_17_Buddy", "TB_BaconShop_HERO_17_Buddy_G", "TB_BaconShop_HERO_55_Buddy", "TB_BaconShop_HP_009", "TB_BaconShop_HP_014", "TB_BaconShop_HP_019", "TB_BaconShop_HP_027", "TB_BaconShop_HP_043", "TB_BaconUps_075", "TB_BaconUps_079", "TB_BaconUps_103", "TB_BaconUps_118", "TB_BaconUps_126", "TB_BaconUps_128", "TB_BaconUps_148", "TB_BBR3_BOSS_01p", "TB_BBR3_BOSS_03p1", "TB_BoomBotFestival_001e", "TB_BountyHunt_Consume", "TB_BuildaBoss_404p", "TB_CoOpBossSpell_6", "TB_CoopHero_001", "TB_CoOpv3_002", "TB_CoOpv3_004", "TB_CoOpv3_005", "TB_CoOpv3_006", "TB_CoOpv3_007", "TB_CoOpv3_008", "TB_CoOpv3_012", "TB_CoOpv3_013", "TB_CoOpv3_200", "TB_CoOpv3_201", "TB_DK_Anduin", "TB_DK_Rexxar", "TB_DK_Thrall", "TB_EVILBRM_LOOTA_805", "TB_FactionWar_Boss_Rag_0", "tb_Fairytalecard_02", "TB_Firefest2_001", "TB_Firefest2_002", "TB_Firefest2_005", "TB_Firefest2_Ahune_HP", "TB_GiftExchange_Snowball", "TB_HeadlessHorseman_001", "TB_HeadlessHorseman_002", "TB_HeadlessHorseman_HP1", "TB_HeadlessHorseman_s004", "TB_HeadlessHorseman_s005", "TB_Henchmania_BoomEnchantBan", "TB_Henchmania_DiscoverB", "TB_HunterPrince_02", "TB_HunterPrince_03", "TB_HunterPrince_03a", "TB_HunterPrince_03b", "TB_Ignoblegarden3", "TB_KTRAF_11", "TB_KTRAF_12", "TB_KTRAF_4m", "TB_KTRAF_7", "TB_LEAGUE_REVIVAL_FinleySandHP", "TB_LevelUp_002", "TB_Lunar_Rooster", "TB_Lunar_RoosterE", "TB_MammothParty_301", "TB_MammothParty_hp002", "TB_MammothParty_s004", "TB_MammothParty_s101", "TB_MammothParty_s101b", "TB_MechWar_Boss2_HeroPower", "TB_OG_027", "TB_RoadToNR_DinoHP", "TB_RoadToNR_MurgathaHP", "TB_SPT_DPromoMinion2", "TB_SPT_DPromoSecret7", "TB_SPT_DPromoSpell1", "TB_TagTeam_ClearBoard", "TB_TempleOutrun_HHHead", "TB_TempleOutrun_Toggwaggle_HP", "TB_ThunderdomeWeaponA", "TB_ThunderdomeWeaponE", "TB_Zombeast_H", "TBST_002", "TOT_030t4", "TOT_100e", "TOT_103e", "TOT_116", "TOT_118", "TOT_340", "TP_Bling_HP2", "TRL_012", "TRL_059", "TRL_065h", "TRL_127", "TRL_157", "TRL_240", "TRL_245", "TRL_246", "TRL_249", "TRL_257", "TRL_258", "TRL_313", "TRL_316t", "TRL_317", "TRL_321", "TRL_341", "TRL_343", "TRL_345", "TRL_347", "TRL_360", "TRL_500", "TRL_505", "TRL_512", "TRL_524", "TRL_526", "TRL_543", "TRL_546", "TRL_555", "TRL_569", "TRLA_065p", "TRLA_129", "TRLA_129s", "TRLA_132", "TRLA_137", "TRLA_157", "TRLA_162e", "TRLA_167", "TRLA_177", "TRLA_182", "TRLA_806e2", "TRLA_808e2", "TU4a_004", "TU4c_002", "TU4c_004", "TU4d_003", "TU4e_005", "TU5_CS2_022", "TU5_CS2_025", "TU5_CS2_029", "TU5_DS1_185", "TU5_EX1_593", "ULD_158", "ULD_161", "ULD_162", "ULD_165", "ULD_172", "ULD_181", "ULD_184", "ULD_190", "ULD_238", "ULD_239", "ULD_240", "ULD_269", "ULD_271", "ULD_272", "ULD_280", "ULD_288", "ULD_293", "ULD_324", "ULD_410", "ULD_435", "ULD_705t", "ULD_707", "ULD_714", "ULD_717", "ULD_718", "ULD_728", "ULDA_006", "ULDA_010", "ULDA_019", "ULDA_024", "ULDA_032", "ULDA_034", "ULDA_044", "ULDA_113", "ULDA_115", "ULDA_204", "ULDA_207", "ULDA_401", "ULDA_404", "ULDA_703e2", "ULDA_713", "ULDA_912", "ULDA_BOSS_05p", "ULDA_BOSS_18e", "ULDA_BOSS_18p", "ULDA_BOSS_18px", "ULDA_BOSS_22p", "ULDA_BOSS_22px", "ULDA_BOSS_23p", "ULDA_BOSS_26p", "ULDA_BOSS_33p", "ULDA_BOSS_34p", "ULDA_BOSS_37p3", "ULDA_BOSS_37px3", "ULDA_BOSS_37t", "ULDA_BOSS_38p1", "ULDA_BOSS_38px1", "ULDA_BOSS_39p2", "ULDA_BOSS_39px2", "ULDA_BOSS_40p2", "ULDA_BOSS_40px2", "ULDA_BOSS_46p", "ULDA_BOSS_52p1", "ULDA_BOSS_54p", "ULDA_BOSS_59p", "ULDA_BOSS_59px", "ULDA_BOSS_60p", "ULDA_BOSS_60px", "ULDA_BOSS_61p", "ULDA_BOSS_61px", "ULDA_BOSS_67p2", "ULDA_BOSS_67p2e", "ULDA_BOSS_68p", "ULDA_BOSS_72e", "ULDA_BOSS_72ex", "ULDA_BOSS_74p", "ULDA_BOSS_74px", "ULDA_BOSS_75p", "ULDA_BOSS_75px", "ULDA_BOSS_76p", "ULDA_BOSS_76px", "ULDA_Brann_HP1", "ULDA_Reno_HP1", "UNG_004", "UNG_018", "UNG_025", "UNG_027", "UNG_027t2", "UNG_047", "UNG_057t1", "UNG_064", "UNG_084", "UNG_087", "UNG_111", "UNG_113", "UNG_116t", "UNG_202", "UNG_205", "UNG_211c", "UNG_211d", "UNG_803", "UNG_807", "UNG_817", "UNG_818", "UNG_831", "UNG_834", "UNG_835", "UNG_840", "UNG_847", "UNG_848", "UNG_910", "UNG_933", "UNG_934t2", "UNG_941", "UNG_946", "UNG_953", "UNG_955", "UNG_956", "UNG_956e", "VAN_CS1_112", "VAN_CS1_113", "VAN_CS1_129", "VAN_CS1_130", "VAN_CS2_008", "VAN_CS2_012", "VAN_CS2_022", "VAN_CS2_024", "VAN_CS2_025", "VAN_CS2_026", "VAN_CS2_028", "VAN_CS2_029", "VAN_CS2_031", "VAN_CS2_032", "VAN_CS2_033", "VAN_CS2_037", "VAN_CS2_042", "VAN_CS2_057", "VAN_CS2_061", "VAN_CS2_062", "VAN_CS2_063", "VAN_CS2_064", "VAN_CS2_072", "VAN_CS2_075", "VAN_CS2_076", "VAN_CS2_084", "VAN_CS2_093", "VAN_CS2_094", "VAN_CS2_108", "VAN_CS2_114", "VAN_CS2_141", "VAN_CS2_150", "VAN_CS2_181", "VAN_CS2_189", "VAN_CS2_203", "VAN_CS2_233", "VAN_CS2_234", "VAN_DREAM_02", "VAN_DREAM_04", "VAN_DREAM_05", "VAN_DS1_183", "VAN_DS1_185", "VAN_DS1_233", "VAN_EX1_002", "VAN_EX1_005", "VAN_EX1_029", "VAN_EX1_048", "VAN_EX1_049", "VAN_EX1_057", "VAN_EX1_066", "VAN_EX1_082", "VAN_EX1_091", "VAN_EX1_102", "VAN_EX1_124", "VAN_EX1_126", "VAN_EX1_129", "VAN_EX1_133", "VAN_EX1_134", "VAN_EX1_137", "VAN_EX1_144", "VAN_EX1_154", "VAN_EX1_154a", "VAN_EX1_154b", "VAN_EX1_161", "VAN_EX1_166", "VAN_EX1_166a", "VAN_EX1_166b", "VAN_EX1_170", "VAN_EX1_173", "VAN_EX1_238", "VAN_EX1_241", "VAN_EX1_245", "VAN_EX1_246", "VAN_EX1_249", "VAN_EX1_251", "VAN_EX1_259", "VAN_EX1_275", "VAN_EX1_277", "VAN_EX1_278", "VAN_EX1_279", "VAN_EX1_283", "VAN_EX1_298", "VAN_EX1_301", "VAN_EX1_302", "VAN_EX1_303", "VAN_EX1_304", "VAN_EX1_308", "VAN_EX1_309", "VAN_EX1_312", "VAN_EX1_313", "VAN_EX1_319", "VAN_EX1_320", "VAN_EX1_323", "VAN_EX1_332", "VAN_EX1_334", "VAN_EX1_360", "VAN_EX1_382", "VAN_EX1_384", "VAN_EX1_391", "VAN_EX1_400", "VAN_EX1_407", "VAN_EX1_408", "VAN_EX1_410", "VAN_EX1_522", "VAN_EX1_537", "VAN_EX1_539", "VAN_EX1_544", "VAN_EX1_558", "VAN_EX1_578", "VAN_EX1_581", "VAN_EX1_593", "VAN_EX1_594", "VAN_EX1_596", "VAN_EX1_603", "VAN_EX1_607", "VAN_EX1_609", "VAN_EX1_610", "VAN_EX1_617", "VAN_EX1_619", "VAN_EX1_622", "VAN_EX1_624", "VAN_EX1_625", "VAN_EX1_626", "VAN_HERO_05bp", "VAN_HERO_05bp2", "VAN_HERO_08bp", "VAN_HERO_08bp2", "VAN_NEW1_003", "VAN_NEW1_004", "VAN_NEW1_005", "VAN_NEW1_007", "VAN_NEW1_007a", "VAN_NEW1_007b", "VAN_NEW1_017", "VAN_NEW1_019", "VAN_NEW1_020", "VAN_NEW1_030", "VAN_NEW1_041", "WC_004", "WC_014", "WC_017", "WC_020", "WC_021", "WC_022", "WC_041", "WC_701", "YOD_014", "YOD_018", "YOD_020", "YOD_022", "YOD_029t", "YOP_006", "YOP_007", "YOP_020", "YOP_023", "YOP_027", "YOP_033" };
+
+        public enum CardEffect { UNKNOWN, FRIENDLY, UNFRIENDLY };
+
+        public static CardEffect ExtractEffect(string cardText)
+        {
+            try
+            {
+                return GetSpellEffect(cardText);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        public static CardEffect GetEffect(string cardId)
+        {
+            if (friendlyCards.Contains(cardId))
+            {
+                return CardEffect.FRIENDLY;
+            }
+            else if (unfriendlyCards.Contains(cardId))
+            {
+                return CardEffect.UNFRIENDLY;
+            }
+            else
+            {
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        private static CardEffect GetSpellEffect(string cardText)
+        {
+            var isFriendly = false;
+            var isUnfriendly = false;
+
+            if (IsSecret(cardText) ||
+                IsChooseAFriendlyMinion(cardText) ||
+                IsDiscover(cardText) ||
+                IsChooseN(cardText) ||
+                IsGiveSomething(cardText) ||
+                IsGainSomething(cardText) ||
+                IsDrawSomething(cardText) ||
+                IsRestoreSomething(cardText) ||
+                IsDoubleSomething(cardText) ||
+                IsPutACopyOf(cardText) ||
+                IsQuest(cardText) ||
+                IsWheneverItAttacks(cardText) ||
+                IsShuffle(cardText) ||
+                IsTrigger(cardText) ||
+                IsReveal(cardText) ||
+                IsSwap(cardText) ||
+                IsAddToHand(cardText) ||
+                IsReplaceYour(cardText) ||
+                IsAdapt(cardText) ||
+                IsResurrect(cardText) ||
+                IsSetGoodStats(cardText) ||
+                IsReturn(cardText) ||
+                IsRecruit(cardText) ||
+                IsSummon(cardText) ||
+                IsCostsLess(cardText) ||
+                IsWildcard(cardText)
+                )
+            {
+                isFriendly = true;
+            }
+
+            if (IsDealNDamage(cardText) ||
+                IsDestroySomething(cardText) ||
+                IsFreezeSomething(cardText) ||
+                IsTakeControl(cardText) ||
+                IsGainControl(cardText) ||
+                IsTransformSomething(cardText) ||
+                IsChangeSomething(cardText) ||
+                IsReturnSomething(cardText) ||
+                IsSilenceSomething(cardText) ||
+                IsShoot(cardText) ||
+                IsDealDamage(cardText) ||
+                IsThrowWeaponAt(cardText) ||
+                IsReduce(cardText) ||
+                IsChooseAnEnemyMinion(cardText) ||
+                IsSetBadStats(cardText) ||
+                IsForceMinion(cardText) ||
+                IsStealStats(cardText)
+                )
+            {
+                isUnfriendly = true;
+            }
+
+            if (isFriendly && isUnfriendly)
+            {
+                // Most cards that are both friendly and unfriendly are something like deal X damage to someone and gain Y health so we want to target unfriendly characters first
+                return CardEffect.UNFRIENDLY;
+            }
+            else if (isFriendly)
+            {
+                return CardEffect.FRIENDLY;
+            }
+            else if (isUnfriendly)
+            {
+                return CardEffect.UNFRIENDLY;
+            }
+            else
+            {
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        private static Regex s_costsLessRegex = new Regex(@" costs \(\d\) less.");
+        private static bool IsCostsLess(string cardText)
+        {
+            return s_costsLessRegex.Match(cardText).Success;
+        }
+
+        private static bool IsChooseAnEnemyMinion(string cardText)
+        {
+            return cardText.Contains("Choose an enemy minion");
+        }
+
+        private static bool IsReduce(string cardText)
+        {
+            return cardText.Contains("Reduce ");
+        }
+
+        private static bool IsThrowWeaponAt(string cardText)
+        {
+            return cardText.Contains("Throw your weapon ");
+        }
+
+        private static bool IsRecruit(string cardText)
+        {
+            return cardText.Contains("<b>Recruit</b>");
+        }
+
+        private static bool IsReturn(string cardText)
+        {
+            return cardText.Contains(" return it ");
+        }
+
+        private static Regex s_setAtkHealthRegex = new Regex(@"Set a minion's Attack and Health to (\d).");
+        private static bool IsSetBadStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val < 3;
+        }
+
+        private static bool IsSetGoodStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val >= 3;
+        }
+
+        private static bool IsResurrect(string cardText)
+        {
+            return cardText.Contains("Resurrect ");
+        }
+
+        private static bool IsAdapt(string cardText)
+        {
+            return cardText.Contains("<b>Adapt</b>");
+        }
+
+        private static bool IsReplaceYour(string cardText)
+        {
+            return cardText.Contains("Replace your ");
+        }
+
+        private static Regex s_addToHandRegex = new Regex(@"Add .* to your hand.*");
+        private static Regex s_addToHandLCRegex = new Regex(@" add .* to your hand.*");
+        private static Regex s_addToHandBrokenRegex = new Regex(@"Add .* to_your hand.*");
+        private static Regex s_addToHandBroken2Regex = new Regex(@"Add .* to your_hand.*");
+        private static bool IsAddToHand(string cardText)
+        {
+            return s_addToHandRegex.Match(cardText).Success ||
+                s_addToHandLCRegex.Match(cardText).Success ||
+                s_addToHandBrokenRegex.Match(cardText).Success ||
+                s_addToHandBroken2Regex.Match(cardText).Success;
+        }
+
+        private static bool IsSwap(string cardText)
+        {
+            return cardText.Contains("Swap ");
+        }
+
+        private static bool IsReveal(string cardText)
+        {
+            return cardText.Contains("Reveal ");
+        }
+
+        private static bool IsTrigger(string cardText)
+        {
+            return cardText.Contains("Trigger ");
+        }
+
+        private static bool IsShuffle(string cardText)
+        {
+            return cardText.Contains("Shuffle ");
+        }
+
+        private static bool IsDealDamage(string cardText)
+        {
+            return cardText.Contains("Deal damage ") || cardText.Contains("Deal that much damage");
+        }
+
+        private static bool IsWheneverItAttacks(string cardText)
+        {
+            return cardText.Contains("Whenever it attacks");
+        }
+
+        private static bool IsShoot(string cardText)
+        {
+            return cardText.Contains("Shoot ");
+        }
+
+        private static bool IsQuest(string cardText)
+        {
+            return cardText.Contains("<b>Quest:</b>") || cardText.Contains("<b>Sidequest:</b>") || cardText.Contains("<b>Questline:</b>");
+        }
+
+        private static bool IsPutACopyOf(string cardText)
+        {
+            return cardText.Contains("Put a copy of");
+        }
+
+        private static bool IsDoubleSomething(string cardText)
+        {
+            return cardText.Contains("Double ");
+        }
+
+        private static bool IsSilenceSomething(string cardText)
+        {
+            return cardText.Contains("<b>Silence</b> ");
+        }
+
+        private static bool IsRestoreSomething(string cardText)
+        {
+            return cardText.Contains("Restore ");
+        }
+
+        private static bool IsReturnSomething(string cardText)
+        {
+            return cardText.Contains("Return ");
+        }
+
+        private static bool IsChangeSomething(string cardText)
+        {
+            return cardText.Contains("Change ");
+        }
+
+        private static bool IsTransformSomething(string cardText)
+        {
+            return cardText.Contains("Transform ");
+        }
+
+        private static bool IsDrawSomething(string cardText)
+        {
+            return cardText.Contains("Draw ");
+        }
+
+        private static bool IsGainSomething(string cardText)
+        {
+            return cardText.Contains("Gain ");
+        }
+
+        private static bool IsForceMinion(string cardText)
+        {
+            return cardText.Contains("Force ");
+        }
+
+        private static bool IsStealStats(string cardText)
+        {
+            return cardText.Contains("It steals "); // e.g. Shadow Word: Devour
+        }
+
+        private static bool IsGainControl(string cardText)
+        {
+            return cardText.Contains("Gain control ") || cardText.Contains("gain control");
+        }
+
+        private static bool IsFreezeSomething(string cardText)
+        {
+            return cardText.Contains("<b>Freeze</b> a");
+        }
+
+        private static bool IsSummon(string cardText)
+        {
+            return cardText.Contains("Summon ") || cardText.Contains(" summon ");
+        }
+
+        private static bool IsDestroySomething(string cardText)
+        {
+            return cardText.Contains("Destroy ") || cardText.Contains(" destroy it");
+        }
+
+        private static bool IsGiveSomething(string cardText)
+        {
+            return cardText.Contains("Give ") || cardText.Contains(" give it") || cardText.Contains("G[x]ive ");
+        }
+
+        private static Regex s_dealNDamageRegex = new Regex(@".*Deal \*?\d+\*? damage.*");
+        private static Regex s_dealXYDamageRegex = new Regex(@".*Deal \*?\d+\*?-\*?\d\*? damage.*");
+        private static Regex s_dealNDamageBrokenRegex = new Regex(@".*Deal_\*?\d+\*? damage.*");
+        private static Regex s_dealNDamageBroken2Regex = new Regex(@".*Deal_\*?\d+\*?_damage.*");
+        private static Regex s_dealNDamageMidStringRegex = new Regex(@".*, deal \*?\d+\*? damage.*"); // See Scalerider
+        private static bool IsDealNDamage(string cardText)
+        {
+            return s_dealNDamageRegex.Match(cardText).Success ||
+                s_dealXYDamageRegex.Match(cardText).Success ||
+                s_dealNDamageBrokenRegex.Match(cardText).Success ||
+                s_dealNDamageBroken2Regex.Match(cardText).Success ||
+                s_dealNDamageMidStringRegex.Match(cardText).Success;
+        }
+
+        private static bool IsTakeControl(string cardText)
+        {
+            return cardText.Contains("Take control ");
+        }
+
+        private static bool IsChooseN(string cardText)
+        {
+            return cardText.Contains("<b>Choose One ") || cardText.Contains("<b>Choose Twice");
+        }
+
+        private static bool IsDiscover(string cardText)
+        {
+            return cardText.Contains("<b>Discover</b>");
+        }
+
+        private static bool IsSecret(string cardText)
+        {
+            return cardText.Contains("<b>Secret:</b>");
+        }
+
+        private static bool IsChooseAFriendlyMinion(string cardText)
+        {
+            return cardText.Contains("Choose a friendly minion");
+        }
+
+        private static HashSet<string> s_wildcards = new HashSet<string>()
+        {
+            "The next spell you cast this turn costs (2) less.",
+"Put a random minion from each player's hand into the battlefield.",
+"When you play or discard this, deal 4 damage to a random enemy.",
+"This turn, your healing effects deal damage instead.",
+"Add two Razorpetals to_your hand that deal_1 damage.",
+"Each time you play a Beast this turn, add_a_random Beast to_your hand.",
+"The next spell you cast this turn costs Health instead of Mana.",
+"Copy the lowest Cost minion in your hand.",
+"Each turn this is in your hand, transform it into a random Mage spell.",
+"Enemy spells cost (5) more next turn.",
+"Each player gains 2_Mana Crystals.",
+"Add 2 random <b>Deathrattle</b> cards to_your hand.",
+"Each player draws 2_cards.",
+"Whenever a minion dies this turn, gain 1 Mana Crystal this turn only.",
+"Your hero is <b>Immune</b> until your next turn.",
+"The next Elemental you_play this turn costs (2) less.",
+"Choose a minion. Add_a copy of it to your hand.",
+"Each player transforms a random minion in their hand into a Demon.",
+"Add a random card from another class to_your hand.",
+"Copy all Beasts in your_hand.",
+"Add a random Hunter Beast, <b>Secret</b>, and weapon to your_hand.",
+"Your hero can't take damage this turn.",
+"Your opponent has 2 fewer Mana Crystals next turn.",
+"Set the Attack of all enemy minions to 1 until your next turn.",
+"Your next spell this turn casts twice.",
+"Set each player to 0 Mana Crystals. Set the Cost of cards in all hands and decks to (1).",
+"Cast 10 random spells <i>(targets chosen randomly).</i>",
+"Replay 5 cards from other classes you've played this game.",
+"[x]Your <b>Deathrattles</b>\ntrigger twice.\nLasts 3 turns.",
+"[x]Your minions have\n+1 Attack.\nLasts 3 turns.",
+"[x]Cast 20 Mana worth of\nMage spells at enemies.",
+"Your minions cost (2) less this turn <i>(but not less than 1)</i>.",
+"[x]Your Hero Power\ndeals 1 more damage\nthis game.",
+"Fill your board with 2/1 Whelps with <b>Rush</b>."
+		};
+
+        private static HashSet<string> s_wildcardSubsets = new HashSet<string>()
+        {
+            "Put one of each <b>Secret</b> from your deck into",
+            "Each player equips",
+            "Set the Attack and Health of all minions",
+            "Cast a random",
+            "Fill your hand with",
+            "When you play",
+            "At the start of your next turn",
+            "Increase the damage of",
+            "Play 3 cards\n with",
+            "Play 3 different",
+            "At the start of your next",
+            "Unlock your <b>Overloaded</b>",
+            "Take 6\n damage on your turns",
+            "Take 6\ndamage on your turns",
+            "At the end of your"
+        };
+
+        private static bool IsWildcard(string cardText)
+        {
+            if (s_wildcards.Contains(cardText))
+            {
+                return true;
+            }
+
+            foreach (var wc in s_wildcardSubsets)
+            {
+                if (cardText.Contains(wc))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private static bool IsAtTheEndOfYourTurn(string cardText)
+		{
+            return cardText.Contains("At the end of your");
+
+		}
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollection.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollection.cs
new file mode 100644
index 0000000..98f65b1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollection.cs
@@ -0,0 +1,28 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionDeckTrayButton : AccessibleItem
+    {
+        private readonly CollectionDeckTrayButton m_button;
+
+        internal AccessibleCollectionDeckTrayButton(AccessibleComponent parent, CollectionDeckTrayButton button) : base(parent)
+        {
+            m_button = button;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_button.m_buttonText.Text);
+
+            return ret;
+        }
+
+        internal CollectionDeckTrayButton GetCollectionDeckTrayButton()
+        {
+            return m_button;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionCardBack.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionCardBack.cs
new file mode 100644
index 0000000..58fb5b1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionCardBack.cs
@@ -0,0 +1,41 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionCardBack : AccessibleItem
+    {
+        private readonly CollectionCardBack m_cardBack;
+
+        internal AccessibleCollectionCardBack(AccessibleComponent parent, CollectionCardBack cardBack) : base(parent)
+        {
+            m_cardBack = cardBack;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_cardBack.m_name.Text);
+
+            if (m_cardBack.m_favoriteBanner?.activeInHierarchy ?? false)
+			{
+                ret.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_FAVORITE_CARD_BACK"));
+			}
+
+            var numCopies = 0;
+            if (CardBackManager.Get()?.IsCardBackOwned(m_cardBack.GetCardBackId()) ?? false)
+			{
+                numCopies = 1;
+			}
+            AccessibleCardUtils.AddOwnedLine(ret, numCopies);
+
+            return ret;
+        }
+
+        internal int GetCardBackId()
+		{
+            return m_cardBack.GetCardBackId();
+		}
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs
new file mode 100644
index 0000000..8d8eab0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs
@@ -0,0 +1,97 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionDeckBoxVisual : AccessibleItem
+    {
+        private readonly CollectionDeckBoxVisual m_deck;
+
+        private bool m_inCollectionManager;
+
+        internal AccessibleCollectionDeckBoxVisual(AccessibleComponent parent, CollectionDeckBoxVisual deck, bool inCollectionManager=false) : base(parent)
+        {
+            m_deck = deck;
+            m_inCollectionManager = inCollectionManager;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_inCollectionManager)
+            {
+                return GetLinesForCollectionManager();
+            }
+            else
+            {
+                return GetLinesForDeckSelectionScreen();
+            }
+        }
+
+        private List<string> GetLinesForDeckSelectionScreen()
+        {
+            // Name and class
+            var ret = GetCommonDeckLines();
+
+            // Inform this can be converted if this is not a standard deck
+            if (m_deck.CanClickToConvertToStandard())
+			{
+                ret.Add(LocalizationUtils.Get(LocalizationKey.DECK_PICKER_CLICK_TO_CONVERT));
+			}
+
+            try
+            {
+                // Hero level
+                var heroLevel = GameUtils.GetHeroLevel(m_deck.GetClass());
+                var currentLevel = heroLevel.CurrentLevel?.Level;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_DECK_HERO_LEVEL, currentLevel));
+            }
+            catch (Exception)
+            {
+                // In some scenarios such as the first time we open practice mode right after the tutorial ends the hero level isn't populated
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForCollectionManager()
+        {
+            // Name and class for now. TODO: Missing cards later
+            return GetCommonDeckLines();
+        }
+
+        private List<string> GetCommonDeckLines()
+        {
+            var ret = new List<string>();
+
+            // Deck name
+            var deckName = m_deck.GetDeckNameText().Text;
+            ret.Add(deckName);
+
+            if (SceneMgr.Get()?.GetMode() != SceneMgr.Mode.ADVENTURE)
+			{
+				// Format
+				var deckFormat = m_deck.GetFormatType();
+				ret.Add(GameStrings.GetFormatName(deckFormat));
+			}
+
+			// Hero name
+			var className = GameStrings.GetClassName(m_deck.GetClass());
+            if (!className.Equals(deckName, StringComparison.InvariantCultureIgnoreCase))
+            {
+                ret.Add(className);
+            }
+
+            // Missing cards
+            if (m_deck.IsMissingCards)
+            {
+                var collectionDeck = m_deck.GetCollectionDeck();
+				int maxCardCount = collectionDeck.GetMaxCardCount();
+				int totalValidCardCount = collectionDeck.GetTotalValidCardCount();
+
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK, totalValidCardCount, maxCardCount));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs
new file mode 100644
index 0000000..daa9246
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs
@@ -0,0 +1,1931 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleCollectionManager : AccessibleScreen
+    {
+        private enum State {
+            LOADING,
+            MAIN_MENU,
+            BROWSE_COLLECTION_MENU,
+            BROWSING_CARDS,
+            BROWSING_COINS,
+            BROWSING_CARD_BACKS,
+            BROWSING_HERO_SKINS,
+            BROWSING_HERO_SKIN_CLASSES,
+            MANAGE_DECKS_MENU,
+            BROWSING_DECKS_FOR_EDITING,
+            BROWSING_DECKS_FOR_DELETING,
+            EDIT_DECK_MENU,
+            EDIT_DECK_SEE_COLLECTION,
+            EDIT_DECK_SEE_DECK,
+            EDIT_DECK_RENAME_DECK,
+            CREATE_DECK_FROM_CLIPBOARD,
+            CRAFTING_MENU,
+            CRAFTING_SEE_COLLECTION,
+            VIEW_CARD,
+            VIEW_CARD_CRAFTING,
+        };
+
+		private State m_curState;
+
+        private AccessibleMenu m_mainMenu;
+
+        private AccessibleMenu m_browseCollectionMenu;
+
+        private AccessibleMenu m_manageDecksMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_editDecksMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_deleteDecksMenu;
+
+        private AccessibleMenu m_editDeckMenu;
+
+        // Collection book stuff
+        private TAG_CLASS m_curClassContext;
+        private AccessibleListOfItems<AccessibleCollectibleCard> m_curPageCards;
+        private AccessibleListOfItems<AccessibleCollectionCardBack> m_curPageCardBacks; // Card backs code is different than everything else
+        private AccessibleListOfItems<AccessibleCollectionHeroPickerButton> m_heroPickerClassButtons; // Hero skins are grouped by classes now
+        private List<CollectionCardActors> m_curPageCardActors;
+        private bool m_justPressedLeft;
+        private int m_curPageNum;
+
+        // Crafting
+        private AccessibleMenu m_craftingMenu;
+        private AccessibleMenu m_viewCardMenu;
+        private AccessibleMenu m_viewCardCraftingMenu;
+        private CraftingUI m_craftingUI;
+        private CardInfoPane m_cardInfoPane;
+        private State m_stateBeforeViewCard; // Used to go back to the right menu after closing a card view
+
+        private bool m_waitingForServerResponse; // Used to read things more intuitively when regaining focus in certain cases
+
+        private bool m_justCanceledDisenchantPopup;
+
+		private static AccessibleCollectionManager s_instance = new AccessibleCollectionManager();
+
+        internal static AccessibleCollectionManager Get() {
+            return s_instance;
+        }
+
+        internal void OnCollectionManagerOpened()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_curState = State.LOADING;
+            m_stateBeforeViewCard = State.LOADING;
+            m_waitingForServerResponse = false;
+            m_justCanceledDisenchantPopup = false;
+
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerOpened");
+            AccessibilityMgr.SetScreen(this);
+        }
+
+		private bool IsSupportedCollectionManager()
+		{
+            // BG and Mercenaries CMs are not supported - break so players using OCR or being helped by sighted players can still access them if they'd like
+            return SceneMgr.Get().GetMode() == SceneMgr.Mode.COLLECTIONMANAGER;
+		}
+
+		private void HandlePageInput()
+        {
+            HandlePageInput(m_curPageCards);
+        }
+
+        private void HandleCardBacksPageInput()
+        {
+            HandlePageInput(m_curPageCardBacks);
+        }
+
+		private void HandlePageInput<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+		{
+			if (items != null)
+            {
+                if (AccessibleKey.READ_NEXT_PAGE.IsPressed())
+                {
+                    GetCollectionPageManager().m_pageRightClickableRegion.TriggerRelease();
+                }
+                else if (AccessibleKey.READ_PREV_PAGE.IsPressed())
+                {
+                    GetCollectionPageManager().m_pageLeftClickableRegion.TriggerRelease();
+                }
+                else if (!items.HandleAccessibleInput())
+                {
+                    if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+                    {
+                        m_justPressedLeft = true;
+                        GetCollectionPageManager().m_pageLeftClickableRegion.TriggerRelease();
+                    }
+                    else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+                    {
+                        GetCollectionPageManager().m_pageRightClickableRegion.TriggerRelease();
+                    }
+                }
+                else
+                {
+                    m_justPressedLeft = false;
+                }
+            }
+        }
+
+        private CollectionManagerDisplay GetCollectionManagerDisplay()
+        {
+            return CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        }
+
+        private ManaFilterTabManager GetManaFilterTabManager()
+        {
+            return GetCollectionManagerDisplay().m_manaTabManager;
+        }
+
+        private CollectionPageManager GetCollectionPageManager()
+        {
+            return GetCollectionManagerDisplay().m_pageManager;
+        }
+
+		internal void OnCancelDisenchantPopup()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_justCanceledDisenchantPopup = true;
+		}
+
+		internal void OnPageChanged<TCollectible>(int curPageNum, ICollection<TCollectible> collectiblesToDisplay, List<CollectionCardActors> cardActors) where TCollectible : ICollectible
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            List<CollectibleCard> cardsToDisplay = collectiblesToDisplay as List<CollectibleCard>;
+
+            if (cardsToDisplay == null)
+			{
+                // TODO: Battlegrounds skin
+                return;
+			}
+
+            AccessibilityUtils.LogDebug("CM OnPageChanged");
+            AccessibilityUtils.LogDebug($"CM curPageNum {curPageNum}");
+            AccessibilityUtils.LogDebug($"CM cardsToDisplay {cardsToDisplay.Count}");
+
+            foreach (var card in cardsToDisplay)
+            {
+                AccessibilityUtils.LogDebug($"CM -- {card.Name}");
+            }
+
+            var classContext = GetCollectionPageManager().m_currentClassContext;
+
+            AccessibilityUtils.LogDebug($"CM classContext={classContext} | m_curClassContext={m_curClassContext}");
+
+            if (curPageNum != m_curPageNum && IsBrowsingCards())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, curPageNum));
+                AccessibilityMgr.Output(this, GameStrings.GetClassName(classContext));
+            }
+            else if (curPageNum != m_curPageNum && IsBrowsingOtherCollectibles())
+			{
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, curPageNum));
+			}
+
+            var readOwned = IsBrowsingOtherCollectibles() || IsCrafting();
+            var readFavorites = m_curState == State.BROWSING_HERO_SKIN_CLASSES || m_curState == State.BROWSING_HERO_SKINS || m_curState == State.BROWSING_COINS;
+
+            var accessibleCards = new List<AccessibleCollectibleCard>(cardsToDisplay.Count);
+            cardsToDisplay.ForEach(c => accessibleCards.Add(new AccessibleCollectibleCard(this, c, true, false, readOwned, readFavorites)));
+
+            var curPageCards = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+
+            if (IsWaitingForServerResponse() && (m_stateBeforeViewCard == State.CRAFTING_SEE_COLLECTION || m_stateBeforeViewCard == State.BROWSING_CARDS))
+			{
+                OnServerResponse();
+
+                var prevIndex = m_curPageCards.GetItemBeingReadIndex();
+                var readFromIndex = Math.Min(prevIndex, curPageCards.Count);
+
+                if (m_curClassContext != classContext || m_curPageNum != curPageNum)
+				{
+                    readFromIndex = 0;
+				}
+
+                curPageCards.StartReadingFromIndex(readFromIndex);
+			}
+            else if (m_curPageCards == null || !SameCards(curPageCards.Items, m_curPageCards.Items))
+            {
+				if (IsBrowsingCards() || IsBrowsingOtherCollectibles())
+				{
+					if (m_justPressedLeft)
+                    {
+                        curPageCards.StartReadingReverse();
+                    }
+                    else
+                    {
+                        curPageCards.StartReading();
+                    }
+                }
+            }
+
+            m_curPageCards = curPageCards;
+            m_curPageCardActors = cardActors;
+            m_curClassContext = classContext;
+            m_curPageNum = curPageNum;
+            m_justPressedLeft = false;
+        }
+
+		internal void OnCardBacksPageChanged(int curPageNum, List<CollectionCardActors> cardActors)
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityUtils.LogDebug("CM OnCardBacksPageChanged");
+            AccessibilityUtils.LogDebug($"CM curPageNum {curPageNum}");
+
+            if (curPageNum != m_curPageNum)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, curPageNum));
+            }
+
+            var accessibleCardBacks = new List<AccessibleCollectionCardBack>(cardActors.Count);
+            foreach (var actor in cardActors)
+			{
+                var cardBack = actor.GetPreferredActor().GetComponent<CollectionCardBack>(); // Flimsy but covered by tests
+                accessibleCardBacks.Add(new AccessibleCollectionCardBack(this, cardBack));
+			}
+
+            var curPageCardBacks = new AccessibleListOfItems<AccessibleCollectionCardBack>(this, accessibleCardBacks);
+
+            if (m_curPageCardBacks == null || !SameCardBacks(curPageCardBacks.Items, m_curPageCardBacks.Items))
+            {
+				if (m_justPressedLeft)
+				{
+					curPageCardBacks.StartReadingReverse();
+				}
+				else
+				{
+					curPageCardBacks.StartReading();
+				}
+			}
+
+			m_curPageCardBacks = curPageCardBacks;
+            m_curPageCardActors = cardActors;
+            m_curClassContext = TAG_CLASS.NEUTRAL;
+            m_curPageNum = curPageNum;
+            m_justPressedLeft = false;
+        }
+
+		internal void OnShowNoMatchesFound(string key)
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            var text = GameStrings.Get(key);
+            m_curPageCards = new AccessibleListOfItems<AccessibleCollectibleCard>(this, new List<AccessibleCollectibleCard>(), text);
+            m_curPageCards.StartReading();
+		}
+
+        private bool SameCards(List<AccessibleCollectibleCard> l1, List<AccessibleCollectibleCard> l2)
+        {
+            if (l1.Count != l2.Count)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < l1.Count; i++)
+            {
+                if (!l1[i].GetName().Equals(l2[i].GetName()))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        private bool SameCardBacks(List<AccessibleCollectionCardBack> l1, List<AccessibleCollectionCardBack> l2)
+        {
+            if (l1.Count != l2.Count)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < l1.Count; i++)
+            {
+                if (l1[i].GetCardBackId() != l2[i].GetCardBackId())
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        internal void OnCollectionManagerClosed()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerClosed");
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        internal void OnCollectibleDisplayReady()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityUtils.LogDebug("CM OnCollectibleDisplayReady");
+            AccessibilityUtils.LogDebug($"{SceneMgr.Get().GetMode()}");
+
+            SetupMainMenu();
+        }
+
+		internal void OnChangeViewMode(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode curMode)
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            if (prevMode == CollectionUtils.ViewMode.MASS_DISENCHANT && curMode == CollectionUtils.ViewMode.CARDS)
+			{
+                MassDisenchant.Get()?.HideThis();
+			}
+		}
+
+		#region Input
+
+		public void HandleInput()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            switch (m_curState)
+            {
+                case State.BROWSING_CARDS:
+                case State.BROWSING_COINS:
+                    HandleBrowsingCollectionInput();
+                    break;
+                case State.BROWSING_HERO_SKINS:
+                    HandleBrowsingCollectionInput(true);
+                    break;
+                case State.BROWSING_CARD_BACKS:
+                    HandleBrowsingCardBacksInput();
+                    break;
+                case State.BROWSING_HERO_SKIN_CLASSES:
+                    HandleBrowsingHeroSkinClassesInput();
+                    break;
+                case State.MANAGE_DECKS_MENU:
+                    m_manageDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSING_DECKS_FOR_EDITING:
+                    m_editDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSING_DECKS_FOR_DELETING:
+                    m_deleteDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.MAIN_MENU:
+                    m_mainMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSE_COLLECTION_MENU:
+                    m_browseCollectionMenu?.HandleAccessibleInput();
+                    break;
+                case State.EDIT_DECK_MENU:
+                    m_editDeckMenu?.HandleAccessibleInput();
+                    break;
+                case State.EDIT_DECK_SEE_COLLECTION:
+                    HandleEditDeckSeeCollection();
+                    break;
+                case State.EDIT_DECK_SEE_DECK:
+                    HandleEditDeckSeeDeck();
+                    break;
+                case State.CRAFTING_MENU:
+                    m_craftingMenu?.HandleAccessibleInput();
+                    break;
+                case State.CRAFTING_SEE_COLLECTION:
+                    HandleCraftingSeeCollection();
+                    break;
+                case State.VIEW_CARD:
+                    m_viewCardMenu?.HandleAccessibleInput();
+                    break;
+                case State.VIEW_CARD_CRAFTING:
+                    m_viewCardCraftingMenu?.HandleAccessibleInput();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+		private void HandleCommonBrowseCollectionInput()
+		{
+            UpdateMouseWhenBrowsingCollection();
+
+            if (IsBrowsingCards())
+            {
+                HandleCommonBrowsingCardsInput();
+            }
+            else
+			{
+                HandlePageInput();
+			}
+		}
+
+		private void HandleCommonBrowsingCardsInput()
+		{
+			if (AccessibleKey.GLOBAL_FIND.IsPressed())
+			{
+				var collectionSearch = GetCollectionManagerDisplay().m_search;
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_SEARCH_PROMPT));
+				collectionSearch.m_background.TriggerRelease();
+				collectionSearch.ClearFilter(false);
+				return;
+			}
+
+			HandleManaFiltersInput();
+			if (!HandleClassTabsInput())
+			{
+				HandlePageInput(); // Protect against tabs
+			}
+
+			if (AccessibleKey.READ_TOOLTIP.IsPressed())
+			{
+				AccessibilityUtils.ReadTooltip(this);
+			}
+		}
+
+		private bool IsBrowsingCards()
+		{
+            return m_curState == State.BROWSING_CARDS || m_curState == State.CRAFTING_SEE_COLLECTION || m_curState == State.EDIT_DECK_SEE_COLLECTION;
+		}
+
+        private bool IsBrowsingOtherCollectibles()
+		{
+            return m_curState == State.BROWSING_HERO_SKIN_CLASSES || m_curState == State.BROWSING_HERO_SKINS || m_curState == State.BROWSING_CARD_BACKS || m_curState == State.BROWSING_COINS;
+		}
+
+        private bool IsCrafting()
+		{
+            return CraftingTray.Get()?.IsShown() ?? false;
+		}
+
+		private void HandleBrowsingCollectionInput(bool heroSkins=false)
+        {
+            HandleCommonBrowseCollectionInput();
+
+			if (AccessibleKey.BACK.IsPressed())
+			{
+                if (heroSkins)
+				{
+                    OnBrowseHeroSkins();
+				}
+                else
+				{
+					RereadMainMenu();
+					RemoveFiltersIfNecessary();
+				}
+			}
+            else if (AccessibleKey.CONFIRM.IsPressed())
+			{
+                AccessibleInputMgr.ClickRightMouseButton();
+			}
+		}
+
+		private void HandleBrowsingCardBacksInput()
+        {
+            UpdateMouseWhenBrowsingCardBacks();
+			HandleCardBacksPageInput();
+
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				RereadMainMenu();
+                RemoveFiltersIfNecessary();
+			}
+            else if (AccessibleKey.CONFIRM.IsPressed())
+			{
+                AccessibleInputMgr.ClickRightMouseButton();
+			}
+		}
+
+		private void HandleBrowsingHeroSkinClassesInput()
+        {
+            UpdateMouseWhenBrowsingItems(m_heroPickerClassButtons);
+
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				RereadMainMenu();
+                GetCollectionManagerDisplay().SetViewMode(CollectionUtils.ViewMode.CARDS);
+                RemoveFiltersIfNecessary();
+			}
+            else if (AccessibleKey.CONFIRM.IsPressed())
+			{
+                ChooseHeroSkinClass(m_heroPickerClassButtons.GetItemBeingRead());
+			}
+            else 
+			{
+                m_heroPickerClassButtons.HandleAccessibleInput();
+			}
+		}
+
+		private void ChooseHeroSkinClass(AccessibleCollectionHeroPickerButton button)
+		{
+            if (button == null)
+			{
+                return;
+			}
+
+            button.GetHeroPickerButton().TriggerRelease();
+
+            m_curState = State.BROWSING_HERO_SKINS;
+		}
+
+		private void RemoveFiltersIfNecessary()
+		{
+            AccessibilityMgr.DisallowTextInput();
+
+            var collectionSearch = GetCollectionManagerDisplay()?.m_search;
+            collectionSearch?.ClearFilter(true);
+
+            var filterTabManager = GetManaFilterTabManager();
+
+            if (filterTabManager?.IsFilterActive ?? false)
+			{
+                filterTabManager.ClearFilter(true);
+			}
+		}
+
+		private void HandleEditDeckSeeCollection()
+        {
+            HandleCommonBrowseCollectionInput();
+
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				SetupEditDeckMenu();
+                RemoveFiltersIfNecessary();
+			}
+			else if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				AccessibleInputMgr.ClickLeftMouseButton();
+			}
+			else
+			{
+				HandleEditDeckShortcuts();
+			}
+		}
+
+		private void HandleCraftingSeeCollection()
+        {
+            HandleCommonBrowseCollectionInput();
+
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadCraftingMenu();
+                RemoveFiltersIfNecessary();
+			}
+            else if (AccessibleKey.CONFIRM.IsPressed())
+			{
+                AccessibleInputMgr.ClickRightMouseButton();
+			}
+		}
+
+		private void HandleEditDeckShortcuts()
+        {
+            if (AccessibleKey.SEE_PLAYER_DECK.IsPressed())
+            {
+                EditDeckSeeDeck();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HAND.IsPressed())
+            {
+                EditDeckAddCards();
+            }
+        }
+
+        private void HandleEditDeckSeeDeck()
+        {
+            UpdateMouseWhenEditingDeck();
+
+            m_editingDeckCards?.HandleAccessibleInput();
+
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                SetupEditDeckMenu();
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    AccessibleInputMgr.ClickLeftMouseButton();
+                }
+            }
+            else
+            {
+                HandleEditDeckShortcuts();
+            }
+        }
+
+        private void UpdateMouseWhenBrowsingCollection()
+        {
+            UpdateMouseWhenBrowsingItems(m_curPageCards);
+        }
+
+        private void UpdateMouseWhenBrowsingCardBacks()
+        {
+            UpdateMouseWhenBrowsingItems(m_curPageCardBacks);
+        }
+
+        private void UpdateMouseWhenBrowsingItems<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+        {
+            if (items == null || items.Count == 0)
+			{
+                return;
+			}
+
+            var idx = items.GetItemBeingReadIndex();
+
+            if (m_curPageCardActors != null && idx < m_curPageCardActors.Count)
+            {
+                var actor = m_curPageCardActors[idx].GetPreferredActor(); // Only 1 in this scenario. Crafting would be different though
+                AccessibleInputMgr.MoveMouseTo(actor);
+            }
+        }
+
+        private AccessibleEditingDeckCard m_prevCardBeingRead;
+
+        private void UpdateMouseWhenEditingDeck()
+        {
+            var curCard = m_editingDeckCards?.GetItemBeingRead();
+
+            if (curCard != m_prevCardBeingRead)
+            {
+                AccessibilityUtils.CenterScrollbarAroundObject(CollectionDeckTray.Get().m_scrollbar, curCard.GetCardTile().gameObject);
+            }
+
+            AccessibleInputMgr.MoveMouseTo(curCard.GetCardTile().GetActor());
+
+            m_prevCardBeingRead = curCard;
+        }
+
+        private static bool s_justOutOfSetFilterTray;
+
+		internal void OnSelectFilterItem()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            s_justOutOfSetFilterTray = true;
+
+            if (m_curState == State.MAIN_MENU)
+			{
+				// Reset main menu to ease journey
+				m_mainMenu.SetIndex(0);
+			}
+            else if (m_curState == State.CRAFTING_MENU)
+			{
+				// Focus crafting menu on "browse cards" to ease journey
+				if (CanMassDisenchant(CraftingTray.Get()?.m_massDisenchantButton))
+				{
+					m_craftingMenu.SetIndex(1);
+				}
+                else
+				{
+					m_craftingMenu.SetIndex(0);
+				}
+			}
+		}
+
+		private bool CanMassDisenchant(PegUIElement massDisenchantButton)
+		{
+            if (massDisenchantButton == null)
+            {
+                return false;
+            }
+
+            return massDisenchantButton.IsEnabled();
+		}
+
+		private void HandleManaFiltersInput()
+        {
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                int pressedTab = numKeyPressed.Value;
+
+				if (pressedTab == 10)
+                {
+                    pressedTab = 0;
+                }
+                else if (pressedTab > ManaFilterTabManager.NUM_MANA_FILTERS)
+                {
+					return;
+                }
+
+                var tabs = GetManaFilterTabManager().m_tabs;
+
+				if (pressedTab >= tabs.Count)
+                {
+					return;
+                }
+
+                m_justPressedLeft = false;
+                ClickManaFilter(tabs[pressedTab]);
+            }
+        }
+
+		private void ClickManaFilter(ManaFilterTab manaFilterTab)
+		{
+            if (!GetManaFilterTabManager()?.IsManaValueActive(manaFilterTab.GetManaID()) ?? false)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_MANA_FILTER_ON, manaFilterTab.m_manaCostText));
+			}
+            else
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MANA_FILTER_OFF));
+			}
+
+			manaFilterTab.TriggerRelease();
+		}
+
+		private bool HandleClassTabsInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(1);
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(-1);
+                return true;
+            }
+
+            return false;
+        }
+
+        private void FlipToFirstClassTab()
+		{
+            var classTabs = GetCollectionPageManager().m_classTabs.FindAll(t => t.IsVisible()); // Show only visible tabs due to filters
+
+            if (classTabs.Count > 0)
+			{
+				classTabs[0].TriggerRelease();
+			}
+		}
+
+        private void FlipToNextClass(int inc)
+        {
+            m_justPressedLeft = false;
+
+            var classTabs = GetCollectionPageManager().m_classTabs.FindAll(t => t.IsVisible()); // Show only visible tabs due to filters
+
+            var curClassTab = 0;
+            for (int i = 0; i < classTabs.Count; i++)
+            {
+                if (classTabs[i].IsSelected())
+                {
+                    curClassTab = i;
+                    break;
+                }
+            }
+
+            int targetClassTab = curClassTab + inc;
+
+            if (targetClassTab < 0)
+            {
+                targetClassTab = classTabs.Count - 1;
+            }
+            else if (targetClassTab >= classTabs.Count)
+            {
+                targetClassTab = 0;
+            }
+
+            classTabs[targetClassTab].TriggerRelease();
+        }
+
+		private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION), () => Navigation.GoBack());
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION), OnBrowseCollection);
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS), SetupDeckManagementMenu);
+
+            if (CollectionManagerDisplay.ShouldSeeCraftingButton())
+			{
+				m_mainMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_CRAFTING_MODE_SHORT"), ClickCraftingButton);
+			}
+
+			AddChangeSetButton(m_mainMenu);
+
+            ReadMainMenu();
+        }
+
+		private void OnBrowseCollection()
+		{
+            m_browseCollectionMenu = new AccessibleMenu(this, "", RereadMainMenu);
+
+            m_browseCollectionMenu.AddOption(LocalizedText.GLOBAL_CARD_PLURAL, OnBrowseCards);
+
+            if (GetCollectionPageManager().m_heroSkinsTab.IsVisible())
+			{
+				m_browseCollectionMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_MANAGER_HERO_SKINS_TITLE"), OnBrowseHeroSkins);
+			}
+
+            if (GetCollectionPageManager().m_cardBacksTab.IsVisible())
+			{
+				m_browseCollectionMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_MANAGER_CARD_BACKS_TITLE"), OnBrowseCardBacks);
+			}
+
+            if (GetCollectionPageManager().m_coinsTab.IsVisible())
+			{
+				m_browseCollectionMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_MANAGER_COINS_TITLE"), OnBrowseCoins);
+			}
+
+            m_browseCollectionMenu.StartReading();
+            m_curState = State.BROWSE_COLLECTION_MENU;
+		}
+
+		private void OnBrowseHeroSkins()
+		{
+            m_curState = State.LOADING;
+
+            var heroSkinsTab = GetCollectionPageManager().m_heroSkinsTab;
+            if (heroSkinsTab.IsSelected())
+			{
+                m_heroPickerClassButtons.StartReading();
+                m_curState = State.BROWSING_HERO_SKIN_CLASSES;
+			}
+            else
+			{
+                ChangeToTab(heroSkinsTab);
+			}
+		}
+
+		private void OnBrowseCardBacks()
+		{
+            m_curState = State.BROWSING_CARD_BACKS;
+
+            var cardBacksTab = GetCollectionPageManager().m_cardBacksTab;
+            if (cardBacksTab.IsSelected())
+			{
+                StartReadingCurrentPage(m_curPageCardBacks);
+			}
+            else
+			{
+                ChangeToTab(cardBacksTab);
+			}
+		}
+
+		private void ResetBook()
+		{
+            m_curPageCards = null;
+			m_curPageCardBacks = null;
+			m_curPageCardActors = null;
+			m_curPageNum = 0;
+			m_justPressedLeft = false;
+            m_curClassContext = TAG_CLASS.NEUTRAL;
+		}
+
+		private void StartReadingCurrentPage<T>(AccessibleListOfItems<T> items) where T: AccessibleItem
+		{
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            items.StartReading();
+		}
+
+		private void OnBrowseCoins()
+		{
+            m_curState = State.BROWSING_COINS;
+
+            var coinsTab = GetCollectionPageManager().m_coinsTab;
+            if (coinsTab.IsSelected())
+			{
+                StartReadingCurrentPage(m_curPageCards);
+			}
+            else
+			{
+                ChangeToTab(coinsTab);
+			}
+		}
+
+		private void ChangeToTab(PegUIElement tab)
+		{
+			ResetBook();
+			tab.TriggerRelease();
+		}
+
+		private void ReadMainMenu(bool readMenuName=true)
+		{
+			m_mainMenu.StartReading(readMenuName);
+            m_curState = State.MAIN_MENU;
+		}
+
+		private void RereadMainMenu()
+		{
+            ReadMainMenu(false);
+		}
+
+        private void OnBrowseCards()
+        {
+            FlipToFirstClassTab();
+            OutputFilter();
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext));
+            m_curPageCards.StartReading();
+            m_curState = State.BROWSING_CARDS;
+        }
+
+        private void SetupDeckManagementMenu()
+        {
+            m_manageDecksMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS), RereadMainMenu);
+
+            if (HasDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), SetupEditDecksMenu);
+            }
+
+            if (CanCreateDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_NEW_DECK), OnNewDeck);
+            }
+
+            if (CanDeleteDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_DELETE_DECK), SetupDeleteDecksMenu);
+            }
+
+            m_manageDecksMenu.StartReading();
+            m_curState = State.MANAGE_DECKS_MENU;
+        }
+
+		private void SetupDeleteDecksMenu()
+        {
+            m_deleteDecksMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_DELETE_DECK), SetupDeckManagementMenu);
+            var scrollbar = CollectionDeckTray.Get().m_scrollbar;
+
+            foreach (var traySection in GetVisibleTraySections())
+            {
+                var deckBox = traySection.m_deckBox;
+
+                m_deleteDecksMenu.AddOption(new AccessibleCollectionDeckBoxVisual(this, deckBox, true), () => DeleteDeck(deckBox), () => AccessibilityUtils.CenterScrollbarAroundObject(scrollbar, deckBox.gameObject));
+            }
+
+            m_deleteDecksMenu.StartReading();
+            m_curState = State.BROWSING_DECKS_FOR_DELETING;
+        }
+
+		private void DeleteDeck(CollectionDeckBoxVisual deck)
+        {
+            CollectionManager.Get().RegisterDeckDeletedListener(OnDeckDeleted);
+            deck.m_deleteButton.TriggerRelease();
+        }
+
+		private void OnDeckDeleted(CollectionDeck removedDeck)
+        {
+            SetupDeckManagementMenu();
+
+            CollectionManager.Get().RemoveDeckDeletedListener(OnDeckDeleted);
+        }
+
+        private void SetupEditDecksMenu()
+        {
+            m_editDecksMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), SetupDeckManagementMenu);
+            var scrollbar = CollectionDeckTray.Get().m_scrollbar;
+
+            foreach (var traySection in GetVisibleTraySections())
+            {
+                var deckBox = traySection.m_deckBox;
+                m_editDecksMenu.AddOption(new AccessibleCollectionDeckBoxVisual(this, deckBox, true), () => EditDeck(deckBox), () => AccessibilityUtils.CenterScrollbarAroundObject(scrollbar, deckBox.gameObject));
+            }
+
+            m_editDecksMenu.StartReading();
+            m_curState = State.BROWSING_DECKS_FOR_EDITING;
+        }
+
+        internal void OnFinishRenamingDeck()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityMgr.DisallowTextInput();
+
+            if (m_curState == State.EDIT_DECK_RENAME_DECK)
+            {
+                // Prevent against rename notifications when the deck closes
+                SetupEditDeckMenu();
+            }
+        }
+
+        private List<TraySection> GetVisibleTraySections()
+        {
+            var ret = new List<TraySection>();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+
+            foreach (var traySection in decksContent.m_traySections)
+            {
+                if (traySection.IsDeckBoxShown())
+                {
+                    ret.Add(traySection);
+                }
+            }
+
+            return ret;
+        }
+
+        private void SetupEditDeckMenu()
+        {
+            AccessibilityUtils.LogDebug("Setup EditDeckMenu");
+
+            AccessibleInputMgr.HideMouse();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+            var deckName = collectionDeckTray.GetEditingDeckBox().GetDeckNameText().Text;
+
+            //m_editDeckMenu = new AccessibleMenu(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), null); // TODO: Back from both edit and create new
+            m_editDeckMenu = new AccessibleMenu(this, deckName, null); // TODO: Back from both edit and create new
+
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION), EditDeckAddCards);
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION), EditDeckSeeDeck);
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION), EditDeckRenameDeck);
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_COPY_DECK_OPTION), EditDeckCopyDeck);
+            m_editDeckMenu.AddOption(CollectionDeckTray.Get().m_doneButton.GetText(), EditDeckDone);
+
+            m_editDeckMenu.StartReading();
+            m_curState = State.EDIT_DECK_MENU;
+
+            CollectionDeckTray.Get().m_cardsContent.UnregisterCardCountUpdated(OnCardCountUpdated);
+            CollectionDeckTray.Get().m_cardsContent.RegisterCardCountUpdated(OnCardCountUpdated);
+        }
+
+		private void OnCardCountUpdated(int cardCount)
+        {
+            if (m_curState == State.EDIT_DECK_SEE_DECK || m_curState == State.EDIT_DECK_SEE_COLLECTION)
+            {
+                int deckSize = CollectionManager.Get().GetDeckSize();
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK, cardCount, deckSize));
+            }
+
+            // Update deck cards if needed
+            if (m_curState == State.EDIT_DECK_SEE_DECK)
+            {
+                UpdateEditingDeckCardsAfterCardRemoved();
+            }
+        }
+
+		private void UpdateEditingDeckCardsAfterCardRemoved()
+        {
+            var numCardsBeforeRemovingCard = m_editingDeckCards.Count;
+            var editingDeckCards = BuildAccessibleEditingDeckCards();
+            var numCardsAfterRemovingCard = editingDeckCards.Count;
+
+            AccessibilityUtils.LogDebug($"CM card removed numCardsBeforeRemovingCard={numCardsBeforeRemovingCard} numCardsAfterRemovingCard={numCardsAfterRemovingCard}");
+
+
+            if (editingDeckCards.Count == 0)
+            {
+                SetupEditDeckMenu();
+            }
+            else if (numCardsBeforeRemovingCard != numCardsAfterRemovingCard)
+            {
+                m_editingDeckCards.UpdateItems(editingDeckCards);
+                m_editingDeckCards.StartReading();
+            }
+            else
+            {
+                m_editingDeckCards.GetItemBeingRead().Reset();
+                m_editingDeckCards.StartReading();
+            }
+        }
+
+        private void EditDeckRenameDeck()
+        {
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT));
+
+            decksContent.m_editingTraySection.m_deckBox.SetDeckName("");
+            decksContent.RenameCurrentlyEditingDeck();
+            AccessibilityMgr.AllowTextInput();
+
+            m_curState = State.EDIT_DECK_RENAME_DECK;
+        }
+
+        private void EditDeckCopyDeck()
+        {
+            CollectionInputMgr.Get().CopyEditedDeck();
+        }
+
+        private AccessibleListOfItems<AccessibleEditingDeckCard> m_editingDeckCards;
+
+        private void EditDeckSeeDeck()
+        {
+            var editingDeckCards = BuildAccessibleEditingDeckCards();
+
+            if (editingDeckCards.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK));
+            }
+            else
+            {
+                AccessibleInputMgr.HideMouse();
+
+                int cardCount = CountCards(editingDeckCards);
+                int deckSize = CollectionManager.Get().GetDeckSize();
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK, cardCount, deckSize));
+
+                m_editingDeckCards = new AccessibleListOfItems<AccessibleEditingDeckCard>(this, BuildAccessibleEditingDeckCards());
+                m_editingDeckCards.StartReading();
+                m_curState = State.EDIT_DECK_SEE_DECK;
+            }
+        }
+
+		private int CountCards(List<AccessibleEditingDeckCard> editingDeckCards)
+        {
+            int ret = 0;
+
+            foreach(var card in editingDeckCards)
+            {
+                ret += card.GetCardTile().GetSlot()?.Count ?? 0;
+            }
+
+            return ret;
+        }
+
+        private List<AccessibleEditingDeckCard> BuildAccessibleEditingDeckCards()
+        {
+            var editingDeckCards = new List<AccessibleEditingDeckCard>();
+
+            foreach(var cardTile in GetNonMissingCardTiles())
+            {
+                editingDeckCards.Add(new AccessibleEditingDeckCard(this, cardTile));
+            }
+
+            return editingDeckCards;
+        }
+
+        private List<DeckTrayDeckTileVisual> GetNonMissingCardTiles()
+        {
+            var ret = new List<DeckTrayDeckTileVisual>();
+
+            CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+            var cardTiles = collectionDeckTray.GetCardsContent().GetCardTiles();
+
+            foreach(var cardTile in cardTiles)
+            {
+                if (cardTile.IsInUse() && !IsMissing(cardTile))
+                {
+                    ret.Add(cardTile);
+                }
+            }
+
+            return ret;
+        }
+
+        private bool IsMissing(DeckTrayDeckTileVisual cardTile)
+        {
+            return cardTile.GetGhostedState() != CollectionDeckTileActor.GhostedState.NONE;
+        }
+
+        private void EditDeckAddCards()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext));
+            m_curPageCards.StartReading();
+            m_curState = State.EDIT_DECK_SEE_COLLECTION;
+        }
+
+        private void EditDeckDone()
+        {
+            CollectionManager.Get().RegisterEditedDeckChanged(OnEditedDeckDone);
+            CollectionDeckTray.Get().m_doneButton.TriggerRelease();
+        }
+
+        private void EditDeck(CollectionDeckBoxVisual deckBox)
+        {
+            CollectionManager.Get().RegisterEditedDeckChanged(OnEditedDeckChanged);
+            AccessibleInputMgr.Click(deckBox.transform);
+        }
+
+        private void OnEditedDeckChanged(CollectionDeck newDeck, CollectionDeck oldDeck, object callbackData)
+        {
+            AccessibilityUtils.LogDebug("CM OnEditDeckChanged");
+            CollectionManager.Get().RemoveEditedDeckChanged(OnEditedDeckChanged);
+            SetupEditDeckMenu();
+        }
+
+        private void OnEditedDeckDone(CollectionDeck newDeck, CollectionDeck oldDeck, object callbackData)
+        {
+            AccessibilityUtils.LogDebug("CM OnEditDeckDone");
+            CollectionManager.Get().RemoveEditedDeckChanged(OnEditedDeckDone);
+
+            SetupMainMenu();
+        }
+
+        private void OnNewDeck()
+        {
+            GetNewDeckButton().TriggerRelease();
+        }
+
+        private bool CanCreateDecks()
+        {
+            var newDeckButton = GetNewDeckButton();
+
+            return newDeckButton != null && newDeckButton.IsEnabled() && newDeckButton.IsUsable();
+        }
+
+        private bool CanDeleteDecks()
+        {
+            return HasDecks(); // TODO
+        }
+
+        private CollectionDeckTrayButton GetNewDeckButton()
+        {
+            return CollectionDeckTray.Get()?.GetDecksContent()?.m_newDeckButton;
+        }
+
+        private bool HasDecks()
+        {
+            return GetVisibleTraySections().Count > 0;
+        }
+
+        internal void OnEditDeckScreen()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            // Just wait if we're creating from clipboard as it'll switch back once the cards fill
+            if (m_curState != State.CREATE_DECK_FROM_CLIPBOARD)
+            {
+                AccessibilityMgr.SetScreen(this);
+
+                SetupEditDeckMenu();
+            }
+        }
+
+        private void SetupCraftingMenu(bool forceHideMassDisenchantButton=false)
+        {
+            AccessibleInputMgr.HideMouse();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+
+            m_craftingMenu = new AccessibleMenu(this, "", ClickCraftingButton);
+
+            if (!forceHideMassDisenchantButton)
+            {
+                var massDisenchantButton = CraftingTray.Get().m_massDisenchantButton;
+
+                if (CanMassDisenchant(massDisenchantButton))
+                {
+                    m_craftingMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_CRAFTING_DISENCHANT_BUTTON_TEXT"), massDisenchantButton.TriggerRelease);
+                }
+            }
+			m_craftingMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARDS), CraftingBrowseCards);
+            m_craftingMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST), ReadArcaneDust);
+
+            AddChangeSetButton(m_craftingMenu);
+
+            ReadCraftingMenu();
+        }
+
+        private void ReadCraftingMenu()
+		{
+            m_craftingMenu.StartReading();
+            m_curState = State.CRAFTING_MENU;
+		}
+
+		private void CraftingBrowseCards()
+		{
+            FlipToFirstClassTab();
+            OutputFilter();
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext));
+            m_curPageCards.StartReading();
+            m_curState = State.CRAFTING_SEE_COLLECTION;
+		}
+
+		private void AddChangeSetButton(AccessibleMenu menu)
+		{
+            if (CollectionManagerDisplay.ShouldSeeFilterButton())
+			{
+                menu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CHANGE_SET), GetCollectionManagerDisplay().m_setFilterTray.m_toggleButton.TriggerPress);
+            }
+		}
+
+		private void OutputFilter()
+		{
+            var filterTray = GetCollectionManagerDisplay().m_setFilterTray;
+
+            //if (filterTray?.HasActiveFilter() ?? false)
+            if (filterTray?.m_selected != null)
+			{
+                AccessibilityMgr.Output(this, filterTray.m_selected.Text);
+			}
+		}
+
+		private void ReadArcaneDust()
+		{
+            var arcaneDust = NetCache.Get().GetArcaneDustBalance();
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, arcaneDust));
+		}
+
+        private void ClickCraftingButton()
+		{
+            GetCollectionManagerDisplay().m_craftingModeButton.TriggerRelease();
+		}
+
+        internal void OnCraftingTrayOpened()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            SetupCraftingMenu();
+		}
+
+        internal void OnCraftingTrayClosed()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            RereadMainMenu();
+		}
+
+		internal void OnEnterCraftMode(CardInfoPane cardInfoPane, CraftingUI craftingUI)
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_cardInfoPane = cardInfoPane;
+            m_craftingUI = craftingUI;
+            PushState();
+
+            m_viewCardMenu = new AccessibleMenu(this, "", CancelCraftMode);
+
+			m_viewCardMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), ReadCardFlavor);
+			m_viewCardMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_CRAFTING_MODE_SHORT"), ViewCardCraftingMenu);
+
+            ReadViewCard();
+		}
+
+		private void PushState()
+		{
+            AccessibilityUtils.LogDebug($"PushState - {m_curState}");
+            m_stateBeforeViewCard = m_curState;
+		}
+
+		private void PopState()
+		{
+            AccessibilityUtils.LogDebug($"PopState - cur: {m_curState} ; prev: {m_stateBeforeViewCard}");
+            m_curState = m_stateBeforeViewCard;
+		}
+
+		private void CancelCraftMode()
+		{
+            AccessibleInputMgr.ClickRightMouseButton();
+		}
+
+		private void ReadCardFlavor()
+		{
+            AccessibilityMgr.Output(this, m_cardInfoPane.m_flavorText.Text);
+		}
+
+		private void ReadViewCard()
+		{
+            m_viewCardMenu.StartReading();
+            m_curState = State.VIEW_CARD;
+		}
+
+        private void ViewCardCraftingMenu()
+		{
+            if (m_craftingUI.m_soulboundNotification.activeSelf)
+			{
+                AccessibilityMgr.Output(this, m_craftingUI.m_soulboundTitle.Text);
+                AccessibilityMgr.Output(this, m_craftingUI.m_soulboundDesc.Text);
+                return;
+			}
+
+            m_viewCardCraftingMenu = new AccessibleMenu(this, "", ReadViewCard);
+
+			var disenchantText = LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_CARD_FOR_N_DUST, m_craftingUI.m_disenchantDustGain);
+            if (m_craftingUI.m_numOwnedIncludePending > 0)
+            {
+				m_viewCardCraftingMenu.AddOption(disenchantText, ClickDisenchantCard);
+			}
+
+			var craftText = LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_FOR_N_DUST, m_craftingUI.m_craftCost);
+			m_viewCardCraftingMenu.AddOption(craftText, ClickCraftCard);
+
+			m_viewCardCraftingMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST), ReadArcaneDust);
+
+            m_viewCardCraftingMenu.StartReading();
+            m_curState = State.VIEW_CARD_CRAFTING;
+		}
+
+		private void ClickCraftCard()
+		{
+            if (m_craftingUI?.m_buttonCreate?.IsButtonEnabled() ?? false)
+			{
+                m_craftingUI.m_buttonCreate.TriggerRelease();
+			}
+            else if (m_craftingUI?.m_reachedCardLimit ?? false)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_CARD_LIMIT_REACHED));
+			}
+            else if (m_craftingUI?.m_craftCost > NetCache.Get().GetArcaneDustBalance())
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_NOT_ENOUGH_DUST));
+			}
+			else
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CANNOT_DO_THAT));
+			}
+		}
+
+		private void ClickDisenchantCard()
+		{
+			if (m_craftingUI?.m_buttonDisenchant?.IsButtonEnabled() ?? false)
+			{
+                m_craftingUI.m_buttonDisenchant.TriggerRelease();
+			}
+            else
+			{
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CANNOT_DO_THAT));
+			}
+		}
+
+		internal void OnCancelCraftMode(CardInfoPane cardInfoPane, CraftingUI craftingUI)
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_cardInfoPane = null;
+            m_craftingUI = null;
+
+            CraftingRereadIfPossible();
+		}
+
+		internal void OnCreateAnimStarted()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_curState = State.LOADING;
+		}
+
+		internal void OnCreateAnimDone()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            CommitCrafting();
+		}
+
+		internal void OnDisenchantAnimStarted()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_curState = State.LOADING;
+		}
+
+		internal void OnDisenchantAnimDone()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            CommitCrafting();
+		}
+
+        private void CommitCrafting()
+		{
+            WaitingForServerResponse();
+            CancelCraftMode();
+		}
+
+		internal void OnMassDisenchantAnimStarted()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityUtils.LogDebug($"OnMassDisenchantAnimStarted() m_curState={m_curState}");
+            m_curState = State.LOADING;
+		}
+
+		internal void OnMassDisenchantAnimDone()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityUtils.LogDebug($"OnMassDisenchantAnimDone() m_curState={m_curState}");
+            CraftingTray.Get().m_massDisenchantButton.TriggerRelease();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE));
+
+            SetupCraftingMenu(true);
+		}
+
+		internal void OnCardCreated()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_DONE));
+
+            // The reread is handled by the normal flow as the server response triggers it
+            PopState();
+		}
+
+		internal void OnCardDisenchanted()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityUtils.LogDebug($"OnCardDisenchanted");
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE));
+
+            // The reread is handled by the normal flow as the server response triggers it
+            PopState();
+		}
+
+		private void CraftingRereadIfPossible()
+		{
+            AccessibilityUtils.LogDebug($"CraftingRereadIfPossible: IsWaitingForServerResponse: {IsWaitingForServerResponse()} ; m_curState: {m_curState} ; m_stateBeforeViewCard: {m_stateBeforeViewCard}");
+            if (IsWaitingForServerResponse())
+			{
+                return;
+			}
+
+            if (m_stateBeforeViewCard == State.BROWSING_CARDS)
+			{
+				m_curPageCards.StartReading();
+				m_curState = State.BROWSING_CARDS;
+			}
+			else if (m_stateBeforeViewCard == State.CRAFTING_SEE_COLLECTION)
+			{
+				m_curPageCards.StartReading();
+				m_curState = State.CRAFTING_SEE_COLLECTION;
+			}
+            else
+			{
+                AccessibilityUtils.LogFatalError($"CraftingRereadIfPossible - reached unexpected state: {m_stateBeforeViewCard}");
+			}
+		}
+
+        #endregion
+
+        public void OnGainedFocus()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+			if (m_curState == State.MAIN_MENU)
+            {
+                if (s_justOutOfSetFilterTray)
+				{
+                    s_justOutOfSetFilterTray = false;
+                    RereadMainMenu();
+				}
+                else
+				{
+                    ReadMainMenu();
+				}
+            }
+            else if (m_curState == State.BROWSING_DECKS_FOR_DELETING)
+            {
+                if (!CollectionManager.Get().IsDeleteDeckPending())
+                {
+                    m_deleteDecksMenu?.StartReading();
+                }
+            }
+            else if (m_curState == State.CRAFTING_MENU)
+			{
+                m_craftingMenu?.StartReading();
+			}
+            else if (m_curState == State.BROWSING_CARDS || m_curState == State.CRAFTING_SEE_COLLECTION || m_curState == State.BROWSING_HERO_SKINS || m_curState == State.BROWSING_COINS)
+			{
+                RereadIfPossible(m_curPageCards);
+			}
+            else if (m_curState == State.BROWSING_CARD_BACKS)
+			{
+                RereadIfPossible(m_curPageCardBacks);
+			}
+            else if (m_justCanceledDisenchantPopup)
+			{
+                m_justCanceledDisenchantPopup = false;
+				m_viewCardCraftingMenu.StartReading();
+			}
+		}
+
+		private void RereadIfPossible<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+		{
+			if (!IsWaitingForServerResponse())
+			{
+                items.StartReading();
+			}
+		}
+
+		private void RereadAfterServerResponse<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+		{
+            OnServerResponse();
+            RereadIfPossible(items);
+		}
+
+		#region Help
+
+		public string GetHelp()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return "";
+			}
+
+            switch(m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                case State.BROWSE_COLLECTION_MENU:
+                    return m_browseCollectionMenu?.GetHelp();
+                case State.BROWSING_CARDS:
+                    return GetHelpForBrowsingCollection();
+                case State.BROWSING_COINS:
+                    return GetHelpForBrowsingCoins();
+                case State.BROWSING_CARD_BACKS:
+                    return GetHelpForBrowsingCardBacks();
+                case State.BROWSING_HERO_SKINS:
+                    return GetHelpForBrowsingHeroSkins();
+                case State.BROWSING_HERO_SKIN_CLASSES:
+                    return GetHelpForBrowsingHeroSkins();
+                case State.MANAGE_DECKS_MENU:
+                    return m_manageDecksMenu?.GetHelp();
+                case State.BROWSING_DECKS_FOR_EDITING:
+                    return m_editDecksMenu?.GetHelp();
+                case State.BROWSING_DECKS_FOR_DELETING:
+                    return m_deleteDecksMenu?.GetHelp();
+                case State.EDIT_DECK_MENU:
+                    return m_editDeckMenu?.GetHelp();
+                case State.EDIT_DECK_SEE_COLLECTION:
+                    return GetHelpForEditDeckSeeCollection();
+                case State.EDIT_DECK_SEE_DECK:
+                    return GetHelpForEditDeckSeeDeck();
+                case State.EDIT_DECK_RENAME_DECK:
+                    return GetHelpForEditDeckRenameDeck();
+                case State.CRAFTING_MENU:
+                    return m_craftingMenu?.GetHelp();
+                case State.CRAFTING_SEE_COLLECTION:
+                    return GetHelpForCraftingSeeCollection();
+                case State.VIEW_CARD:
+                    return m_viewCardMenu?.GetHelp();
+                case State.VIEW_CARD_CRAFTING:
+                    return m_viewCardCraftingMenu?.GetHelp();
+            }
+
+            return "";
+        }
+
+        internal void OnFinishingDeckAutoFill()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_curState = State.LOADING;
+        }
+
+        private string GetHelpForBrowsingCollection()
+        {
+            return AccessibleSpeechUtils.CombineLines(GetHelpLinesForBrowsingCollection());
+        }
+
+        private List<string> GetHelpLinesForBrowsingCollection()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP, AccessibleKey.READ_NEXT_VALID_ITEM));
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_COLLECTION_FILTERS_HELP, AccessibleKey.GLOBAL_FIND));
+
+            return ret;
+        }
+
+        private string GetHelpForBrowsingCoins()
+        {
+            return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_COINS_HELP, AccessibleKey.CONFIRM);
+        }
+
+        private string GetHelpForBrowsingCardBacks()
+        {
+            return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_CARD_BACKS_HELP, AccessibleKey.CONFIRM);
+        }
+
+        private string GetHelpForBrowsingHeroSkins()
+        {
+            return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_HERO_SKINS_HELP, AccessibleKey.CONFIRM);
+        }
+
+        internal void OnDeleteDeckCanceled()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_deleteDecksMenu?.StartReading();
+        }
+
+        private string GetHelpForEditDeckSeeDeck()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP));
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP, AccessibleKey.CONFIRM));
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        private string GetHelpForEditDeckSeeCollection()
+        {
+            var ret = GetHelpLinesForBrowsingCollection();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP, AccessibleKey.CONFIRM));
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        private string GetHelpForEditDeckRenameDeck()
+        {
+            return LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT);
+        }
+
+        private string GetHelpForCraftingSeeCollection()
+        {
+            var ret = GetHelpLinesForBrowsingCollection();
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        #endregion
+
+        internal void OnCreateDeckFromClipboard()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            m_curState = State.CREATE_DECK_FROM_CLIPBOARD;
+        }
+
+        internal void OnFinishAutoAddCardsWithTiming()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            if (m_curState == State.CREATE_DECK_FROM_CLIPBOARD)
+            {
+                AccessibilityMgr.SetScreen(this);
+                SetupEditDeckMenu();
+            }
+        }
+
+        internal bool IsCreatingDeckFromClipboard()
+        {
+            if (!IsSupportedCollectionManager())
+			{
+                return false;
+			}
+
+            return m_curState == State.CREATE_DECK_FROM_CLIPBOARD;
+        }
+
+		#region Favorites
+
+		internal void OnFavoriteHeroSkinChanged()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_HERO_SKIN_SET));
+            RereadAfterServerResponse(m_curPageCards);
+		}
+
+		internal void OnFavoriteCardBackChanged(bool isFavorite)
+		{
+            if (!IsSupportedCollectionManager() || !isFavorite) // Signal on favorite=true only
+			{
+                return;
+			}
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_CARD_BACK_SET));
+            RereadAfterServerResponse(m_curPageCardBacks);
+		}
+
+		internal void OnFavoriteCoinChanged()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_COIN_SET));
+            RereadAfterServerResponse(m_curPageCards);
+		}
+
+		#endregion
+
+		internal void WaitingForServerResponse()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            AccessibilityUtils.LogDebug("WaitingForServerResponse()");
+            m_waitingForServerResponse = true;
+		}
+
+		private void OnServerResponse()
+		{
+            AccessibilityUtils.LogDebug("OnServerResponse()");
+			m_waitingForServerResponse = false;
+		}
+
+		private bool IsWaitingForServerResponse()
+		{
+            AccessibilityUtils.LogDebug($"IsWaitingForServerResponse() -> {m_waitingForServerResponse}");
+			return m_waitingForServerResponse;
+		}
+
+		internal void OnBrowsingHeroSkinClasses()
+		{
+            if (!IsSupportedCollectionManager())
+			{
+                return;
+			}
+
+            var collectionPageDisplay = GetCollectionPageManager().GetCollectionPageDisplay();
+            var heroPickerButtons = collectionPageDisplay.GetCollectionHeroPickerButtons();
+
+            var accessibleHeroPickerButtons = new List<AccessibleCollectionHeroPickerButton>();
+            foreach (var btn in heroPickerButtons.m_heroButtons)
+			{
+                accessibleHeroPickerButtons.Add(new AccessibleCollectionHeroPickerButton(this, btn));
+			}
+            m_heroPickerClassButtons = new AccessibleListOfItems<AccessibleCollectionHeroPickerButton>(this, accessibleHeroPickerButtons);
+            m_heroPickerClassButtons.StartReading();
+
+            m_curState = State.BROWSING_HERO_SKIN_CLASSES;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs
new file mode 100644
index 0000000..8116cec
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs
@@ -0,0 +1,35 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleDeckTemplatePickerButton : AccessibleItem
+    {
+        private readonly DeckTemplatePickerButton m_button;
+
+        private bool m_isCustomDeck;
+
+        internal AccessibleDeckTemplatePickerButton(AccessibleComponent parent, DeckTemplatePickerButton button, bool isCustomDeck = false) : base(parent)
+        {
+            m_button = button;
+            m_isCustomDeck = isCustomDeck;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            // Template name
+            ret.Add(m_button.m_title.Text);
+
+            if (!m_isCustomDeck)
+            {
+                // Owned cards
+                var ownedCardCount = m_button.GetOwnedCardCount();
+                int deckSize = CollectionManager.Get().GetDeckSize();
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT, ownedCardCount, deckSize));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs
new file mode 100644
index 0000000..ac76d3d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs
@@ -0,0 +1,35 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleEditingDeckCard : AccessibleItem
+    {
+        private AccessibleCollectibleCard m_card;
+
+        private readonly CollectibleCard m_collectibleCard;
+
+        private readonly DeckTrayDeckTileVisual m_cardTile;
+
+        public AccessibleEditingDeckCard(AccessibleComponent parent, DeckTrayDeckTileVisual cardTile) : base(parent)
+        {
+            var cardId = cardTile.GetCardID();
+            var cardRecord = GameUtils.GetCardRecord(cardId);
+            var cardEntityDef = DefLoader.Get().GetEntityDef(cardId);
+
+            m_collectibleCard = new CollectibleCard(cardRecord, cardEntityDef, cardTile.GetPremium());
+            m_cardTile = cardTile;
+        }
+
+        internal override List<string> GetLines()
+        {
+            int count = m_cardTile.GetSlot()?.Count ?? 1;
+            m_card = new AccessibleCollectibleCard(m_parent, m_collectibleCard, count);
+            return m_card.GetLines();
+        }
+
+        public DeckTrayDeckTileVisual GetCardTile()
+        {
+            return m_cardTile;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleFormatTypePickerPopup.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleFormatTypePickerPopup.cs
new file mode 100644
index 0000000..b98d7fb
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleFormatTypePickerPopup.cs
@@ -0,0 +1,94 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using PegasusShared;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleFormatTypePickerPopup : AccessibleUI
+    {
+        private readonly Widget m_formatTypePickerPopup;
+
+		private AccessibleHorizontalMenu<AccessibleMultilineText> m_formatTypes;
+
+		private static AccessibleFormatTypePickerPopup s_instance;
+
+		public AccessibleFormatTypePickerPopup(Widget formatTypePickerPopup)
+		{
+			m_formatTypePickerPopup = formatTypePickerPopup;
+		}
+
+		internal static void Show(Widget formatTypePickerPopup)
+		{
+			if (s_instance != null)
+			{
+				// Should never happen but might as well protect against potential HS bugs
+				Hide();
+			}
+
+			s_instance = new AccessibleFormatTypePickerPopup(formatTypePickerPopup);
+			AccessibilityMgr.ShowUI(s_instance);
+			s_instance.ReadPopup();
+		}
+
+		internal static void Hide()
+		{
+			AccessibilityMgr.HideUI(s_instance);
+			s_instance = null;
+		}
+
+		private void ReadPopup()
+		{
+			var formatWrapper = AccessibleWidgetUtils.GetChildObject(m_formatTypePickerPopup, "Root/Controller/Popup/FormatWrapper");
+
+			if (formatWrapper == null)
+			{
+				AccessibilityUtils.LogFatalError("AccessibleFormatTypePickerPopup: Could not find FormatWrapper");
+				return;
+			}
+
+			var classicFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "ClassicFormat");
+			var standardFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "StandardFormat");
+			var wildFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "WildFormat");
+			var casualFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "Casual");
+
+			m_formatTypes = new AccessibleHorizontalMenu<AccessibleMultilineText>(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_FORMAT), null);
+
+			AddFormatTypeIfActive(m_formatTypes, standardFormatButton, GameStrings.GetFormatName(FormatType.FT_STANDARD), "GLUE_TOURNAMENT_DESCRIPTION_STANDARD");
+			AddFormatTypeIfActive(m_formatTypes, wildFormatButton, GameStrings.GetFormatName(FormatType.FT_WILD), "GLUE_TOURNAMENT_DESCRIPTION_WILD");
+			AddFormatTypeIfActive(m_formatTypes, classicFormatButton, GameStrings.GetFormatName(FormatType.FT_CLASSIC), "GLUE_TOURNAMENT_DESCRIPTION_CLASSIC");
+			AddFormatTypeIfActive(m_formatTypes, casualFormatButton, GameStrings.Get("GLUE_TOURNAMENT_CASUAL"), "GLUE_TOURNAMENT_DESCRIPTION_CASUAL");
+
+			if (m_formatTypes.GetNumItems() == 0)
+			{
+				AccessibilityUtils.LogFatalError("AccessibleFormatTypePickerPopup: Attempted to open a picker with no active formats");
+				m_formatTypes = null; // Prevent access
+				return;
+			}
+
+			m_formatTypes.StartReading();
+		}
+
+		private void AddFormatTypeIfActive(AccessibleHorizontalMenu<AccessibleMultilineText> formatTypes, PegUIElement formatButton, string formatName, string formatDescriptionKey)
+		{
+			if (formatButton == null || !formatButton.isActiveAndEnabled)
+			{
+				return;
+			}
+
+			var text = new AccessibleMultilineText(this, formatName, GameStrings.Get(formatDescriptionKey));
+			formatTypes.AddOption(text, () => AccessibleWidgetUtils.ClickButton(formatButton), () => AccessibleInputMgr.MoveMouseTo(formatButton));
+		}
+
+		public string GetAccessibleHelp()
+		{
+			return m_formatTypes?.GetHelp();
+		}
+
+		public void HandleAccessibleInput()
+		{
+			m_formatTypes?.HandleAccessibleInput();
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Crafting/AccessibleCraftingTestingUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/Crafting/AccessibleCraftingTestingUtils.cs
new file mode 100644
index 0000000..3143623
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Crafting/AccessibleCraftingTestingUtils.cs
@@ -0,0 +1,139 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using Hearthstone.Progression;
+using PegasusUtil;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace Accessibility
+{
+    class AccessibleCraftingTestingUtils
+    {
+		private static Network.CardSaleResult s_cardSaleResult;
+
+		private static int s_totalDisenchantAmount;
+
+		private static string WAITING_FOR_SERVER_RESPONSE_TEST_MESSAGE = "Waiting for server response";
+
+        internal static bool IsTestingCrafting()
+		{
+			return HearthstoneAccessConstants.DEV_MODE; // Used to be a flag but not a good idea given that I kept forgetting about turning it on
+		}
+
+		internal static bool TriggerOnCardSaleResponse(bool error=false)
+		{
+			if (s_cardSaleResult == null)
+			{
+				return false;
+			}
+
+			if (error)
+			{
+				s_cardSaleResult.Action = Network.CardSaleResult.SaleResult.GENERIC_FAILURE;
+			}
+
+			CollectionManager.Get().OnCardSale();
+
+			if (s_cardSaleResult.Action == Network.CardSaleResult.SaleResult.CARD_WAS_BOUGHT)
+			{
+				CollectionManager.Get().OnCardAdded(s_cardSaleResult.AssetName, s_cardSaleResult.Premium, s_cardSaleResult.Count, false);
+				CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
+					.RefreshCurrentPageContents();
+				CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks();
+			}
+			else if (s_cardSaleResult.Action == Network.CardSaleResult.SaleResult.CARD_WAS_SOLD)
+			{
+				CollectionManager.Get().OnCardRemoved(s_cardSaleResult.AssetName, s_cardSaleResult.Premium, s_cardSaleResult.Count);
+				CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
+					.RefreshCurrentPageContents();
+				CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks();
+			}
+
+			s_cardSaleResult = null;
+			return true;
+		}
+
+		internal static Network.CardSaleResult GetCardSaleResult()
+		{
+			return s_cardSaleResult;
+		}
+
+		internal static void BuyCard(int assetId, TAG_PREMIUM premium, int count, int unitBuyPrice, int currentCollectionCount)
+		{
+			s_cardSaleResult = new Network.CardSaleResult();
+			s_cardSaleResult.Action = Network.CardSaleResult.SaleResult.CARD_WAS_BOUGHT;
+			s_cardSaleResult.AssetID = assetId;
+			s_cardSaleResult.AssetName = GameUtils.TranslateDbIdToCardId(assetId);
+			s_cardSaleResult.Amount = count;
+			s_cardSaleResult.Premium = premium;
+			AccessibilityMgr.OutputNotification(WAITING_FOR_SERVER_RESPONSE_TEST_MESSAGE);
+		}
+
+		internal static void SellCard(int assetId, TAG_PREMIUM premium, int count, int unitSellPrice, int currentCollectionCount)
+		{
+			s_cardSaleResult = new Network.CardSaleResult();
+			s_cardSaleResult.Action = Network.CardSaleResult.SaleResult.CARD_WAS_SOLD;
+			s_cardSaleResult.AssetID = assetId;
+			s_cardSaleResult.AssetName = GameUtils.TranslateDbIdToCardId(assetId);
+			s_cardSaleResult.Amount = count;
+			s_cardSaleResult.Premium = premium;
+			AccessibilityMgr.OutputNotification(WAITING_FOR_SERVER_RESPONSE_TEST_MESSAGE);
+		}
+
+		internal static Collection AddFakeCards(Collection collection)
+		{
+			var yesterday = DateTime.Today.AddDays(-1).ToFileTimeUtc();
+
+			// Primordial studies x3
+			var fakeStack = new PegasusShared.CardStack();
+			var fakeCardDef = new PegasusShared.CardDef();
+			fakeCardDef.Premium = 0;
+			fakeCardDef.Asset = 59213;
+			fakeStack.CardDef = fakeCardDef;
+			fakeStack.Count = 3;
+			fakeStack.NumSeen = 3;
+			fakeStack.LatestInsertDate = TimeUtils.FileTimeUtcToPegDate(yesterday);
+			collection.Stacks.Add(fakeStack);
+
+			// Lab Partner x2
+			var fakeStack2 = new PegasusShared.CardStack();
+			var fakeCardDef2 = new PegasusShared.CardDef();
+			fakeCardDef2.Premium = 0;
+			fakeCardDef2.Asset = GameUtils.TranslateCardIdToDbId("SCH_310");
+			fakeStack2.CardDef = fakeCardDef2;
+			fakeStack2.Count = 2;
+			fakeStack2.NumSeen = 2;
+			fakeStack2.LatestInsertDate = TimeUtils.FileTimeUtcToPegDate(yesterday);
+			collection.Stacks.Add(fakeStack2);
+
+			return collection;
+		}
+
+		internal static bool TriggerMassDisenchantResponse()
+		{
+			if (s_totalDisenchantAmount == 0)
+			{
+				return false;
+			}
+
+			CollectionManager.Get().OnMassDisenchantResponse();
+
+			s_totalDisenchantAmount = 0;
+			return true;
+		}
+
+		internal static Network.MassDisenchantResponse GetMassDisenchantResponse()
+		{
+			var ret = new Network.MassDisenchantResponse();
+			ret.Amount = s_totalDisenchantAmount;
+
+			return ret;
+		}
+
+		internal static void DoMassDisenchant()
+		{
+			s_totalDisenchantAmount = MassDisenchant.Get().GetTotalAmount();
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs b/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs
new file mode 100644
index 0000000..9ad24e7
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs
@@ -0,0 +1,38 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class EntityComparer : IEqualityComparer<Entity>
+    {
+        public bool Equals(Entity e1, Entity e2)
+        {
+            if (e1 == null || e2 == null)
+            {
+                // None of this should happen but..
+                if (e1 == e2)
+                {
+                    return true; // Keep the hashCode contract
+                }
+
+                return false;
+            }
+
+            return e1.GetEntityId() == e2.GetEntityId();
+        }
+
+        public int GetHashCode(Entity e)
+        {
+            if (e == null)
+            {
+                return 0;
+            }
+
+            return e.GetEntityId().GetHashCode();
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs
new file mode 100644
index 0000000..15674a5
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs
@@ -0,0 +1,28 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class GlobalAccessibleMenuUtils
+    {
+        public static bool ReadPrevIsPressed()
+        {
+            return AccessibleKey.READ_PREV_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_GLOBAL_VALID_MENU_OPTION.IsPressed();
+        }
+
+        public static bool ReadNextIsPressed()
+        {
+            return AccessibleKey.READ_NEXT_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_GLOBAL_VALID_MENU_OPTION.IsPressed();
+        }
+
+        internal static bool ConfirmIsPressed()
+        {
+            return AccessibleKey.GLOBAL_CONFIRM.IsPressed();
+        }
+
+        internal static bool BackIsPressed()
+        {
+            return AccessibleKey.GLOBAL_BACK.IsPressed();
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs b/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs
new file mode 100644
index 0000000..ea00cae
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs
@@ -0,0 +1,262 @@
+﻿using Blizzard.T5.Configuration;
+using PegasusShared;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    class HSADevTools
+    {
+        private static int s_curCheat;
+
+        internal static void Init()
+        {
+            // Disable cinematics and other things blind users wouldn't be able to enjoy
+            InitNecessaryOverrides();
+
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+
+            //ResetRotationTutorial();
+
+            //ShowFakeNerfedCards();
+
+            //ShowFakeAddedCards();
+
+            //ShowGoldCapAlert();
+
+            //ShowFakeBreakingNews();
+
+            //ResetLoginPopupSequence();
+
+            //SetNewPlayerFirstTime();
+
+            //SetFirstTimeHub(); // Only applies on the next login actually
+
+            //SetNotReturningPlayer(); // Ran into something weird here and had to fix it -- TODO: Rethink this
+
+            //SetReturningPlayer(); // Done via method -- TODO: Rethink this
+        }
+
+        private static void ResetRotationTutorial()
+        {
+            SetNotReturningPlayer();
+            CheatMgr.Get().ProcessCheat("resetrotationtutorial veteran");
+        }
+
+        private static void ShowGoldCapAlert()
+        {
+            NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().Cap = -1;
+        }
+
+        private static void ShowFakeBreakingNews()
+        {
+            Vars.Key("Cheats.ShowFakeBreakingNews").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeAddedCards()
+        {
+            Vars.Key("Cheats.ShowFakeAddedCards").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeNerfedCards()
+        {
+            Vars.Key("Cheats.ShowFakeNerfedCards").Set(true.ToString(), false);
+        }
+
+        private static void ResetLoginPopupSequence()
+        {
+            GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.PLAYER_OPTIONS, GameSaveKeySubkeyId.LOGIN_POPUP_SEQUENCE_SEEN_POPUPS, new long[0]));
+        }
+
+        private static void InitNecessaryOverrides()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_NEW_CINEMATIC, true);
+        }
+
+        private static void SetNotReturningPlayer()
+        {
+            ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_NOT_RETURNING_PLAYER);
+        }
+
+        private static void SetReturningPlayer()
+        {
+            ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_ACTIVE);
+            Options.Get().SetInt(Option.RETURNING_PLAYER_BANNER_SEEN, 0);
+        }
+
+        private static void SetFirstTimeHub()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_HUB, false);
+            Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_TRAY, false);
+            Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, false);
+        }
+
+        private static void SetNewPlayerFirstTime()
+        {
+            var profileProgress = ReactiveNetCacheObject<NetCache.NetCacheProfileProgress>.CreateInstance();
+            profileProgress.Value.CampaignProgress = TutorialProgress.NOTHING_COMPLETE;
+        }
+
+        internal static void RunTests()
+        {
+            //ShowFatalError(); // TODO: Figure out where we want to test this given that it forces a close
+
+            RunManualTests();
+        }
+
+        private static void RunManualTests()
+        {
+            var cheats = new string[]{
+                // vvv All of this is automated now. Keeping the list as it might be useful to test new features
+
+                // Testing requires bronze 10 thingy
+                "notice card 2 NEW1_040 true",
+
+                // Daily quests on login
+                "iks",
+
+                // ReconnectHelperDialog
+                "hsashowreconnecthelperdialog false false false",
+                "hsashowreconnecthelperdialog false true false",
+                "hsashowreconnecthelperdialog true false false",
+
+                // Quest toasts
+                "notice gold 327 1 true",
+                "notice arcane_orbs 327 1 true",
+                "notice dust 327 1 true",
+                "notice booster 2 1 true",
+                "notice booster 1 10 true",
+                "notice card 2 NEW1_040 true",
+                "notice cardback 1 1 true",
+                "notice cardback 2 1 true",
+                "hsashowquesttoastmount",
+                "hsashowquesttoastminiset",
+
+                // Welcome quests
+                "hsashowwelcomequests",
+
+                // Returning player banner
+                "hsashowreturningplayerbanner",
+
+                // Show Set Rotation Tutorial Popup
+                "setrotationrotatedboosterspopup",
+
+                // Show Ranked Intro Popup
+                "rankedintropopup",
+
+                // Show login popup sequence - Not used for now as we're blocking it
+                // "loginpopupsequence",
+
+                // Show arena coming soon popup
+                // TODO: CheatMgr has an "arena popup" command for this but we never have prefabs for the next one so
+
+                // Alerts & Warnings
+                "alert",
+                "warning",
+
+                // Other popups
+                "hsashowstandardcomingsoonpopup",
+                "hsashowcoresetavailablepopup",
+                "hsashowwhizbangpopup",
+
+                // Quest progress legacy popup
+                "questprogresspopup QuestTitle QuestDescription 3 10",
+
+                // Quest complete popups
+                //"questcompletepopup 1", // Hero -> this is that empty broken one
+                "questcompletepopup 11", // Card pack
+                "questcompletepopup 12", // Gold
+                "questcompletepopup 55", // Arcane Dust
+                "questcompletepopup 58", // Card
+                "questcompletepopup 59", // Gold Card
+                "questcompletepopup 60", // Rare Card
+                "questcompletepopup 61", // Gold legendary card
+                "questcompletepopup 94", // Free ticket
+                "questcompletepopup 98", // Golden hero unlocked (druid)
+                "questcompletepopup 110", // Mount
+                "questcompletepopup 130", // Two cards
+                "questcompletepopup 215", // Card back
+                "questcompletepopup 2628", // Arcane orbs
+
+                // Season end dialog with reward chests
+                "seasondialog diamond1",
+
+                // Banners
+                "banner",
+
+                // End of game experience
+                "simendofgamexp 7",
+
+                // Quote
+                "quote default",
+
+                // Fixed rewards
+                "fixedrewardcomplete 5794",
+
+                // Legacy rewards
+                //"hsashowleaguepromotionrewards", // Seems broken as it's missing a "done" button at the end when all packages open
+                //"hsashowquestchestreward", // Seems broken as it's missing a "done" button at the end when all packages open
+
+                // Rank rewards
+                "rankreward bronze5 all", // TODO: Not implemented yet
+
+                // Track rewards
+                "showtrackreward 1 1 1", // 1 Card
+                "showtrackreward 1 1 2", // 2 Boosters
+                "showtrackreward 1 1 4", // 1 Random card
+                "showtrackreward 1 1 5", // 1 Custom coin
+                "showtrackreward 1 1 7", // GOLD; DUST; BOOSTER; BOOSTER; TAVERN_TICKET; CARD; RANDOM_CARD; CARD_BACK; HERO_SKIN; CUSTOM_COIN;
+                "showtrackreward 1 1 10", // CARD; REWARD_TRACK_XP_BOOST;
+                "showtrackreward 1 1 15", // Hero skin
+                "showtrackreward 1 1 16", // Gold
+                "showtrackreward 1 1 20", // Card back
+                "showtrackreward 1 1 26", // Tavern ticket
+                "showtrackreward 1 1 68", // 10 Hero skins (Choose one)
+                "showtrackreward 1 1 78", // Arcane orbs
+                "showtrackreward 1 1 162", // Card subset (all from 162 - 205)
+
+                // ReconnectHelperDialog forcing a close
+                "hsashowreconnecthelperdialog true false true",
+
+                ///
+                ///
+                ///
+
+                // TODO: Decide how we're going to handle these which require something to change at login time (e.g. returning player, veteran, etc.)
+                // Used to test track rewards scroll vvv
+                //"hsashowchangedcardspopup", // 5 changed cards
+                //"hsashowaddedcardspopup", // 5 added cards
+
+                // TODO: Test fatal errors?
+            };
+
+            var curCheat = s_curCheat % cheats.Length;
+            var cheat = cheats[curCheat];
+
+            AccessibilityUtils.LogDebug($"Running test cheat: {cheat}");
+            CheatMgr.Get().ProcessCheat(cheat);
+
+            s_curCheat++;
+        }
+
+        private static void ShowFatalError()
+        {
+            /*var fatalErrorMessage = new FatalErrorMessage();
+            FatalErrorMgr.Get().Add(fatalErrorMessage);*/
+            Error.AddFatal(FatalErrorReason.INACTIVITY_TIMEOUT, "GLOBAL_ERROR_INACTIVITY_KICK");
+            var fatalErrorMessage = new FatalErrorMessage();
+            fatalErrorMessage.m_text = "It's been a while since your last Hearthstone action and your connection was shut down. Relaunch the game when you're ready!";
+            fatalErrorMessage.m_reason = FatalErrorReason.INACTIVITY_TIMEOUT;
+
+            SceneMgr.Get().GoToFatalErrorScreen(fatalErrorMessage);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs b/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs
new file mode 100644
index 0000000..9473d38
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs
@@ -0,0 +1,88 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class HSASpeech
+    {
+        public class L10N
+        {
+            // Used for falling back to TTS in languages other than English while we think about this..
+            private LocalizationKey m_localizationKey;
+            private object[] m_args;
+
+            public static L10N Of(LocalizationKey localizationKey, params object[] args)
+            {
+                return new L10N
+                {
+                    m_localizationKey = localizationKey,
+                    m_args = args
+                };
+            }
+
+            public string GetLocalizedText()
+            {
+                if (m_args == null || m_args.Length == 0)
+                {
+                    return LocalizationUtils.Get(m_localizationKey);
+                }
+                else
+                {
+                    return LocalizationUtils.Format(m_localizationKey, m_args);
+                }
+            }
+        }
+
+        public static string FILE_EXTENSION = ".ogg";
+
+        public string Key { get; }
+
+        public string Value { get; }
+
+        public int Hash { get; }
+
+        private L10N m_l10n;
+
+        public HSASpeech(string key, string value, L10N l10n)
+        {
+            Key = key;
+            Value = value;
+            Hash = ComputeHashCode(value);
+            m_l10n = l10n;
+        }
+
+        public HSASpeech(string key, int hash)
+        {
+            Key = key;
+            Hash = hash;
+        }
+
+        public string GetFileName()
+        {
+            return $"{Key}-{Hash}{FILE_EXTENSION}";
+        }
+
+        private int ComputeHashCode(string value)
+        {
+            unchecked
+            {
+                int hash1 = 5381;
+                int hash2 = hash1;
+
+                for (int i = 0; i < value.Length && value[i] != '\0'; i += 2)
+                {
+                    hash1 = ((hash1 << 5) + hash1) ^ value[i];
+                    if (i == value.Length - 1 || value[i + 1] == '\0')
+                        break;
+                    hash2 = ((hash2 << 5) + hash2) ^ value[i + 1];
+                }
+
+                return Math.Abs(hash1 + (hash2 * 1566083941));
+            }
+        }
+
+        public string GetLocalizedText()
+        {
+            return m_l10n.GetLocalizedText();
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs b/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
new file mode 100644
index 0000000..75271b5
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
@@ -0,0 +1,32 @@
+﻿using System.IO;
+
+namespace Accessibility
+{
+    public class HearthstoneAccessConstants
+    {
+        public static string HEARTHSTONE_VERSION = "22.6.0.133923";
+
+        public static string HEARTHSTONE_ACCESS_VERSION = "27";
+
+        public static bool DEV_MODE = false;
+
+        public static bool DEBUG_SOUND = false;
+
+        public static string GetGithubToken()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-token.txt")) : null;
+        }
+
+        private static string GetGithubGroupName()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-group.txt")) : "HearthstoneAccess";
+        }
+
+        public static string GetHearthstoneAccessRepoUrl()
+        {
+            var githubGroupName = GetGithubGroupName();
+
+            return $"https://raw.githubusercontent.com/{githubGroupName}/HearthstoneAccess";
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs b/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs
new file mode 100644
index 0000000..a554d0f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs
@@ -0,0 +1,369 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class InGameSystemTests
+    {
+        internal static void Run()
+        {
+            TestCardEffectInterpreter();
+            TestLocalization();
+            ScanBattlegroundsPermanentEffects();
+        }
+
+        #region Card Effects
+
+        internal static void BuildTestCardEffectInterpreter()
+        {
+            // Build using enUS and just record the IDs so other languages are ok
+            var allCards = GameUtils.GetAllCardIds();
+            AccessibilityUtils.LogDebug($"Building {allCards.Count} cards");
+
+            int okCount = 0;
+            int failCount = 0;
+
+            var friendlyCards = new SortedSet<string>();
+            var unfriendlyCards = new SortedSet<string>();
+
+            foreach (var cardId in allCards)
+            {
+                EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+                var cardTextInHand = entityDef.GetCardTextInHand();
+                var effect = CardEffectInterpreter.ExtractEffect(cardTextInHand);
+
+                if (effect == CardEffectInterpreter.CardEffect.FRIENDLY)
+                {
+                    friendlyCards.Add(cardId);
+                    okCount++;
+                }
+                else if (effect == CardEffectInterpreter.CardEffect.UNFRIENDLY)
+                {
+                    unfriendlyCards.Add(cardId);
+                    okCount++;
+                }
+                else
+                {
+                    failCount++;
+                }
+            }
+
+            AccessibilityUtils.LogDebug("Build ended");
+            AccessibilityUtils.LogDebug($"#OK: {okCount}");
+            AccessibilityUtils.LogDebug($"#FAIL: {failCount}");
+            AccessibilityUtils.LogDebug($"#TOTAL: {okCount + failCount}");
+
+            AccessibilityUtils.LogDebug("friendlyCards:");
+            AccessibilityUtils.LogDebug(GenerateCardsHashSetCode("friendlyCards", friendlyCards));
+            AccessibilityUtils.LogDebug("unfriendlyCards:");
+            AccessibilityUtils.LogDebug(GenerateCardsHashSetCode("unfriendlyCards", unfriendlyCards));
+        }
+
+        private static string GenerateCardsHashSetCode(string variableName, SortedSet<string> cardIds)
+        {
+            var sb = new StringBuilder();
+            sb.Append($"private static HashSet<string> {variableName} = new HashSet<string>() {{");
+
+            int i = 0;
+            foreach (var cardId in cardIds)
+            {
+                if (i > 0)
+                {
+                    sb.Append(",");
+                }
+
+                sb.Append($"\"{cardId}\"");
+
+                i++;
+            }
+            sb.Append("};");
+
+            return sb.ToString();
+        }
+
+        internal static void TestCardEffectInterpreter()
+        {
+            AccessibilityMgr.Output(null, "Testing card effects interpreter");
+
+            var allCards = CollectionManager.Get().GetAllCards(); // TODO: We probably should include hero powers here as well..
+            AccessibilityUtils.LogDebug($"Testing {allCards.Count} cards");
+
+            int okCount = 0;
+            int failCount = 0;
+
+            foreach (var card in allCards)
+            {
+                //if (card.CardType == TAG_CARDTYPE.SPELL || IsBattlecryMinion(card)) // We don't really care about battlecries right now as none of the unhandled ones is really in a grey area
+                if (card.CardType == TAG_CARDTYPE.SPELL || card.CardType == TAG_CARDTYPE.HERO_POWER)
+                {
+                    if (IsEffectHandled(card))
+                    {
+                        okCount++;
+                    }
+                    else
+                    {
+                        failCount++;
+                        AccessibilityUtils.LogDebug($"Failed to handle {card.Name} - {card.CardInHandText}");
+                    }
+                }
+            }
+
+            AccessibilityUtils.LogDebug("Test ended");
+            AccessibilityUtils.LogDebug($"#OK: {okCount}");
+            AccessibilityUtils.LogDebug($"#FAIL: {failCount}");
+            AccessibilityUtils.LogDebug($"#TOTAL: {okCount + failCount}");
+
+            AccessibilityMgr.Output(null, $"OK count: {okCount}");
+            AccessibilityMgr.Output(null, $"Fail count: {failCount}");
+        }
+
+        private static bool IsBattlecryMinion(CollectibleCard card)
+        {
+            if (card.CardType != TAG_CARDTYPE.MINION)
+            {
+                return false;
+            }
+
+            return card.CardInHandText.Contains("<b>Battlecry:</b>");
+        }
+
+        private static bool IsEffectHandled(CollectibleCard card)
+        {
+            return CardEffectInterpreter.GetEffect(card.CardId) != CardEffectInterpreter.CardEffect.UNKNOWN;
+            //return CardEffectInterpreter.GetEffect(card.CardInHandText) != CardEffectInterpreter.CardEffect.UNKNOWN;
+        }
+
+        #endregion
+
+        #region Localization
+
+        // Used to test any localization we get from Blizzard to ensure TTS doesn't break in HS updates
+        internal static void TestLocalization()
+        {
+            AccessibilityMgr.Output(null, "Testing localization");
+            s_failedAssertions = 0;
+
+            AccessibilityUtils.LogDebug($"Testing localization");
+
+            AccessibilityUtils.LogDebug($"Making sure all strings exist");
+            foreach (var key in LocalizationKey.GetAllKeys())
+            {
+                if (!GameStrings.HasKey(key.Key))
+                {
+                    AccessibilityUtils.LogDebug($"Missing key: {key.Key}");
+                }
+            }
+
+            AccessibilityUtils.LogDebug($"Testing Blizzard provided strings");
+
+            AssertEquals("Game Menu", LocalizationUtils.Get(LocalizationKey.MENU_GAME_MENU_TITLE));
+            AssertEquals("Solo Adventures", LocalizationUtils.Get(LocalizationKey.GLOBAL_SOLO_ADVENTURES));
+            AssertEquals("Help", LocalizationUtils.Get(LocalizationKey.GLOBAL_HELP));
+            AssertEquals("Your Turn", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOUR_TURN));
+            AssertEquals("Reconnected", LocalizationUtils.Get(LocalizationKey.GLOBAL_RECONNECTED));
+            AssertEquals("Choose One", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_ONE));
+            AssertEquals("Starting Hand", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN));
+            AssertEquals("Keep or Replace Cards", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS));
+            AssertEquals("Taunt", LocalizationUtils.Get(LocalizationKey.GLOBAL_TAUNT));
+            AssertEquals("Deathrattle", LocalizationUtils.Get(LocalizationKey.GLOBAL_DEATHRATTLE));
+            AssertEquals("Battlecry", LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLECRY));
+            AssertEquals("Charge", LocalizationUtils.Get(LocalizationKey.GLOBAL_CHARGE));
+            AssertEquals("Lifesteal", LocalizationUtils.Get(LocalizationKey.GLOBAL_LIFESTEAL));
+            AssertEquals("Rush", LocalizationUtils.Get(LocalizationKey.GLOBAL_RUSH));
+            AssertEquals("Windfury", LocalizationUtils.Get(LocalizationKey.GLOBAL_WINDFURY));
+            AssertEquals("Divine Shield", LocalizationUtils.Get(LocalizationKey.GLOBAL_DIVINE_SHIELD));
+            AssertEquals("Freeze", LocalizationUtils.Get(LocalizationKey.GLOBAL_FREEZE));
+            AssertEquals("Frozen", LocalizationUtils.Get(LocalizationKey.GLOBAL_FROZEN));
+            AssertEquals("Poisonous", LocalizationUtils.Get(LocalizationKey.GLOBAL_POISONOUS));
+            AssertEquals("Stealth", LocalizationUtils.Get(LocalizationKey.GLOBAL_STEALTH));
+            AssertEquals("Immune", LocalizationUtils.Get(LocalizationKey.GLOBAL_IMMUNE));
+            AssertEquals("Dormant", LocalizationUtils.Get(LocalizationKey.GLOBAL_DORMANT));
+            AssertEquals("Enchantment", LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT));
+            AssertEquals("Silence", LocalizationUtils.Get(LocalizationKey.GLOBAL_SILENCE));
+            AssertEquals("The following sets are now Wild!", LocalizationUtils.Get(LocalizationKey.UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE));
+            AssertEquals("Reconnecting", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING));
+            AssertEquals("Options", LocalizationUtils.Get(LocalizationKey.GLOBAL_OPTIONS));
+            AssertEquals("Practice", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION));
+            AssertEquals("Arcane Dust", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_DUST));
+            AssertEquals("Gold", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_GOLD));
+            AssertEquals("Arcane Orbs", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_ORBS));
+            AssertEquals("New Class Unlocked!", LocalizationUtils.Get(LocalizationKey.UI_REWARD_NEW_CLASS_UNLOCKED));
+            AssertEquals("You are currently offline", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_OFFLINE));
+            AssertEquals("You must reconnect before you can proceed. However, you can still access your collection offline.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED));
+            AssertEquals("Reconnect Failed", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED));
+            AssertEquals("Please verify that your device has Internet access enabled and try again.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_NO_INTERNET));
+            AssertEquals("New version available", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER));
+            AssertEquals("You must update before you can proceed.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY));
+            AssertEquals("It's been a while since your last Hearthstone action and your connection was shut down.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT));
+            AssertEquals("Unable to reconnect. Please relaunch Hearthstone.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED));
+            AssertEquals("Not yet! You can still attack.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_NO_ENDTURN_ATK));
+            AssertEquals("Not yet! You have more cards to play!", LocalizationUtils.Get(LocalizationKey.TUTORIAL_NO_ENDTURN));
+            AssertEquals("Save that for the enemy!", LocalizationUtils.Get(LocalizationKey.TUTORIAL01_HELP_07));
+            AssertEquals("Ignore the puny gnoll and finish off Hogger.", LocalizationUtils.Get(LocalizationKey.TUTORIAL01_HELP_08));
+            AssertEquals("You gain a Mana Crystal every turn.", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_01));
+            AssertEquals("Your used Mana Crystals refill each turn.", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_03));
+            AssertEquals("Get Millhouse!", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_06));
+            AssertEquals("Expend your Mana each turn to crush this annoying gnome!", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_07));
+            AssertEquals("'Battlecry' minions do something special when you play them.", LocalizationUtils.Get(LocalizationKey.TUTORIAL06_HELP_03));
+            AssertEquals("Kill enemy minions before they become a problem!", LocalizationUtils.Get(LocalizationKey.TUTORIAL06_HELP_04));
+            AssertEquals("Welcome to the Jungle", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_14));
+            AssertEquals("Kill his minions or he'll overwhelm you!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_15));
+            AssertEquals("Subdue minions with your hero power and spells!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_16));
+            AssertEquals("Sheep it!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_02));
+            AssertEquals("Save that for the Fen Creeper!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_03));
+            AssertEquals("This fight is totally not fair. Blame the terrible game designers.", LocalizationUtils.Get(LocalizationKey.TUTORIAL05_HELP_03));
+            AssertEquals("Your Taunt minions can protect you from attacks!", LocalizationUtils.Get(LocalizationKey.TUTORIAL05_HELP_04));
+            AssertEquals("This minion has a power that lasts until he dies.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_RAID_LEADER_DESCRIPTION));
+            AssertEquals("You can have 10 cards in your hand.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_ARCANE_INTELLECT_DESCRIPTION));
+            AssertEquals("Level 42", LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_DECK_HERO_LEVEL, 42));
+            AssertEquals("My Collection", LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION));
+            AssertEquals("My Decks", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS));
+            AssertEquals("New Deck", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_NEW_DECK));
+            AssertEquals("Rename", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION));
+            AssertEquals("Page 2", LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, 2));
+            AssertEquals("235 FREE Cards!", LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_HEADER));
+            AssertEquals("Core set now available!", LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_SUBHEADER));
+            AssertEquals("Standard Format will update soon! You've been playing Standard, which allows only Basic, Classic, and the newest 2 years of sets. You will also gain access to Wild Format, which allows all cards!", LocalizationUtils.Get(LocalizationKey.UI_STANDARD_FORMAT_POPUP_TEXT));
+            AssertEquals("Choose Your Deck", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE));
+            AssertEquals("Choose Opponent", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_TITLE));
+            AssertEquals("Choose Your Hero", LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE));
+            AssertEquals("Master Volume", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MASTER_VOLUME_OPTION));
+            AssertEquals("Music Volume", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MUSIC_VOLUME_OPTION));
+            AssertEquals("Fullscreen", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FULLSCREEN_OPTION));
+            AssertEquals("Sound In Background", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION));
+            AssertEquals("Allow Friends to Spectate my Games", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ALLOW_SPECTATORS_OPTION));
+            AssertEquals("Enable Screen Shake", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION));
+            AssertEquals("Modes", LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_MODES));
+            AssertEquals("Choose a Mode", LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE));
+            AssertEquals("Claim a Free Deck", LocalizationUtils.Get(LocalizationKey.UI_CHOOSE_FREE_DECK_TITLE));
+            AssertEquals("Open Packs", LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS));
+            AssertEquals("NEW!", LocalizationUtils.Get(LocalizationKey.COLLECTION_CARD_NEW));
+            AssertEquals("Enchantment", LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT));
+            AssertEquals("Journal", LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL));
+            AssertEquals("Click to convert", LocalizationUtils.Get(LocalizationKey.DECK_PICKER_CLICK_TO_CONVERT));
+            AssertEquals("Play Standard", LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_STANDARD));
+            AssertEquals("Play Wild", LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_WILD));
+            AssertEquals("Play Casual", LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_CASUAL));
+            AssertEquals("Alliance", LocalizationUtils.Get(LocalizationKey.GLOBAL_ALLIANCE));
+            AssertEquals("Horde", LocalizationUtils.Get(LocalizationKey.GLOBAL_HORDE));
+            AssertEquals("Ready!", LocalizationUtils.Get(LocalizationKey.GLOBAL_READY));
+            AssertEquals("1 Mana Crystal <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_OVERLOADED_MANA, 1));
+            AssertEquals("2 Mana Crystals <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_OVERLOADED_MANA, 2));
+            AssertEquals("1 Mana Crystal <b>Overloaded</b> last turn.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_LOCKED_MANA, 1));
+            AssertEquals("2 Mana Crystals <b>Overloaded</b> last turn.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_LOCKED_MANA, 2));
+            AssertEquals("1 Mana Crystal <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA, 1));
+            AssertEquals("2 Mana Crystals <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA, 2));
+            AssertEquals("Standard", LocalizationUtils.Get(LocalizationKey.GLOBAL_STANDARD));
+            AssertEquals("Wild", LocalizationUtils.Get(LocalizationKey.GLOBAL_WILD));
+            AssertEquals("Classic", LocalizationUtils.Get(LocalizationKey.GLOBAL_CLASSIC));
+            AssertEquals("Golden Tarecgosa", LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_PREMIUM_GOLDEN, "Tarecgosa"));
+            AssertEquals("RECRUIT PHASE", LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE));
+            AssertEquals("COMBAT PHASE", LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE));
+            AssertEquals("Play", LocalizationUtils.Get(LocalizationKey.GLOBAL_PLAY));
+            AssertEquals("Battlegrounds", LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLEGROUNDS));
+            AssertEquals("1st Place!!!", TB_BaconShop.GetPlaceString(1));
+            AssertEquals("2nd Place!!", TB_BaconShop.GetPlaceString(2));
+            AssertEquals("3rd Place!", TB_BaconShop.GetPlaceString(3));
+            AssertEquals("4th Place!", TB_BaconShop.GetPlaceString(4));
+            AssertEquals("5th Place", TB_BaconShop.GetPlaceString(5));
+            AssertEquals("6th Place", TB_BaconShop.GetPlaceString(6));
+            AssertEquals("7th Place", TB_BaconShop.GetPlaceString(7));
+            AssertEquals("8th Place", TB_BaconShop.GetPlaceString(8));
+            AssertEquals("Triples Created", LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARD_STATS_PLAYER_TRIPLES_CREATED));
+            AssertEquals("As Millhouse Manastorm", GameStrings.Format("GAMEPLAY_BACON_ALTERNATE_PLAYER_NAME", "Millhouse Manastorm"));
+            AssertEquals("Mixed Minions", GameStrings.Get("GLOBAL_RACE_MIXED_BATTLEGROUNDS"));
+
+            // GameStrings we depend on
+            // Made turns to hold out generic so need to signal if something else shows up
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_UTHER_08"));
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_GULDAN_01"));
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_ILLIDAN_08"));
+            AssertEquals(3, GameStrings.FindKeysWithValue("|4(Turn,Turns) to Hold Out").Count);
+
+            AccessibilityUtils.LogDebug($"Localization test ended");
+
+            if (s_failedAssertions > 0)
+            {
+                AccessibilityMgr.Output(null, $"Failed {s_failedAssertions} assertions");
+            }
+            else
+            {
+                AccessibilityMgr.Output(null, "All tests OK");
+            }
+        }
+
+        private static int s_failedAssertions;
+
+        private static void AssertEquals(string expected, string actual)
+        {
+            if (!expected.Equals(actual))
+            {
+                AccessibilityUtils.LogDebug($"Assertion failed. Expected: {expected} , Actual: {actual}");
+                s_failedAssertions++;
+            }
+        }
+
+        private static void AssertEquals(int expected, int actual)
+        {
+            if (!expected.Equals(actual))
+            {
+                AccessibilityUtils.LogDebug($"Assertion failed. Expected: {expected} , Actual: {actual}");
+                s_failedAssertions++;
+            }
+        }
+
+		#endregion
+
+		#region Battlegrounds
+
+        internal static void ScanBattlegroundsPermanentEffects()
+        {
+            // Build using enUS and just record the IDs so other languages are ok
+            var allCards = GameUtils.GetAllCardIds();
+
+            AccessibilityUtils.LogDebug($"Scanning {allCards.Count} cards");
+
+            var bgCardIds = allCards.FindAll(c => c.StartsWith("BG"));
+
+            AccessibilityUtils.LogDebug($"Found {bgCardIds} BG cards");
+            AccessibilityUtils.LogDebug($"Scanning cards with 'permanently' in their description");
+
+            var permanentlyEffectCards = new HashSet<string>();
+
+            foreach (var cardId in bgCardIds)
+            {
+                EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+                var cardTextInHand = entityDef.GetCardTextInHand();
+
+                if (cardTextInHand.ToLower().Contains("permanently"))
+				{
+                    permanentlyEffectCards.Add(cardId);
+					AccessibilityUtils.LogDebug($"Found card with 'permanently' effect. Card name={entityDef.GetName()} ; Card ID={entityDef.GetCardId()}; Card Description={cardTextInHand}");
+				}
+            }
+
+            AccessibilityUtils.LogDebug("Scanning ended");
+            AccessibilityUtils.LogDebug($"#BG cards: {bgCardIds.Count}");
+
+            var permanentlyEffectCardsText = $"#Permanently effect cards: {permanentlyEffectCards.Count}";
+            AccessibilityUtils.LogDebug(permanentlyEffectCardsText);
+            AccessibilityMgr.Output(null, permanentlyEffectCardsText);
+
+            var ok = BattlegroundsCardEffectInterpreter.AreAllBGCardsAccountedFor(permanentlyEffectCards);
+
+            if (ok)
+			{
+				AccessibilityMgr.Output(null, $"BG permanently effect cards OK");
+			}
+            else
+			{
+				AccessibilityMgr.Output(null, $"BG permanently effect cards FAIL");
+			}
+        }
+
+		#endregion
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs b/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
new file mode 100644
index 0000000..6a622be
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
@@ -0,0 +1,20 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    public abstract class InaccessibleDialogBase : DialogBase
+    {
+        public override string GetAccessibleHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.UI_UNKNOWN_DIALOG);
+        }
+
+        public override void HandleAccessibleInput()
+        {
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs
new file mode 100644
index 0000000..be45111
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs
@@ -0,0 +1,499 @@
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using Assets;
+using Blizzard.T5.Core;
+using Blizzard.T5.Jobs;
+using PegasusShared;
+using UnityEngine;
+using Accessibility;
+
+// Simplified copy of GameStrings.cs without logging and forcing enUS locale
+// Used for defaults for non-localized versions
+// Could do it some other way but might as well use what's already proven and tested
+public class DefaultGameStrings
+{
+    #region Accessibility
+    private static Locale DEFAULT_LOCALE = Locale.enUS;
+	private static CultureInfo DEFAULT_CULTURE_INFO = new CultureInfo("en-US");
+	#endregion
+
+	public const string s_UnknownName = "UNKNOWN";
+
+	private static Map<Global.GameStringCategory, GameStringTable> s_tables = new Map<Global.GameStringCategory, GameStringTable>();
+
+	private static readonly char[] LANGUAGE_RULE_ARG_DELIMITERS = new char[1] { ',' };
+
+	private static List<Global.GameStringCategory> s_nativeGameStringCatetories = new List<Global.GameStringCategory>
+	{
+		Global.GameStringCategory.GLOBAL,
+		Global.GameStringCategory.GLUE
+	};
+
+	public static void LoadAll()
+	{
+		AccessibilityUtils.LogDebug("DefaultGameStrings.LoadAll()");
+		float realtimeSinceStartup = Time.realtimeSinceStartup;
+        LoadCategory(Global.GameStringCategory.ACCESSIBILITY, native: false);
+        float realtimeSinceStartup2 = Time.realtimeSinceStartup;
+	}
+	public static IAsyncJobResult CreateLoadCategoryJob(Global.GameStringCategory category, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.CreateLoadCategoryJob({category}, {native})");
+
+		return new JobDefinition($"DefaultGameStrings.LoadCategory[{category}]", Job_LoadCategory(category, native));
+	}
+
+	private static IEnumerator<IAsyncJobResult> Job_LoadCategory(Global.GameStringCategory category, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Job_LoadCategory({category}, {native})");
+		if (!s_tables.ContainsKey(category))
+		{
+            LoadCategory(category, native);
+		}
+        yield break;
+    }
+
+	private static void ReloadAllInternal(bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.ReloadAllInternal({native})");
+
+		float realtimeSinceStartup = Time.realtimeSinceStartup;
+		foreach (Global.GameStringCategory value in Enum.GetValues(typeof(Global.GameStringCategory)))
+		{
+			if (value != 0 && (!native || s_nativeGameStringCatetories.Contains(value)))
+			{
+				if (s_tables.ContainsKey(value))
+				{
+					UnloadCategory(value);
+				}
+				LoadCategory(value, native);
+			}
+		}
+		float realtimeSinceStartup2 = Time.realtimeSinceStartup;
+		AccessibilityUtils.LogDebug(string.Format("Reloading {0} GameStrings took {1}s)", native ? "Native" : "All", realtimeSinceStartup2 - realtimeSinceStartup));
+	}
+
+	public static void ReloadAll()
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.ReloadAll()");
+
+		ReloadAllInternal(native: false);
+	}
+
+	public static void LoadNative()
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.LoadNative()");
+
+		ReloadAllInternal(native: true);
+	}
+
+    public static bool HasKey(string key)
+	{
+		return Find(key) != null;
+	}
+
+	public static bool TryGet(string key, out string localized)
+	{
+		localized = null;
+		string text = Find(key);
+		if (text == null)
+		{
+			return false;
+		}
+		localized = ParseLanguageRules(text);
+		return true;
+	}
+
+	public static string Get(string key)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Get({key})");
+
+		if (!TryGet(key, out var localized))
+		{
+			return key;
+		}
+		return localized;
+	}
+
+	public static string Format(string key, params object[] args)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Format({key})");
+
+		string text = Find(key);
+		if (text == null)
+		{
+			return key;
+		}
+		return FormatLocalizedString(text, args);
+	}
+
+	public static string FormatLocalizedString(string text, params object[] args)
+	{
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		text = ParseLanguageRules(text);
+		return text;
+	}
+
+	public static string FormatLocalizedStringWithPlurals(string text, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+	{
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		text = ParseLanguageRules(text, pluralNumbers);
+		return text;
+	}
+
+	public static string FormatPlurals(string key, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.FormatPlurals({key})");
+
+		string text = Find(key);
+		if (text == null)
+		{
+			return key;
+		}
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		return ParseLanguageRules(text, pluralNumbers);
+	}
+
+	public static string FormatStringWithPlurals(List<LocalizedString> protoLocalized, string stringKey, params object[] optionalFormatArgs)
+	{
+		Locale locale = DEFAULT_LOCALE;
+		LocalizedString localizedString = protoLocalized.FirstOrDefault((LocalizedString s) => s.Key == stringKey);
+		LocalizedStringValue localizedStringValue = null;
+		if (localizedString == null)
+		{
+			Debug.LogWarning($"DefaultGameStrings.FormatStringWithPlurals() - localizedStr was null for string key {stringKey}");
+			return null;
+		}
+		localizedStringValue = localizedString.Values.FirstOrDefault((LocalizedStringValue v) => v.Locale == (int)locale);
+		if (localizedStringValue.Value == null)
+		{
+			Debug.LogWarning($"DefaultGameStrings.FormatStringWithPlurals() - localizedVal was null");
+			return null;
+		}
+		return ParseLanguageRules(string.Format(localizedStringValue.Value, optionalFormatArgs));
+	}
+
+	public static string ParseLanguageRules(string str)
+	{
+		str = ParseLanguageRule1(str);
+		str = ParseLanguageRule4(str);
+		return str;
+	}
+
+	public static string ParseLanguageRules(string str, GameStrings.PluralNumber[] pluralNumbers)
+	{
+		str = ParseLanguageRule1(str);
+		str = ParseLanguageRule4(str, pluralNumbers);
+		return str;
+	}
+
+	private static bool LoadCategory(Global.GameStringCategory cat, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.LoadCategory({cat}, {native})");
+
+		if (s_tables.ContainsKey(cat))
+		{
+			return false;
+		}
+		GameStringTable gameStringTable = new GameStringTable();
+		if (!gameStringTable.Load(cat, DEFAULT_LOCALE, native))
+		{
+			return false;
+		}
+		s_tables.Add(cat, gameStringTable);
+		return true;
+	}
+
+	private static bool UnloadCategory(Global.GameStringCategory cat)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.UnloadCategory({cat})");
+
+		if (!s_tables.Remove(cat))
+		{
+			AccessibilityUtils.LogDebug($"GameStrings.UnloadCategory() - {cat} was never loaded");
+			return false;
+		}
+		return true;
+	}
+
+	private static string Find(string key)
+	{
+		if (key == null)
+		{
+			return null;
+		}
+		foreach (GameStringTable value in s_tables.Values)
+		{
+			string text = value.Get(key);
+			if (text != null)
+			{
+				return text;
+			}
+		}
+		if (key.StartsWith("Assets/"))
+		{
+		}
+		return null;
+	}
+
+	private static string[] ParseLanguageRuleArgs(string str, int ruleIndex, out int argStartIndex, out int argEndIndex)
+	{
+		argStartIndex = -1;
+		argEndIndex = -1;
+		argStartIndex = str.IndexOf('(', ruleIndex + 2);
+		if (argStartIndex < 0)
+		{
+			return null;
+		}
+		argEndIndex = str.IndexOf(')', argStartIndex + 1);
+		if (argEndIndex < 0)
+		{
+			return null;
+		}
+		StringBuilder stringBuilder = new StringBuilder();
+		stringBuilder.Append(str, argStartIndex + 1, argEndIndex - argStartIndex - 1);
+		string text = stringBuilder.ToString();
+		MatchCollection matchCollection = Regex.Matches(text, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (matchCollection.Count == 0)
+		{
+			matchCollection = Regex.Matches(text, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (matchCollection.Count > 0)
+		{
+			stringBuilder.Remove(0, stringBuilder.Length);
+			int num = 0;
+			foreach (Match item in matchCollection)
+			{
+				stringBuilder.Append(text, num, item.Index - num);
+				stringBuilder.Append('0', item.Length);
+				num = item.Index + item.Length;
+			}
+			stringBuilder.Append(text, num, text.Length - num);
+			text = stringBuilder.ToString();
+		}
+		string[] array = text.Split(LANGUAGE_RULE_ARG_DELIMITERS);
+		int num2 = 0;
+		for (int i = 0; i < array.Length; i++)
+		{
+			string text2 = array[i];
+			if (matchCollection.Count > 0)
+			{
+				stringBuilder.Remove(0, stringBuilder.Length);
+				int num3 = 0;
+				foreach (Match item2 in matchCollection)
+				{
+					if (item2.Index >= num2 && item2.Index < num2 + text2.Length)
+					{
+						int num4 = item2.Index - num2;
+						stringBuilder.Append(text2, num3, num4 - num3);
+						stringBuilder.Append(item2.Value);
+						num3 = num4 + item2.Length;
+					}
+				}
+				stringBuilder.Append(text2, num3, text2.Length - num3);
+				text2 = stringBuilder.ToString();
+				num2 += text2.Length + 1;
+			}
+			text2 = (array[i] = text2.Trim());
+		}
+		return array;
+	}
+
+	private static string ParseLanguageRule1(string str)
+	{
+		int num = str.IndexOf("|1");
+		if (num < 0)
+		{
+			return str;
+		}
+		StringBuilder stringBuilder;
+		string text;
+		int num3;
+		string[] array;
+		int num4;
+		for (stringBuilder = new StringBuilder(); num >= 0; stringBuilder.Append(text), stringBuilder.Append(array[num4]), str = str.Substring(num3 + 1), num = str.IndexOf("|1"))
+		{
+			text = str.Substring(0, num);
+			if (text.Length == 0)
+			{
+				break;
+			}
+			int num2 = str.IndexOf('(', num);
+			if (num2 < 0)
+			{
+				break;
+			}
+			num3 = str.IndexOf(')', num2);
+			if (num3 < 0)
+			{
+				break;
+			}
+			string text2 = str.Substring(num2 + 1, num3 - num2 - 1);
+			array = text2.Split(',');
+			if (array.Length != 2)
+			{
+				break;
+			}
+			char c = text[text.Length - 1];
+			num4 = 0;
+			switch (c)
+			{
+			case '0':
+			case '1':
+			case '3':
+			case '6':
+			case '7':
+			case '8':
+				num4 = 0;
+				continue;
+			case '2':
+			case '4':
+			case '5':
+			case '9':
+				num4 = 1;
+				continue;
+			default:
+				if (c >= '가' && c <= '힣')
+				{
+					num4 = (((c - 44032) % 28 == 0) ? 1 : 0);
+					continue;
+				}
+				break;
+			}
+			break;
+		}
+		stringBuilder.Append(str);
+		return stringBuilder.ToString();
+	}
+
+	private static string ParseLanguageRule4(string str, GameStrings.PluralNumber[] pluralNumbers = null)
+	{
+		StringBuilder stringBuilder = null;
+		int? num = null;
+		int num2 = 0;
+		int num3 = 0;
+		for (int num4 = str.IndexOf("|4"); num4 >= 0; num4 = str.IndexOf("|4", num4 + 2))
+		{
+			num3++;
+			int argStartIndex;
+			int argEndIndex;
+			string[] array = ParseLanguageRuleArgs(str, num4, out argStartIndex, out argEndIndex);
+			if (array == null)
+			{
+				continue;
+			}
+			int num5 = num2;
+			int num6 = num4 - num2;
+			string text = str.Substring(num5, num6);
+			GameStrings.PluralNumber pluralNumber = null;
+			if (pluralNumbers != null)
+			{
+				int pluralArgIndex = num3 - 1;
+				pluralNumber = Array.Find(pluralNumbers, (GameStrings.PluralNumber currPluralNumber) => currPluralNumber.m_index == pluralArgIndex);
+			}
+			int number;
+			if (pluralNumber != null)
+			{
+				num = pluralNumber.m_number;
+			}
+			else if (ParseLanguageRule4Number(array, text, out number))
+			{
+				num = number;
+			}
+			else if (!num.HasValue)
+			{
+				continue;
+			}
+			int pluralIndex = GetPluralIndex(num.Value);
+			if (pluralIndex >= array.Length)
+			{
+			}
+			else
+			{
+				string value = array[pluralIndex];
+				if (stringBuilder == null)
+				{
+					stringBuilder = new StringBuilder();
+				}
+				stringBuilder.Append(text);
+				stringBuilder.Append(value);
+				num2 = argEndIndex + 1;
+			}
+			if (pluralNumber != null && pluralNumber.m_useForOnlyThisIndex)
+			{
+				num = null;
+			}
+		}
+		if (stringBuilder == null)
+		{
+			return str;
+		}
+		stringBuilder.Append(str, num2, str.Length - num2);
+		return stringBuilder.ToString();
+	}
+
+	private static bool ParseLanguageRule4Number(string[] args, string betweenRulesStr, out int number)
+	{
+		if (ParseLanguageRule4Number_Foreward(args[0], out number))
+		{
+			return true;
+		}
+		if (ParseLanguageRule4Number_Backward(betweenRulesStr, out number))
+		{
+			return true;
+		}
+		number = 0;
+		return false;
+	}
+
+	private static bool ParseLanguageRule4Number_Foreward(string str, out int number)
+	{
+		number = 0;
+		Match match = Regex.Match(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (!match.Success)
+		{
+			match = Regex.Match(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (!match.Success)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(match.Value, out number))
+		{
+			return false;
+		}
+		return true;
+	}
+
+	private static bool ParseLanguageRule4Number_Backward(string str, out int number)
+	{
+		number = 0;
+		MatchCollection matchCollection = Regex.Matches(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (matchCollection.Count == 0)
+		{
+			matchCollection = Regex.Matches(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (matchCollection.Count == 0)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(matchCollection[matchCollection.Count - 1].Value, out number))
+		{
+			return false;
+		}
+		return true;
+	}
+
+	private static int GetPluralIndex(int number)
+	{
+		if (number == 1)
+        {
+			return 0;
+        }
+		return 1;
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs
new file mode 100644
index 0000000..d0bee5b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs
@@ -0,0 +1,1009 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+public class LocalizationKey
+{
+    public static LocalizationKey WELCOME_TO_HEARTHSTONE = CreateKey("ACCESSIBILITY_WELCOME_TO_HEARTHSTONE"); 
+
+    // Press key to
+    public static LocalizationKey PRESS_KEY_TO_START = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_START"); 
+    public static LocalizationKey PRESS_KEY_TO_CONTINUE = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_CONTINUE"); 
+    public static LocalizationKey PRESS_KEY_TO_FINISH = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_FINISH"); 
+    public static LocalizationKey PRESS_KEY_TO_GO_BACK = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_GO_BACK");
+    public static LocalizationKey PRESS_KEY_TO_EXIT = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_EXIT"); 
+    public static LocalizationKey PRESS_KEY_ONCE_DONE = CreateKey("ACCESSIBILITY_PRESS_KEY_ONCE_DONE"); 
+
+    // Menus
+    public static LocalizationKey MENU_HELP_NO_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HELP_NO_BACK_BUTTON");
+    public static LocalizationKey MENU_HELP_WITH_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HELP_WITH_BACK_BUTTON");
+    public static LocalizationKey MENU_HORIZONTAL_HELP_NO_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HORIZONTAL_HELP_NO_BACK_BUTTON");
+    public static LocalizationKey MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON");
+    public static LocalizationKey MENU_OPTION_FORMAT = CreateKey("ACCESSIBILITY_MENU_OPTION_FORMAT");
+    public static LocalizationKey MENU_NO_ITEMS = CreateKey("ACCESSIBILITY_LIST_NO_ITEMS");
+    public static LocalizationKey MENU_GAME_MENU_TITLE = CreateKey("GLOBAL_TOOLTIP_MENU_HEADER");
+    public static LocalizationKey OPTIONS_MENU_TITLE = CreateKey("ACCESSIBILITY_OPTIONS_MENU_TITLE");
+    public static LocalizationKey OPTIONS_MENU_GRAPHICS_QUALITY_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_GRAPHICS_QUALITY_OPTION");
+    public static LocalizationKey OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION");
+    public static LocalizationKey OPTIONS_MENU_MASTER_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_MASTER_VOLUME_LABEL");
+    public static LocalizationKey OPTIONS_MENU_MUSIC_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_MUSIC_VOLUME_LABEL");
+    public static LocalizationKey OPTIONS_MENU_FULLSCREEN_OPTION = CreateKey("GLOBAL_OPTIONS_GRAPHICS_FULLSCREEN_LABEL");
+    public static LocalizationKey OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_IN_BACKGROUND");
+    public static LocalizationKey OPTIONS_MENU_ALLOW_SPECTATORS_OPTION = CreateKey("GLOBAL_OPTIONS_SPECTATOR_OPEN_JOIN");
+    public static LocalizationKey OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION = CreateKey("GLOBAL_OPTIONS_SCREEN_SHAKE");
+    public static LocalizationKey OPTIONS_MENU_ADJUST_VOLUME = CreateKey("ACCESSIBILITY_OPTIONS_MENU_ADJUST_VOLUME");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_LABEL = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_LABEL");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_CHECKED = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_CHECKED");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_NOT_CHECKED = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_NOT_CHECKED");
+
+    // Hub
+    public static LocalizationKey HUB_MAIN_MENU_TITLE = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_TITLE");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_GAME_MENU = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_GAME_MENU");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_SOCIAL_MENU = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_SOCIAL_MENU");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_HELP = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_HELP");
+
+    // Global
+    public static LocalizationKey GLOBAL_SOLO_ADVENTURES = CreateKey("GLUE_ADVENTURE");
+    public static LocalizationKey GLOBAL_BATTLEGROUNDS = CreateKey("GLUE_BACON");
+    public static LocalizationKey GLOBAL_GAME_MODES = CreateKey("GLUE_GAME_MODES");
+    public static LocalizationKey GLOBAL_CHOOSE_MODE = CreateKey("GLUE_GAME_MODES_POPUP_HEADER");
+    public static LocalizationKey GLOBAL_MY_COLLECTION = CreateKey("GLUE_MY_COLLECTION");
+    public static LocalizationKey GLOBAL_OPEN_PACKS = CreateKey("GLUE_OPEN_PACKS");
+    public static LocalizationKey GLOBAL_JOURNAL = CreateKey("GLUE_TOOLTIP_BUTTON_JOURNAL_HEADLINE");
+    public static LocalizationKey GLOBAL_SHOP = CreateKey("GLUE_STORE_HEADLINE");
+    public static LocalizationKey GLOBAL_HELP = CreateKey("GLOBAL_HELP");
+    public static LocalizationKey GLOBAL_LOADING_GAME = CreateKey("ACCESSIBILITY_GLOBAL_LOADING_GAME");
+    public static LocalizationKey GLOBAL_CLOSING_GAME = CreateKey("ACCESSIBILITY_GLOBAL_CLOSING_GAME");
+    public static LocalizationKey GLOBAL_GAME_LOADED = CreateKey("ACCESSIBILITY_GLOBAL_GAME_LOADED");
+    public static LocalizationKey GLOBAL_LOADING = CreateKey("ACCESSIBILITY_GLOBAL_LOADING");
+    public static LocalizationKey GLOBAL_PLEASE_WAIT = CreateKey("ACCESSIBILITY_GLOBAL_PLEASE_WAIT");
+    public static LocalizationKey GLOBAL_RECONNECTED = CreateKey("GLOBAL_RECONNECT_RECONNECTED_HEADER");
+    public static LocalizationKey GLOBAL_CARD = CreateKey("ACCESSIBILITY_GLOBAL_CARD");
+    public static LocalizationKey GLOBAL_CARD_PLURAL = CreateKey("ACCESSIBILITY_GLOBAL_CARD_PLURAL");
+    public static LocalizationKey GLOBAL_SECRET = CreateKey("ACCESSIBILITY_GLOBAL_SECRET");
+    public static LocalizationKey GLOBAL_GAME_SPEED = CreateKey("ACCESSIBILITY_GLOBAL_GAME_SPEED");
+    public static LocalizationKey GLOBAL_GAME_SPEED_CANNOT_ADJUST_VS_PLAYERS = CreateKey("ACCESSIBILITY_GLOBAL_GAME_SPEED_CANNOT_ADJUST_VS_PLAYERS");
+    public static LocalizationKey GLOBAL_OPTIONS = CreateKey("GLOBAL_OPTIONS");
+    public static LocalizationKey GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE = CreateKey("ACCESSIBILITY_GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE");
+    public static LocalizationKey GLOBAL_CANNOT_DO_THAT = CreateKey("ACCESSIBILITY_GLOBAL_CANNOT_DO_THAT");
+    public static LocalizationKey GLOBAL_SWITCH_FORMAT = CreateKey("ACCESSIBILITY_GLOBAL_SWITCH_FORMAT");
+    public static LocalizationKey GLOBAL_CHOOSE_FORMAT = CreateKey("ACCESSIBILITY_GLOBAL_CHOOSE_FORMAT");
+    public static LocalizationKey GLOBAL_STANDARD = CreateKey("GLOBAL_STANDARD");
+    public static LocalizationKey GLOBAL_WILD = CreateKey("GLOBAL_WILD");
+    public static LocalizationKey GLOBAL_CLASSIC = CreateKey("GLOBAL_CLASSIC");
+    public static LocalizationKey GLOBAL_PLAY = CreateKey("GLOBAL_PLAY");
+
+    // Global cont'd
+    public static LocalizationKey GLOBAL_ACCESSIBILITY_ON = CreateKey("ACCESSIBILITY_GLOBAL_ACCESSIBILITY_ON");
+    public static LocalizationKey GLOBAL_ACCESSIBILITY_OFF = CreateKey("ACCESSIBILITY_GLOBAL_ACCESSIBILITY_OFF");
+    public static LocalizationKey GLOBAL_STREAMER_MODE_ON = CreateKey("ACCESSIBILITY_GLOBAL_STREAMER_MODE_ON");
+    public static LocalizationKey GLOBAL_STREAMER_MODE_OFF = CreateKey("ACCESSIBILITY_GLOBAL_STREAMER_MODE_OFF");
+
+    // Formatting
+    public static LocalizationKey FORMATTING_PERIOD = CreateKey("ACCESSIBILITY_FORMATTING_PERIOD");
+    public static LocalizationKey FORMATTING_SENTENCE_ENDING_CHARACTERS = CreateKey("ACCESSIBILITY_FORMATTING_SENTENCE_ENDING_CHARACTERS");
+    public static LocalizationKey FORMATTING_LIST_SEPARATOR = CreateKey("ACCESSIBILITY_FORMATTING_LIST_SEPARATOR");
+    public static LocalizationKey FORMATTING_LIST_FINAL_SEPARATOR = CreateKey("ACCESSIBILITY_FORMATTING_LIST_FINAL_SEPARATOR");
+
+    // Orders
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_1 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_1");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_2 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_2");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_3 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_3");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_4 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_4");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_5 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_5");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_6 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_6");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_7 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_7");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_8 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_8");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_9 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_9");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_10 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_10");
+
+    // Input
+    public static LocalizationKey INPUT_COMMAND_WITH_MODIFIER_FORMAT = CreateKey("ACCESSIBILITY_INPUT_COMMAND_WITH_MODIFIER_FORMAT");
+    public static LocalizationKey INPUT_COMMAND_WITH_CTRL_FORMAT = CreateKey("ACCESSIBILITY_INPUT_COMMAND_WITH_CTRL_FORMAT");
+    public static string INPUT_KEY_OVERRIDE_FORMAT = "ACCESSIBILITY_INPUT_KEY_OVERRIDE_{0}";
+
+    // Card reading
+    public static LocalizationKey READ_CARD_COST = CreateKey("ACCESSIBILITY_READ_CARD_COST");
+    public static LocalizationKey READ_CARD_ATK_HEALTH = CreateKey("ACCESSIBILITY_READ_CARD_ATK_HEALTH");
+    public static LocalizationKey READ_CARD_ATK_DURABILITY = CreateKey("ACCESSIBILITY_READ_CARD_ATK_DURABILITY");
+    public static LocalizationKey READ_HERO_CARD_ATK = CreateKey("ACCESSIBILITY_READ_HERO_CARD_ATK");
+    public static LocalizationKey READ_HERO_CARD_HEALTH = CreateKey("ACCESSIBILITY_READ_HERO_CARD_HEALTH");
+    public static LocalizationKey READ_HERO_CARD_ARMOR = CreateKey("ACCESSIBILITY_READ_HERO_CARD_ARMOR");
+    public static LocalizationKey READ_CARD_N_COPIES = CreateKey("ACCESSIBILITY_READ_CARD_N_COPIES");
+    public static LocalizationKey READ_COLLECTION_CARD_NAME_GOLDEN = CreateKey("ACCESSIBILITY_READ_COLLECTION_CARD_NAME_GOLDEN");
+    public static LocalizationKey READ_COLLECTION_CARD_NAME_DIAMOND = CreateKey("ACCESSIBILITY_READ_COLLECTION_CARD_NAME_DIAMOND");
+
+    // Global keywords
+    public static LocalizationKey GLOBAL_TAUNT = CreateKey("GLOBAL_KEYWORD_TAUNT");
+    public static LocalizationKey GLOBAL_DEATHRATTLE = CreateKey("GLOBAL_KEYWORD_DEATHRATTLE");
+    public static LocalizationKey GLOBAL_BATTLECRY = CreateKey("GLOBAL_KEYWORD_BATTLECRY");
+    public static LocalizationKey GLOBAL_CHARGE = CreateKey("GLOBAL_KEYWORD_CHARGE");
+    public static LocalizationKey GLOBAL_LIFESTEAL = CreateKey("GLOBAL_KEYWORD_LIFESTEAL");
+    public static LocalizationKey GLOBAL_RUSH = CreateKey("GLOBAL_KEYWORD_RUSH");
+    public static LocalizationKey GLOBAL_WINDFURY = CreateKey("GLOBAL_KEYWORD_WINDFURY");
+    public static LocalizationKey GLOBAL_DIVINE_SHIELD = CreateKey("GLOBAL_KEYWORD_DIVINE_SHIELD");
+    public static LocalizationKey GLOBAL_FREEZE = CreateKey("GLOBAL_KEYWORD_FREEZE");
+    public static LocalizationKey GLOBAL_FROZEN = CreateKey("GLOBAL_KEYWORD_FROZEN");
+    public static LocalizationKey GLOBAL_POISONOUS = CreateKey("GLOBAL_KEYWORD_POISONOUS");
+    public static LocalizationKey GLOBAL_STEALTH = CreateKey("GLOBAL_KEYWORD_STEALTH");
+    public static LocalizationKey GLOBAL_IMMUNE = CreateKey("GLOBAL_KEYWORD_IMMUNE");
+    public static LocalizationKey GLOBAL_DORMANT = CreateKey("GLOBAL_KEYWORD_DORMANT");
+    public static LocalizationKey GLOBAL_REBORN = CreateKey("GLOBAL_KEYWORD_REBORN");
+    public static LocalizationKey GLOBAL_ENCHANTMENT = CreateKey("GLOBAL_CARDTYPE_ENCHANTMENT");
+    public static LocalizationKey GLOBAL_SILENCE = CreateKey("GLOBAL_KEYWORD_SILENCE");
+    public static LocalizationKey GLOBAL_CURSED = CreateKey("ACCESSIBILITY_GLOBAL_KEYWORD_CURSED");
+    public static LocalizationKey GLOBAL_READY = CreateKey("GAMEPLAY_LETTUCE_READY_BUTTON");
+
+    // Global keywords cont'd
+    public static LocalizationKey GLOBAL_ALLIANCE = CreateKey("GLOBAL_KEYWORD_ALLIANCE");
+    public static LocalizationKey GLOBAL_HORDE = CreateKey("GLOBAL_KEYWORD_HORDE");
+
+    // Gameplay
+    public static LocalizationKey GAMEPLAY_YOUR_TURN = CreateKey("GAMEPLAY_YOUR_TURN");
+    public static LocalizationKey GAMEPLAY_OPPONENT_TURN = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_TURN");
+    public static LocalizationKey GAMEPLAY_TURN_ENDED = CreateKey("ACCESSIBILITY_GAMEPLAY_TURN_ENDED");
+    public static LocalizationKey GAMEPLAY_PLAYER_CARD_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CARD_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CARD_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CARD_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_CARD_IN_ZONE_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_CARD_IN_ZONE_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_PLAYER_PLAYED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_PLAYED_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_PLAYED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_PLAYED_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_SUMMONED_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_SUMMONED_MINION");
+    public static LocalizationKey GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_SUMMONED_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_SUMMONED_MINION");
+    public static LocalizationKey GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_TRADED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_TRADED_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_TRADED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_TRADED_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_USED_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_USED_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_USED_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_USED_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_CAST_SECRET = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CAST_SECRET");
+    public static LocalizationKey GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CAST_SECRET = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CAST_SECRET");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CAST_N_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CAST_N_SECRETS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED");
+    public static LocalizationKey GAMEPLAY_ENTITY_ATTACKED = CreateKey("ACCESSIBILITY_GAMEPLAY_ENTITY_ATTACKED");
+    public static LocalizationKey GAMEPLAY_ENTITY_ATTACKED_OTHER = CreateKey("ACCESSIBILITY_GAMEPLAY_ENTITY_ATTACKED_OTHER");
+    public static LocalizationKey GAMEPLAY_JOUST_PLAYER_REVEALED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_PLAYER_REVEALED_CARD");
+    public static LocalizationKey GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD");
+    public static LocalizationKey GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS");
+    public static LocalizationKey GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS");
+
+    // Gameplay
+    public static LocalizationKey GAMEPLAY_PLAYER_TURN_START_READ_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_TURN_START_READ_MANA");
+    public static LocalizationKey GAMEPLAY_YOU_GO_FIRST = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_GO_FIRST");
+    public static LocalizationKey GAMEPLAY_OPPONENT_GOES_FIRST = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_GOES_FIRST");
+    public static LocalizationKey GAMEPLAY_YOU_START_WITH_N_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_START_WITH_N_CARDS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARDS");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARDS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DISCARDED_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DISCARDED_CARDS");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DISCARDED_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DISCARDED_CARDS");
+    public static LocalizationKey GAMEPLAY_YOU_GET_THE_COIN = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_GET_THE_COIN");
+    public static LocalizationKey GAMEPLAY_WAITING_FOR_OPPONENT = CreateKey("ACCESSIBILITY_GAMEPLAY_WAITING_FOR_OPPONENT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN");
+    public static LocalizationKey GAMEPLAY_QUERY_PLAY_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_PLAY_CARD");
+    public static LocalizationKey GAMEPLAY_QUERY_TRADE_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_TRADE_CARD");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_NO_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_NO_MINIONS");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS");
+    public static LocalizationKey GAMEPLAY_CHOOSE_TARGET = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET");
+    public static LocalizationKey GAMEPLAY_CHOOSE_ONE = CreateKey("GAMEPLAY_CHOOSE_ONE");
+    public static LocalizationKey GAMEPLAY_N_SECONDS_REMAINING = CreateKey("ACCESSIBILITY_GAMEPLAY_N_SECONDS_REMAINING");
+    public static LocalizationKey GAMEPLAY_VS_PLAYER_ANNOUNCEMENT = CreateKey("ACCESSIBILITY_GAMEPLAY_VS_PLAYER_ANNOUNCEMENT");
+
+    // Gameplay read zones
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_COUNT = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_COUNT");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_NO_VALID_PLAYS = CreateKey("ACCESSIBILITY_GAMEPLAY_NO_VALID_PLAYS");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_OVERLOADED_MANA = CreateKey("GAMEPLAY_TOOLTIP_MANA_OVERLOAD_DESCRIPTION");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_LOCKED_MANA = CreateKey("GAMEPLAY_TOOLTIP_MANA_LOCKED_DESCRIPTION");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA = CreateKey("GAMEPLAY_TOOLTIP_ENEMYOVERLOAD_DESC");
+
+    // Gameplay game over
+    public static LocalizationKey GAMEPLAY_GAME_OVER_WON = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_WON");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_LOST = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_LOST");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_TIED = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_TIED");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_GENERIC");
+
+    // Gameplay zones
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HERO = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HERO");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HERO = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HERO");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_WEAPON");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_WEAPON");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_MINIONS");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_SECRETS");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_SECRETS");
+
+    // Gameplay diff zones
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD");
+
+    // Gameplay entity diffs
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_DIED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_DIED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED");
+    public static LocalizationKey GAMEPLAY_DIFF_WEAPON_BROKE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_WEAPON_BROKE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_TRANSFORMED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_TRANSFORMED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_DURABILITY = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_DURABILITY");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_ATTACK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_ATTACK");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_ARMOR = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_ARMOR");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_WAS_CURSED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_WAS_CURSED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_CURSED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_CURSED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_GAINED_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_GAINED_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_LOST_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_LOST_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS");
+
+    // Speeches
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT");
+
+    // Gameplay entity naming
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES");
+
+    // Gameplay entity groups
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_EVERYONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_EVERYONE");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ALL_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ALL_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_BOTH_HEROES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_BOTH_HEROES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ENEMIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ENEMIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES");
+
+    // Gameplay movements
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC");
+
+    // Gameplay movements continued
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT");
+
+    // Gameplay spell damage
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE");
+
+    // Gameplay mana crystals
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_MANA");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_MANA");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS");
+
+    // Gameplay help
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARDS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARDS_HELP");
+    public static LocalizationKey GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_TO_ATTACK_TARGET");
+    public static LocalizationKey GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION");
+    public static LocalizationKey GAMEPLAY_CONFIRM_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_END_TURN_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_VALID_OPTIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_VALID_OPTIONS");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HAND_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_HAND_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_MINIONS_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_MINIONS_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_SECRETS_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_WEAPON_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_WEAPON_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_PLAYER_DECK_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_DECK_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_TOOLTIP_HELP");
+    public static LocalizationKey GAMEPLAY_PLAY_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAY_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_TRADE_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_TRADE_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_SUMMON_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMON_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_CHOICE_MODE_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOICE_MODE_HELP");
+    public static LocalizationKey GAMEPLAY_CHOOSE_TARGET_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET_HELP");
+    public static LocalizationKey GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_USE_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_USE_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_THROUGH_VALID_TARGETS");
+    public static LocalizationKey GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_THIS_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_CANCEL_ATTACK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_ATTACK_HELP");
+    public static LocalizationKey GAMEPLAY_CANCEL_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_HELP");
+    public static LocalizationKey GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP");
+    public static LocalizationKey GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_OPEN_HISTORY_LOG_HELP");
+    public static LocalizationKey GAMEPLAY_READ_HISTORY_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_HISTORY_HELP");
+    public static LocalizationKey GAMEPLAY_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_END_TURN_HELP");
+
+    // Gameplay History Log
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_EMPTY");
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT");
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_CLOSE = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_CLOSE");
+
+    // Gameplay special events
+    public static LocalizationKey GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD"); // See BoH Jaina 6
+    public static LocalizationKey GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD"); // See BoH Rexxar 3
+
+    // Mulligan
+    public static LocalizationKey GAMEPLAY_MULLIGAN_WILL_BE_REPLACED = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_WILL_BE_REPLACED");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED");
+    public static LocalizationKey GAMEPLAY_MULLIGAN = CreateKey("GAMEPLAY_MULLIGAN_STARTING_HAND");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS = CreateKey("GAMEPLAY_MULLIGAN_SUBTITLE");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_HELP");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START");
+
+    // Battlegrounds
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_CARD_PREMIUM_GOLDEN = CreateKey("GLUE_MASS_DISENCHANT_PREMIUM_TITLE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE = CreateKey("GLUE_BACON_INFO_POPUP_RECRUIT");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE = CreateKey("GLUE_BACON_INFO_POPUP_COMBAT");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE_START_DESCRIBE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE_START_DESCRIBE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_INCLUDE_ARMOR = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_INCLUDE_ARMOR");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_AGAINST_DEAD_PLAYER = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_AGAINST_DEAD_PLAYER");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_CURRENT_AND_TOTAL = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_CURRENT_AND_TOTAL");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_REMAINING_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_REMAINING_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_ZONE_MINIONS_FOR_SALE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_ZONE_MINIONS_FOR_SALE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_SEE_ZONE_MINIONS_FOR_SALE_EMPTY = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_SEE_ZONE_MINIONS_FOR_SALE_EMPTY");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_BUY_MINION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_BUY_MINION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_SELL_MINION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_SELL_MINION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN_FOR_N_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN_FOR_N_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_UNFREEZE_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_UNFREEZE_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_REFRESH_TAVERN_FOR_N_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_REFRESH_TAVERN_FOR_N_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_UPGRADE_TAVERN_FOR_N_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_UPGRADE_TAVERN_FOR_N_GOLD");
+
+    // Battlegrounds cont'd
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_LAST_POSITION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_LAST_POSITION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_FIRST_POSITION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_FIRST_POSITION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_BETWEEN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_BETWEEN");
+
+    // Battlegrounds in-game stats
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARD_STATS_PLAYER_TRIPLES_CREATED = CreateKey("GLUE_BACON_STATS_LABEL_TRIPLES");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_DEALT_DAMAGE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_DEALT_DAMAGE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TOOK_DAMAGE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TOOK_DAMAGE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TIED = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TIED");
+
+    // Battlegrounds diffs
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_HAND = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_HAND");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_HAND = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_HAND");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_MINIONS = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_MINIONS");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_OTHER_BARTENDER_MINIONS = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_OTHER_BARTENDER_MINIONS");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_SAME_NAME_ENTITIES");
+
+    // Battlegrounds cont'd
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_PLAYER_WON = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_PLAYER_WON");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_OPPONENT_WON = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_OPPONENT_WON");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_DIED = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_DIED");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_REMAINING = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_REMAINING");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_BUDDY_METER = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_BUDDY_METER");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_ZONE_HERO_BUDDY = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_ZONE_HERO_BUDDY");
+
+    // Battlegrounds help messages
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_TAVERN_INFORMATION_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_TAVERN_INFORMATION_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_HERO_BUDDY_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_HERO_BUDDY_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_NEXT_OPPONENT_STATS_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_NEXT_OPPONENT_STATS_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_LEADERBOARD_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_LEADERBOARD_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_MY_STATS_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_MY_STATS_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_RACES_IN_GAME_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_RACES_IN_GAME_HELP");
+
+    // UI
+    public static LocalizationKey UI_POPUP = CreateKey("ACCESSIBILITY_UI_POPUP");
+    public static LocalizationKey UI_REWARDS_TITLE = CreateKey("ACCESSIBILITY_UI_REWARDS_TITLE");
+    public static LocalizationKey UI_UNKNOWN_POPUP = CreateKey("ACCESSIBILITY_UI_UNKNOWN_POPUP");
+    public static LocalizationKey UI_UNKNOWN_DIALOG = CreateKey("ACCESSIBILITY_UI_UNKNOWN_DIALOG");
+
+    // Alert Popup
+    public static LocalizationKey UI_ALERT_POPUP_TITLE = CreateKey("ACCESSIBILITY_UI_ALERT_POPUP_TITLE");
+
+    // Core Set Popup
+    public static LocalizationKey UI_CORE_SET_POPUP_HEADER = CreateKey("GLUE_CORE_SET_POPUP_HEADER");
+    public static LocalizationKey UI_CORE_SET_POPUP_SUBHEADER = CreateKey("GLUE_CORE_SET_POPUP_SUBHEADER");
+
+    // Standard format Popup
+    public static LocalizationKey UI_STANDARD_FORMAT_POPUP_TEXT = CreateKey("GLUE_STANDARD_COMING_SOON_BODY");
+
+    // Reward scroll
+    public static LocalizationKey UI_REWARD_SCROLL_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_SCROLL_HELP");
+
+    // Quest notification popup
+    public static LocalizationKey UI_QUEST_NOTIFICATION_POPUP_HELP = CreateKey("ACCESSIBILITY_UI_QUEST_NOTIFICATION_POPUP_HELP");
+
+    // Welcome quests
+    public static LocalizationKey UI_WELCOME_QUESTS_HELP = CreateKey("ACCESSIBILITY_UI_WELCOME_QUESTS_HELP");
+
+    // Reward
+    public static LocalizationKey UI_REWARD_TITLE = CreateKey("ACCESSIBILITY_UI_REWARD_TITLE");
+    public static LocalizationKey UI_REWARD_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_HELP");
+
+    // Ranked intro popup
+    public static LocalizationKey UI_RANKED_INTRO_POPUP = CreateKey("ACCESSIBILITY_UI_RANKED_INTRO_POPUP");
+
+    // Ranked bonus stars popup
+    public static LocalizationKey UI_RANKED_BONUS_STARS_POPUP = CreateKey("ACCESSIBILITY_UI_RANKED_BONUS_STARS_POPUP");
+
+    // Set rotation rotated boosters popup
+    public static LocalizationKey UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE = CreateKey("GLUE_ROTATED_SETS_DIALOG");
+
+    // Reconnect helper dialog
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECTING = CreateKey("GLOBAL_RECONNECT_RECONNECTING_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_TITLE = CreateKey("ACCESSIBILITY_UI_RECONNECT_HELPER_DIALOG_TITLE");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_OFFLINE = CreateKey("GLUE_RECONNECT_HELPER_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED = CreateKey("GLUE_RECONNECT_HELPER_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED = CreateKey("GLUE_RECONNECT_HELPER_FAILED_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_NO_INTERNET = CreateKey("GLUE_RECONNECT_HELPER_ACCESS_DISABLED_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER = CreateKey("GLUE_RECONNECT_HELPER_BAD_VERSION_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY = CreateKey("GLUE_RECONNECT_HELPER_BAD_VERSION_RESET_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT = CreateKey("GLUE_RECONNECT_HELPER_INACTIVE_TIMEOUT_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED = CreateKey("GLUE_RECONNECT_HELPER_RESET_REQUIRED_BODY");
+
+    // Season end dialog
+    public static LocalizationKey UI_SEASON_END_DIALOG_RANK_EARNED = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_RANK_EARNED");
+    public static LocalizationKey UI_SEASON_END_DIALOG_CHEST_EARNED = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_CHEST_EARNED");
+    public static LocalizationKey UI_SEASON_END_DIALOG_CHEST_EARNED_HELP = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_CHEST_EARNED_HELP");
+    public static LocalizationKey UI_SEASON_END_DIALOG_SEASON_WELCOME = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_SEASON_WELCOME");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REDUCED_WELCOME = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REDUCED_WELCOME");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REMINDER_CHEST = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REMINDER_CHEST");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REMINDER_CARDBACK = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REMINDER_CARDBACK");
+
+    // Card list popup
+    public static LocalizationKey UI_CARD_LIST_POPUP_HELP = CreateKey("ACCESSIBILITY_UI_CARD_LIST_POPUP_HELP");
+
+    // Chest reward display
+    public static LocalizationKey UI_CHEST_REWARD_DISPLAY_TITLE = CreateKey("ACCESSIBILITY_UI_CHEST_REWARD_DISPLAY_TITLE");
+    public static LocalizationKey UI_CHEST_REWARD_DISPLAY_HELP = CreateKey("ACCESSIBILITY_UI_CHEST_REWARD_DISPLAY_HELP");
+
+    // Reward boxes display
+    public static LocalizationKey UI_REWARD_BOXES_DISPLAY_TITLE = CreateKey("ACCESSIBILITY_UI_REWARD_BOXES_DISPLAY_TITLE");
+    public static LocalizationKey UI_REWARD_BOXES_DISPLAY_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_BOXES_DISPLAY_HELP");
+
+    // Quests (via AccessibleQuest)
+    public static LocalizationKey UI_QUEST_NO_NAME_XP_ONLY = CreateKey("ACCESSIBILITY_UI_QUEST_NO_NAME_XP_ONLY");
+    public static LocalizationKey UI_QUEST_REWARD_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_QUEST_REWARD_DESCRIPTION");
+    public static LocalizationKey UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION");
+
+    // Quest log
+    public static LocalizationKey UI_QUEST_LOG_NO_QUESTS = CreateKey("ACCESSIBILITY_UI_QUEST_LOG_NO_QUESTS");
+    public static LocalizationKey UI_QUEST_LOG_ABANDON_QUEST = CreateKey("ACCESSIBILITY_UI_QUEST_LOG_ABANDON_QUEST");
+    public static LocalizationKey UI_QUEST_LOG_REROLL_QUEST = CreateKey("ACCESSIBILITY_UI_QUEST_LOG_REROLL_QUEST");
+
+    // Rewards track XP gains
+    public static LocalizationKey UI_TRACK_REWARD_LEVEL_UP = CreateKey("ACCESSIBILITY_UI_TRACK_REWARD_LEVEL_UP");
+    public static LocalizationKey UI_TRACK_REWARD_XP_GAIN = CreateKey("ACCESSIBILITY_UI_TRACK_REWARD_XP_GAIN");
+    public static LocalizationKey UI_TRACK_REWARD_XP_GAIN_FROM_QUEST = CreateKey("ACCESSIBILITY_UI_TRACK_REWARD_XP_GAIN_FROM_QUEST");
+
+    // Rank changes
+    public static LocalizationKey UI_RANK_CHANGE_UI_CURRENT_RANK = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_CURRENT_RANK");
+    public static LocalizationKey UI_RANK_CHANGE_UI_NEW_RANK = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_NEW_RANK");
+    public static LocalizationKey UI_RANK_CHANGE_UI_CURRENT_STARS = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_CURRENT_STARS");
+    public static LocalizationKey UI_RANK_CHANGE_UI_EARNED_STARS = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_EARNED_STARS");
+    public static LocalizationKey UI_RANK_CHANGE_UI_LOST_STARS = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_LOST_STARS");
+    public static LocalizationKey UI_RANK_CHANGE_UI_STAR_BONUS_MULT = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_STAR_BONUS_MULT");
+    public static LocalizationKey UI_RANK_CHANGE_UI_WIN_STREAK_MULT = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_WIN_STREAK_MULT");
+
+    // Battlegrounds UI stuff
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_CHANGE_INCREASED = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_CHANGE_INCREASED");
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_CHANGE_DECREASED = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_CHANGE_DECREASED");
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_CHANGE_NEW_RATING = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_CHANGE_NEW_RATING");
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_NO_CHANGE = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_NO_CHANGE");
+    public static LocalizationKey UI_BATTLEGROUNDS_MULLIGAN_PLAYERS_READY = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_MULLIGAN_PLAYERS_READY");
+
+    // Rewards
+    public static LocalizationKey UI_REWARD_TYPE_REWARD_PACKAGE = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_REWARD_PACKAGE");
+    public static LocalizationKey UI_REWARD_TYPE_ARCANE_DUST = CreateKey("GLUE_CRAFTING_ARCANEDUST");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD_PACK = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD_PACK");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD_BACK = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD_BACK");
+    public static LocalizationKey UI_REWARD_TYPE_GOLD = CreateKey("GLUE_TOOLTIP_GOLD_HEADER");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_MOUNT = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_MOUNT");
+    public static LocalizationKey UI_REWARD_TYPE_ARCANE_ORBS = CreateKey("GLUE_TOOLTIP_BOOSTER_CURRENCY_HEADER");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_MINI_SET = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_MINI_SET");
+    public static LocalizationKey UI_REWARD_TYPE_UNKNOWN = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_UNKNOWN");
+    public static LocalizationKey UI_REWARD_N_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_TICKETS");
+    public static LocalizationKey UI_REWARD_MINI_SET_WITH_N_CARDS = CreateKey("ACCESSIBILITY_UI_REWARD_MINI_SET_WITH_N_CARDS");
+    public static LocalizationKey UI_REWARD_N_ARCANE_ORBS = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARCANE_ORBS");
+    public static LocalizationKey UI_REWARD_N_ARCANE_DUST = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARCANE_DUST");
+    public static LocalizationKey UI_REWARD_N_CARD_PACKS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CARD_PACKS");
+    public static LocalizationKey UI_REWARD_N_GOLD = CreateKey("ACCESSIBILITY_UI_REWARD_N_GOLD");
+    public static LocalizationKey UI_REWARD_CARD_FROM_CLASS = CreateKey("ACCESSIBILITY_UI_REWARD_CARD_FROM_CLASS");
+    public static LocalizationKey UI_REWARD_CORE_CARD_FROM_CLASS = CreateKey("ACCESSIBILITY_UI_REWARD_CORE_CARD_FROM_CLASS");
+    public static LocalizationKey UI_REWARD_GOLDEN_HERO = CreateKey("ACCESSIBILITY_UI_REWARD_GOLDEN_HERO");
+    public static LocalizationKey UI_REWARD_CLASS_HERO = CreateKey("ACCESSIBILITY_UI_REWARD_CLASS_HERO");
+    public static LocalizationKey UI_REWARD_CLASS_UNLOCK_PROGRESS = CreateKey("ACCESSIBILITY_UI_REWARD_CLASS_UNLOCK_PROGRESS");
+    public static LocalizationKey UI_REWARD_NEW_CLASS_UNLOCKED = CreateKey("GLUE_CLASS_UNLOCKED_CLASS");
+    public static LocalizationKey UI_REWARD_CARD = CreateKey("ACCESSIBILITY_UI_REWARD_CARD");
+    public static LocalizationKey UI_REWARD_N_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_HERO_SKINS");
+    public static LocalizationKey UI_REWARD_N_CARD_BACKS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CARD_BACKS");
+    public static LocalizationKey UI_REWARD_N_ARENA_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARENA_TICKETS");
+    public static LocalizationKey UI_REWARD_N_RUNESTONES = CreateKey("ACCESSIBILITY_UI_REWARD_N_RUNESTONES");
+    public static LocalizationKey UI_REWARD_N_ADVENTURES = CreateKey("ACCESSIBILITY_UI_REWARD_N_ADVENTURES");
+    public static LocalizationKey UI_REWARD_N_TAVERN_BRAWL_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_TAVERN_BRAWL_TICKETS");
+    public static LocalizationKey UI_REWARD_N_CUSTOM_COINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CUSTOM_COINS");
+    public static LocalizationKey UI_REWARD_XP_BOOST = CreateKey("ACCESSIBILITY_UI_REWARD_XP_BOOST");
+    public static LocalizationKey UI_REWARD_N_MINI_SETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_MINI_SETS");
+    public static LocalizationKey UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS");
+    public static LocalizationKey UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS");
+
+    // Choose free deck UI
+    public static LocalizationKey UI_CHOOSE_FREE_DECK_TITLE = CreateKey("GLUE_FREE_DECK_POPUP_TITLE");
+
+    // Social
+    public static LocalizationKey UI_SOCIAL_MENU_NAME = CreateKey("ACCESSIBILITY_UI_SOCIAL_MENU_NAME");
+    public static LocalizationKey UI_SOCIAL_BATTLETAG_COPIED_TO_CLIPBOARD = CreateKey("ACCESSIBILITY_UI_SOCIAL_BATTLETAG_COPIED_TO_CLIPBOARD");
+    public static LocalizationKey UI_SOCIAL_CHAT_MESSAGE_RECEIVED = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_MESSAGE_RECEIVED");
+    public static LocalizationKey UI_SOCIAL_CHAT_MESSAGE_SENT = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_MESSAGE_SENT");
+    public static LocalizationKey UI_SOCIAL_CHAT_SEND_MESSAGE = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_SEND_MESSAGE");
+    public static LocalizationKey UI_SOCIAL_CHAT_TYPE_MESSAGE_PROMPT = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_TYPE_MESSAGE_PROMPT");
+
+    // Rewards Track
+    public static LocalizationKey UI_REWARDS_TRACK_READ_LEVEL = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_READ_LEVEL");
+    public static LocalizationKey UI_REWARDS_TRACK_CLAIM_REWARDS = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_CLAIM_REWARDS");
+    public static LocalizationKey UI_REWARDS_TRACK_CLAIM_REWARDS_NO_REWARDS = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_CLAIM_REWARDS_NO_REWARDS");
+
+    // Shop
+    public static LocalizationKey UI_SHOP_READ_GOLD = CreateKey("ACCESSIBILITY_UI_SHOP_READ_GOLD");
+    public static LocalizationKey UI_SHOP_BUY_PACKS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_PACKS");
+    public static LocalizationKey UI_SHOP_BUY_MINI_SETS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_MINI_SETS");
+    public static LocalizationKey UI_SHOP_BUY_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_HERO_SKINS");
+    public static LocalizationKey UI_SHOP_BUY_BUNDLES = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_BUNDLES");
+    public static LocalizationKey UI_SHOP_BUY_OTHERS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_OTHERS");
+    public static LocalizationKey UI_SHOP_ITEM_READ_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_SHOP_ITEM_READ_DESCRIPTION");
+    public static LocalizationKey UI_SHOP_ITEM_BUY_FOR_N_GOLD = CreateKey("ACCESSIBILITY_UI_SHOP_ITEM_BUY_FOR_N_GOLD");
+    public static LocalizationKey UI_SHOP_ITEM_GET_FOR_FREE = CreateKey("ACCESSIBILITY_UI_SHOP_ITEM_GET_FOR_FREE");
+    public static LocalizationKey UI_SHOP_READ_CARDS = CreateKey("ACCESSIBILITY_UI_SHOP_READ_CARDS");
+    public static LocalizationKey UI_SHOP_READ_CARDS_HELP = CreateKey("ACCESSIBILITY_UI_SHOP_READ_CARDS_HELP");
+    public static LocalizationKey UI_SHOP_PURCHASE_COMPLETE_GOLD_REMAINING = CreateKey("ACCESSIBILITY_UI_SHOP_PURCHASE_COMPLETE_GOLD_REMAINING");
+
+    // Screens
+    public static LocalizationKey SCREEN_GO_BACK = CreateKey("ACCESSIBILITY_SCREEN_GO_BACK");
+
+    // Fatal error screen
+    public static LocalizationKey SCREEN_FATAL_ERROR_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_FATAL_ERROR_SCREEN_TITLE");
+
+    // End game screen
+    public static LocalizationKey SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP = CreateKey("ACCESSIBILITY_SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP");
+
+    // Coose adventurer screen
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP");
+
+    // Adventure screen
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE = CreateKey("GLUE_CHOOSE_YOUR_HERO");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE");
+
+    // Choose adventure screen
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION = CreateKey("GLUE_PRACTICE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED");
+
+    // Choose opponent menu
+    public static LocalizationKey SCREEN_CHOOSE_OPPONENT_MENU_TITLE = CreateKey("GLUE_CHOOSE_OPPONENT");
+    public static LocalizationKey SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL");
+
+    // Choose deck screen
+    public static LocalizationKey SCREEN_CHOOSE_DECK_TITLE = CreateKey("GLUE_CHOOSE_YOUR_DECK");
+    public static LocalizationKey SCREEN_CHOOSE_DECK_HERO_LEVEL = CreateKey("GLOBAL_PROGRESSION_TOOLTIP_CLASS_DEFAULT_DESC");
+
+    // My collection screen
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_MY_DECKS = CreateKey("GLUE_COLLECTION_MY_DECKS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_NEW_DECK = CreateKey("GLUE_COLLECTION_NEW_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_DELETE_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_DELETE_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION = CreateKey("GLUE_COLLECTION_DECK_RENAME");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_COPY_DECK_OPTION = CreateKey("GLUE_COLLECTION_DECK_COPY_TOOLTIP_HEADLINE");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM = CreateKey("GLUE_COLLECTION_PAGE_NUM");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_COLLECTION_FILTERS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_COLLECTION_FILTERS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_COINS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_COINS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_CARD_BACKS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_CARD_BACKS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_HERO_SKINS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_HERO_SKINS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_SEARCH_PROMPT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_SEARCH_PROMPT");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_MANA_FILTER_ON = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_MANA_FILTER_ON");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_MANA_FILTER_OFF = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_MANA_FILTER_OFF");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CHANGE_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CHANGE_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_HERO_SKIN_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_HERO_SKIN_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_CARD_BACK_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_CARD_BACK_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_COIN_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_COIN_SET");
+
+    // Crafting
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARDS = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARDS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_MASS_DISENCHANT_FOR_N_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_MASS_DISENCHANT_FOR_N_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_FOR_N_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_FOR_N_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_CARD_FOR_N_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_CARD_FOR_N_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_NOT_ENOUGH_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_NOT_ENOUGH_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_CARD_LIMIT_REACHED = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_CARD_LIMIT_REACHED");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_DONE = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_DONE");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE");
+
+    // Pack opening screen
+    public static LocalizationKey SCREEN_PACK_OPENING_OPEN_CARDS_HELP = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_OPEN_CARDS_HELP");
+    public static LocalizationKey SCREEN_PACK_OPENING_NO_CARD_PACKS = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_NO_CARD_PACKS");
+
+    // Hearthstone/Play screen
+    public static LocalizationKey SCREEN_HEARTHSTONE_RANKED_READ_RANK = CreateKey("ACCESSIBILITY_SCREEN_HEARTHSTONE_RANKED_READ_RANK");
+    public static LocalizationKey SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STARS = CreateKey("ACCESSIBILITY_SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STARS");
+    public static LocalizationKey SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STAR_BONUS = CreateKey("ACCESSIBILITY_SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STAR_BONUS");
+
+    // Hearthstone (virtual) menu
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_RANKED = CreateKey("GLOBAL_PLAY_RANKED");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_CASUAL = CreateKey("GLUE_PLAY_CASUAL");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_STANDARD = CreateKey("GLOBAL_PLAY_STANDARD");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_WILD = CreateKey("GLOBAL_PLAY_WILD");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_CLASSIC = CreateKey("GLUE_PLAY_CLASSIC");
+
+    // Battlegrounds screen menus
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_READ_STATS = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_READ_STATS");
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_OPTIONS_NARRATE_ATTACKS = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_OPTIONS_NARRATE_ATTACKS");
+
+    // Deck picker generic stuff
+    public static LocalizationKey DECK_PICKER_CLICK_TO_CONVERT = CreateKey("GLUE_COLLECTION_DECK_WILD_LABEL");
+
+    // Quest progress toast
+    public static LocalizationKey TOAST_QUEST_PROGRESS_TOAST_TITLE = CreateKey("ACCESSIBILITY_TOAST_QUEST_PROGRESS_TOAST_TITLE");
+    public static LocalizationKey TOAST_QUEST_PROGRESS_TOAST_PROGRESS = CreateKey("ACCESSIBILITY_TOAST_QUEST_PROGRESS_TOAST_PROGRESS");
+
+    // Quest toast
+    public static LocalizationKey TOAST_QUEST_TOAST_TITLE = CreateKey("ACCESSIBILITY_TOAST_QUEST_TOAST_TITLE");
+
+    // Collectible cards
+    public static LocalizationKey COLLECTION_CARD_NEW = CreateKey("GLUE_COLLECTION_CARD_NEW");
+
+    // Tutorial
+    public static LocalizationKey TUTORIAL_LOADING_TUTORIAL = CreateKey("ACCESSIBILITY_TUTORIAL_LOADING_TUTORIAL");
+    public static LocalizationKey TUTORIAL_WELCOME_BACK = CreateKey("ACCESSIBILITY_TUTORIAL_WELCOME_BACK");
+    public static LocalizationKey TUTORIAL_DEFEATED_HOGGER = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_HOGGER");
+    public static LocalizationKey TUTORIAL_DEFEATED_MILLHOUSE = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_MILLHOUSE");
+    public static LocalizationKey TUTORIAL_DEFEATED_CHO = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_CHO");
+    public static LocalizationKey TUTORIAL_DEFEATED_MUKLA = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_MUKLA");
+    public static LocalizationKey TUTORIAL_DEFEATED_NESINGWARY = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_NESINGWARY");
+    public static LocalizationKey TUTORIAL_DEFEATED_ILLIDAN = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_ILLIDAN");
+    public static LocalizationKey TUTORIAL_NEXT_HOGGER = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_HOGGER");
+    public static LocalizationKey TUTORIAL_NEXT_MILLHOUSE = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_MILLHOUSE");
+    public static LocalizationKey TUTORIAL_NEXT_CHO = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_CHO");
+    public static LocalizationKey TUTORIAL_NEXT_MUKLA = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_MUKLA");
+    public static LocalizationKey TUTORIAL_NEXT_NESINGWARY = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_NESINGWARY");
+    public static LocalizationKey TUTORIAL_NEXT_ILLIDAN = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_ILLIDAN");
+
+    // Tutorial generic narrator speeches
+    public static LocalizationKey TUTORIAL_NARRATOR_INTRO = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO");
+    public static LocalizationKey TUTORIAL_NARRATOR_HELP_KEYS = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_HELP_KEYS");
+    public static LocalizationKey TUTORIAL_NARRATOR_INTRO_END = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO_END");
+    public static LocalizationKey TUTORIAL_FREE_STARTING_PACK = CreateKey("ACCESSIBILITY_TUTORIAL_FREE_STARTING_PACK");
+    public static LocalizationKey TUTORIAL_NICE_WORK = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_WORK");
+    public static LocalizationKey TUTORIAL_NICE_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_JOB");
+    public static LocalizationKey TUTORIAL_NICE_ONE = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_ONE");
+    public static LocalizationKey TUTORIAL_GOOD_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_GOOD_JOB");
+    public static LocalizationKey TUTORIAL_YOU_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_YOU_GOT_IT");
+    public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_IT");
+    public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_THAT");
+    public static LocalizationKey TUTORIAL_TRY_IT_OUT = CreateKey("ACCESSIBILITY_TUTORIAL_TRY_IT_OUT");
+    public static LocalizationKey TUTORIAL_ALL_RIGHT = CreateKey("ACCESSIBILITY_TUTORIAL_ALL_RIGHT");
+    public static LocalizationKey TUTORIAL_LETS_LEARN_HOW = CreateKey("ACCESSIBILITY_TUTORIAL_LETS_LEARN_HOW");
+    public static LocalizationKey TUTORIAL_CAN_YOU_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_CAN_YOU_DO_IT");
+    public static LocalizationKey TUTORIAL_THINK_YOU_CAN_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_THINK_YOU_CAN_DO_IT");
+    public static LocalizationKey TUTORIAL_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_GOT_IT");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN_ATK = CreateKey("TUTORIAL_NO_ENDTURN_ATK");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN = CreateKey("TUTORIAL_NO_ENDTURN");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN_HP = CreateKey("ACCESSIBILITY_TUTORIAL_NO_ENDTURN_HP");
+
+    // Tutorial Hogger
+    public static LocalizationKey TUTORIAL_HOGGER_START = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_START");
+    public static LocalizationKey TUTORIAL01_HELP_07 = CreateKey("TUTORIAL01_HELP_07");
+    public static LocalizationKey TUTORIAL01_HELP_08 = CreateKey("TUTORIAL01_HELP_08");
+    public static LocalizationKey TUTORIAL_HOGGER_FORCE_CARD_READ = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_CARD_READ");
+    public static LocalizationKey TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_SUMMON_MINION_FIRST");
+    public static LocalizationKey TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST");
+    public static LocalizationKey TUTORIAL_HOGGER_2_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_0");
+    public static LocalizationKey TUTORIAL_HOGGER_2_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_1");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2B = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2B");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2D = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2D");
+    public static LocalizationKey TUTORIAL_HOGGER_2_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_3");
+    public static LocalizationKey TUTORIAL_HOGGER_2_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_4");
+    public static LocalizationKey TUTORIAL_HOGGER_2_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_5");
+    public static LocalizationKey TUTORIAL_HOGGER_2_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_6");
+    public static LocalizationKey TUTORIAL_HOGGER_3_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_0");
+    public static LocalizationKey TUTORIAL_HOGGER_3_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_1");
+    public static LocalizationKey TUTORIAL_HOGGER_3_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2");
+    public static LocalizationKey TUTORIAL_HOGGER_3_2_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_3_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_3");
+    public static LocalizationKey TUTORIAL_HOGGER_3_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_4");
+    public static LocalizationKey TUTORIAL_HOGGER_3_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5");
+    public static LocalizationKey TUTORIAL_HOGGER_3_5_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_3_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_6");
+    public static LocalizationKey TUTORIAL_HOGGER_3_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_7");
+    public static LocalizationKey TUTORIAL_HOGGER_4_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1");
+    public static LocalizationKey TUTORIAL_HOGGER_4_1_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_2");
+    public static LocalizationKey TUTORIAL_HOGGER_4_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_4");
+    public static LocalizationKey TUTORIAL_HOGGER_4_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_5");
+    public static LocalizationKey TUTORIAL_HOGGER_4_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6");
+    public static LocalizationKey TUTORIAL_HOGGER_4_6_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_8");
+    public static LocalizationKey TUTORIAL_HOGGER_4_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9");
+    public static LocalizationKey TUTORIAL_HOGGER_4_9_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_10");
+    public static LocalizationKey TUTORIAL_HOGGER_4_11 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11");
+    public static LocalizationKey TUTORIAL_HOGGER_4_11_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_12");
+    public static LocalizationKey TUTORIAL_HOGGER_4_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13");
+    public static LocalizationKey TUTORIAL_HOGGER_4_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_16");
+    public static LocalizationKey TUTORIAL_HOGGER_4_17 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_17");
+    public static LocalizationKey TUTORIAL_HOGGER_6_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_1");
+    public static LocalizationKey TUTORIAL_HOGGER_6_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_2");
+    public static LocalizationKey TUTORIAL_HOGGER_6_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_3");
+    public static LocalizationKey TUTORIAL_HOGGER_6_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_4");
+    public static LocalizationKey TUTORIAL_HOGGER_6_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_5");
+    public static LocalizationKey TUTORIAL_HOGGER_6_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_6");
+    public static LocalizationKey TUTORIAL_HOGGER_6_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_7");
+    public static LocalizationKey TUTORIAL_HOGGER_6_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_8");
+    public static LocalizationKey TUTORIAL_HOGGER_6_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_9");
+    public static LocalizationKey TUTORIAL_HOGGER_6_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_10");
+    public static LocalizationKey TUTORIAL_HOGGER_6_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12");
+    public static LocalizationKey TUTORIAL_HOGGER_6_12_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13");
+    public static LocalizationKey TUTORIAL_HOGGER_6_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_14 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_14");
+    public static LocalizationKey TUTORIAL_HOGGER_6_15 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_15");
+    public static LocalizationKey TUTORIAL_HOGGER_6_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16");
+    public static LocalizationKey TUTORIAL_HOGGER_6_16_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_21 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_21");
+    public static LocalizationKey TUTORIAL_HOGGER_8_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_8_1");
+
+    // Tutorial Millhouse Manastorm
+    public static LocalizationKey TUTORIAL02_HELP_01 = CreateKey("TUTORIAL02_HELP_01");
+    public static LocalizationKey TUTORIAL02_HELP_03 = CreateKey("TUTORIAL02_HELP_03");
+    public static LocalizationKey TUTORIAL02_HELP_06 = CreateKey("TUTORIAL02_HELP_06");
+    public static LocalizationKey TUTORIAL02_HELP_07 = CreateKey("TUTORIAL02_HELP_07");
+    public static LocalizationKey TUTORIAL_RAID_LEADER_DESCRIPTION = CreateKey("TUTORIAL_RAID_LEADER_DESCRIPTION");
+    public static LocalizationKey TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateKey("TUTORIAL_ARCANE_INTELLECT_DESCRIPTION");
+    public static LocalizationKey TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MILLHOUSE_SEE_MANA_HELP");
+    public static LocalizationKey TUTORIAL06_HELP_03 = CreateKey("TUTORIAL06_HELP_03");
+
+    // Tutorial Lorewalker Cho
+    public static LocalizationKey TUTORIAL_CHO_1 = CreateKey("ACCESSIBILITY_TUTORIAL_CHO_1");
+    public static LocalizationKey TUTORIAL06_HELP_02 = CreateKey("ACCESSIBILITY_TUTORIAL06_HELP_02");
+    public static LocalizationKey TUTORIAL06_HELP_04 = CreateKey("TUTORIAL06_HELP_04");
+
+    // Tutorial King Mukla
+    public static LocalizationKey TUTORIAL_MUKLA_START = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START");
+    public static LocalizationKey TUTORIAL_MUKLA_START_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_B");
+    public static LocalizationKey TUTORIAL_MUKLA_START_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_C");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_B");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_C");
+    public static LocalizationKey TUTORIAL04_HELP_14 = CreateKey("TUTORIAL04_HELP_14");
+    public static LocalizationKey TUTORIAL04_HELP_15 = CreateKey("TUTORIAL04_HELP_15");
+    public static LocalizationKey TUTORIAL04_HELP_16 = CreateKey("TUTORIAL04_HELP_16");
+    public static LocalizationKey TUTORIAL04_HELP_02 = CreateKey("TUTORIAL04_HELP_02");
+    public static LocalizationKey TUTORIAL04_HELP_03 = CreateKey("TUTORIAL04_HELP_03");
+
+    // Tutorial Hemet Nesingwary
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP");
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_B");
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_C");
+
+    // Tutorial Illidan Stormrage
+    public static LocalizationKey TUTORIAL05_HELP_03 = CreateKey("TUTORIAL05_HELP_03");
+    public static LocalizationKey TUTORIAL05_HELP_04 = CreateKey("TUTORIAL05_HELP_04");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B");
+
+    // In-game tutorial first time mulligan
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E");
+
+    // Battlegrounds tutorial
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGBUY_BODY_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGBUY_BODY_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGSELL_BODY_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGSELL_BODY_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_FREEZE_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_FREEZE_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_SUMMON_MINION_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_SUMMON_MINION_HELP");
+
+
+    public string Key { get; private set; }
+
+    private LocalizationKey(string key)
+    {
+        Key = key;
+    }
+
+    private static List<LocalizationKey> s_keys;
+    private static Dictionary<string, LocalizationKey> s_keyDict;
+
+    private static LocalizationKey CreateKey(string key)
+    {
+        if (key == null)
+        {
+            throw new ArgumentException($"Invoked CreateKey in an invalid context");
+        }
+
+        var newKey = new LocalizationKey(key);
+        if (s_keys == null)
+        {
+            s_keys = new List<LocalizationKey>();
+        }
+
+        if (s_keyDict == null)
+        {
+            s_keyDict = new Dictionary<string, LocalizationKey>();
+        }
+
+        if (s_keyDict.ContainsKey(key))
+        {
+            throw new ArgumentException($"Fatal error initializing localization keys. Found duplicate key: {key}");
+        }
+
+        s_keys.Add(newKey);
+        s_keyDict.Add(key, newKey);
+
+        return newKey;
+    }
+
+    public static List<LocalizationKey> GetAllKeys()
+    {
+        return s_keys;
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs
new file mode 100644
index 0000000..a7d8e6a
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs
@@ -0,0 +1,130 @@
+﻿using Accessibility;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+public class LocalizationUtils
+{
+    private static Dictionary<int, LocalizationKey> ORDERS = new Dictionary<int, LocalizationKey>
+    {
+        [1] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_1,
+        [2] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_2,
+        [3] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_3,
+        [4] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_4,
+        [5] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_5,
+        [6] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_6,
+        [7] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_7,
+        [8] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_8,
+        [9] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_9,
+        [10] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_10,
+    };
+
+    internal static bool HasKey(LocalizationKey key)
+    {
+        // Used to enable/disable narration in the tutorial
+        // The narrator will only disappear if a particular key hasn't been localized
+        // Note that we cannot default here
+        return GameStrings.HasKey(key.Key);
+    }
+
+    public static string Get(LocalizationKey key)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.Get(key.Key);
+        }
+        else
+        {
+            return DefaultGameStrings.Get(key.Key);
+        }
+    }
+
+    public static string Format(LocalizationKey key, params object[] args)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.Format(key.Key, args);
+        }
+        else
+        {
+            return DefaultGameStrings.Format(key.Key, args);
+        }
+    }
+
+    public static string FormatPlurals(LocalizationKey key, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.FormatPlurals(key.Key, pluralNumbers, args);
+        }
+        else
+        {
+            return DefaultGameStrings.FormatPlurals(key.Key, pluralNumbers, args);
+        }
+    }
+
+    public static bool HasOverrideForKey(KeyCode keyCode)
+    {
+        var stringsKey = GetKeyOverrideLocalizationKey(keyCode);
+        return GameStrings.HasKey(stringsKey);
+    }
+
+    public static string GetOverrideForKey(KeyCode keyCode)
+    {
+        var stringsKey = GetKeyOverrideLocalizationKey(keyCode);
+
+        if (GameStrings.HasKey(stringsKey))
+        {
+            return GameStrings.Get(stringsKey);
+        }
+        else
+        {
+            return DefaultGameStrings.Get(stringsKey);
+        }
+    }
+
+    private static string GetKeyOverrideLocalizationKey(KeyCode keyCode)
+    {
+        var keyCodeStr = keyCode.ToString();
+        return String.Format(LocalizationKey.INPUT_KEY_OVERRIDE_FORMAT, keyCodeStr);
+    }
+
+    public static string GetPeriod()
+    {
+        return Get(LocalizationKey.FORMATTING_PERIOD);
+    }
+
+    public static string GetSentenceEndingCharacters()
+    {
+        return Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+    }
+
+    public static string GetOrdinalNumber(int num)
+    {
+        if (num >= 1 && num <= 10 && GameStrings.HasKey(ORDERS[num].Key)) // Simply default to a normal digit representation for non-translated locales
+        {
+            return Get(ORDERS[num]);
+        }
+
+        return $"{num}";
+    }
+
+    public static bool IsOrdinalNumber(string text)
+    {
+        return GetOrdinalNumbers().Contains(text);
+    }
+    private static List<string> GetOrdinalNumbers()
+    {
+        var ret = new List<string>();
+
+        foreach (var entry in ORDERS)
+        {
+            ret.Add(GetOrdinalNumber(entry.Key));
+        }
+
+        return ret;
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs
new file mode 100644
index 0000000..f23f414
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs
@@ -0,0 +1,72 @@
+﻿using Accessibility;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+class LocalizedText
+{
+    // Menus
+    public static string GAME_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.MENU_GAME_MENU_TITLE);
+    public static string OPTIONS_MENU_ADJUST_VOLUME => LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ADJUST_VOLUME);
+    public static string MENU_NO_ITEMS => LocalizationUtils.Get(LocalizationKey.MENU_NO_ITEMS);
+
+    // Hub
+    public static string HUB_MAIN_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.HUB_MAIN_MENU_TITLE);
+    public static string HUB_BATTLEGROUNDS_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLEGROUNDS);
+    public static string HUB_GAME_MODES_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_MODES);
+    public static string HUB_MY_COLLECTION_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION);
+    public static string HUB_HELP_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_HELP);
+
+    // Modes
+    public static string MODES_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE);
+    public static string MODES_SOLO_ADVENTURES_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_SOLO_ADVENTURES);
+
+    // Global
+    public static string GLOBAL_GAME_LOADED => LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_LOADED);
+    public static string GLOBAL_LOADING => LocalizationUtils.Get(LocalizationKey.GLOBAL_LOADING);
+    public static string GLOBAL_PLEASE_WAIT => LocalizationUtils.Get(LocalizationKey.GLOBAL_PLEASE_WAIT);
+    public static string GLOBAL_CARD => LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+    public static string GLOBAL_CARD_PLURAL => LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD_PLURAL);
+    public static string GLOBAL_RECONNECTED => LocalizationUtils.Get(LocalizationKey.GLOBAL_RECONNECTED);
+    public static string GLOBAL_OPTIONS => LocalizationUtils.Get(LocalizationKey.GLOBAL_OPTIONS);
+    public static string GLOBAL_PRESS_ENTER_TO_CONFIRM_OR_BACKSPACE_TO_CANCEL => AccessibleSpeech.TUTORIAL_HOGGER_2_5.GetLocalizedText();
+
+    // Global keywords
+    public static string GLOBAL_TAUNT => LocalizationUtils.Get(LocalizationKey.GLOBAL_TAUNT);
+    public static string GLOBAL_DEATHRATTLE => LocalizationUtils.Get(LocalizationKey.GLOBAL_DEATHRATTLE);
+    public static string GLOBAL_BATTLECRY => LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLECRY);
+    public static string GLOBAL_CHARGE => LocalizationUtils.Get(LocalizationKey.GLOBAL_CHARGE);
+    public static string GLOBAL_LIFESTEAL => LocalizationUtils.Get(LocalizationKey.GLOBAL_LIFESTEAL);
+    public static string GLOBAL_RUSH => LocalizationUtils.Get(LocalizationKey.GLOBAL_RUSH);
+    public static string GLOBAL_WINDFURY => LocalizationUtils.Get(LocalizationKey.GLOBAL_WINDFURY);
+    public static string GLOBAL_DIVINE_SHIELD => LocalizationUtils.Get(LocalizationKey.GLOBAL_DIVINE_SHIELD);
+    public static string GLOBAL_FREEZE => LocalizationUtils.Get(LocalizationKey.GLOBAL_FREEZE);
+    public static string GLOBAL_FROZEN => LocalizationUtils.Get(LocalizationKey.GLOBAL_FROZEN);
+    public static string GLOBAL_POISONOUS => LocalizationUtils.Get(LocalizationKey.GLOBAL_POISONOUS);
+    public static string GLOBAL_STEALTH => LocalizationUtils.Get(LocalizationKey.GLOBAL_STEALTH);
+    public static string GLOBAL_IMMUNE => LocalizationUtils.Get(LocalizationKey.GLOBAL_IMMUNE);
+    public static string GLOBAL_DORMANT => LocalizationUtils.Get(LocalizationKey.GLOBAL_DORMANT);
+    public static string GLOBAL_REBORN => LocalizationUtils.Get(LocalizationKey.GLOBAL_REBORN);
+    public static string GLOBAL_ENCHANTMENT => LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT);
+    public static string GLOBAL_SILENCE => LocalizationUtils.Get(LocalizationKey.GLOBAL_SILENCE);
+
+    // Gameplay
+    public static string GAMEPLAY_YOUR_TURN => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOUR_TURN);
+    public static string GAMEPLAY_OPPONENT_TURN => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_TURN);
+    public static string GAMEPLAY_TURN_ENDED => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_TURN_ENDED);
+
+    // UI
+    public static string UI_POPUP => LocalizationUtils.Get(LocalizationKey.UI_POPUP);
+    public static string UI_REWARDS_TITLE => LocalizationUtils.Get(LocalizationKey.UI_REWARDS_TITLE);
+
+    // Screens
+    public static string SCREEN_GO_BACK => LocalizationUtils.Get(LocalizationKey.SCREEN_GO_BACK);
+
+    // Collectible cards
+    public static string COLLECTION_CARD_NEW => LocalizationUtils.Get(LocalizationKey.COLLECTION_CARD_NEW).ToLower();
+
+    // Tutorial
+    public static string TUTORIAL_LOADING_TUTORIAL => LocalizationUtils.Get(LocalizationKey.TUTORIAL_LOADING_TUTORIAL);
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs
new file mode 100644
index 0000000..6833ca0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs
@@ -0,0 +1,55 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessiblePackOpeningCard : AccessibleItem
+    {
+        private readonly PackOpeningCard m_card;
+
+        internal AccessiblePackOpeningCard(AccessibleComponent parent, PackOpeningCard card) : base(parent)
+        {
+            m_card = card;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_card.IsRevealed())
+            {
+                return GetLinesForRevealedCard();
+            }
+            else
+            {
+                return GetLinesForHiddenCard();
+            }
+        }
+
+        private List<string> GetLinesForRevealedCard()
+        {
+            var ret = new List<string>();
+
+            ret.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_card.GetEntityDef(), m_card.m_premium, m_card.GetClassName()));
+
+            if (m_card.m_isNew)
+            {
+                ret.Add(LocalizedText.COLLECTION_CARD_NEW);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForHiddenCard()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD));
+
+            return ret;
+        }
+
+        public PackOpeningCard GetPackOpeningCard()
+        {
+            return m_card;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs
new file mode 100644
index 0000000..eef8e5e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs
@@ -0,0 +1,52 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleUnopenedPack : AccessibleItem
+    {
+        private readonly UnopenedPack m_pack;
+
+        internal AccessibleUnopenedPack(AccessibleComponent parent, UnopenedPack pack) : base(parent)
+        {
+            m_pack = pack;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, m_pack.GetCount()));
+
+            AccessibleCardUtils.AddLineIfExists(GetLockedRibbonText(), ret);
+            AccessibleCardUtils.AddLineIfExists(GetPackName(), ret);
+
+            return ret;
+        }
+
+        public string GetLockedRibbonText()
+        {
+            if (m_pack.CanOpenPack())
+            {
+                return null;
+            }
+
+            return m_pack.m_LockedRibbonText?.Text;
+        }
+
+        private string GetPackName()
+        {
+            return AccessibleCardUtils.GetCardPackName(m_pack.GetBoosterId());
+        }
+
+        public bool IsLocked()
+        {
+            return !m_pack.CanOpenPack();
+        }
+
+        public UnopenedPack GetUnopenedPack()
+        {
+            return m_pack;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs b/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs
new file mode 100644
index 0000000..0f96e9c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs
@@ -0,0 +1,152 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class QueuedText
+    {
+        private string m_text;
+
+        private bool m_playing;
+
+        private Stopwatch m_stopwatch;
+
+        private float m_playTimeMs;
+
+        private Action m_onStart, m_onEnd;
+
+        private bool m_interrupt;
+        private bool m_wait;
+
+        private bool m_narration;
+
+        public QueuedText(string text, Action onStart, Action onEnd, bool interrupt=false, bool wait=true, bool narration=false)
+        {
+            m_wait = wait; // Needs to be set first so we handle all text updates properly
+
+            UpdateText(text);
+            m_stopwatch = new Stopwatch();
+
+            m_onStart = onStart;
+            m_onEnd = onEnd;
+
+            m_interrupt = interrupt;
+
+            m_narration = narration;
+
+            //Log.Accessibility.Print($"SPS New QueuedText({text}) / PlayTime={m_playTimeMs}");
+        }
+
+        internal void UpdateText(string text)
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_text = text;
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        internal void UpdateSpeed()
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        private float EstimatePlayTimeMs()
+        {
+            // Was like this when testing initially vv
+            // Normal english speaking person rate = somewhere between 140~160. 150 seems like a good baseline
+            // Normal characters per word in english is ~4.5/wordl 5 seems like a good rate
+            // So 150WPM * 5Chars = 12.5CPS -> seems like a good baseline
+            // <100WPM is slow. JFK's speech was ~95WPM
+            // 100WPM is 8CPS
+            //int cps = 15; // This assumes 5/word + random spaces/punctuation = 1/word = 150WPM*6/60 = 15 CPS
+
+            //float safetyNet = 500;
+            //float safetyNet = 0;
+
+            if (!m_wait)
+            {
+                // Used for menus, popups, etc
+                return 0;
+            }
+
+            return (m_text.Length) / AccessibilityMgr.GetCPS() * 1000;
+        }
+
+        internal bool IsNarration()
+        {
+            return m_narration;
+        }
+
+        internal void Play()
+        {
+            if (!ScreenReader.Output(m_text, m_interrupt))
+            {
+                // e.g. optimized text which became empty
+                OnStartPlaying();
+                OnEndPlaying();
+            }
+            else
+            {
+                OnStartPlaying();
+            }
+        }
+
+        private void OnStartPlaying()
+        {
+            m_playing = true;
+            m_stopwatch.Start();
+
+            if (m_onStart != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnStartPlaying {m_text}");
+                m_onStart();
+            }
+        }
+
+        internal void Interrupt()
+        {
+            OnEndPlaying();
+        }
+
+        private void OnEndPlaying()
+        {
+            m_playing = false;
+            m_stopwatch.Stop();
+
+            if (m_onEnd != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnEndPlaying {m_text}");
+                m_onEnd();
+            }
+        }
+
+        internal bool IsPlaying()
+        {
+            if (m_stopwatch.ElapsedMilliseconds >= m_playTimeMs)
+            {
+                OnEndPlaying();
+            }
+
+            return m_playing;
+        }
+
+        public string GetText()
+        {
+            return m_text;
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Ranked/AccessibleRankedUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/Ranked/AccessibleRankedUtils.cs
new file mode 100644
index 0000000..6527575
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Ranked/AccessibleRankedUtils.cs
@@ -0,0 +1,106 @@
+﻿using Hearthstone.DataModels;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace Accessibility
+{
+    class AccessibleRankedUtils
+    {
+        public static string GetBestRank(MedalInfoTranslator medalInfo)
+        {
+            if (medalInfo.IsDisplayable())
+            {
+                var sb = new StringBuilder();
+                var bestFormat = medalInfo.GetBestCurrentRankFormatType();
+
+                if (bestFormat != PegasusShared.FormatType.FT_STANDARD)
+                {
+                    sb.Append($"{GameStrings.GetFormatName(bestFormat)} ");
+                }
+
+                var bestMedal = medalInfo.GetCurrentMedal(bestFormat);
+                sb.Append(GetRankText(bestMedal));
+
+                return sb.ToString();
+            }
+
+            return "";
+        }
+
+        public static string GetRankText(TranslatedMedalInfo medalInfo)
+		{
+			var sb = new StringBuilder();
+
+			sb.Append(medalInfo.GetRankName());
+
+			if (medalInfo.IsLegendRank())
+			{
+				sb.Append($" {medalInfo.legendIndex}");
+			}
+
+			return sb.ToString();
+		}
+
+        public static string GetRankStarsText(TranslatedMedalInfo medalInfo)
+		{
+			if (!medalInfo.IsLegendRank())
+			{
+				var earnedStars = medalInfo.earnedStars;
+				var maxStars = medalInfo.RankConfig.Stars;
+
+				return LocalizationUtils.Format(LocalizationKey.SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STARS, earnedStars, maxStars);
+			}
+
+			return null;
+		}
+
+        public static string GetStarBonusText(TranslatedMedalInfo medalInfo)
+		{
+			if (!medalInfo.IsLegendRank() && medalInfo.starsPerWin > 1)
+			{
+				return LocalizationUtils.Format(LocalizationKey.SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STAR_BONUS, medalInfo.starsPerWin);
+			}
+
+			return null;
+		}
+
+		public static bool PlayerHasStandardDecks()
+		{
+			return CollectionManager.Get().GetNumberOfStandardDecks() > 0;
+		}
+
+		public static bool PlayerHasCasualDecks()
+		{
+			// This is highly inefficient but maintainability and less conflicts are more important here
+			var numStandardDecks = CollectionManager.Get().GetNumberOfStandardDecks();
+			var numWildDecks = CollectionManager.Get().GetNumberOfWildDecks();
+			var numClassicDecks = CollectionManager.Get().GetNumberOfClassicDecks();
+
+			var numEligibleDecks = numStandardDecks + numWildDecks + numClassicDecks;
+
+			return numEligibleDecks > 0;
+		}
+
+		public static bool PlayerCanPlayWild()
+		{
+			if (!CollectionManager.Get().ShouldAccountSeeStandardWild())
+			{
+				return false;
+			}
+
+			// This is highly inefficient but maintainability and less conflicts are more important here
+			var numStandardDecks = CollectionManager.Get().GetNumberOfStandardDecks();
+			var numWildDecks = CollectionManager.Get().GetNumberOfWildDecks();
+
+			var numEligibleDecks = numStandardDecks + numWildDecks;
+
+			return numEligibleDecks > 0;
+		}
+
+		public static bool PlayerCanPlayClassic()
+		{
+            return CollectionManager.Get().AccountCanSeeClassic() && CollectionManager.Get().GetNumberOfClassicDecks() > 0;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs b/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs
new file mode 100644
index 0000000..7422d75
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs
@@ -0,0 +1,51 @@
+﻿using DavyKager;
+using System;
+using System.IO;
+
+namespace Accessibility
+{
+    class ScreenReader
+    {
+        internal static bool Output(string text, bool interrupt=false)
+        {
+            if (text.Length == 0)
+            {
+                return false;
+            }
+
+            bool success = Tolk.Output(text, interrupt);
+
+            AccessibilityUtils.LogDebug($"Output to screen reader (success={success}): {text}");
+
+            return success;
+        }
+
+        internal static void Load()
+        {
+            // Append accessibility deps (e.g. Tolk, NVDA drivers, etc.) to PATH
+            string path = System.Environment.GetEnvironmentVariable("PATH", System.EnvironmentVariableTarget.Process);
+            string accessibilityAssembliesDir = Path.Combine(Directory.GetCurrentDirectory(), "Hearthstone_Data", "Managed", "Accessibility");
+            path += $";{accessibilityAssembliesDir}";
+            System.Environment.SetEnvironmentVariable("PATH", path, System.EnvironmentVariableTarget.Process);
+
+            // Load Tolk
+            Tolk.TrySAPI(true);
+            Tolk.Load();
+        }
+
+        internal static void Unload()
+        {
+            Tolk.Unload();
+        }
+
+        internal static bool IsUsingSAPI()
+        {
+            return Tolk.DetectScreenReader().Equals("SAPI");
+        }
+
+        internal static void Interrupt()
+        {
+            Tolk.Output("", true);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Shop/AccessibleShopUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/Shop/AccessibleShopUtils.cs
new file mode 100644
index 0000000..56a748c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Shop/AccessibleShopUtils.cs
@@ -0,0 +1,277 @@
+﻿using Hearthstone.DataModels;
+using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+	class AccessibleShopUtils
+	{
+		internal static bool CanProductOrVariantsBeBoughtWithGold(ProductDataModel dataModel)
+		{
+			var prices = dataModel.Prices;
+			var variants = dataModel.Variants;
+
+			if (HasGoldPrice(prices))
+			{
+				return true;
+			}
+
+			if (variants != null)
+			{
+				foreach (var variant in variants)
+				{
+					if (HasGoldPrice(variant.Prices))
+					{
+						return true;
+					}
+				}
+			}
+
+			return false;
+		}
+
+		internal static bool CanVariantBeBoughtWithGold(ProductDataModel dataModel)
+		{
+			var prices = dataModel.Prices;
+
+			return HasGoldPrice(prices);
+		}
+
+		internal static bool CanBeBoughtWithGold(ShopSlot slot)
+		{
+			if (!IsAvailable(slot))
+			{
+				return false;
+			}
+
+			var dataModel = slot.m_productDataModel;
+
+			if (dataModel == null)
+			{
+				return false;
+			}
+
+			return CanProductOrVariantsBeBoughtWithGold(dataModel);
+		}
+
+		internal static List<ShopSlot> FilterSlotsWhichCanBeBoughtWithGold(List<ShopSlot> slots)
+		{
+			var ret = new List<ShopSlot>();
+
+			foreach (var slot in slots)
+			{
+				if (CanBeBoughtWithGold(slot))
+				{
+					ret.Add(slot);
+				}
+			}
+
+			return ret;
+		}
+
+		internal static bool IsCardPackSlot(ShopSlot slot)
+		{
+			return IsSlotWithSingleRewardType(slot, RewardItemType.BOOSTER);
+		}
+
+		internal static bool IsMiniSetSlot(ShopSlot slot)
+		{
+			return IsSlotWithSingleRewardType(slot, RewardItemType.MINI_SET);
+		}
+
+		internal static bool IsHeroSkinSlot(ShopSlot slot)
+		{
+			return IsSlotWithSingleRewardType(slot, RewardItemType.HERO_SKIN);
+		}
+
+		internal static bool IsBundle(ShopSlot slot)
+		{
+			var dataModel = slot.m_productDataModel;
+
+			if (dataModel == null)
+			{
+				return false;
+			}
+
+			var items = dataModel.Items;
+			if (items == null)
+			{
+				return false;
+			}
+
+			return items.Count > 1;
+		}
+
+		internal static string GetBuyForGoldText(ProductDataModel product)
+		{
+			var goldCost = GetGoldCost(product);
+
+			if (goldCost == 0)
+			{
+				return LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_GET_FOR_FREE);
+			}
+			else
+			{
+				return LocalizationUtils.Format(LocalizationKey.UI_SHOP_ITEM_BUY_FOR_N_GOLD, goldCost);
+			}
+		}
+
+		private static bool IsSlotWithSingleRewardType(ShopSlot slot, RewardItemType type)
+		{
+			var dataModel = slot.m_productDataModel;
+
+			if (dataModel == null)
+			{
+				return false;
+			}
+
+			var items = dataModel.Items;
+			if (items == null)
+			{
+				return false;
+			}
+
+			if (items.Count != 1)
+			{
+				return false;
+			}
+
+			return items[0].ItemType == type;
+		}
+
+		internal static bool IsAvailable(ShopSlot slot)
+		{
+			return IsAvailable(slot.m_productDataModel);
+		}
+
+		internal static bool IsAvailable(ProductDataModel dataModel)
+		{
+			return dataModel?.Availability == ProductAvailability.CAN_PURCHASE;
+		}
+
+		private static bool HasGoldPrice(DataModelList<PriceDataModel> prices)
+		{
+			if (prices == null)
+			{
+				return false;
+			}
+
+			foreach (var price in prices)
+			{
+				if (price.Currency == CurrencyType.GOLD)
+				{
+					return true;
+				}
+			}
+
+			return false;
+		}
+
+		internal static List<ProductDataModel> GetVariantsWhichCanBeBoughtWithGold(ProductDataModel product)
+		{
+			var ret = new List<ProductDataModel>();
+
+			foreach (var variant in product.Variants)
+			{
+				if (IsAvailable(variant) && CanVariantBeBoughtWithGold(variant))
+				{
+					ret.Add(variant);
+				}
+			}
+
+			return ret;
+		}
+
+		internal static long GetGoldCost(ProductDataModel variant)
+		{
+			foreach (var price in variant.Prices)
+			{
+				if (price.Currency == CurrencyType.GOLD)
+				{
+					return Mathf.RoundToInt(price.Amount);
+				}
+			}
+
+			return 0;
+		}
+
+		internal static List<string> CreateMultilineDescriptionForVariant(ProductDataModel variant)
+		{
+			var ret = new List<string>();
+
+			AccessibleCardUtils.AddLineIfExists(variant.DescriptionHeader, ret);
+
+			if (variant.Description != null)
+			{
+				var descLines = variant.Description.Split('•');
+
+				if (descLines != null)
+				{
+					foreach (var line in descLines)
+					{
+						if (line.Length > 0)
+						{
+							ret.Add(line);
+						}
+					}
+				}
+			}
+
+			return ret;
+		}
+
+		internal static long GetGoldBalance()
+		{
+			return ShopUtils.GetCachedBalance(CurrencyType.GOLD);
+		}
+
+		internal static bool HasEnoughGoldToBuyVariant(ProductDataModel variant)
+		{
+			var prices = variant.Prices;
+			var curBalance = GetGoldBalance();
+
+			foreach (var price in prices)
+			{
+				if (price.Currency == CurrencyType.GOLD && price.Amount <= curBalance)
+				{
+					return true;
+				}
+			}
+
+			return false;
+		}
+
+		internal static int GetGoldPriceOptionForVariant(ProductDataModel variant)
+		{
+			var prices = variant.Prices;
+			var curBalance = GetGoldBalance();
+
+			for (int i = 0; i < prices.Count; i++)
+			{
+				var price = prices[i];
+
+				if (price.Currency == CurrencyType.GOLD && price.Amount <= curBalance)
+				{
+					return i;
+				}
+			}
+
+			return -1;
+		}
+
+		internal static void ReadGold(AccessibleComponent speaker)
+		{
+			var gold = GetGoldBalance();
+			AccessibilityMgr.Output(speaker, LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, gold));
+		}
+
+		internal static void ReadRemainingGold(AccessibleComponent speaker)
+		{
+			var gold = GetGoldBalance();
+			AccessibilityMgr.Output(speaker, LocalizationUtils.Format(LocalizationKey.UI_SHOP_PURCHASE_COMPLETE_GOLD_REMAINING, gold));
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Social/AccessibleFriendListFriendFrame.cs b/Decompiled/Assembly-CSharp/Accessibility/Social/AccessibleFriendListFriendFrame.cs
new file mode 100644
index 0000000..8f6976b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Social/AccessibleFriendListFriendFrame.cs
@@ -0,0 +1,44 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleFriendListFriendFrame : AccessibleItem
+    {
+        private readonly FriendListFriendFrame m_frame;
+
+        internal AccessibleFriendListFriendFrame(AccessibleComponent parent, FriendListFriendFrame frame) : base(parent)
+        {
+            m_frame = frame;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            var friendDataModel = m_frame.m_friendDataModel;
+
+            if (friendDataModel.IsOnline)
+            {
+                ret.Add(friendDataModel.PlayerName);
+                AccessibleCardUtils.AddLineIfExists(AccessibleRankedUtils.GetBestRank(m_frame.m_rankedMedalInfo), ret);
+            }
+            else
+            {
+                var name = AccessibleSpeechUtils.CombineWordsWithComma(GameStrings.Get("GLOBAL_OFFLINE"), friendDataModel.PlayerName);
+                ret.Add(name);
+            }
+
+            ret.Add(friendDataModel.PlayerStatus);
+
+            return ret;
+        }
+
+		internal FriendListFriendFrame GetFriendListFriendFrame()
+        {
+            return m_frame;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Social/AccessibleFriendListRequestFrame.cs b/Decompiled/Assembly-CSharp/Accessibility/Social/AccessibleFriendListRequestFrame.cs
new file mode 100644
index 0000000..6d417cf
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Social/AccessibleFriendListRequestFrame.cs
@@ -0,0 +1,32 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleFriendListRequestFrame : AccessibleItem
+    {
+        private readonly FriendListRequestFrame m_frame;
+
+        internal AccessibleFriendListRequestFrame(AccessibleComponent parent, FriendListRequestFrame frame) : base(parent)
+        {
+            m_frame = frame;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            AccessibleCardUtils.AddLineIfExists(m_frame.m_PlayerNameText.Text, ret);
+            AccessibleCardUtils.AddLineIfExists(m_frame.m_TimeText.Text, ret);
+
+            return ret;
+        }
+
+        internal FriendListRequestFrame GetFriendListRequestFrame()
+        {
+            return m_frame;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Social/AccessiblePlayerProfile.cs b/Decompiled/Assembly-CSharp/Accessibility/Social/AccessiblePlayerProfile.cs
new file mode 100644
index 0000000..6733da9
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Social/AccessiblePlayerProfile.cs
@@ -0,0 +1,58 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static FriendListFrame;
+
+namespace Accessibility
+{
+    class AccessiblePlayerProfile : AccessibleItem
+    {
+        private readonly FriendListFriendFrame m_frame;
+
+        private readonly Me m_me;
+
+        internal AccessiblePlayerProfile(AccessibleComponent parent, Me me) : base(parent)
+        {
+            m_me = me;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_me.nameText.Text);
+
+            ret.AddRange(GetRankedPlayDataModel());
+
+            return ret;
+        }
+
+        private List<string> GetRankedPlayDataModel()
+        {
+            var ret = new List<string>();
+
+            MedalInfoTranslator medalInfo = RankMgr.Get().GetLocalPlayerMedalInfo();
+
+            var rankedMedalText = AccessibleRankedUtils.GetBestRank(medalInfo);
+
+            if (rankedMedalText?.Length > 0)
+            {
+                ret.Add(rankedMedalText);
+            }
+
+            return ret;
+        }
+
+        public void CopyBattleTagToClipboard()
+        {
+            BnetPlayer myPlayer = BnetPresenceMgr.Get().GetMyPlayer();
+
+            var battleTag = myPlayer.GetBattleTag();
+
+            ClipboardUtils.CopyToClipboard(battleTag.ToString());
+
+            UIStatus.Get().AddInfo(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_BATTLETAG_COPIED_TO_CLIPBOARD));
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Testing/AccessibleQuestsTestingUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/Testing/AccessibleQuestsTestingUtils.cs
new file mode 100644
index 0000000..7f013f8
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Testing/AccessibleQuestsTestingUtils.cs
@@ -0,0 +1,245 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using Hearthstone.Progression;
+using PegasusUtil;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace Accessibility
+{
+    class AccessibleQuestsTestingUtils
+    {
+		private static QuestListDataModel s_quests;
+
+		private static bool s_poolEnabled;
+
+		private static RerollQuestResponse s_rerollResponse;
+
+		internal static bool SetScenario(int scenarioId)
+		{
+			switch (scenarioId)
+			{
+				case 0:
+					s_poolEnabled = false;
+					s_quests = null;
+					return true;
+				case 1:
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { });
+					return true;
+				case 2:
+					// Daily quests only
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126 });
+					return true;
+				case 3:
+					// Weekly quests only
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { -1, 98, 97, 94 });
+					return true;
+				case 4:
+					// 4 daily + 3 weekly
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, 56, 98, 97, 94 });
+					return true;
+				case 5:
+					// 5 "daily" to test bounds (which are 4)
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, 56, 22 });
+					return true;
+				case 6:
+					// 5 daily + 3 weekly
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, 56, 22, 98, 97, 94 });
+					return true;
+				case 7:
+					// Including "next quest in X" tiles
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, -1, 98, 97, -2, -2 });
+					return true;
+				case 8:
+					// All quests complete scenario
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { -1, -2, -2, -2 });
+					return true;
+				// Abandon scenarios
+				case 9:
+					// Abandon first quest
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126 });
+					return true;
+				case 10:
+					// Abandon last quest
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 126, 142 });
+					return true;
+				case 11:
+					// Abandon only quest
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142 });
+					return true;
+				case 12:
+					// Abandon only daily quest when a weekly one exists as well
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 98 });
+					return true;
+				// Reroll scenarios
+				case 13:
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { -1, 98, -2, -2 });
+					return true;
+				case 99:
+					// Weekly quests only - special QuestsPopupOnLoginTest scenario
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 98, 97, 94 });
+					return true;
+				default:
+					return false;
+			}
+		}
+
+		private static QuestListDataModel CreateQuestListDataModel(int[] questIds)
+		{
+			var ret = new QuestListDataModel();
+			ret.Quests = new Hearthstone.UI.DataModelList<QuestDataModel>();
+
+			foreach (var questId in questIds)
+			{
+				if (questId == -1)
+				{
+					var questPoolRecord = GetQuestPoolRecord(QuestPool.QuestPoolType.DAILY);
+					var timeUntilNextQuestString = QuestManager.Get().GetElapsedTimeString(new TimeSpan(3, 59, 0));
+					var questTile = QuestManager.Get().CreateNextQuestTimeDataModel(questPoolRecord, timeUntilNextQuestString);
+					ret.Quests.Add(questTile);
+				}
+				else if (questId == -2)
+				{
+					var questPoolRecord = GetQuestPoolRecord(QuestPool.QuestPoolType.WEEKLY);
+					var timeUntilNextQuestString = QuestManager.Get().GetElapsedTimeString(new TimeSpan(24 * 6 + 23, 0, 0));
+					var questTile = QuestManager.Get().CreateNextQuestTimeDataModel(questPoolRecord, timeUntilNextQuestString);
+					ret.Quests.Add(questTile);
+				}
+				else
+				{
+					ret.Quests.Add(QuestManager.Get().CreateQuestDataModelById(questId));
+				}
+			}
+
+			return ret;
+		}
+
+		private static QuestPoolDbfRecord GetQuestPoolRecord(QuestPool.QuestPoolType questPoolType)
+		{
+			var records = GameDbf.QuestPool.GetRecords();
+
+			foreach(var record in records)
+			{
+				if (record.QuestPoolType == questPoolType)
+				{
+					return record;
+				}
+			}
+
+			return null;
+		}
+
+		internal static QuestListDataModel GetQuests()
+		{
+			return s_quests;
+		}
+
+		internal static QuestListDataModel GetQuestsForPoolType(QuestPool.QuestPoolType questPoolType)
+		{
+			if (s_quests == null)
+			{
+				return CreateQuestListDataModel(new int[] { });
+			}
+
+			var ret = new QuestListDataModel();
+			ret.Quests = new Hearthstone.UI.DataModelList<QuestDataModel>();
+
+			foreach (var quest in s_quests.Quests)
+			{
+				if (quest.PoolType == questPoolType)
+				{
+					ret.Quests.Add(quest);
+				}
+			}
+
+			return ret;
+		}
+
+		internal static bool IsMockingQuests()
+		{
+			return s_quests != null;
+		}
+
+		internal static PlayerQuestStateUpdate GetPlayerQuestStateUpdate()
+		{
+			var ret = new PlayerQuestStateUpdate();
+			ret.Quest = new List<PlayerQuestState>();
+
+			foreach (var quest in s_quests.Quests)
+			{
+				var questState = new PlayerQuestState();
+				questState.QuestId = quest.QuestId;
+				questState.Progress = quest.Progress;
+				questState.Status = (int)quest.Status;
+				ret.Quest.Add(questState);
+			}
+
+			return ret;
+		}
+
+		internal static bool RerollQuest(int questId)
+		{
+			s_rerollResponse = new RerollQuestResponse();
+			s_rerollResponse.RerolledQuestId = questId;
+			s_rerollResponse.GrantedQuestId = 94;
+			s_rerollResponse.Success = true;
+
+			return true;
+		}
+
+		internal static void ReceiveRerollQuestResponseMessage()
+		{
+			QuestManager.Get().ReceiveRerollQuestResponseMessage();
+		}
+
+		internal static bool AbandonQuest(int questId)
+		{
+			return true;
+		}
+
+		internal static PlayerQuestPoolStateUpdate GetPlayerQuestPoolStateUpdate()
+		{
+			var ret = new PlayerQuestPoolStateUpdate();
+			ret.QuestPool = new List<PlayerQuestPoolState>();
+			var dailyState = new PlayerQuestPoolState();
+			dailyState.QuestPoolId = GetQuestPoolRecord(QuestPool.QuestPoolType.DAILY).ID;
+			dailyState.RerollAvailableCount = 0;
+			dailyState.SecondsUntilNextGrant = 4 * 60 * 60;
+
+			var weeklyState = new PlayerQuestPoolState();
+			weeklyState.QuestPoolId = GetQuestPoolRecord(QuestPool.QuestPoolType.WEEKLY).ID;
+			weeklyState.RerollAvailableCount = 1;
+			weeklyState.SecondsUntilNextGrant = 7 * 24 * 60 * 60;
+
+			ret.QuestPool.Add(dailyState);
+			ret.QuestPool.Add(weeklyState);
+
+			return ret;
+		}
+
+		internal static RerollQuestResponse GetRerollQuestResponse()
+		{
+			return s_rerollResponse;
+		}
+
+		internal static bool CanBeGrantedPoolQuests()
+		{
+			return s_poolEnabled;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Testing/AccessibleRewardsTrackTestingUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/Testing/AccessibleRewardsTrackTestingUtils.cs
new file mode 100644
index 0000000..5aea1aa
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Testing/AccessibleRewardsTrackTestingUtils.cs
@@ -0,0 +1,203 @@
+﻿using Hearthstone.Progression;
+using PegasusUtil;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+	class AccessibleRewardsTrackTestingUtils
+	{
+		// Note: this needs to be updated every time the rewards track resets (the automated suite will fail with 0 rewards left to claim regardless of the scenario)
+		// The code is protected to stop Network requests from firing though so mocks should keep working and leave the actual track untouched unless something changes
+		// at some point
+		private static int TEST_TRACK_ID = 28;
+
+		private static Map<int, PlayerRewardTrackLevelState> s_cheatState;
+
+		private static bool s_premiumRewardsUnlocked;
+
+		private static int s_currentTrackLevel;
+
+		private static int s_currentTrackId;
+
+		internal static bool SetScenario(int scenarioId)
+		{
+			var ret = SetScenarioInternal(scenarioId);
+			RewardTrackManager.Get().Cheat_SetPlayerRewardTrackLevelState(s_cheatState);
+			return ret;
+		}
+
+		private static bool SetScenarioInternal(int scenarioId)
+		{
+			switch(scenarioId)
+			{
+				case 0:
+					s_cheatState = null;
+					s_premiumRewardsUnlocked = false;
+					s_currentTrackLevel = 0;
+					s_currentTrackId = 0;
+					return true;
+				case 1:
+					CreateStateUpToLevel(0, 1, TEST_TRACK_ID, false);
+					return true;
+				case 2:
+					CreateStateUpToLevel(10, 12, TEST_TRACK_ID, false);
+					return true;
+				case 3:
+					CreateStateUpToLevel(13, 16, TEST_TRACK_ID, false);
+					return true;
+				case 4:
+					CreateStateUpToLevel(13, 16, TEST_TRACK_ID, true);
+					return true;
+				case 5:
+					CreateStateUpToLevel(100, 103, TEST_TRACK_ID, true);
+					return true;
+				case 6:
+					// Choose one
+					CreateStateUpToLevel(99, 100, TEST_TRACK_ID, true);
+					return true;
+				case 7:
+					// Nothing to claim from the start
+					CreateStateUpToLevel(1, 1, TEST_TRACK_ID, false);
+					return true;
+				default:
+					return false;
+			}
+		}
+
+		private static void CreateStateUpToLevel(int lastClaimedLevel, int curLevel, int trackId, bool includePremium)
+		{
+			s_cheatState = new Map<int, PlayerRewardTrackLevelState>();
+
+			var paidRewardStatus = includePremium ? 1 : 0;
+
+			for (int i = 1; i <= lastClaimedLevel; i++)
+			{
+				s_cheatState[i] = new PlayerRewardTrackLevelState
+				{
+					Level = i,
+					FreeRewardStatus = 1,
+					PaidRewardStatus = paidRewardStatus
+				};
+			}
+
+			for (int i = lastClaimedLevel + 1; i <= curLevel; i++)
+			{
+				s_cheatState[i] = new PlayerRewardTrackLevelState
+				{
+					Level = i,
+					FreeRewardStatus = 0,
+					PaidRewardStatus = 0
+				};
+			}
+
+			s_currentTrackId = trackId;
+			s_currentTrackLevel = curLevel;
+			s_premiumRewardsUnlocked = includePremium;
+		}
+
+		internal static bool IsMockingRewardsTrack()
+		{
+			return s_cheatState != null;
+		}
+
+		private static PlayerRewardTrackState s_stateUpdateAckdReward;
+
+		internal static bool AckRewardTrackReward(int rewardTrackId, int level, bool forPaidTrack)
+		{
+			// Note: turns out this isn't actually needed as ACKs are fire and forget
+			s_stateUpdateAckdReward = CreatePlayerRewardTrackStateUpdate(rewardTrackId, level, forPaidTrack, 2);
+
+			var notif = "Waiting for ACK response";
+			AccessibilityMgr.OutputNotification(notif);
+
+			return true;
+		}
+
+		private static PlayerRewardTrackState s_stateUpdateClaimedReward;
+
+		internal static bool ClaimRewardTrackReward(int rewardTrackId, int level, bool forPaidTrack, int chooseOneRewardItemId)
+		{
+			s_stateUpdateClaimedReward = CreatePlayerRewardTrackStateUpdate(rewardTrackId, level, forPaidTrack, 1);
+
+			if (chooseOneRewardItemId != 0)
+			{
+				RewardItemOutput rewardItem = new RewardItemOutput();
+				rewardItem.RewardItemId = chooseOneRewardItemId;
+				var rewardItemOutputs = new List<RewardItemOutput>();
+				rewardItemOutputs.Add(rewardItem);
+
+				s_stateUpdateClaimedReward.TrackLevel[0].RewardItemOutput = rewardItemOutputs;
+			}
+
+			var notif = "Waiting for Claimed response";
+			AccessibilityMgr.OutputNotification(notif);
+
+			return true;
+		}
+
+		private static PlayerRewardTrackState CreatePlayerRewardTrackStateUpdate(int rewardTrackId, int level, bool forPaidTrack, int newStatus)
+		{
+			var ret = new PlayerRewardTrackState();
+			ret.RewardTrackId = rewardTrackId;
+			ret.Level = level;
+			ret.TrackLevel = new List<PlayerRewardTrackLevelState>();
+
+			var curLevelState = s_cheatState[level];
+			var levelState = new PlayerRewardTrackLevelState();
+			levelState.Level = curLevelState.Level;
+			levelState.FreeRewardStatus = curLevelState.FreeRewardStatus;
+			levelState.PaidRewardStatus = curLevelState.PaidRewardStatus;
+
+			if (forPaidTrack)
+			{
+				levelState.PaidRewardStatus = newStatus;
+			}
+			else
+			{
+				levelState.FreeRewardStatus = newStatus;
+			}
+
+			ret.TrackLevel.Add(levelState);
+
+			return ret;
+		}
+
+		internal static bool TriggerClaimedRewardResponse()
+		{
+			if (s_stateUpdateClaimedReward != null)
+			{
+				RewardTrackManager.Get().HandleRewardTrackStateUpdate(s_stateUpdateClaimedReward);
+				return true;
+			}
+
+			return false;
+		}
+
+		internal static bool TriggerAckdRewardResponse()
+		{
+			// This isn't actually needed as the ACK after grant is fire and forget
+			if (s_stateUpdateAckdReward != null)
+			{
+				RewardTrackManager.Get().HandleRewardTrackStateUpdate(s_stateUpdateAckdReward);
+				return true;
+			}
+
+			return false;
+		}
+
+		internal static bool ArePremiumRewardsUnlocked()
+		{
+			return s_premiumRewardsUnlocked;
+		}
+
+		internal static int GetCurrentTrackLevel()
+		{
+			return s_currentTrackLevel;
+		}
+
+		internal static int GetCurrentTrackId()
+		{
+			return s_currentTrackId;
+		}
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs
new file mode 100644
index 0000000..4f62bdf
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs
@@ -0,0 +1,1296 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_01 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification handBounceArrow;
+
+    private Notification handFadeArrow;
+
+    private TooltipPanel attackHelpPanel;
+
+    private TooltipPanel healthHelpPanel;
+
+    private Card mousedOverCard;
+
+    private GameObject costLabel;
+
+    private GameObject attackLabel;
+
+    private GameObject healthLabel;
+
+    private Card firstMurlocCard;
+
+    private Card firstRaptorCard;
+
+    private GameObject startingPack;
+
+    private bool packOpened;
+
+    private bool announcerIsFinishedYapping;
+
+    private bool m_jainaSpeaking;
+
+    private bool m_isShowingAttackHelpPanel;
+
+    private bool m_fullyReadMurlocRaider;
+
+    private bool m_finishedReadingOpponentMinion;
+
+    private bool m_attackedOpponentMinion;
+
+    private bool m_attackedOpponentMinionOnTurn6;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool>
+        {
+            {
+                GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN,
+                true
+            },
+            {
+                GameEntityOption.SHOW_HERO_TOOLTIPS,
+                true
+            },
+            {
+                GameEntityOption.DISABLE_TOOLTIPS,
+                true
+            }
+        };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_01()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+        MulliganManager.Get().ForceMulliganActive(active: true);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8");
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41");
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada");
+        PreloadSound("VO_TUTORIAL_01_JAINA_13_10.prefab:b13670e36c248e141837c4eb0645a000");
+        PreloadSound("VO_TUTORIAL_01_JAINA_01_01.prefab:883391234efbde84eb99a16abd164d9d");
+        PreloadSound("VO_TUTORIAL_01_JAINA_02_02.prefab:cccdcb509085a974d922ac1d545d9bb6");
+        PreloadSound("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47");
+        PreloadSound("VO_TUTORIAL_01_JAINA_20_16.prefab:7980d02c581e4174991a8066e5785666");
+        PreloadSound("VO_TUTORIAL_01_JAINA_05_05.prefab:982193e53ab81f04ba562de4b32dd39c");
+        PreloadSound("VO_TUTORIAL_01_JAINA_06_06.prefab:ffe0ebdca06ca1d4c84cc28e4a1ed7cf");
+        PreloadSound("VO_TUTORIAL_01_JAINA_07_07.prefab:a8bf811494e94d742a3910fac9da906f");
+        PreloadSound("VO_TUTORIAL_01_JAINA_21_17.prefab:c1524bd0ef92bb845b5dab48cbd017f9");
+        PreloadSound("VO_TUTORIAL_01_JAINA_09_08.prefab:b7b739d9e31865a478275394ee57ad89");
+        PreloadSound("VO_TUTORIAL_01_JAINA_15_11.prefab:a644986d34ab8964582c6221cde54d45");
+        PreloadSound("VO_TUTORIAL_01_JAINA_16_12.prefab:e6b4ab6fc1f11634e88f013ce5351e46");
+        PreloadSound("VO_TUTORIAL_JAINA_02_55_ALT2.prefab:d049e67ad6c16db4da2c04be7a02a1ae");
+        PreloadSound("VO_TUTORIAL_01_JAINA_10_09.prefab:5bf553d532aca174083f48bf407b2b11");
+        PreloadSound("VO_TUTORIAL_01_JAINA_17_13.prefab:9b257c86e7c7f9045a2b819d35876aca");
+        PreloadSound("VO_TUTORIAL_01_JAINA_18_14.prefab:fedcdecb3346ec745b6fb4204f7dd4e0");
+        PreloadSound("VO_TUTORIAL_01_JAINA_19_15.prefab:659652a121ac01941a40c64c1c151f87");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_01_01.prefab:5833f4aeb72110741a2c9bc3a92f9bc8");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_02_02.prefab:7f321b26431a4974a82deefc368adf63");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_03_03.prefab:4ef21f71824b97842b33d8ebccb37ed2");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_04_04.prefab:3e16e42edb324e2469a25363ffd013a6");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_06_06_ALT.prefab:6c9ef3c501462474ab59a37b967cab6f");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_08_08_ALT.prefab:19ddb4ddaa4aee2468b17bae25da9419");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_09_09_ALT.prefab:70c4d2941509856448660f89d6c72b2b");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        base.NotifyOfGameOver(gameResult);
+        if (attackHelpPanel != null)
+        {
+            Object.Destroy(attackHelpPanel.gameObject);
+            attackHelpPanel = null;
+        }
+        if (healthHelpPanel != null)
+        {
+            Object.Destroy(healthHelpPanel.gameObject);
+            healthHelpPanel = null;
+        }
+        EnsureCardGemsAreOnTheCorrectLayer();
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.HOGGER_COMPLETE);
+                PlaySound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+                break;
+        }
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            InputManager.Get().RemovePhoneHandShownListener(OnPhoneHandShown);
+            InputManager.Get().RemovePhoneHandHiddenListener(OnPhoneHandHidden);
+        }
+    }
+
+    private void EnsureCardGemsAreOnTheCorrectLayer()
+    {
+        List<Card> list = new List<Card>();
+        list.AddRange(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+            .GetCards());
+        list.AddRange(GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+            .GetCards());
+        list.Add(GameState.Get().GetFriendlySidePlayer().GetHeroCard());
+        list.Add(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+        foreach (Card item in list)
+        {
+            if (!(item == null) && !(item.GetActor() == null))
+            {
+                if (item.GetActor().GetAttackObject() != null)
+                {
+                    SceneUtils.SetLayer(item.GetActor().GetAttackObject().gameObject, GameLayer.Default);
+                }
+                if (item.GetActor().GetHealthObject() != null)
+                {
+                    SceneUtils.SetLayer(item.GetActor().GetHealthObject().gameObject, GameLayer.Default);
+                }
+            }
+        }
+    }
+
+	public override bool ShouldAllowCardGrab(Entity entity)
+	{
+        if (GetTag(GAME_TAG.TURN) == 2 && !m_fullyReadMurlocRaider)
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_FORCE_CARD_READ);
+            return false;
+        }
+		return true;
+	}
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (GetTag(GAME_TAG.TURN) == 2 || entity.GetCardId() == "TU5_CS2_025")
+        {
+            BoardTutorial.Get().EnableHighlight(enable: true);
+        }
+        NukeNumberLabels();
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        if (GetTag(GAME_TAG.TURN) == 2 || entity.GetCardId() == "TU5_CS2_025")
+        {
+            BoardTutorial.Get().EnableHighlight(enable: false);
+        }
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN_ATK";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        if (!GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    public override bool NotifyOfPlayError(PlayErrors.ErrorType error, int? errorParam, Entity errorSource)
+    {
+        if (error == PlayErrors.ErrorType.REQ_ATTACK_GREATER_THAN_0 && errorSource.GetCardId() == "TU4a_006")
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public override void NotifyOfTargetModeCancelled()
+    {
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_11_HELP);
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 1)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_SUMMON_MINION_FIRST);
+                return false;
+            }
+            
+            if (!m_finishedReadingOpponentMinion)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST);
+                return false;
+            }
+
+            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_13_HELP);
+        }
+        if (GetTag(GAME_TAG.TURN) == 6 && clickedEntity.GetZone() == TAG_ZONE.PLAY && GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() < 2)
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_SUMMON_MINION_FIRST);
+            return false;
+        }
+
+        if (GetTag(GAME_TAG.TURN) == 6 && clickedEntity.GetCardId() == "TU4a_001" && wasInTargetMode)
+        {
+            NotificationManager.Get().DestroyAllPopUps();
+        }
+        if (wasInTargetMode && InputManager.Get().GetHeldCard() != null && InputManager.Get().GetHeldCard().GetEntity()
+            .GetCardId() == "TU5_CS2_029")
+        {
+            if (clickedEntity.IsControlledByLocalUser())
+            {
+                ShowDontFireballYourselfPopup(clickedEntity.GetCard().transform.position);
+                return false;
+            }
+            if (clickedEntity.GetCardId() == "TU4a_003" && GetTag(GAME_TAG.TURN) >= 8)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_08);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public override bool NotifyOfCardTooltipDisplayShow(Card card)
+    {
+        if (GameState.Get().IsGameOver())
+        {
+            return false;
+        }
+        Entity entity = card.GetEntity();
+        if (entity.IsMinion())
+        {
+            if (attackHelpPanel == null)
+            {
+                m_isShowingAttackHelpPanel = true;
+            }
+            return false;
+        }
+        if (entity.IsHero())
+        {
+            return false;
+        }
+        return true;
+    }
+
+	public override void NotifyOfEntityAttacked(Entity attacker, Entity defender)
+	{
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            m_attackedOpponentMinion = true;
+        }
+        else if (GetTag(GAME_TAG.TURN) == 6)
+        {
+            m_attackedOpponentMinionOnTurn6 = true;
+        }
+	}
+
+    public override void NotifyOfCardTooltipDisplayHide(Card card)
+    {
+        if (attackHelpPanel != null)
+        {
+            if (card != null)
+            {
+                GemObject attackObject = card.GetActor().GetAttackObject();
+                SceneUtils.SetLayer(attackObject.gameObject, GameLayer.Default);
+                attackObject.Shrink();
+            }
+            Object.Destroy(attackHelpPanel.gameObject);
+            m_isShowingAttackHelpPanel = false;
+        }
+        if (healthHelpPanel != null)
+        {
+            if (card != null)
+            {
+                GemObject healthObject = card.GetActor().GetHealthObject();
+                SceneUtils.SetLayer(healthObject.gameObject, GameLayer.Default);
+                healthObject.Shrink();
+            }
+            Object.Destroy(healthHelpPanel.gameObject);
+        }
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+            if (costTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            costLabel = go;
+            go.transform.parent = costTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(-0.017f, 0.3512533f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+        }
+    }
+
+    private void AttackLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject attackTextObject = ((Card)callbackData).GetActor().GetAttackTextObject();
+            if (attackTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            attackLabel = go;
+            go.transform.parent = attackTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(-0.2f, -0.3039344f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_ATTACK");
+        }
+    }
+
+    private void HealthLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject healthTextObject = ((Card)callbackData).GetActor().GetHealthTextObject();
+            if (healthTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            healthLabel = go;
+            go.transform.parent = healthTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(0.21f, -0.31f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_HEALTH");
+        }
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOverEntity))
+        {
+            NotificationManager.Get().DestroyAllArrows();
+        }
+        if (mousedOverEntity.GetZone() == TAG_ZONE.HAND)
+        {
+            mousedOverCard = mousedOverEntity.GetCard();
+            IAssetLoader assetLoader = AssetLoader.Get();
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", AttackLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", HealthLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOffEntity))
+        {
+            Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+        }
+        NukeNumberLabels();
+    }
+
+    private void NukeNumberLabels()
+    {
+        mousedOverCard = null;
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+        if (attackLabel != null)
+        {
+            Object.Destroy(attackLabel);
+        }
+        if (healthLabel != null)
+        {
+            Object.Destroy(healthLabel);
+        }
+    }
+
+    private bool ShouldShowArrowOnCardInHand(Entity entity)
+    {
+        if (entity.GetZone() != TAG_ZONE.HAND)
+        {
+            return false;
+        }
+        switch (GetTag(GAME_TAG.TURN))
+        {
+            case 2:
+                return true;
+            case 4:
+                if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+                    .GetCards()
+                    .Count == 0)
+                {
+                    return true;
+                }
+                break;
+        }
+        return false;
+    }
+
+    private IEnumerator ShowArrowInSeconds(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count != 0)
+        {
+            Card cardInHand = cards[0];
+            while (iTween.Count(cardInHand.gameObject) > 0)
+            {
+                yield return null;
+            }
+            if (!cardInHand.IsMousedOver() && !(InputManager.Get().GetHeldCard() == cardInHand))
+            {
+                ShowHandBouncingArrow();
+            }
+        }
+    }
+
+    private void ShowHandBouncingArrow()
+    {
+        if (!(handBounceArrow != null))
+        {
+            List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                .GetCards();
+            if (cards.Count != 0)
+            {
+                Card card = cards[0];
+                Vector3 position = card.transform.position;
+                Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z + 2f) : new Vector3(position.x - 0.08f, position.y + 0.2f, position.z + 1.2f));
+                handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
+                handBounceArrow.transform.parent = card.transform;
+            }
+        }
+    }
+
+    private void ShowHandFadeArrow()
+    {
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count != 0)
+        {
+            ShowFadeArrow(cards[0]);
+        }
+    }
+
+    private void ShowFadeArrow(Card card, Card target = null)
+    {
+        if (!(handFadeArrow != null))
+        {
+            Vector3 position = card.transform.position;
+            Vector3 rotation = new Vector3(0f, 180f, 0f);
+            Vector3 vector2;
+            if (target != null)
+            {
+                Vector3 vector = target.transform.position - position;
+                vector2 = new Vector3(position.x, position.y + 0.47f, position.z + 0.27f);
+                float num = Vector3.Angle(target.transform.position - vector2, new Vector3(0f, 0f, -1f));
+                rotation = new Vector3(0f, (0f - Mathf.Sign(vector.x)) * num, 0f);
+                vector2 += 0.3f * vector;
+            }
+            else
+            {
+                vector2 = new Vector3(position.x, position.y + 0.047f, position.z + 0.95f);
+            }
+            handFadeArrow = NotificationManager.Get().CreateFadeArrow(vector2, rotation);
+            if (target != null)
+            {
+                handFadeArrow.transform.localScale = 1.25f * Vector3.one;
+            }
+            handFadeArrow.transform.parent = card.transform;
+        }
+    }
+
+    private void HideFadeArrow()
+    {
+        if (handFadeArrow != null)
+        {
+            NotificationManager.Get().DestroyNotification(handFadeArrow, 0f);
+            handFadeArrow = null;
+        }
+    }
+
+    private void OnPhoneHandShown(object userData)
+    {
+        if (handBounceArrow != null)
+        {
+            NotificationManager.Get().DestroyNotification(handBounceArrow, 0f);
+            handBounceArrow = null;
+        }
+        ShowHandFadeArrow();
+    }
+
+    private void OnPhoneHandHidden(object userData)
+    {
+        HideFadeArrow();
+        ShowHandBouncingArrow();
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 1:
+                {
+                    List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetDeckZone()
+                        .GetCards();
+                    firstMurlocCard = cards[cards.Count - 1];
+                    firstRaptorCard = cards[cards.Count - 2];
+                    GameState.Get().SetBusy(busy: true);
+                    Board.Get().FindCollider("DragPlane").enabled = false;
+                    yield return new WaitForSeconds(1.25f);
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL01_HELP_14", "TUTORIAL01_HELP_15", "TUTORIAL01_HELP_16", Vector2.zero);
+                    tutorialStartDialog.SetWantedText(GameStrings.Get("MISSION_PRE_TUTORIAL_WANTED"));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_START);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE, AccessibleKey.CONFIRM);
+                    break;
+                }
+            case 2:
+                {
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        InputManager.Get().RegisterPhoneHandShownListener(OnPhoneHandShown);
+                        InputManager.Get().RegisterPhoneHandHiddenListener(OnPhoneHandHidden);
+                    }
+                    yield return new WaitForSeconds(1f);
+                    yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_02_02.prefab:cccdcb509085a974d922ac1d545d9bb6", "TUTORIAL01_JAINA_02", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                    List<Card> cards2 = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                        .GetCards();
+
+                    var onlyCard = cards2[0];
+                    var cardSelected = false;
+                    AccessibleCard cardBeingRead = null;
+                    if (GetTag(GAME_TAG.TURN) == 2 && cards2.Count == 1 && InputManager.Get().GetHeldCard() == null && !onlyCard.IsMousedOver())
+                    {
+                        AccessibleGameplay.Get().RegisterCardSelectedListener(onlyCard, (ac) =>
+                        {
+                            cardSelected = true;
+                            cardBeingRead = ac;
+                        });
+                        Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0f));
+                        AccessibilityMgr.BlockAllInput(false, true);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_0);;
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_1);;
+                        AccessibilityMgr.UnblockAllInput();
+                        AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_2_1);
+                        yield return new WaitUntil(() => cardSelected);
+                        AccessibilityMgr.ResetHelpSpeech();
+                        AccessibilityMgr.BlockAllInput(false, true);
+                    }
+
+                    var cardRead = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        cardRead = true;
+                        m_fullyReadMurlocRaider = true;
+                    });
+                    yield return new WaitForSeconds(2);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_READ_CARD_HELP);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.GAMEPLAY_READ_CARDS_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_NEXT_LINE, AccessibleKey.READ_PREV_LINE);
+                    yield return new WaitUntil(() => cardRead);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2D);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_3);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_4);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION);
+                    var cardGrabbed = false;
+                    AccessibleGameplay.Get().RegisterSummoningCardListener(onlyCard, () =>
+                    {
+                        cardGrabbed = true;
+                    });
+                    yield return new WaitUntil(() => cardGrabbed);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    AccessibilityMgr.ResetHelpSpeech();
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_5);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION);
+                    yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 1);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    break;
+                }
+            case 3:
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    InputManager.Get().RemovePhoneHandShownListener(OnPhoneHandShown);
+                    InputManager.Get().RemovePhoneHandHiddenListener(OnPhoneHandHidden);
+                }
+                break;
+            case 4:
+                AccessibilityMgr.BlockAllInput(false, true);
+                actor.SetActorState(ActorStateType.CARD_IDLE);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_06_06.prefab:ffe0ebdca06ca1d4c84cc28e4a1ed7cf", "TUTORIAL01_JAINA_06", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+
+                // 1
+                var summoningMinion = false;
+                AccessibleGameplay.Get().RegisterSummoningCardListener(firstRaptorCard, () =>
+                {
+                    summoningMinion = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_1);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_1_HELP);
+                yield return new WaitUntil(() => summoningMinion);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 2
+                yield return new WaitForSeconds(1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_TRY_IT_OUT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_1_HELP);
+                yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 2);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 4
+                yield return new WaitForSeconds(7);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_4);
+                var seenBattlefield = false;
+                AccessibleGameplay.Get().RegisterZoneSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone(), () =>
+                {
+                    seenBattlefield = true;
+                });
+                yield return new WaitForSeconds(0.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+                yield return new WaitUntil(() => seenBattlefield);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 6
+                var minionsRemaining = 2;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1), (_) =>
+                {
+                    minionsRemaining--;
+                });
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(2), (_) =>
+                {
+                    minionsRemaining--;
+                });
+                yield return new WaitForSeconds(2.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_6);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_6_HELP);
+                yield return new WaitUntil(() => minionsRemaining == 0);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 8
+                seenBattlefield = false;
+                AccessibleCard accessibleCard = null; 
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardAtPos(1), (opponentMinion) =>
+                {
+                    seenBattlefield = true;
+                    accessibleCard = opponentMinion;
+                });
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_8);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP);
+                yield return new WaitUntil(() => seenBattlefield);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 9
+                var readOpponentCard = false;
+                accessibleCard.RegisterFinishReadListener(() =>
+                {
+                    readOpponentCard = true;
+                    m_finishedReadingOpponentMinion = true; // Prevent an attack until this happens
+                });
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_9);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_4_9_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                yield return new WaitUntil(() => readOpponentCard);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 10
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_YOU_GOT_IT);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_10);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_11);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_11_HELP);
+                yield return new WaitUntil(() => GameState.Get().IsInTargetMode());
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return new WaitForSeconds(1.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_13);
+
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_13_HELP);
+                yield return new WaitUntil(() => m_attackedOpponentMinion);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 16
+                yield return new WaitForSeconds(5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_ONE);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_16);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_17);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+
+                if (firstMurlocCard != null)
+                {
+                    firstMurlocCard.GetActor().ToggleForceIdle(bOn: true);
+                    firstMurlocCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
+                }
+                break;
+            case 6:
+                var minionInBattlefieldAtTurn6 = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1);
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_17_13.prefab:9b257c86e7c7f9045a2b819d35876aca", "TUTORIAL01_JAINA_17", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_4);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_LETS_LEARN_HOW);
+                var firstCardInHandSelected = false;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCardAtPos(1), (_) =>
+                {
+                    firstCardInHandSelected = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_6);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_6_6, AccessibleKey.READ_NEXT_VALID_ITEM);
+                yield return new WaitUntil(() => firstCardInHandSelected);
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.READ_NEXT_VALID_ITEM);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_7);
+                var firstMinionInBattlefieldSelected = false;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1), (_) =>
+                {
+                    firstMinionInBattlefieldSelected = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_8);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_6_8, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.READ_PREV_VALID_ITEM);
+                yield return new WaitUntil(() => firstMinionInBattlefieldSelected);
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.READ_PREV_VALID_ITEM);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_9);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_10);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_12);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_CAN_YOU_DO_IT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_12_HELP);
+                yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 2);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_JOB);
+
+                yield return new WaitForSeconds(1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_13);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_THINK_YOU_CAN_DO_IT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_13_HELP);
+
+                yield return new WaitUntil(() => GameState.Get().IsInTargetMode());
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_14);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_15);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_16);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_16_HELP);
+
+                // Wait for atk
+                yield return new WaitUntil(() => m_attackedOpponentMinionOnTurn6);
+                yield return new WaitForSeconds(4);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_WORK);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_21);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                break;
+            case 8:
+                AccessibilityMgr.BlockAllInput(false, false);
+                m_jainaSpeaking = true;
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_18_14.prefab:fedcdecb3346ec745b6fb4204f7dd4e0", "TUTORIAL01_JAINA_18", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                m_jainaSpeaking = false;
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_8_1);
+                AccessibilityMgr.UnblockAllInput();
+                yield return new WaitForSeconds(1f);
+                Gameplay.Get().StartCoroutine(FlashMinionUntilAttackBegins(firstRaptorCard));
+                break;
+            case 10:
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_19_15.prefab:659652a121ac01941a40c64c1c151f87", "TUTORIAL01_JAINA_19", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                AccessibilityMgr.UnblockAllInput();
+
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor hoggerActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                GameState.Get().SetBusy(busy: true);
+                HistoryManager.Get().DisableHistory();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_01_01.prefab:883391234efbde84eb99a16abd164d9d", "TUTORIAL01_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                Gameplay.Get().SetGameStateBusy(busy: false, 2.2f);
+                break;
+            case 3:
+                {
+                    int turn = GameState.Get().GetTurn();
+                    yield return new WaitForSeconds(1.5f);
+                    if (turn == GameState.Get().GetTurn())
+                    {
+                        yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47", "TUTORIAL01_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+
+                        if (GetTag(GAME_TAG.TURN) == 2 && !EndTurnButton.Get().IsInWaitingState())
+                        {
+                            ShowEndTurnBouncingArrow();
+                            yield return new WaitForSeconds(0.5f);
+                            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_6);
+                            yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                            AccessibilityMgr.UnblockAllInput();
+                            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                            yield return new WaitUntil(() => GameState.Get().GetTurn() > turn);
+                            AccessibilityMgr.ResetHelpSpeech();
+                            AccessibilityMgr.BlockAllInput(false, true);
+                        }
+                    }
+                    break;
+                }
+            case 4:
+                {
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource prevLine = GetPreloadedSound("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47");
+                    while (SoundManager.Get().IsPlaying(prevLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_20_16.prefab:7980d02c581e4174991a8066e5785666", "TUTORIAL01_JAINA_20", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_06_06_ALT.prefab:6c9ef3c501462474ab59a37b967cab6f", "TUTORIAL01_HOGGER_07", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    Vector3 position6 = jainaActor.transform.position;
+                    Vector3 position7 = new Vector3(position6.x + 3.3f, position6.y + 0.5f, position6.z - 0.85f);
+                    Notification.PopUpArrowDirection direction2 = Notification.PopUpArrowDirection.Left;
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        position7 = new Vector3(position6.x + 3f, position6.y + 0.5f, position6.z + 0.85f);
+                        direction2 = Notification.PopUpArrowDirection.LeftDown;
+                    }
+
+                    var seenHero = false;
+                    AccessibleCard cardBeingRead = null;
+                    AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), (accessibleCard) =>
+                    {
+                        seenHero = true;
+                        cardBeingRead = accessibleCard;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_0);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+                    yield return new WaitUntil(() => seenHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    // Hero has been selected at this point
+
+                    yield return new WaitForSeconds(1);
+                    var readHero = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        readHero = true;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_2);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_3_2, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                    yield return new WaitUntil(() => readHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1.5f);
+                    var seenOpponentHero = false;
+                    AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), (accessibleCard) =>
+                    {
+                        seenOpponentHero = true;
+                        cardBeingRead = accessibleCard;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_3);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_4);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_HERO_HELP);
+                    yield return new WaitUntil(() => seenOpponentHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(2);
+                    var readOpponentHero = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        readOpponentHero = true;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_5);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_3_5_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                    yield return new WaitUntil(() => readOpponentHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_JOB);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_6);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_7);
+
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 5:
+                HideFadeArrow();
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_05_05.prefab:982193e53ab81f04ba562de4b32dd39c", "TUTORIAL01_JAINA_05", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 7:
+                NotificationManager.Get().DestroyAllPopUps();
+                yield return new WaitForSeconds(1.2f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_07_07.prefab:a8bf811494e94d742a3910fac9da906f", "TUTORIAL01_JAINA_07", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                yield return new WaitForSeconds(4f);
+                if (GetTag(GAME_TAG.TURN) == 4 && EndTurnButton.Get().IsInNMPState())
+                {
+                    yield return new WaitForSeconds(1f);
+                    ShowEndTurnBouncingArrow();
+                }
+                break;
+            case 8:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_03_03.prefab:4ef21f71824b97842b33d8ebccb37ed2", "TUTORIAL01_HOGGER_05", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_21_17.prefab:c1524bd0ef92bb845b5dab48cbd017f9", "TUTORIAL01_JAINA_21", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 12:
+                yield return new WaitForSeconds(1f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_15_11.prefab:a644986d34ab8964582c6221cde54d45", "TUTORIAL01_JAINA_15", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 13:
+                while (m_jainaSpeaking)
+                {
+                    yield return null;
+                }
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_16_12.prefab:e6b4ab6fc1f11634e88f013ce5351e46", "TUTORIAL01_JAINA_16", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 14:
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_08_08_ALT.prefab:19ddb4ddaa4aee2468b17bae25da9419", "TUTORIAL01_HOGGER_08", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    Vector3 position2 = hoggerActor.transform.position;
+                    Vector3 position3 = new Vector3(position2.x + 3.3f, position2.y + 0.5f, position2.z - 1f);
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        position3 = new Vector3(position2.x + 3f, position2.y + 0.5f, position2.z - 0.75f);
+                    }
+                    Notification.PopUpArrowDirection direction = Notification.PopUpArrowDirection.Left;
+                    if (GetTag(GAME_TAG.TURN) == 6 && EndTurnButton.Get().IsInNMPState())
+                    {
+                        yield return new WaitForSeconds(9f);
+                        ShowEndTurnBouncingArrow();
+                    }
+                    break;
+                }
+            case 15:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_JAINA_02_55_ALT2.prefab:d049e67ad6c16db4da2c04be7a02a1ae", "", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 20:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_10_09.prefab:5bf553d532aca174083f48bf407b2b11", "TUTORIAL01_JAINA_10", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    yield return new WaitForSeconds(1.5f);
+                    GameState.Get().SetBusy(busy: false);
+                    List<Card> cards = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+                        .GetCards();
+                    cards[cards.Count - 1].GetActor().GetAttackObject().Jiggle();
+                    break;
+                }
+            case 22:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_09_09_ALT.prefab:70c4d2941509856448660f89d6c72b2b", "TUTORIAL01_HOGGER_02", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                Gameplay.Get().SetGameStateBusy(busy: false, 2f);
+                break;
+            case 55:
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.CONFIRM);
+                GetGameOptions().SetBooleanOption(GameEntityOption.DISABLE_TOOLTIPS, value: false);
+                Board.Get().FindCollider("DragPlane").enabled = true;
+                while (!announcerIsFinishedYapping)
+                {
+                    yield return null;
+                }
+                if (!SoundUtils.CanDetectVolume())
+                {
+                    Notification battlebegin = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 84.8f), GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_05"), "", 15f);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada", "", Notification.SpeechBubbleDirection.None, null));
+                    NotificationManager.Get().DestroyNotification(battlebegin, 0f);
+                }
+                else
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada", "", Notification.SpeechBubbleDirection.None, null));
+                }
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_01_01.prefab:5833f4aeb72110741a2c9bc3a92f9bc8", "TUTORIAL01_HOGGER_01", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                GameState.Get().SetBusy(busy: false);
+                yield return new WaitForSeconds(4f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_04_04.prefab:3e16e42edb324e2469a25363ffd013a6", "TUTORIAL01_HOGGER_06", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                break;
+            case 66:
+                {
+                    Vector3 position = new Vector3(136f, NotificationManager.DEPTH, 131f);
+                    Vector3 middleSpot = new Vector3(136f, NotificationManager.DEPTH, 80f);
+                    if (!SoundUtils.CanDetectVolume())
+                    {
+                        Notification innkeeperLine3 = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, position, GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_01"), "", 15f);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8", "", Notification.SpeechBubbleDirection.None, null));
+                        NotificationManager.Get().DestroyNotification(innkeeperLine3, 0f);
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8", "", Notification.SpeechBubbleDirection.None, null));
+                    }
+                    yield return new WaitForSeconds(0.5f);
+                    if (!SoundUtils.CanDetectVolume())
+                    {
+                        Notification innkeeperLine3 = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, middleSpot, GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_02"), "", 15f);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41", "", Notification.SpeechBubbleDirection.None, null));
+                        NotificationManager.Get().DestroyNotification(innkeeperLine3, 0f);
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41", "", Notification.SpeechBubbleDirection.None, null));
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_02_02.prefab:7f321b26431a4974a82deefc368adf63", "TUTORIAL01_HOGGER_04", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        Gameplay.Get().AddGamePlayNameBannerPhone();
+                    }
+                    announcerIsFinishedYapping = true;
+                    break;
+                }
+            default:
+                Debug.LogWarning("WARNING - Mission fired an event that we are not listening for.");
+                break;
+            case 6:
+                break;
+        }
+    }
+
+    private IEnumerator FlashMinionUntilAttackBegins(Card minionToFlash)
+    {
+        yield return new WaitForSeconds(8f);
+        Gameplay.Get().StartCoroutine(BeginFlashingMinionLoop(minionToFlash));
+    }
+
+    private IEnumerator BeginFlashingMinionLoop(Card minionToFlash)
+    {
+        if (!(minionToFlash == null) && !minionToFlash.GetEntity().IsExhausted() && minionToFlash.GetActor().GetActorStateType() != ActorStateType.CARD_IDLE && minionToFlash.GetActor().GetActorStateType() != ActorStateType.CARD_MOUSE_OVER)
+        {
+            minionToFlash.GetActorSpell(SpellType.WIGGLE).Activate();
+            yield return new WaitForSeconds(1.5f);
+            Gameplay.Get().StartCoroutine(BeginFlashingMinionLoop(minionToFlash));
+        }
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    private void ShowDontFireballYourselfPopup(Vector3 origin)
+    {
+        AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_07);
+    }
+
+    public override bool ShouldDoAlternateMulliganIntro()
+    {
+        return true;
+    }
+
+    public override bool DoAlternateMulliganIntro()
+    {
+        AssetLoader.Get().InstantiatePrefab("GameOpen_Pack.prefab:fca6ae094e9a74644b00fc9029f304c3", PackLoadedCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
+        return true;
+    }
+
+    private void PackLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        MusicManager.Get().StartPlaylist(MusicPlaylistType.Misc_Tutorial01);
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        Card heroCard2 = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
+        startingPack = go;
+        Transform transform = SceneUtils.FindChildBySubstring(startingPack, "Hero_Dummy").transform;
+        heroCard.transform.parent = transform;
+        heroCard.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        heroCard.transform.localPosition = new Vector3(0f, 0f, 0f);
+        SceneUtils.SetLayer(heroCard.GetActor().GetRootObject(), GameLayer.IgnoreFullScreenEffects);
+        Transform transform2 = SceneUtils.FindChildBySubstring(startingPack, "HeroEnemy_Dummy").transform;
+        heroCard2.transform.parent = transform2;
+        heroCard2.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        heroCard2.transform.localPosition = new Vector3(0f, 0f, 0f);
+        heroCard.SetDoNotSort(on: true);
+        Transform transform3 = Board.Get().FindBone("Tutorial1HeroStart");
+        go.transform.position = transform3.position;
+        heroCard.GetActor().GetHealthObject().Hide();
+        heroCard2.GetActor().GetHealthObject().Hide();
+        heroCard2.GetActor().Hide();
+        heroCard.GetActor().Hide();
+        SceneMgr.Get().NotifySceneLoaded();
+        Gameplay.Get().StartCoroutine(UpdatePresence());
+        Gameplay.Get().StartCoroutine(ShowPackOpeningArrow(transform3.position));
+    }
+
+    private IEnumerator UpdatePresence()
+    {
+        while (LoadingScreen.Get().IsPreviousSceneActive() || LoadingScreen.Get().IsFadingOut())
+        {
+            yield return null;
+        }
+        GameMgr.Get().UpdatePresence();
+    }
+
+    private IEnumerator ShowPackOpeningArrow(Vector3 packSpot)
+    {
+        yield return new WaitForSeconds(4f);
+        if (!packOpened)
+        {
+            AccessibleGameplay.Get().StopHidingMouse();
+            var packHovered = false;
+            AccessibilityMgr.WaitForForcedKey(AccessibleKey.CONFIRM, () => {
+                AccessibleInputMgr.MoveMouseToWorldPosition(packSpot);
+                packHovered = true;
+            });
+
+            AccessibilityMgr.BlockAllInput(false, true);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.WELCOME_TO_HEARTHSTONE);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_INTRO);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_HELP_KEYS);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_INTRO_END);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_FREE_STARTING_PACK);
+            AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_FREE_STARTING_PACK, AccessibleKey.CONFIRM);
+            yield return new WaitUntil(() => packHovered);
+            yield return new WaitForSeconds(2);
+            AccessibleInputMgr.ClickLeftMouseButton();
+            AccessibleGameplay.Get().StartHidingMouse();
+            AccessibilityMgr.BlacklistKeys(AccessibleKey.CONFIRM);
+        }
+    }
+
+    public override void NotifyOfGamePackOpened()
+    {
+        packOpened = true;
+    }
+
+    public override void NotifyOfCustomIntroFinished()
+    {
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        Card heroCard2 = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
+        heroCard.SetDoNotSort(on: false);
+        heroCard2.GetActor().TurnOnCollider();
+        heroCard.GetActor().TurnOnCollider();
+        heroCard.transform.parent = null;
+        heroCard2.transform.parent = null;
+        SceneUtils.SetLayer(heroCard.GetActor().GetRootObject(), GameLayer.CardRaycast);
+        Gameplay.Get().StartCoroutine(ContinueFinishingCustomIntro());
+    }
+
+    private IEnumerator ContinueFinishingCustomIntro()
+    {
+        yield return new WaitForSeconds(3f);
+        Object.Destroy(startingPack);
+        GameState.Get().SetBusy(busy: false);
+        MulliganManager.Get().SkipMulligan();
+    }
+
+    public override bool ShouldShowBigCard()
+    {
+        return GetTag(GAME_TAG.TURN) > 8;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        PlaySound("VO_TUTORIAL_01_JAINA_13_10.prefab:b13670e36c248e141837c4eb0645a000");
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_023", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs
new file mode 100644
index 0000000..4df1957
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs
@@ -0,0 +1,495 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_02 : TutorialEntity
+{
+    private Notification endTurnNotifier;
+
+    private Notification manaNotifier;
+
+    private Notification manaNotifier2;
+
+    private GameObject costLabel;
+
+    private int numManaThisTurn = 1;
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_02_05.prefab:d1334881818e67d4c85216afa56226d6");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_01_04.prefab:5b48a6d28da46464ea99c7b278f63226");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_04_07.prefab:a804332a9a314af49b35d1c6d4a1f306");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_05_08.prefab:946dc71f989978844af5222d4342df4c");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_07_10.prefab:ffdc387467735484390ee8545698c57e");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_11_14.prefab:ada9c4aef7cd8dc418005c0a4c5f578d");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_13_16.prefab:80757414dc5a3b54b9cfc328ce2b7f6c");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_15_17.prefab:973e26c00c354b24595965035e8efba7");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_06_09.prefab:04bd4efe66a93bb438327216a4254560");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_03_06.prefab:c509f7e0eca4fb84dbf9be77a7ed5823");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_10_13.prefab:a22defa2f9b5ec242a1f4e502d9349eb");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+        PreloadSound("VO_TUTORIAL_02_JAINA_08_22.prefab:52cd86a7a20daeb4b8d1f3fd2647e9ea");
+        PreloadSound("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_19_21.prefab:bc8b4236bf74f1244afa49a8195c7f74");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.MILLHOUSE_COMPLETE);
+                PlaySound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        if (GameState.Get().IsFriendlySidePlayerTurn())
+        {
+            numManaThisTurn++;
+        }
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 1:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_02_HELP_01);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MILLHOUSE_SEE_MANA_HELP);
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return new WaitForSeconds(0.5f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_04_07.prefab:a804332a9a314af49b35d1c6d4a1f306", "TUTORIAL02_MILLHOUSE_04", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                yield return new WaitForSeconds(0.3f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_05_08.prefab:946dc71f989978844af5222d4342df4c", "TUTORIAL02_MILLHOUSE_05", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 3:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_03);
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 4:
+                {
+                    if (manaNotifier2 != null)
+                    {
+                        NotificationManager.Get().DestroyNotification(manaNotifier2, 0f);
+                    }
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource previousLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00");
+                    while (SoundManager.Get().IsPlaying(previousLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_07_10.prefab:ffdc387467735484390ee8545698c57e", "TUTORIAL02_MILLHOUSE_07", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 6:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_11_14.prefab:ada9c4aef7cd8dc418005c0a4c5f578d", "TUTORIAL02_MILLHOUSE_11", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 8:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_13_16.prefab:80757414dc5a3b54b9cfc328ce2b7f6c", "TUTORIAL02_MILLHOUSE_13", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 9:
+                yield return new WaitForSeconds(0.5f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_15_17.prefab:973e26c00c354b24595965035e8efba7", "TUTORIAL02_MILLHOUSE_15", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 10:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource comeOnLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8");
+                    while (SoundManager.Get().IsPlaying(comeOnLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_06_09.prefab:04bd4efe66a93bb438327216a4254560", "TUTORIAL02_MILLHOUSE_06", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return new WaitForSeconds(1.5f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_03_06.prefab:c509f7e0eca4fb84dbf9be77a7ed5823", "TUTORIAL02_MILLHOUSE_03", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                yield return new WaitForSeconds(4f);
+                if (GetTag(GAME_TAG.TURN) == 1 && !EndTurnButton.Get().IsInWaitingState())
+                {
+                    ShowEndTurnBouncingArrow();
+                }
+                break;
+            case 3:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00", "TUTORIAL02_MILLHOUSE_17", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 4:
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7", "TUTORIAL02_MILLHOUSE_08", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2", "TUTORIAL02_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac", "TUTORIAL02_MILLHOUSE_09", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 5:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource feelslikeLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7");
+                    while (SoundManager.Get().IsPlaying(feelslikeLine))
+                    {
+                        yield return null;
+                    }
+                    AudioSource whatLine = GetPreloadedSound("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2");
+                    while (SoundManager.Get().IsPlaying(whatLine))
+                    {
+                        yield return null;
+                    }
+                    AudioSource winngingLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac");
+                    while (SoundManager.Get().IsPlaying(winngingLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_10_13.prefab:a22defa2f9b5ec242a1f4e502d9349eb", "TUTORIAL02_MILLHOUSE_10", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 6:
+                if (EndTurnButton.Get().IsInNMPState())
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8", "TUTORIAL02_MILLHOUSE_16", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                }
+                break;
+            case 54:
+                yield return new WaitForSeconds(2f);
+                var tutorialStartDialog = ShowTutorialDialog("TUTORIAL02_HELP_06", "TUTORIAL02_HELP_07", "TUTORIAL01_HELP_16", new Vector2(0.5f, 0f));
+                tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_06);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_07);
+                tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                break;
+            case 55:
+                FadeInHeroActor(millhouseActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_02_05.prefab:d1334881818e67d4c85216afa56226d6", "TUTORIAL02_MILLHOUSE_02", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                HistoryManager.Get().DisableHistory();
+                MulliganManager.Get().BeginMulligan();
+                yield return new WaitForSeconds(1.1f);
+                FadeOutHeroActor(millhouseActor);
+                break;
+        }
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (mousedOverEntity.GetZone() == TAG_ZONE.HAND && GetTag(GAME_TAG.TURN) <= 7)
+        {
+            AssetLoader.Get().InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, mousedOverEntity.GetCard(), AssetLoadingOptions.IgnorePrefabPosition);
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+    }
+
+    public override void NotifyOfCoinFlipResult()
+    {
+        Gameplay.Get().StartCoroutine(HandleCoinFlip());
+    }
+
+    private IEnumerator HandleCoinFlip()
+    {
+        GameState.Get().SetBusy(busy: true);
+        yield return new WaitForSeconds(3.5f);
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        FadeInHeroActor(millhouseActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_01_04.prefab:5b48a6d28da46464ea99c7b278f63226", "TUTORIAL02_MILLHOUSE_01", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+        GameState.Get().SetBusy(busy: false);
+        yield return new WaitForSeconds(0.175f);
+        FadeOutHeroActor(millhouseActor);
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null)
+        {
+            if (!optionsPacket.HasValidOption())
+            {
+                NotificationManager.Get().DestroyAllArrows();
+                return true;
+            }
+            bool flag = false;
+            for (int i = 0; i < optionsPacket.List.Count; i++)
+            {
+                Network.Options.Option option = optionsPacket.List[i];
+                if (option.Main.PlayErrorInfo.IsValid() && option.Type == Network.Options.Option.OptionType.POWER && !(GameState.Get().GetEntity(option.Main.ID).GetCardId() == "TU5_CS2_025"))
+                {
+                    flag = true;
+                    break;
+                }
+            }
+            if (!flag)
+            {
+                return true;
+            }
+        }
+        if (endTurnNotifier != null)
+        {
+            NotificationManager.Get().DestroyNotificationNowWithNoAnim(endTurnNotifier);
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN_ATK";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    public override string[] NotifyOfKeywordHelpPanelDisplay(Entity entity)
+    {
+        if (entity.GetCardId() == "CS2_122")
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_RAID_LEADER_DESCRIPTION);
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL_RAID_LEADER_HEADLINE"),
+                GameStrings.Get("TUTORIAL_RAID_LEADER_DESCRIPTION")
+            };
+        }
+        if (entity.GetCardId() == "TU5_CS2_023")
+        {
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL_ARCANE_INTELLECT_HEADLINE"),
+                GameStrings.Get("TUTORIAL_ARCANE_INTELLECT_DESCRIPTION")
+            };
+        }
+        return null;
+    }
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (entity.GetCardId() == "TU5_CS2_023" && GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources() >= entity.GetCost())
+        {
+            BoardTutorial.Get().EnableFullHighlight(enable: true);
+        }
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        if (entity.GetCardId() == "TU5_CS2_023")
+        {
+            BoardTutorial.Get().EnableFullHighlight(enable: false);
+        }
+    }
+
+    public override void NotifyOfManaCrystalSpawned()
+    {
+        AssetLoader.Get().InstantiatePrefab("plus1.prefab:7427d28c07eea8645a3308e04398ee30", Plus1ActorLoadedCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
+        if (GetTag(GAME_TAG.TURN) == 3)
+        {
+            Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+                .GetCard()
+                .GetActor();
+            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_02_JAINA_08_22.prefab:52cd86a7a20daeb4b8d1f3fd2647e9ea", "TUTORIAL02_JAINA_08", Notification.SpeechBubbleDirection.BottomLeft, actor));
+        }
+        FadeInManaSpotlight();
+    }
+
+    private void FadeInManaSpotlight()
+    {
+        Gameplay.Get().StartCoroutine(StartManaSpotFade());
+    }
+
+    private IEnumerator StartManaSpotFade()
+    {
+        Light manaSpot = BoardTutorial.Get().m_ManaSpotlight;
+        manaSpot.enabled = true;
+        manaSpot.spotAngle = 179f;
+        manaSpot.intensity = 0f;
+        float TARGET_INTENSITY = 0.6f;
+        while (manaSpot.intensity < TARGET_INTENSITY * 0.95f)
+        {
+            manaSpot.intensity = Mathf.Lerp(manaSpot.intensity, TARGET_INTENSITY, Time.deltaTime * 5f);
+            manaSpot.spotAngle = Mathf.Lerp(manaSpot.spotAngle, 80f, Time.deltaTime * 5f);
+            yield return null;
+        }
+        yield return new WaitForSeconds(2f);
+        while (manaSpot.intensity > 0.05f)
+        {
+            manaSpot.intensity = Mathf.Lerp(manaSpot.intensity, 0f, Time.deltaTime * 10f);
+            yield return null;
+        }
+        manaSpot.enabled = false;
+    }
+
+    private void Plus1ActorLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        Vector3 position = SceneUtils.FindChildBySubstring(Board.Get().gameObject, "ManaCounter_Friendly").transform.position;
+        Vector3 position2 = new Vector3(position.x - 0.02f, position.y + 0.2f, position.z);
+        go.transform.position = position2;
+        go.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
+        Vector3 localScale = go.transform.localScale;
+        go.transform.localScale = new Vector3(1f, 1f, 1f);
+        iTween.MoveTo(go, new Vector3(position2.x, position2.y, position2.z + 2f), 3f);
+        float num = 2.5f;
+        iTween.ScaleTo(go, new Vector3(localScale.x * num, localScale.y * num, localScale.z * num), 3f);
+        iTween.RotateTo(go, new Vector3(0f, 170f, 0f), 3f);
+        iTween.FadeTo(go, 0f, 2.75f);
+    }
+
+    public override void NotifyOfEnemyManaCrystalSpawned()
+    {
+        AssetLoader.Get().InstantiatePrefab("plus1.prefab:7427d28c07eea8645a3308e04398ee30", Plus1ActorLoadedCallbackEnemy, null, AssetLoadingOptions.IgnorePrefabPosition);
+    }
+
+    private void Plus1ActorLoadedCallbackEnemy(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        Vector3 position = SceneUtils.FindChildBySubstring(Board.Get().gameObject, "ManaCounter_Opposing").transform.position;
+        Vector3 position2 = new Vector3(position.x, position.y + 0.2f, position.z);
+        go.transform.position = position2;
+        go.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
+        Vector3 localScale = go.transform.localScale;
+        go.transform.localScale = new Vector3(1f, 1f, 1f);
+        iTween.MoveTo(go, new Vector3(position2.x, position2.y, position2.z - 2f), 3f);
+        float num = 2.5f;
+        iTween.ScaleTo(go, new Vector3(localScale.x * num, localScale.y * num, localScale.z * num), 3f);
+        iTween.RotateTo(go, new Vector3(0f, 170f, 0f), 3f);
+        iTween.FadeTo(go, 0f, 2.75f);
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+        if (costTextObject == null)
+        {
+            Object.Destroy(go);
+            return;
+        }
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+        costLabel = go;
+        go.transform.parent = costTextObject.transform;
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localPosition = new Vector3(-0.025f, 0.28f, 0f);
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+    }
+
+    public override void NotifyOfTooltipZoneMouseOver(TooltipZone tooltip)
+    {
+        if (tooltip.targetObject.GetComponent<ManaCrystalMgr>() != null)
+        {
+            if (manaNotifier != null)
+            {
+                Object.Destroy(manaNotifier.gameObject);
+            }
+            if (manaNotifier2 != null)
+            {
+                Object.Destroy(manaNotifier2.gameObject);
+            }
+        }
+    }
+
+    public override string GetTurnStartReminderText()
+    {
+        return GameStrings.Format("TUTORIAL02_HELP_04", numManaThisTurn);
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        Gameplay.Get().StartCoroutine(PlayGoingOutSound());
+    }
+
+    private IEnumerator PlayGoingOutSound()
+    {
+        AudioSource deathLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+        while (deathLine != null && deathLine.isPlaying)
+        {
+            yield return null;
+        }
+        PlaySound("VO_TUTORIAL02_MILLHOUSE_19_21.prefab:bc8b4236bf74f1244afa49a8195c7f74");
+    }
+
+    protected override void NotifyOfManaError()
+    {
+        NotificationManager.Get().DestroyNotificationNowWithNoAnim(manaNotifier);
+        NotificationManager.Get().DestroyNotificationNowWithNoAnim(manaNotifier2);
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("EX1_015", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs
new file mode 100644
index 0000000..f4bd683
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs
@@ -0,0 +1,389 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_03 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private int numTauntGorillasPlayed;
+
+    private bool enemyPlayedBigBrother;
+
+    private bool needATaunterVOPlayed;
+
+    private bool monkeyLinePlayedOnce;
+
+    private bool defenselessVoPlayed;
+
+    private bool seenTheBrother;
+
+    private bool warnedAgainstAttackingGorilla;
+
+    private bool victory;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool>
+        {
+            {
+                GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN,
+                false
+            },
+            {
+                GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+                true
+            },
+            {
+                GameEntityOption.SHOW_CRAZY_KEYWORD_TOOLTIP,
+                true
+            }
+        };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_03()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_03_JAINA_17_33.prefab:b96f78fff7ab94a42894930d51bd45bd");
+        PreloadSound("VO_TUTORIAL_03_JAINA_18_34.prefab:b9a2a99d30893804790829b3ceabc9b8");
+        PreloadSound("VO_TUTORIAL_03_JAINA_01_24.prefab:b9515cf173f876a458202c6092055709");
+        PreloadSound("VO_TUTORIAL_03_JAINA_05_25.prefab:38e2d64610e757245877b8f8e2f68584");
+        PreloadSound("VO_TUTORIAL_03_JAINA_07_26.prefab:e93d67263c3d99740aaa4acc4b7d87a4");
+        PreloadSound("VO_TUTORIAL_03_JAINA_12_28.prefab:d30f0c732643aa74aba9ec4cf2c2e6dd");
+        PreloadSound("VO_TUTORIAL_03_JAINA_13_29.prefab:efca9c5305a101e4d968d08e58061cda");
+        PreloadSound("VO_TUTORIAL_03_JAINA_16_32.prefab:b05bea699e2f897478c81a485a7d1a1a");
+        PreloadSound("VO_TUTORIAL_03_JAINA_14_30.prefab:0787881bd0a25a342ba06f566f16051b");
+        PreloadSound("VO_TUTORIAL_03_JAINA_15_31.prefab:4e0f1eaa19e283a4cac77219e1f10fe3");
+        PreloadSound("VO_TUTORIAL_03_JAINA_20_36.prefab:79671f155307aa24a89b0581e4c5c4b2");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_01_01.prefab:3f6638f7f0d96da4ca422a290035c97a");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_03_03.prefab:5018131495f68c247bac073424fab700");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_04_04.prefab:0e4a4c87ac994c845b06230a34b168f9");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_05_05.prefab:8c12c75976cdfe044ad8ff3dd14ae5b8");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_06_06.prefab:8ed0c9ff5d18314469821d5be3d62dc7");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.MUKLA_COMPLETE);
+                PlaySound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.MUKLA_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (enemyPlayedBigBrother)
+        {
+            if (GameState.Get().IsFriendlySidePlayerTurn())
+            {
+                if (GameState.Get().GetNumEnemyMinionsInPlay(includeUntouchables: false) > 0)
+                {
+                    if (!needATaunterVOPlayed)
+                    {
+                        if (!GameState.Get().GetFriendlySidePlayer().HasATauntMinion())
+                        {
+                            needATaunterVOPlayed = true;
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_17_33.prefab:b96f78fff7ab94a42894930d51bd45bd", "TUTORIAL03_JAINA_17", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                        }
+                        yield break;
+                    }
+                    if (!defenselessVoPlayed)
+                    {
+                        bool flag = true;
+                        foreach (Card card in GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+                            .GetCards())
+                        {
+                            if (card.GetEntity().HasTaunt())
+                            {
+                                flag = false;
+                            }
+                        }
+                        if (flag)
+                        {
+                            defenselessVoPlayed = true;
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_18_34.prefab:b9a2a99d30893804790829b3ceabc9b8", "TUTORIAL03_JAINA_18", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                        }
+                    }
+                }
+            }
+            else if (!seenTheBrother)
+            {
+                Gameplay.Get().StartCoroutine(GetReadyForBro());
+            }
+        }
+        switch (turn)
+        {
+            case 1:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_01_24.prefab:b9515cf173f876a458202c6092055709", "TUTORIAL03_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                break;
+            case 5:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_05_25.prefab:38e2d64610e757245877b8f8e2f68584", "TUTORIAL03_JAINA_05", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_03_03.prefab:5018131495f68c247bac073424fab700", "TUTORIAL03_MUKLA_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 6:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_04_04.prefab:0e4a4c87ac994c845b06230a34b168f9", "TUTORIAL03_MUKLA_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 9:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_07_26.prefab:e93d67263c3d99740aaa4acc4b7d87a4", "TUTORIAL03_JAINA_07", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                break;
+            case 14:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_05_05.prefab:8c12c75976cdfe044ad8ff3dd14ae5b8", "TUTORIAL03_MUKLA_05", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    private IEnumerator GetReadyForBro()
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        seenTheBrother = true;
+        GameState.Get().SetBusy(busy: true);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_12_28.prefab:d30f0c732643aa74aba9ec4cf2c2e6dd", "TUTORIAL03_JAINA_12", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+        GameState.Get().SetBusy(busy: false);
+        yield return new WaitForSeconds(3.2f);
+        Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_13_29.prefab:efca9c5305a101e4d968d08e58061cda", "TUTORIAL03_JAINA_13", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                AssetLoader.Get().InstantiatePrefab("TutorialKeywordManager.prefab:c1276fda3e1df594990295731f80c9c2", AssetLoadingOptions.IgnorePrefabPosition);
+                break;
+            case 4:
+                numTauntGorillasPlayed++;
+                if (numTauntGorillasPlayed == 1)
+                {
+                    Gameplay.Get().StartCoroutine(ShowTauntPopup());
+                }
+                else if (numTauntGorillasPlayed == 2 && !DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_06_06.prefab:8ed0c9ff5d18314469821d5be3d62dc7", "TUTORIAL03_MUKLA_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 10:
+                enemyPlayedBigBrother = true;
+                Gameplay.Get().StartCoroutine(AdjustBigBrotherTransform());
+                if (!GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    Gameplay.Get().StartCoroutine(GetReadyForBro());
+                }
+                break;
+            case 11:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_16_32.prefab:b05bea699e2f897478c81a485a7d1a1a", "TUTORIAL03_JAINA_16", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                break;
+            case 12:
+                if (!monkeyLinePlayedOnce)
+                {
+                    monkeyLinePlayedOnce = true;
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_14_30.prefab:0787881bd0a25a342ba06f566f16051b", "TUTORIAL03_JAINA_14", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                else if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_15_31.prefab:4e0f1eaa19e283a4cac77219e1f10fe3", "TUTORIAL03_JAINA_15", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                break;
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    string bodyTextGameString = "TUTORIAL03_HELP_03";
+                    if (UniversalInputManager.Get().IsTouchMode())
+                    {
+                        bodyTextGameString = "TUTORIAL03_HELP_03_TOUCH";
+                    }
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL03_HELP_02", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0.5f, 0.5f));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START_B);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START_C);
+                    break;
+                }
+            case 55:
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_01_01.prefab:3f6638f7f0d96da4ca422a290035c97a", "TUTORIAL03_MUKLA_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                MulliganManager.Get().BeginMulligan();
+                FadeOutHeroActor(enemyActor);
+                break;
+        }
+    }
+
+    private IEnumerator ShowTauntPopup()
+    {
+        Card gorillaCard = null;
+        while (gorillaCard == null)
+        {
+            gorillaCard = FindCardInEnemyBattlefield("TU5_CS2_127");
+            if (gorillaCard != null)
+            {
+                break;
+            }
+            yield return null;
+        }
+        while (!gorillaCard.IsActorReady())
+        {
+            yield return null;
+        }
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP);
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP_B);
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP_C);
+    }
+
+    private IEnumerator AdjustBigBrotherTransform()
+    {
+        ZonePlay enemyBattlefield = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+        Vector3 prevBattlefieldScale = enemyBattlefield.transform.localScale;
+        enemyBattlefield.transform.localScale = 1.6f * enemyBattlefield.transform.localScale;
+        Vector3 position = enemyBattlefield.transform.position;
+        enemyBattlefield.transform.position = new Vector3(position.x + 2.3931637f, position.y, position.z + 0.7f);
+        Card bigBrotherCard = null;
+        while (bigBrotherCard == null)
+        {
+            bigBrotherCard = FindCardInEnemyBattlefield("TU4c_007");
+            if (bigBrotherCard != null)
+            {
+                break;
+            }
+            yield return null;
+        }
+        while (!bigBrotherCard.IsActorReady())
+        {
+            yield return null;
+        }
+        Actor actor = bigBrotherCard.GetActor();
+        Transform parent = actor.transform.parent;
+        Vector3 localScale = actor.transform.localScale;
+        actor.transform.parent = null;
+        bigBrotherCard.transform.localScale = prevBattlefieldScale;
+        GameObject gameObject = new GameObject();
+        gameObject.transform.parent = parent;
+        gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
+        gameObject.transform.localScale = new Vector3(1.6f, 1.6f, 1.6f);
+        actor.transform.parent = gameObject.transform;
+        actor.transform.localScale = localScale;
+        enemyBattlefield.transform.localScale = prevBattlefieldScale;
+    }
+
+    private Card FindCardInEnemyBattlefield(string cardId)
+    {
+        ZonePlay battlefieldZone = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+        for (int i = 0; i < battlefieldZone.GetCardCount(); i++)
+        {
+            Card cardAtIndex = battlefieldZone.GetCardAtIndex(i);
+            if (!(cardAtIndex.GetEntity().GetCardId() != cardId))
+            {
+                return cardAtIndex;
+            }
+        }
+        return null;
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        GetGameOptions().SetBooleanOption(GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN, value: false);
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (mousedOverEntity.HasTaunt())
+        {
+            GetGameOptions().SetBooleanOption(GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN, value: true);
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (!base.NotifyOfBattlefieldCardClicked(clickedEntity, wasInTargetMode))
+        {
+            return false;
+        }
+        if (wasInTargetMode && clickedEntity.GetCardId() == "TU4c_007" && !warnedAgainstAttackingGorilla)
+        {
+            warnedAgainstAttackingGorilla = true;
+            HandleMissionEvent(11);
+            return false;
+        }
+        return true;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (victory)
+        {
+            PlaySound("VO_TUTORIAL_03_JAINA_20_36.prefab:79671f155307aa24a89b0581e4c5c4b2");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_022", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs
new file mode 100644
index 0000000..e129991
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs
@@ -0,0 +1,641 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_04 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification endTurnNotifier;
+
+    private Notification handBounceArrow;
+
+    private Notification sheepTheBog;
+
+    private Notification noSheepPopup;
+
+    private int numBeastsPlayed;
+
+    private GameObject m_heroPowerCostLabel;
+
+    private Notification heroPowerHelp;
+
+    private bool victory;
+
+    private bool m_hemetSpeaking;
+
+    private int numComplaintsMade;
+
+    private bool m_shouldSignalPolymorph;
+
+    private bool m_isPolymorphGrabbed;
+
+    private bool m_isBogSheeped;
+
+    private bool m_playOneHealthCommentNextTurn;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_04()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+        PreloadSound("VO_TUTORIAL04_HEMET_15_13.prefab:c0da1267215708947a954e9c0ea1b061");
+        PreloadSound("VO_TUTORIAL04_HEMET_20_18.prefab:5d49a0bac4c03b94e9e13945624a581b");
+        PreloadSound("VO_TUTORIAL04_HEMET_16_14.prefab:df368c7075e4a2649803729f7b86601e");
+        PreloadSound("VO_TUTORIAL04_HEMET_13_12.prefab:fe14ab273aa4b7e4491f30310a7d0eca");
+        PreloadSound("VO_TUTORIAL04_HEMET_19_17.prefab:b9d5bd30659aae84b8a1380cbdba0398");
+        PreloadSound("VO_TUTORIAL_04_JAINA_09_43.prefab:1ee05d74948aba04ebd7065e44813921");
+        PreloadSound("VO_TUTORIAL_04_JAINA_10_44.prefab:6f5921db1071ead4585c8cc9689d22ea");
+        PreloadSound("VO_TUTORIAL04_HEMET_06_05.prefab:2527939914db3e543941a13266e88a01");
+        PreloadSound("VO_TUTORIAL04_HEMET_07_06_ALT.prefab:c19475ec3c3b0e648a97f423e0e86143");
+        PreloadSound("VO_TUTORIAL_04_JAINA_04_40.prefab:5bfc80c6184279140878a51eb1fa3469");
+        PreloadSound("VO_TUTORIAL04_HEMET_08_07.prefab:68207d2681a60c84d840d37c4b90740f");
+        PreloadSound("VO_TUTORIAL04_HEMET_09_08.prefab:2994b6b35f2e5f54782b6100ea92f40e");
+        PreloadSound("VO_TUTORIAL04_HEMET_10_09.prefab:3282099b41c7ab94aa99e84c20dd7db7");
+        PreloadSound("VO_TUTORIAL04_HEMET_11_10.prefab:db8c8cea0db51d14fbd5d4c782b8b160");
+        PreloadSound("VO_TUTORIAL04_HEMET_12_11.prefab:b0ea652d6f1ec6845845226680ade252");
+        PreloadSound("VO_TUTORIAL04_HEMET_12_11_ALT.prefab:b59f55e14876bee43a0d9ab4b7317f84");
+        PreloadSound("VO_TUTORIAL_04_JAINA_08_42.prefab:36763b11766e2b64198719d44b0fa8bf");
+        PreloadSound("VO_TUTORIAL04_HEMET_01_01.prefab:89be0839b16c1244a9221b373fd8fb61");
+        PreloadSound("VO_TUTORIAL_04_JAINA_01_37.prefab:c7fc40d1595ca3c49b524b9929264477");
+        PreloadSound("VO_TUTORIAL04_HEMET_02_02.prefab:c3ca1337cb01efe4194899d42918f80c");
+        PreloadSound("VO_TUTORIAL04_HEMET_03_03.prefab:b014c684c85f1c440bed5560c6b6dbf5");
+        PreloadSound("VO_TUTORIAL_04_JAINA_02_38.prefab:83b64d5eeb884db43b9fa5f20316da2c");
+        PreloadSound("VO_TUTORIAL04_HEMET_04_04_ALT.prefab:bb3fadd78adce274993862115f3c5137");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        if (m_heroPowerCostLabel != null)
+        {
+            Object.Destroy(m_heroPowerCostLabel);
+        }
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.NESINGWARY_COMPLETE);
+                PlaySound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.NESINGWARY_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        m_shouldSignalPolymorph = false;
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (m_playOneHealthCommentNextTurn)
+        {
+            m_playOneHealthCommentNextTurn = false;
+            GameState.Get().SetBusy(busy: true);
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_08_42.prefab:36763b11766e2b64198719d44b0fa8bf", "TUTORIAL04_JAINA_08", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+            GameState.Get().SetBusy(busy: false);
+        }
+        switch (turn)
+        {
+            case 1:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_15_13.prefab:c0da1267215708947a954e9c0ea1b061", "TUTORIAL04_HEMET_15", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 4:
+                {
+                    yield return new WaitForSeconds(1f);
+                    GameState.Get().SetBusy(busy: true);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return new WaitForSeconds(1f);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP_B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP_C);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_TRY_IT_OUT);
+                    AccessibilityMgr.UnblockAllInput();
+                    GameState.Get().SetBusy(busy: false);
+
+                    AssetLoader.Get().InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard(), AssetLoadingOptions.IgnorePrefabPosition);
+                    break;
+                }
+            case 5:
+                NotificationManager.Get().DestroyNotification(heroPowerHelp, 0f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_20_18.prefab:5d49a0bac4c03b94e9e13945624a581b", "TUTORIAL04_HEMET_20", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+            case 7:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_16_14.prefab:df368c7075e4a2649803729f7b86601e", "TUTORIAL04_HEMET_16", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 9:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_13_12.prefab:fe14ab273aa4b7e4491f30310a7d0eca", "TUTORIAL04_HEMET_13", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 11:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().SetGameStateBusy(busy: false, 3f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_19_17.prefab:b9d5bd30659aae84b8a1380cbdba0398", "TUTORIAL04_HEMET_19", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                yield return new WaitForSeconds(0.7f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_09_43.prefab:1ee05d74948aba04ebd7065e44813921", "TUTORIAL04_JAINA_09", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 12:
+                {
+                    if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                    {
+                        break;
+                    }
+                    m_shouldSignalPolymorph = true;
+                    List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                        .GetCards();
+                    if (!(InputManager.Get().GetHeldCard() == null))
+                    {
+                        break;
+                    }
+                    Card card = null;
+                    foreach (Card item in cards)
+                    {
+                        if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+                        {
+                            card = item;
+                        }
+                    }
+                    if (!(card == null) && !card.IsMousedOver())
+                    {
+                        Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0f));
+                    }
+                    break;
+                }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_06_05.prefab:2527939914db3e543941a13266e88a01", "TUTORIAL04_HEMET_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_07_06_ALT.prefab:c19475ec3c3b0e648a97f423e0e86143", "TUTORIAL04_HEMET_07", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                yield return Gameplay.Get().StartCoroutine(Wait(1f));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 3:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(Wait(2f));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 4:
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    InputManager.Get().GetFriendlyHand().SetHandEnlarged(enlarged: false);
+                }
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_04_40.prefab:5bfc80c6184279140878a51eb1fa3469", "TUTORIAL04_JAINA_04", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 5:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    switch (numBeastsPlayed)
+                    {
+                        case 0:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_08_07.prefab:68207d2681a60c84d840d37c4b90740f", "TUTORIAL04_HEMET_08", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 1:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_09_08.prefab:2994b6b35f2e5f54782b6100ea92f40e", "TUTORIAL04_HEMET_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 2:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_10_09.prefab:3282099b41c7ab94aa99e84c20dd7db7", "TUTORIAL04_HEMET_10", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 3:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_11_10.prefab:db8c8cea0db51d14fbd5d4c782b8b160", "TUTORIAL04_HEMET_11", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                    }
+                    numBeastsPlayed++;
+                }
+                break;
+            case 6:
+                if (numComplaintsMade == 0)
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_12_11.prefab:b0ea652d6f1ec6845845226680ade252", "TUTORIAL04_HEMET_12a", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    numComplaintsMade++;
+                }
+                else
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_12_11_ALT.prefab:b59f55e14876bee43a0d9ab4b7317f84", "TUTORIAL04_HEMET_12b", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 7:
+                m_playOneHealthCommentNextTurn = true;
+                break;
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE));
+                    string bodyTextGameString = flag? "TUTORIAL04_HELP_15" : "TUTORIAL04_HELP_16";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL04_HELP_14", bodyTextGameString, "TUTORIAL01_HELP_16", Vector2.zero, swapMaterial: true);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL04_HELP_14);
+                    yield return AccessibilityMgr.Narrate(flag? AccessibleSpeech.TUTORIAL04_HELP_15 : AccessibleSpeech.TUTORIAL04_HELP_16);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_01_01.prefab:89be0839b16c1244a9221b373fd8fb61", "TUTORIAL04_HEMET_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    FadeInHeroActor(jainaActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_01_37.prefab:c7fc40d1595ca3c49b524b9929264477", "TUTORIAL04_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    FadeOutHeroActor(jainaActor);
+                    yield return new WaitForSeconds(0.5f);
+                }
+                MulliganManager.Get().BeginMulligan();
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    m_hemetSpeaking = true;
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_02_02.prefab:c3ca1337cb01efe4194899d42918f80c", "TUTORIAL04_HEMET_02", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    m_hemetSpeaking = false;
+                }
+                break;
+        }
+    }
+
+    public override void NotifyOfCoinFlipResult()
+    {
+        Gameplay.Get().StartCoroutine(HandleCoinFlip());
+    }
+
+    private IEnumerator HandleCoinFlip()
+    {
+        GameState.Get().SetBusy(busy: true);
+        yield return Gameplay.Get().StartCoroutine(Wait(1f));
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        while (m_hemetSpeaking)
+        {
+            yield return null;
+        }
+        FadeInHeroActor(enemyActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_03_03.prefab:b014c684c85f1c440bed5560c6b6dbf5", "TUTORIAL04_HEMET_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+        FadeOutHeroActor(enemyActor);
+        yield return new WaitForSeconds(0.3f);
+        FadeInHeroActor(jainaActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_02_38.prefab:83b64d5eeb884db43b9fa5f20316da2c", "TUTORIAL04_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+        FadeOutHeroActor(jainaActor);
+        yield return new WaitForSeconds(0.25f);
+        if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+        {
+            FadeInHeroActor(enemyActor);
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_04_04_ALT.prefab:bb3fadd78adce274993862115f3c5137", "TUTORIAL04_HEMET_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+            FadeOutHeroActor(enemyActor);
+            yield return new WaitForSeconds(0.4f);
+        }
+        GameState.Get().SetBusy(busy: false);
+    }
+
+    private IEnumerator Wait(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+    }
+
+    private bool AllowEndTurn()
+    {
+        if (!m_shouldSignalPolymorph || (m_shouldSignalPolymorph && m_isBogSheeped))
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        if (GetTag(GAME_TAG.TURN) != 4 && AllowEndTurn())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        if (endTurnNotifier != null)
+        {
+            NotificationManager.Get().DestroyNotificationNowWithNoAnim(endTurnNotifier);
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN_HP";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_HP;
+        if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN_ATK";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        }
+        if (m_shouldSignalPolymorph && !m_isBogSheeped)
+        {
+            key = "TUTORIAL_NO_ENDTURN";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    public override void NotifyOfTargetModeCancelled()
+    {
+        if (!(sheepTheBog == null))
+        {
+            NotificationManager.Get().DestroyAllPopUps();
+        }
+    }
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (!m_shouldSignalPolymorph)
+        {
+            return;
+        }
+        if (entity.GetCardId() == "TU5_CS2_022")
+        {
+            m_isPolymorphGrabbed = true;
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            if (handBounceArrow != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(handBounceArrow);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            Vector3 position = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+                .GetFirstCard()
+                .transform.position;
+            Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL04_HELP_02);
+        }
+        else
+        {
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            if ((bool)UniversalInputManager.UsePhoneUI)
+            {
+                InputManager.Get().ReturnHeldCardToHand();
+            }
+            else
+            {
+                InputManager.Get().DropHeldCard();
+            }
+        }
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        m_isPolymorphGrabbed = false;
+        if (m_shouldSignalPolymorph)
+        {
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            if (ShouldShowArrowOnCardInHand(entity))
+            {
+                Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+            }
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (m_shouldSignalPolymorph)
+        {
+            if (!(clickedEntity.GetCardId() == "TU5_CS1_069" && wasInTargetMode))
+            {
+                if (m_isPolymorphGrabbed && wasInTargetMode)
+                {
+                    if (noSheepPopup != null)
+                    {
+                        NotificationManager.Get().DestroyNotificationNowWithNoAnim(noSheepPopup);
+                    }
+                    Vector3 position = clickedEntity.GetCard().transform.position;
+                    Vector3 position2 = new Vector3(position.x + 2.5f, position.y, position.z);
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL04_HELP_03);
+                    return false;
+                }
+                return false;
+            }
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            m_shouldSignalPolymorph = false;
+            m_isBogSheeped = true;
+        }
+        return true;
+    }
+
+    public override bool ShouldAllowCardGrab(Entity entity)
+    {
+        if (m_shouldSignalPolymorph && entity.GetCardId() != "TU5_CS2_022")
+        {
+            return false;
+        }
+        return true;
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+        if (costTextObject == null)
+        {
+            Object.Destroy(go);
+            return;
+        }
+        m_heroPowerCostLabel = go;
+        SceneUtils.SetLayer(go, GameLayer.Default);
+        go.transform.parent = costTextObject.transform;
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localPosition = new Vector3(-0.02f, 0.38f, 0f);
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localScale = new Vector3(go.transform.localScale.x, go.transform.localScale.x, go.transform.localScale.x);
+        go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOverEntity))
+        {
+            NotificationManager.Get().DestroyAllArrows();
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOffEntity))
+        {
+            Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+        }
+    }
+
+    private bool ShouldShowArrowOnCardInHand(Entity entity)
+    {
+        if (entity.GetZone() != TAG_ZONE.HAND)
+        {
+            return false;
+        }
+        if (m_shouldSignalPolymorph && entity.GetCardId() == "TU5_CS2_022")
+        {
+            return true;
+        }
+        return false;
+    }
+
+    private IEnumerator ShowArrowInSeconds(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count == 0 || m_isPolymorphGrabbed)
+        {
+            yield break;
+        }
+        Card polyMorph = null;
+        foreach (Card item in cards)
+        {
+            if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+            {
+                polyMorph = item;
+            }
+        }
+        if (!(polyMorph == null))
+        {
+            while (iTween.Count(polyMorph.gameObject) > 0)
+            {
+                yield return null;
+            }
+            if (!polyMorph.IsMousedOver() && !(InputManager.Get().GetHeldCard() == polyMorph))
+            {
+                ShowHandBouncingArrow();
+            }
+        }
+    }
+
+    private void ShowHandBouncingArrow()
+    {
+        if (handBounceArrow != null)
+        {
+            return;
+        }
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count == 0)
+        {
+            return;
+        }
+        Card card = null;
+        foreach (Card item in cards)
+        {
+            if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+            {
+                card = item;
+            }
+        }
+        if (!(card == null) && !m_isPolymorphGrabbed)
+        {
+            Vector3 position = card.transform.position;
+            Vector3 position2 = new Vector3(position.x, position.y, position.z + 2f);
+            handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
+            handBounceArrow.transform.parent = card.transform;
+        }
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (victory)
+        {
+            PlaySound("VO_TUTORIAL_04_JAINA_10_44.prefab:6f5921db1071ead4585c8cc9689d22ea");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_213", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs
new file mode 100644
index 0000000..09a1272
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs
@@ -0,0 +1,302 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_05 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private int weaponsPlayed;
+
+    private int numTimesRemindedAboutGoal;
+
+    private bool heroPowerHasNotBeenUsed = true;
+
+    private bool victory;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_05()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+        PreloadSound("VO_TUTORIAL_04_JAINA_03_39.prefab:ef84060011610064abeee5d2d526bf85");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_11_11.prefab:8cd68956e13f8ee43bb816a92c56ab7e");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_02_03.prefab:00cdf773e524ae548a31d82db5bb35c2");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_04_05.prefab:eb68b53ffa7195841a18d4c50516ce35");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_08_08.prefab:32281bee676aa6d4e9c590dfb9e03cb6");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_03_04.prefab:38739c8e8bb7eba42a94afe8bce981f3");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_05_06.prefab:30bf89624d8c3df4b9f776218c7300ad");
+        PreloadSound("VO_TUTORIAL_05_JAINA_02_46.prefab:4daa9f9fc9fc730429c198b9a7212521");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_06_07.prefab:f8e57e165a11de047a2fcaa95e22457b");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_09_09.prefab:1ca9806eebcb0e841be971e486199833");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_10_10.prefab:30c0266100fcd714e804006040c241ad");
+        PreloadSound("VO_TUTORIAL_05_JAINA_05_47.prefab:8caf0051fc3c91c48852eed53e886e4b");
+        PreloadSound("VO_TUTORIAL_05_JAINA_06_48.prefab:fbfba7282a8cb334ba40699cab0524fd");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_01_02.prefab:d4b65ea6366e7a64d8833321001590f1");
+        PreloadSound("VO_TUTORIAL_05_JAINA_01_45.prefab:d5b645ea8a95c0e44a90838ab77b2564");
+        PreloadSound("VO_INNKEEPER_TUT_COMPLETE_05.prefab:c8d19a552e18c7c429946f62102c9460");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.ILLIDAN_COMPLETE);
+                if (Network.ShouldBeConnectedToAurora() && Network.IsLoggedIn() && !GameMgr.Get().IsSpectator())
+                {
+                    BnetPresenceMgr.Get().SetGameField(15u, 1);
+                }
+                ResetTutorialLostProgress();
+                PlaySound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.ILLIDAN_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (GameState.Get().GetOpposingSidePlayer().HasWeapon())
+        {
+            GameState.Get().GetOpposingSidePlayer().GetWeaponCard()
+                .GetActorSpell(SpellType.DEATH)
+                .m_BlockServerEvents = true;
+        }
+        if (turn == 2)
+        {
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_03_39.prefab:ef84060011610064abeee5d2d526bf85", "TUTORIAL04_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, actor));
+            if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+            {
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_11_11.prefab:8cd68956e13f8ee43bb816a92c56ab7e", "TUTORIAL05_ILLIDAN_11", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                GameState.Get().SetBusy(busy: false);
+            }
+            if (GetTag(GAME_TAG.TURN) == 2 && EndTurnButton.Get().IsInNMPState())
+            {
+                ShowEndTurnBouncingArrow();
+            }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    weaponsPlayed++;
+                    if (weaponsPlayed == 1)
+                    {
+                        AccessibilityMgr.BlockAllInput(false, true);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_02_03.prefab:00cdf773e524ae548a31d82db5bb35c2", "TUTORIAL05_ILLIDAN_02", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H);
+                        AccessibilityMgr.UnblockAllInput();
+                    }
+                    else if (weaponsPlayed == 2)
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_04_05.prefab:eb68b53ffa7195841a18d4c50516ce35", "TUTORIAL05_ILLIDAN_04", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_08_08.prefab:32281bee676aa6d4e9c590dfb9e03cb6", "TUTORIAL05_ILLIDAN_08", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    }
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 3:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_03_04.prefab:38739c8e8bb7eba42a94afe8bce981f3", "TUTORIAL05_ILLIDAN_03", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                }
+                break;
+            case 4:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_05_06.prefab:30bf89624d8c3df4b9f776218c7300ad", "TUTORIAL05_ILLIDAN_05", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 5:
+                if (heroPowerHasNotBeenUsed)
+                {
+                    heroPowerHasNotBeenUsed = false;
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(2f);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_02_46.prefab:4daa9f9fc9fc730429c198b9a7212521", "TUTORIAL05_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_06_07.prefab:f8e57e165a11de047a2fcaa95e22457b", "TUTORIAL05_ILLIDAN_06", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 8:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_09_09.prefab:1ca9806eebcb0e841be971e486199833", "TUTORIAL05_ILLIDAN_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 9:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_10_10.prefab:30c0266100fcd714e804006040c241ad", "TUTORIAL05_ILLIDAN_10", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                }
+                break;
+            case 10:
+                if (numTimesRemindedAboutGoal == 0)
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_05_47.prefab:8caf0051fc3c91c48852eed53e886e4b", "TUTORIAL05_JAINA_05", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                else if (numTimesRemindedAboutGoal == 1)
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_06_48.prefab:fbfba7282a8cb334ba40699cab0524fd", "TUTORIAL05_JAINA_06", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                numTimesRemindedAboutGoal++;
+                break;
+            case 12:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return new WaitForSeconds(2f);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B);
+                    AccessibilityMgr.UnblockAllInput();
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE));
+                    string bodyTextGameString = flag ? "TUTORIAL05_HELP_03" : "TUTORIAL05_HELP_04";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL05_HELP_02", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0.5f, 0f), swapMaterial: true);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(flag ? AccessibleSpeech.TUTORIAL05_HELP_03 : AccessibleSpeech.TUTORIAL05_HELP_03);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_01_02.prefab:d4b65ea6366e7a64d8833321001590f1", "TUTORIAL05_ILLIDAN_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    yield return new WaitForSeconds(0.5f);
+                    FadeInHeroActor(jainaActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_01_45.prefab:d5b645ea8a95c0e44a90838ab77b2564", "TUTORIAL05_JAINA_01", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                MulliganManager.Get().BeginMulligan();
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    yield return new WaitForSeconds(2.3f);
+                    FadeOutHeroActor(jainaActor);
+                }
+                break;
+        }
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        NotificationManager.Get().DestroyAllArrows();
+        return true;
+    }
+
+    public override bool NotifyOfTooltipDisplay(TooltipZone specificZone)
+    {
+        return false;
+    }
+
+    public override string[] NotifyOfKeywordHelpPanelDisplay(Entity entity)
+    {
+        if (entity.GetCardId() == "TU4e_004" || entity.GetCardId() == "TU4e_007")
+        {
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL05_WEAPON_HEADLINE"),
+                GameStrings.Get("TUTORIAL05_WEAPON_DESC")
+            };
+        }
+        return null;
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("EX1_277", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs
new file mode 100644
index 0000000..4f2f06e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs
@@ -0,0 +1,328 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_06 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification m_endTurnNotifier;
+
+    private bool m_victory;
+
+    private bool m_choSpeaking;
+
+    private Spell m_choFloatSpell;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_06()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_06_CHO_15_15.prefab:5f0d0a2d3c6884a47aeadcf29b3d802d");
+        PreloadSound("VO_TUTORIAL_06_CHO_09_13.prefab:99a983ceaa6615848a8bea922e428a2d");
+        PreloadSound("VO_TUTORIAL_06_CHO_17_16.prefab:d337628cbe1422e4ca21dbe174ddef2e");
+        PreloadSound("VO_TUTORIAL_06_CHO_05_09.prefab:ef06af76837b9ff4c8ac27ee18516291");
+        PreloadSound("VO_TUTORIAL_06_JAINA_03_51.prefab:06bd40a237dd0674e8d377240de40e65");
+        PreloadSound("VO_TUTORIAL_06_CHO_06_10.prefab:cd28a9685f46936409d5300001540558");
+        PreloadSound("VO_TUTORIAL_06_CHO_21_18.prefab:48c935e7ec96a104ab04d185382898a4");
+        PreloadSound("VO_TUTORIAL_06_CHO_20_17.prefab:dfc795a107caddb42b3d131d6a627fd8");
+        PreloadSound("VO_TUTORIAL_06_CHO_07_11.prefab:b691c4acfee6c5342a727189de686b6d");
+        PreloadSound("VO_TUTORIAL_06_JAINA_04_52.prefab:5d75f42502bc99b4c84704bedf553ba5");
+        PreloadSound("VO_TUTORIAL_06_CHO_04_08.prefab:8164c968ccb1be44d9dfc01c1668b014");
+        PreloadSound("VO_TUTORIAL_06_CHO_12_14.prefab:13ee98fef9d3e6746a69c385c889dc3a");
+        PreloadSound("VO_TUTORIAL_06_CHO_01_05.prefab:10097a4886a24384d8e8f6dd668bb1c7");
+        PreloadSound("VO_TUTORIAL_06_JAINA_01_49.prefab:b9513645100911741b9bda379bc27a75");
+        PreloadSound("VO_TUTORIAL_06_CHO_02_06.prefab:a9c29883676f21d4e932dccc0f92feca");
+        PreloadSound("VO_TUTORIAL_06_JAINA_02_50.prefab:b97fe840305cae04f8486ac1770b126f");
+        PreloadSound("VO_TUTORIAL_06_CHO_03_07.prefab:c71aaff381cdbd346a9bcf54fa5d7db9");
+        PreloadSound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+        PreloadSound("VO_TUTORIAL_06_JAINA_05_53.prefab:6fb71de610db1234887f6d6c948f5174");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        CancelChoFloating();
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            m_victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.CHO_COMPLETE);
+                PlaySound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.CHO_COMPLETE);
+                break;
+        }
+    }
+
+    protected override Spell BlowUpHero(Card card, SpellType spellType)
+    {
+        if (card.GetEntity().GetCardId() != "TU4f_001")
+        {
+            return base.BlowUpHero(card, spellType);
+        }
+        Spell result = card.ActivateActorSpell(SpellType.CHODEATH);
+        Gameplay.Get().StartCoroutine(HideOtherElements(card));
+        return result;
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 2:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_15_15.prefab:5f0d0a2d3c6884a47aeadcf29b3d802d", "TUTORIAL06_CHO_15", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 4:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_09_13.prefab:99a983ceaa6615848a8bea922e428a2d", "TUTORIAL06_CHO_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 15:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    while (m_choSpeaking)
+                    {
+                        yield return null;
+                    }
+                    yield return new WaitForSeconds(0.5f);
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_05_09.prefab:ef06af76837b9ff4c8ac27ee18516291", "TUTORIAL06_CHO_05", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_03_51.prefab:06bd40a237dd0674e8d377240de40e65", "TUTORIAL06_JAINA_03", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_06_10.prefab:cd28a9685f46936409d5300001540558", "TUTORIAL06_CHO_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                }
+                break;
+            case 14:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    while (m_choSpeaking)
+                    {
+                        yield return null;
+                    }
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_21_18.prefab:48c935e7ec96a104ab04d185382898a4", "TUTORIAL06_CHO_21", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                }
+                break;
+            case 16:
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_20_17.prefab:dfc795a107caddb42b3d131d6a627fd8", "TUTORIAL06_CHO_20", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                while (m_choSpeaking)
+                {
+                    yield return null;
+                }
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_17_16.prefab:d337628cbe1422e4ca21dbe174ddef2e", "TUTORIAL06_CHO_17", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 6:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    Card card = GameState.Get().GetOpposingSidePlayer().GetHero()
+                        .GetCard();
+                    m_choFloatSpell = card.GetActorSpell(SpellType.CHOFLOAT);
+                    m_choFloatSpell.ActivateState(SpellStateType.BIRTH);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_07_11.prefab:b691c4acfee6c5342a727189de686b6d", "TUTORIAL06_CHO_07", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_04_52.prefab:5d75f42502bc99b4c84704bedf553ba5", "TUTORIAL06_JAINA_04", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    break;
+                }
+            case 8:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_04_08.prefab:8164c968ccb1be44d9dfc01c1668b014", "TUTORIAL06_CHO_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+            case 9:
+                CancelChoFloating();
+                m_choSpeaking = true;
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_12_14.prefab:13ee98fef9d3e6746a69c385c889dc3a", "TUTORIAL06_CHO_12", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                m_choSpeaking = false;
+                break;
+            case 10:
+                {
+                    Card card2 = FindVoodooDoctorInOpposingSide();
+                    if (!(card2 == null))
+                    {
+                        GameState.Get().SetBusy(busy: true);
+                        yield return new WaitForSeconds(2f);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL06_HELP_03);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_CHO_1);
+                        GameState.Get().SetBusy(busy: false);
+                    }
+                    break;
+                }
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE));
+                    string bodyTextGameString = flag? "TUTORIAL06_HELP_02" : "TUTORIAL06_HELP_04";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL06_HELP_01", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0f, 0.5f));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(flag? AccessibleSpeech.TUTORIAL06_HELP_02 : AccessibleSpeech.TUTORIAL06_HELP_04);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                MulliganManager.Get().BeginMulligan();
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_01_05.prefab:10097a4886a24384d8e8f6dd668bb1c7", "TUTORIAL06_CHO_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                FadeOutHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.5f));
+                FadeInHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_01_49.prefab:b9513645100911741b9bda379bc27a75", "TUTORIAL06_JAINA_01", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                FadeOutHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.5f));
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_02_06.prefab:a9c29883676f21d4e932dccc0f92feca", "TUTORIAL06_CHO_02", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                FadeOutHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.25f));
+                FadeInHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_02_50.prefab:b97fe840305cae04f8486ac1770b126f", "TUTORIAL06_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                FadeOutHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.25f));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_03_07.prefab:c71aaff381cdbd346a9bcf54fa5d7db9", "TUTORIAL06_CHO_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    private void CancelChoFloating()
+    {
+        if (!(m_choFloatSpell == null) && m_choFloatSpell.GetActiveState() != 0)
+        {
+            m_choFloatSpell.ActivateState(SpellStateType.CANCEL);
+        }
+    }
+
+    private Card FindVoodooDoctorInOpposingSide()
+    {
+        foreach (Card card in GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+            .GetCards())
+        {
+            if (card.GetEntity().GetCardId() == "EX1_011")
+            {
+                return card;
+            }
+        }
+        return null;
+    }
+
+    private IEnumerator Wait(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+    }
+
+    public override float GetAdditionalTimeToWaitForSpells()
+    {
+        return 1.5f;
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        for (int i = 0; i < optionsPacket.List.Count; i++)
+        {
+            Network.Options.Option option = optionsPacket.List[i];
+            if (option.Main.PlayErrorInfo.IsValid() && option.Type == Network.Options.Option.OptionType.POWER && GameState.Get().GetEntity(option.Main.ID).GetZone() == TAG_ZONE.PLAY)
+            {
+                if (m_endTurnNotifier != null)
+                {
+                    NotificationManager.Get().DestroyNotificationNowWithNoAnim(m_endTurnNotifier);
+                }
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (m_victory)
+        {
+            PlaySound("VO_TUTORIAL_06_JAINA_05_53.prefab:6fb71de610db1234887f6d6c948f5174");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!m_victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_124", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/AchieveManager.cs b/Decompiled/Assembly-CSharp/AchieveManager.cs
index 4eab34b..468a01f 100644
--- a/Decompiled/Assembly-CSharp/AchieveManager.cs
+++ b/Decompiled/Assembly-CSharp/AchieveManager.cs
@@ -359,17 +359,26 @@ public class AchieveManager : IService, IHasUpdate
 		return value.IsCompleted();
 	}
 
-	public bool HasUnlockedDefaultHeroes()
-	{
+	public int NumDefaultHeroesUnlocked()
+    {
+		int ret = 0;
+
 		foreach (TAG_CLASS oRDERED_HERO_CLASS in GameUtils.ORDERED_HERO_CLASSES)
-		{
+        {
 			NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(oRDERED_HERO_CLASS);
-			if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
-			{
-				return false;
-			}
-		}
-		return true;
+			if (heroLevel != null && heroLevel.CurrentLevel.Level != 0)
+            {
+                ret++;
+            }
+        }
+
+		return ret;
+    }
+
+	public bool HasUnlockedDefaultHeroes()
+	{
+		// 21.0.0.88998 broke a bunch of stuff around this such as the quest markers
+		return NumDefaultHeroesUnlocked() == GameUtils.ORDERED_HERO_CLASSES.Count();
 	}
 
 	public bool HasUnlockedArena()
@@ -379,7 +388,7 @@ public class AchieveManager : IService, IHasUpdate
 
 	public Achievement GetAchievement(int achieveID)
 	{
-		if (!m_achievements.ContainsKey(achieveID))
+        if (!m_achievements.ContainsKey(achieveID))
 		{
 			return null;
 		}
diff --git a/Decompiled/Assembly-CSharp/Achievement.cs b/Decompiled/Assembly-CSharp/Achievement.cs
index 445501e..df1b85a 100644
--- a/Decompiled/Assembly-CSharp/Achievement.cs
+++ b/Decompiled/Assembly-CSharp/Achievement.cs
@@ -641,7 +641,7 @@ public class Achievement
 		}
 	}
 
-	private void SetRewards(List<RewardData> rewardDataList)
+	internal void SetRewards(List<RewardData> rewardDataList)
 	{
 		m_rewards = new List<RewardData>(rewardDataList);
 		FixUpRewardOrigins(m_rewards);
diff --git a/Decompiled/Assembly-CSharp/ActorStateType.cs b/Decompiled/Assembly-CSharp/ActorStateType.cs
index a47ef32..cf1e552 100644
--- a/Decompiled/Assembly-CSharp/ActorStateType.cs
+++ b/Decompiled/Assembly-CSharp/ActorStateType.cs
@@ -47,5 +47,6 @@ public enum ActorStateType
 	CARD_ATTACKABLE_BY_RUSH_MOUSE_OVER,
 	CARD_MOVEABLE,
 	CARD_MOVEABLE_MOUSE_OVER,
-	CARD_AUTO_ATTACKING
+	CARD_AUTO_ATTACKING,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/AddFriendFrame.cs b/Decompiled/Assembly-CSharp/AddFriendFrame.cs
index 5998c0d..d32af5c 100644
--- a/Decompiled/Assembly-CSharp/AddFriendFrame.cs
+++ b/Decompiled/Assembly-CSharp/AddFriendFrame.cs
@@ -1,7 +1,8 @@
 using System;
 using UnityEngine;
+using Accessibility;
 
-public class AddFriendFrame : MonoBehaviour
+public class AddFriendFrame : MonoBehaviour, AccessibleUI
 {
 	public AddFriendFrameBones m_Bones;
 
@@ -54,9 +55,11 @@ public class AddFriendFrame : MonoBehaviour
 			m_InputTextField.Text = m_inputText;
 			UpdateInstructions();
 		}
+
+		ReadFrame();
 	}
 
-	private void OnDestroy()
+    private void OnDestroy()
 	{
 		DialogManager.Get().OnDialogShown -= OnDialogShown;
 		DialogManager.Get().OnDialogHidden -= OnDialogHidden;
@@ -230,6 +233,8 @@ public class AddFriendFrame : MonoBehaviour
 
 	private void OnClosed()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (this.Closed != null)
 		{
 			this.Closed();
@@ -257,4 +262,25 @@ public class AddFriendFrame : MonoBehaviour
 	{
 		ShowSavedText();
 	}
+
+    #region Accessibility
+
+    private void ReadFrame()
+    {
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_ADDFRIEND_INSTRUCTION"));
+    }
+
+    public void HandleAccessibleInput()
+    {
+		return;
+    }
+
+    public string GetAccessibleHelp()
+    {
+		// This is actually overridden by the text box for entering BTag or email
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs b/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
index f63bd61..50c2dc0 100644
--- a/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
@@ -1145,7 +1145,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 			yield return null;
 		}
 		m_adventureBookPageContentsWidget.RemoveEventListener(AdventureNewlyCompletedEventListener);
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateAdventureComplete"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateAdventureComplete"))
 		{
 			bool allPopupsShown = false;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
@@ -1184,7 +1184,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 				yield return null;
 			}
 			m_adventureBookPageContentsWidget.RemoveEventListener(RewardChestAnimEventListener);
-			if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
+			if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
 			{
 				bool allPopupsShown = false;
 				if (AdventureScene.Get().IsDevMode)
diff --git a/Decompiled/Assembly-CSharp/AdventureChooserTray.cs b/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
index e1f500a..645e22a 100644
--- a/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
+++ b/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
@@ -49,6 +49,7 @@ public class AdventureChooserTray : AccordionMenuTray
 		AdventureProgressMgr.Get().RegisterProgressUpdatedListener(OnAdventureProgressUpdated);
 		Box.Get().AddTransitionFinishedListener(OnBoxTransitionFinished);
 		StartCoroutine(InitTrayWhenReady());
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureChooserTrayAwake(this);
 	}
 
 	private void Start()
diff --git a/Decompiled/Assembly-CSharp/AdventureConfig.cs b/Decompiled/Assembly-CSharp/AdventureConfig.cs
index eb2bad7..f0a4901 100644
--- a/Decompiled/Assembly-CSharp/AdventureConfig.cs
+++ b/Decompiled/Assembly-CSharp/AdventureConfig.cs
@@ -5,6 +5,7 @@ using Hearthstone.DataModels;
 using Hearthstone.DungeonCrawl;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureConfig : MonoBehaviour
@@ -71,7 +72,7 @@ public class AdventureConfig : MonoBehaviour
 
 	private Map<AdventureDbId, AdventureModeDbId> m_ClientChooserAdventureModes = new Map<AdventureDbId, AdventureModeDbId>();
 
-	private AdventureDbId SelectedAdventure
+	internal AdventureDbId SelectedAdventure
 	{
 		get
 		{
@@ -96,7 +97,7 @@ public class AdventureConfig : MonoBehaviour
 		}
 	}
 
-	private AdventureModeDbId SelectedMode
+	internal AdventureModeDbId SelectedMode
 	{
 		get
 		{
@@ -421,6 +422,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void SetSelectedAdventureMode(AdventureDbId adventureId, AdventureModeDbId modeId)
 	{
+		AccessibilityUtils.LogDebug($"SetSelectedAdventureMode({adventureId}, {modeId})");
 		SelectedAdventure = adventureId;
 		SelectedMode = modeId;
 		m_ClientChooserAdventureModes[adventureId] = modeId;
@@ -664,6 +666,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void ChangeSubScene(AdventureData.Adventuresubscene subscene, bool pushToBackStack = true)
 	{
+		AccessibilityUtils.LogDebug($"ChangeSubScene({subscene})");
 		if (subscene == m_CurrentSubScene)
 		{
 			Debug.Log($"Sub scene {subscene} is already set.");
@@ -999,9 +1002,10 @@ public class AdventureConfig : MonoBehaviour
 
 	public void OnAdventureSceneAwake()
 	{
-		SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
-		SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
-		if (!ShouldDisplayAdventure(SelectedAdventure))
+        SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
+        SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
+
+        if (!ShouldDisplayAdventure(SelectedAdventure))
 		{
 			SelectedAdventure = AdventureDbId.PRACTICE;
 			SelectedMode = AdventureModeDbId.LINEAR;
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
index 2c68893..5c62a57 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
@@ -5,7 +5,7 @@ public class AdventureDungeonCrawlDeckTray : BasePhoneDeckTray
 {
 	public PlayMakerFSM DeckTrayGlow;
 
-	private CollectionDeck m_deck;
+	internal CollectionDeck m_deck;
 
 	protected override void Awake()
 	{
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
index c256861..1e40d06 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
@@ -10,9 +10,10 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class AdventureDungeonCrawlDisplay : MonoBehaviour
+public class AdventureDungeonCrawlDisplay : MonoBehaviour, AccessibleScreen
 {
 	[Serializable]
 	public class DungeonCrawlDisplayStyleOverride
@@ -335,15 +336,15 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		m_subsceneController.TransitionComplete += OnSubSceneTransitionComplete;
 		AdventureDbId selectedAdv = m_dungeonCrawlData.GetSelectedAdventure();
 		AdventureModeDbId selectedMode = m_dungeonCrawlData.GetSelectedMode();
-		AdventureDataDbfRecord adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
+		m_adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
 		m_playerHeroData = new PlayerHeroData(m_dungeonCrawlData);
 		m_playerHeroData.OnHeroDataChanged += delegate
 		{
 			m_playMat.SetPlayerHeroDbId(m_playerHeroData.HeroCardDbId);
 		};
-		m_AdventureTitle.Text = adventureDataRecord.Name;
-		m_gameSaveDataServerKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataServerKey;
-		m_gameSaveDataClientKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataClientKey;
+		m_AdventureTitle.Text = m_adventureDataRecord.Name;
+		m_gameSaveDataServerKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataServerKey;
+		m_gameSaveDataClientKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataClientKey;
 		if (m_gameSaveDataServerKey <= (GameSaveKeyId)0)
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has no GameSaveDataKey set! This mode does not work without defining GAME_SAVE_DATA_SERVER_KEY in ADVENTURE.dbi!", selectedAdv, selectedMode);
@@ -356,12 +357,12 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has an equal GameSaveDataKey for Client and Server. These keys are not allowed to be equal!", selectedAdv, selectedMode);
 		}
-		m_bossCardBackId = adventureDataRecord.BossCardBack;
+		m_bossCardBackId = m_adventureDataRecord.BossCardBack;
 		if (m_bossCardBackId == 0)
 		{
 			m_bossCardBackId = 0;
 		}
-		m_saveHeroDataUsingHeroId = adventureDataRecord.DungeonCrawlSaveHeroUsingHeroDbId;
+		m_saveHeroDataUsingHeroId = m_adventureDataRecord.DungeonCrawlSaveHeroUsingHeroDbId;
 		if (m_isPVPDR && PvPDungeonRunDisplay.Get().GetPVPDRLobbyDataModel().IsSessionRolledOver)
 		{
 			PvpdrSeasonDbfRecord record = GameDbf.PvpdrSeason.GetRecord(PvPDungeonRunDisplay.Get().GetPVPDRLobbyDataModel().Season);
@@ -401,13 +402,13 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 				Log.Adventures.Print("Owns wing for this Dungeon Run? {0}", AdventureProgressMgr.Get().OwnsWing(scenarioDbfRecord2.WingId));
 			}
 		}
-		m_shouldSkipHeroSelect = adventureDataRecord.DungeonCrawlSkipHeroSelect;
-		m_mustPickShrine = adventureDataRecord.DungeonCrawlMustPickShrine;
-		m_mustSelectChapter = adventureDataRecord.DungeonCrawlSelectChapter;
-		m_anomalyModeCardDbId = adventureDataRecord.AnomalyModeDefaultCardId;
+		m_shouldSkipHeroSelect = m_adventureDataRecord.DungeonCrawlSkipHeroSelect;
+		m_mustPickShrine = m_adventureDataRecord.DungeonCrawlMustPickShrine;
+		m_mustSelectChapter = m_adventureDataRecord.DungeonCrawlSelectChapter;
+		m_anomalyModeCardDbId = m_adventureDataRecord.AnomalyModeDefaultCardId;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_dungeonCrawlPlayMatReference.RegisterReadyListener<AdventureDungeonCrawlPlayMat>(OnPlayMatReady);
-		bool retireButtonSupported = adventureDataRecord.DungeonCrawlIsRetireSupported;
+		bool retireButtonSupported = m_adventureDataRecord.DungeonCrawlIsRetireSupported;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_retireButtonReference.RegisterReadyListener(delegate(Widget w)
 		{
@@ -415,24 +416,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			{
 				if (eventName == "Button_Framed_Clicked" && retireButtonSupported)
 				{
-					m_retireButton.SetActive(value: false);
-					AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
-					{
-						m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
-						m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
-						m_showAlertIcon = true,
-						m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
-						m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
-					};
-					if (m_isPVPDR)
-					{
-						popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
-					}
-					else
-					{
-						popupInfo.m_responseCallback = OnRetirePopupResponse;
-					}
-					DialogManager.Get().ShowPopup(popupInfo);
+					RetireFromAdventure();
 				}
 			});
 			m_retireButton = w.gameObject;
@@ -469,7 +453,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		SetDungeonCrawlDisplayVisualStyle();
 	}
 
-	public void EnablePlayButton()
+    public void EnablePlayButton()
 	{
 		if (m_playMat != null)
 		{
@@ -1176,6 +1160,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			m_retireButton.SetActive(adventureDataRecord.DungeonCrawlIsRetireSupported);
 		}
 		m_assetLoadingHelper.AssetLoadCompleted();
+		ReadScreen();
 	}
 
 	private void OnPlayMatPaperControllerReady(VisualController paperController)
@@ -3241,4 +3226,228 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		Navigation.PopBlockBackingOut();
 		Navigation.GoBack();
 	}
+
+	#region Accessibility
+
+	private enum AccessibleState { WAITING, IS_VO_PLAYING, READING_PLAY_MENU, READING_DECK, RUN_COMPLETED };
+
+	private AccessibleState m_curAccessibleState;
+
+	private AccessibleState m_stateAfterVO;
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleDeckTray;
+
+	private AdventureDataDbfRecord m_adventureDataRecord;
+
+	private void ReadScreen()
+    {
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+		AccessibilityMgr.SetScreen(this);
+
+		if (ShouldShowRunCompletedScreen())
+        {
+			ReadCompletedScreen();
+        }
+		else
+        {
+            ReadPlayMenu(); // TODO: Figure out a cleanway to delay this until VO plays that doesn't require refactoring playMat..
+        }
+    }
+
+    private void ReadCompletedScreen()
+    {
+		m_curAccessibleState = AccessibleState.RUN_COMPLETED;
+		m_stateAfterVO = AccessibleState.RUN_COMPLETED;
+
+		AccessibilityMgr.Output(this, GetAdventureCompleteSpeech());
+    }
+
+	private string GetAdventureCompleteSpeech()
+    {
+		var text = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE);
+		return AccessibleSpeechUtils.CombineSentences(text, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_FINISH, AccessibleKey.CONFIRM));
+    }
+
+    private void ReadPlayMenu()
+    {
+		m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+		m_stateAfterVO = AccessibleState.READING_PLAY_MENU;
+
+		var numDefeatedBosses = m_playMat.m_numBossesDefeated;
+		var numBossesInRun = m_playMat.m_bossesPerRun;
+
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE, numDefeatedBosses + 1, numBossesInRun));
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE), () => m_BackButton.TriggerRelease());
+
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION), () => m_playMat.ClickPlayButton());
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION), ReadDeck);
+
+        if (m_adventureDataRecord.DungeonCrawlIsRetireSupported)
+        {
+			m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION), () => RetireFromAdventure());
+        }
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void ReadDeck()
+	{
+		if (m_dungeonCrawlDeckTray == null || m_dungeonCrawlDeckTray.m_deck == null || m_dungeonCrawlDeckTray.m_deck.GetCards().Count == 0)
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK));
+			return;
+		}
+
+		m_curAccessibleState = AccessibleState.READING_DECK;
+
+		var cards = m_dungeonCrawlDeck.GetDeckContents();
+
+		var accessibleCards = new List<AccessibleCollectibleCard>(cards.Cards.Count);
+
+		foreach (var card in cards.Cards)
+        {
+			var cardDbId = card.Def.Asset;
+			var cardId = GameUtils.TranslateDbIdToCardId(cardDbId);
+			var cardQty = card.Qty;
+			var entityDef = DefLoader.Get().GetEntityDef(cardId);
+			var cardRecord = GameUtils.GetCardRecord(cardId);
+			var collectibleCard = new CollectibleCard(cardRecord, entityDef, TAG_PREMIUM.NORMAL);
+			collectibleCard.OwnedCount = cardQty;
+			var accessibleCollectibleCard = new AccessibleCollectibleCard(this, collectibleCard, true);
+
+			accessibleCards.Add(accessibleCollectibleCard);
+        }
+
+		m_accessibleDeckTray = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+		m_accessibleDeckTray.StartReading();
+    }
+
+    private bool SupportedAdventure()
+    {
+		return m_dungeonCrawlData.GetSelectedAdventure() == AdventureDbId.BOH;
+    }
+
+    public void HandleInput()
+    {
+		// Wait for VO to finish
+		if (NotificationManager.Get().IsQuotePlaying)
+        {
+			m_curAccessibleState = AccessibleState.IS_VO_PLAYING;
+
+			if (AccessibleKey.SKIP_NOTIFICATION.IsPressed())
+            {
+				NotificationManager.Get().m_quote.clickOff?.TriggerPress();
+            }
+			return;
+        }
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+        {
+			if (m_stateAfterVO == AccessibleState.RUN_COMPLETED)
+            {
+				ReadCompletedScreen();
+            }
+			else
+            {
+                // Repeat menu
+                ReadPlayMenu();
+            }
+
+            return;
+        }
+
+		// Normal flow
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+            m_accessibleMenu.HandleAccessibleInput();
+        }
+		else if (m_curAccessibleState == AccessibleState.READING_DECK)
+        {
+			if (AccessibleKey.BACK.IsPressed())
+            {
+				m_accessibleMenu.StartReading();
+				m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+            }
+			else
+            {
+				m_accessibleDeckTray.HandleAccessibleInput();
+
+				var curCardIdx = m_accessibleDeckTray.GetItemBeingReadIndex();
+				var cardTiles = m_dungeonCrawlDeckTray.GetCardsContent().GetCardTiles();
+				AccessibleInputMgr.MoveMouseTo(cardTiles[curCardIdx]);
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_BackButton.TriggerRelease();
+            }
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+			return m_accessibleMenu.GetHelp();
+        }
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+        {
+			return GetAdventureCompleteSpeech();
+        }
+        else if (m_curAccessibleState == AccessibleState.READING_DECK)
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP);
+			return AccessibleSpeechUtils.CombineSentences(helpText, AccessibleSpeech.PRESS_BACK_ONCE_DONE);
+        }
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+        {
+			return LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP);
+        }
+
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+			m_accessibleMenu.StartReading();
+        }
+		else
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_TITLE));
+        }
+    }
+
+    private void RetireFromAdventure()
+    {
+        m_retireButton.SetActive(value: false);
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
+        {
+            m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
+            m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
+            m_showAlertIcon = true,
+            m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
+            m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
+        };
+        if (m_isPVPDR)
+        {
+            popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
+        }
+        else
+        {
+            popupInfo.m_responseCallback = OnRetirePopupResponse;
+        }
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
index 184acf6..83e7b10 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
@@ -7,6 +7,7 @@ using Hearthstone.DungeonCrawl;
 using Hearthstone.Progression;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureDungeonCrawlPlayMat : MonoBehaviour
@@ -266,9 +267,9 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 
 	private OptionType m_currentOptionType;
 
-	private int m_numBossesDefeated;
+	internal int m_numBossesDefeated;
 
-	private int m_bossesPerRun;
+	internal int m_bossesPerRun;
 
 	private bool m_allowPlayButtonAnimation;
 
@@ -1113,10 +1114,13 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 		}
 		if ((!(m_bossHeroPowerTooltip != null) || m_bossHeroPowerTooltip.IsDying()) && m_shouldShowBossHeroPowerTooltip)
 		{
-			m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
-			m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
-			m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
-		}
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
+                m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
+                m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
+            }
+        }
 	}
 
 	public void HideBossHeroPowerTooltip(bool immediate = false)
@@ -1891,4 +1895,13 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 			}
 		}
 	}
+
+    #region Accessibility
+
+    internal void ClickPlayButton()
+    {
+		m_playButton.TriggerRelease();
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs b/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
index 0c99290..ca7329c 100644
--- a/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
@@ -885,7 +885,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 				wingIds.Add((int)item2.GetWingId());
 			}
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			m_WaitingForClassChallengeUnlocks = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
diff --git a/Decompiled/Assembly-CSharp/AdventureProductPage.cs b/Decompiled/Assembly-CSharp/AdventureProductPage.cs
index 5c7b396..7de4870 100644
--- a/Decompiled/Assembly-CSharp/AdventureProductPage.cs
+++ b/Decompiled/Assembly-CSharp/AdventureProductPage.cs
@@ -5,10 +5,10 @@ using UnityEngine;
 
 public class AdventureProductPage : ProductPage
 {
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		SetMusicOverride(MusicPlaylistType.Invalid);
-		base.Open();
+		base.Open(false);
 	}
 
 	protected override void OnProductSet()
diff --git a/Decompiled/Assembly-CSharp/AdventureScene.cs b/Decompiled/Assembly-CSharp/AdventureScene.cs
index 4c21e7c..ce52a6c 100644
--- a/Decompiled/Assembly-CSharp/AdventureScene.cs
+++ b/Decompiled/Assembly-CSharp/AdventureScene.cs
@@ -133,6 +133,7 @@ public class AdventureScene : PegasusScene
 		adventureConfig.AddSelectedModeChangeListener(OnSelectedModeChanged);
 		adventureConfig.AddAdventureModeChangeListener(OnAdventureModeChanged);
 		adventureConfig.AddAdventureMissionSetListener(OnAdventureMissionChanged);
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureSceneShown();
 		m_StartupAssetLoads++;
 		SetCurrentTransitionDirection();
 		if (HearthstoneApplication.IsInternal())
@@ -318,7 +319,7 @@ public class AdventureScene : PegasusScene
 					runCallback((string)subSceneDef.m_Prefab, widgetInstance.Widget.gameObject, callbackData);
 				}
 				UpdateAdventureModeMusic();
-				m_isLoading = false;
+				DoneLoading(subscene);
 			});
 			return;
 		}
@@ -330,11 +331,12 @@ public class AdventureScene : PegasusScene
 				runCallback(assetRef, go, data);
 			}
 			UpdateAdventureModeMusic();
-			m_isLoading = false;
+			DoneLoading(subscene);
 		}, callbackData, AssetLoadingOptions.IgnorePrefabPosition);
 	}
 
-	private void OnSubSceneChange(AdventureData.Adventuresubscene newscene, bool forward)
+
+    private void OnSubSceneChange(AdventureData.Adventuresubscene newscene, bool forward)
 	{
 		m_transitionIsGoingBack = !forward;
 		LoadSubScene(newscene);
@@ -599,7 +601,9 @@ public class AdventureScene : PegasusScene
 
 	private void ShowExpertAIUnlockTip()
 	{
-		if (AchieveManager.Get().HasUnlockedDefaultHeroes() && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("AdventureScene.ShowExpertAIUnlockTip"))
+		// vvv This is broken since Blizzard's 21.0.0.88998 patch
+		//if (NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>().Levels.Count <= 0 && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "AdventureScene.ShowExpertAIUnlockTip"))
+		if (AchieveManager.Get().HasUnlockedDefaultHeroes() && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "AdventureScene.ShowExpertAIUnlockTip"))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_EXPERT_AI_10"), "VO_INNKEEPER_EXPERT_AI_10.prefab:7979b1ca6d60f7b448686a248246542d");
 			Options.Get().SetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, val: true);
@@ -668,4 +672,12 @@ public class AdventureScene : PegasusScene
 			m_CurrentTransitionDirection = m_TransitionDirection;
 		}
 	}
+
+    #region Accessibility
+    private void DoneLoading(AdventureData.Adventuresubscene subscene)
+    {
+        m_isLoading = false;
+		Accessibility.AccessibleAdventureScene.Get().OnSubSceneLoaded(subscene);
+    }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs b/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
index f673f12..8eff520 100644
--- a/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
+++ b/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
@@ -348,7 +348,7 @@ public class AdventureWingFrozenThroneHelper : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			waitingForNextStep = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
diff --git a/Decompiled/Assembly-CSharp/AlertPopup.cs b/Decompiled/Assembly-CSharp/AlertPopup.cs
index 3654f34..c81ab1e 100644
--- a/Decompiled/Assembly-CSharp/AlertPopup.cs
+++ b/Decompiled/Assembly-CSharp/AlertPopup.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using Blizzard.T5.AssetManager;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AlertPopup : DialogBase
@@ -29,7 +30,8 @@ public class AlertPopup : DialogBase
 		OK,
 		CONFIRM,
 		CANCEL,
-		CONFIRM_CANCEL
+		CONFIRM_CANCEL,
+		EOE
 	}
 
 	public delegate void ResponseCallback(Response response, object userData);
@@ -236,6 +238,8 @@ public class AlertPopup : DialogBase
 		DoShowAnimation();
 		bool systemDialogActive = m_popupInfo == null || !m_popupInfo.m_layerToUse.HasValue || m_popupInfo.m_layerToUse.Value == GameLayer.UI || m_popupInfo.m_layerToUse.Value == GameLayer.HighPriorityUI;
 		UniversalInputManager.Get().SetSystemDialogActive(systemDialogActive);
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -306,9 +310,11 @@ public class AlertPopup : DialogBase
 			break;
 		}
 		m_buttonContainer.UpdateSlices();
+
+		ReadPopupOptions();
 	}
 
-	private void UpdateTexts(PopupInfo popupInfo)
+    private void UpdateTexts(PopupInfo popupInfo)
 	{
 		m_alertText.RichText = m_popupInfo.m_richTextEnabled;
 		m_alertText.Alignment = m_popupInfo.m_alertTextAlignment;
@@ -467,4 +473,84 @@ public class AlertPopup : DialogBase
 			m_header.m_container.UpdateSlices();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private ResponseDisplay m_lastPopupType; // Keep track of the latest popup type to eat any duplicate updates
+
+	private void ReadPopup()
+    {
+		m_lastPopupType = ResponseDisplay.NONE;
+
+        AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_ALERT_POPUP_TITLE), true);
+
+        ReadPopupOptions();
+    }
+
+    private void ReadPopupOptions()
+    {
+		try
+		{
+
+			var accessibleMenu = new AccessibleMenu(this, m_alertText?.Text, null);
+
+			switch (m_popupInfo.m_responseDisplay)
+			{
+				case ResponseDisplay.OK:
+					AddAccessibleOption(accessibleMenu, m_okayButton);
+					break;
+				case ResponseDisplay.CONFIRM:
+					AddAccessibleOption(accessibleMenu, m_confirmButton);
+					break;
+				case ResponseDisplay.CANCEL:
+					AddAccessibleOption(accessibleMenu, m_cancelButton);
+					break;
+				case ResponseDisplay.CONFIRM_CANCEL:
+					AddAccessibleOption(accessibleMenu, m_confirmButton);
+					AddAccessibleOption(accessibleMenu, m_cancelButton);
+					break;
+				default:
+					// ResponseDisplay will come as part of an update
+					m_lastPopupType = ResponseDisplay.NONE;
+					return;
+			}
+
+			if (m_lastPopupType != m_popupInfo.m_responseDisplay)
+			{
+				m_accessibleMenu = accessibleMenu;
+				if (m_header?.m_text?.Text != null)
+				{
+					AccessibilityMgr.Output(this, m_header.m_text.Text);
+				}
+
+				m_accessibleMenu.StartReading();
+			}
+
+			m_lastPopupType = m_popupInfo.m_responseDisplay;
+		}
+		catch (Exception e)
+		{
+			AccessibilityUtils.LogFatalError(e);
+		}
+    }
+
+    private void AddAccessibleOption(AccessibleMenu menu, UIBButton button)
+    {
+        menu.AddOption(button.GetText(), () => button.TriggerRelease());
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs b/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
index b81211e..3f68585 100644
--- a/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
+++ b/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.Streaming;
 
-public class AssetDownloadDialog : DialogBase
+public class AssetDownloadDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/Assets/AdventureData.cs b/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
index 0680bff..42d9a16 100644
--- a/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
+++ b/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
@@ -25,7 +25,9 @@ namespace Assets
 			[Description("Bonus_Challenge")]
 			BONUS_CHALLENGE,
 			[Description("Location_Select")]
-			LOCATION_SELECT
+			LOCATION_SELECT,
+			[Description("EOE")]
+			EOE
 		}
 
 		public enum Adventurebooklocation
diff --git a/Decompiled/Assembly-CSharp/Assets/Global.cs b/Decompiled/Assembly-CSharp/Assets/Global.cs
index a519fb3..bb93644 100644
--- a/Decompiled/Assembly-CSharp/Assets/Global.cs
+++ b/Decompiled/Assembly-CSharp/Assets/Global.cs
@@ -334,7 +334,8 @@ namespace Assets
 			GAMEPLAY,
 			TUTORIAL,
 			PRESENCE,
-			MISSION
+			MISSION,
+			ACCESSIBILITY
 		}
 
 		public enum MercenariesPremium
diff --git a/Decompiled/Assembly-CSharp/Assets/QuestPool.cs b/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
index 004674a..4a545a2 100644
--- a/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
+++ b/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
@@ -11,7 +11,9 @@ namespace Assets
 			[Description("daily")]
 			DAILY,
 			[Description("weekly")]
-			WEEKLY
+			WEEKLY,
+			[Description("eoe")]
+			EOE
 		}
 
 		public static QuestPoolType ParseQuestPoolTypeValue(string value)
diff --git a/Decompiled/Assembly-CSharp/AttackSpellController.cs b/Decompiled/Assembly-CSharp/AttackSpellController.cs
index 025710b..6c27ad0 100644
--- a/Decompiled/Assembly-CSharp/AttackSpellController.cs
+++ b/Decompiled/Assembly-CSharp/AttackSpellController.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class AttackSpellController : SpellController
 {
@@ -36,6 +37,8 @@ public class AttackSpellController : SpellController
 
 	private bool m_repeatProposed;
 
+	private AccessibleAttackSpellController m_accController;
+
 	protected override bool AddPowerSourceAndTargets(PowerTaskList taskList)
 	{
 		m_attackType = taskList.GetAttackType();
@@ -54,6 +57,7 @@ public class AttackSpellController : SpellController
 		{
 			AddTarget(defender.GetCard());
 		}
+		m_accController = new AccessibleAttackSpellController(taskList);
 		return true;
 	}
 
@@ -232,6 +236,7 @@ public class AttackSpellController : SpellController
 
 	private void LaunchAttack()
 	{
+		m_accController.OnLaunchAttack();
 		Card source = GetSource();
 		Entity entity = source.GetEntity();
 		Card target = GetTarget();
@@ -399,6 +404,7 @@ public class AttackSpellController : SpellController
 
 	private void OnBattlegroundsFinisherFinished(Spell spell, object favoriteFinisherRecordObject)
 	{
+		m_accController.OnBattlegroundsFinisherFinished();
 		Card source = GetSource();
 		Card target = GetTarget();
 		bool showImpactEffects = ((FinisherGameplaySettings)favoriteFinisherRecordObject).ShowImpactEffects;
diff --git a/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs b/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
index ebd86bd..b77bcc9 100644
--- a/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
+++ b/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
@@ -102,7 +102,7 @@ public class BaconCollectionDisplay : CollectibleDisplay
 
 	protected override void OnDestroy()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/BaconDisplay.cs b/Decompiled/Assembly-CSharp/BaconDisplay.cs
index 81354bb..c0a68de 100644
--- a/Decompiled/Assembly-CSharp/BaconDisplay.cs
+++ b/Decompiled/Assembly-CSharp/BaconDisplay.cs
@@ -40,7 +40,7 @@ public class BaconDisplay : MonoBehaviour
 
 	private WidgetTemplate m_OwningWidget;
 
-	private PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
 	private UIBButton m_statsButton;
 
@@ -63,6 +63,12 @@ public class BaconDisplay : MonoBehaviour
 
 	private static bool m_hasSeenLowMemoryWarningThisSession;
 
+	#region Accessibility
+
+	internal UIBButton m_backButton;
+
+	#endregion
+
 	public bool IsFinishedLoading
 	{
 		get
@@ -143,7 +149,9 @@ public class BaconDisplay : MonoBehaviour
 			Error.AddDevWarning("UI Error!", "BackButton could not be found! You will not be able to click 'Back'!");
 			return;
 		}
-		buttonVisualController.gameObject.GetComponent<UIBButton>().AddEventListener(UIEventType.RELEASE, BackButtonRelease);
+		m_backButton = buttonVisualController.gameObject.GetComponent<UIBButton>();
+		m_backButton.AddEventListener(UIEventType.RELEASE, BackButtonRelease);
+		
 		m_backButtonFinishedLoading = true;
 	}
 
diff --git a/Decompiled/Assembly-CSharp/BaconScene.cs b/Decompiled/Assembly-CSharp/BaconScene.cs
index e8ea5ab..24f02be 100644
--- a/Decompiled/Assembly-CSharp/BaconScene.cs
+++ b/Decompiled/Assembly-CSharp/BaconScene.cs
@@ -1,9 +1,11 @@
 using System.Collections;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 [CustomEditClass]
-public class BaconScene : PegasusScene
+public class BaconScene : PegasusScene, AccessibleScreen
 {
 	[CustomEditField(T = EditType.GAME_OBJECT)]
 	public String_MobileOverride m_screenPrefab;
@@ -119,5 +121,151 @@ public class BaconScene : PegasusScene
 			yield return null;
 		}
 		SceneMgr.Get().NotifySceneLoaded();
+
+		ReadScreen();
+	}
+
+	#region Accessibility
+
+	private enum State { LOADING, MAIN_MENU, READING_STATS, OPTIONS_MENU }; // TODO: Help, tutorial, full stats maybe
+
+	private State m_curState = State.LOADING;
+
+	private AccessibleMenu m_curMenu;
+
+	private AccessibleMultilineText m_accessibleStats;
+
+	private AccessibleMenu m_optionsMenu;
+
+	private void ReadScreen()
+	{
+		AccessibilityMgr.SetScreen(this);
+
+		m_curMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLEGROUNDS), OnGoBackToHub);
+		m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_PLAY), OnClickPlay);
+		m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_READ_STATS), OnReadStats);
+		m_curMenu.AddOption(GameStrings.Get("GLOBAL_OPTIONS"), OnClickOptions);
+		m_curMenu.AddOption(GameStrings.Get("GLUE_BACON_INFO_POPUP_PLAY_TUTORIAL"), m_baconDisplay.PlayBaconTutorial);
+
+		ReadMainMenu();
+	}
+
+	private void ReadMainMenu()
+	{
+		m_curState = State.MAIN_MENU;
+		m_curMenu.StartReading();
+	}
+
+	private void OnReadStats()
+	{
+		var baconLobbyDataModel = m_baconDisplay.GetBaconLobbyDataModel();
+
+		var firstPlaceCount = baconLobbyDataModel.FirstPlaceFinishes;
+		var top4Count = baconLobbyDataModel.Top4Finishes;
+		var rating = baconLobbyDataModel.Rating;
+
+		var lines = new List<string>();
+
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_BACON_FIRST_PLACE_LABEL"), $"{firstPlaceCount}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_BACON_TOP_4_LABEL"), $"{top4Count}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_BACON_RATING_LABEL"), $"{rating}"));
+
+		m_accessibleStats = new AccessibleMultilineText(this, lines);
+		m_accessibleStats.ReadAllLines();
+		m_curState = State.READING_STATS;
+	}
+
+	private void OnClickOptions()
+	{
+		m_optionsMenu = new AccessibleMenu(this, "", ReadMainMenu);
+        m_optionsMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_OPTIONS_NARRATE_ATTACKS)), OnToggleNarrateAttacks);
+
+		m_curState = State.OPTIONS_MENU;
+		m_optionsMenu.StartReading();
+	}
+
+	private void OnToggleNarrateAttacks()
+	{
+		var state = AccessibleGameplayUtils.ToggleBattlegroundsAttackPhaseNarration();
+
+		if (state)
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED));
+		}
+		else
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED));
+		}
+	}
+
+	private void OnClickPlay()
+	{
+		m_curState = State.LOADING;
+		m_baconDisplay.m_playButton.TriggerRelease();
 	}
+
+	private void OnGoBackToHub()
+	{
+		m_curState = State.LOADING;
+		m_baconDisplay.m_backButton.TriggerRelease();
+	}
+
+	public void HandleInput()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_curMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.OPTIONS_MENU)
+		{
+			m_optionsMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadMainMenu();
+			}
+			else
+			{
+				m_accessibleStats?.HandleAccessibleInput();
+			}
+		}
+	}
+
+	public string GetHelp()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			return m_curMenu?.GetHelp();
+		}
+		else if (m_curState == State.OPTIONS_MENU)
+		{
+			return m_optionsMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+
+		return "";
+	}
+
+	public void OnGainedFocus()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_curMenu?.StartReading();
+		}
+		else if (m_curState == State.OPTIONS_MENU)
+		{
+			m_optionsMenu?.StartReading();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			m_accessibleStats.ReadAllLines();
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BaconTwoScoop.cs b/Decompiled/Assembly-CSharp/BaconTwoScoop.cs
index dcb9080..a3d969f 100644
--- a/Decompiled/Assembly-CSharp/BaconTwoScoop.cs
+++ b/Decompiled/Assembly-CSharp/BaconTwoScoop.cs
@@ -1,5 +1,7 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
+using System;
 
 public class BaconTwoScoop : VictoryTwoScoop
 {
@@ -39,6 +41,12 @@ public class BaconTwoScoop : VictoryTwoScoop
 
 	private int m_ratingChange;
 
+	#region Accessibility
+
+	private bool m_ratingChangeDisabled;
+
+	#endregion
+
 	protected override void ShowImpl()
 	{
 		StartCoroutine(ShowWhenReady());
@@ -62,10 +70,10 @@ public class BaconTwoScoop : VictoryTwoScoop
 		{
 			baconGameEntity = (TB_BaconShop)GameState.Get().GetGameEntity();
 		}
-		bool ratingChangeDisabled = GameMgr.Get().IsFriendlyBattlegrounds();
+		m_ratingChangeDisabled = GameMgr.Get().IsFriendlyBattlegrounds();
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.WAIT_FOR_RATING_INFO))
 		{
-			while (baconGameEntity != null && baconGameEntity.RatingChangeData == null && !ratingChangeDisabled && m_waitForRatingTimeoutTimer < 5f)
+			while (baconGameEntity != null && baconGameEntity.RatingChangeData == null && !m_ratingChangeDisabled && m_waitForRatingTimeoutTimer < 5f)
 			{
 				m_waitForRatingTimeoutTimer += Time.unscaledDeltaTime;
 				yield return null;
@@ -113,6 +121,8 @@ public class BaconTwoScoop : VictoryTwoScoop
 
 	private IEnumerator PlayRatingChangeAnimation()
 	{
+		ReadPlace();
+
 		int oldRating = m_newRating - m_ratingChange;
 		m_RatingChangeText.Text = "";
 		m_RatingText.Text = oldRating.ToString();
@@ -134,5 +144,43 @@ public class BaconTwoScoop : VictoryTwoScoop
 			yield return null;
 		}
 		m_RatingText.Text = m_newRating.ToString();
+
+		// e.g. friendly BGs don't influence rating
+		if (!m_ratingChangeDisabled)
+		{
+			ReadRatingChange(m_ratingChange, m_newRating);
+		}
 	}
+
+	#region Accessibility
+
+	private void ReadPlace()
+	{
+		AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), m_bannerLabel.Text);
+	}
+
+	private void ReadRatingChange(int ratingChange, int newRating)
+	{
+		// Actual change
+		if (ratingChange > 0)
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_CHANGE_INCREASED, ratingChange));
+		}
+		else if (ratingChange < 0)
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_CHANGE_DECREASED, ratingChange));
+		}
+
+		// New (or old) rating
+		if (ratingChange == 0)
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_NO_CHANGE, newRating));
+		}
+		else
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_CHANGE_NEW_RATING, newRating));
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BannerPopup.cs b/Decompiled/Assembly-CSharp/BannerPopup.cs
index a8610a3..12f16e7 100644
--- a/Decompiled/Assembly-CSharp/BannerPopup.cs
+++ b/Decompiled/Assembly-CSharp/BannerPopup.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class BannerPopup : MonoBehaviour
+public class BannerPopup : MonoBehaviour, AccessibleUI
 {
 	public GameObject m_root;
 
@@ -55,6 +56,8 @@ public class BannerPopup : MonoBehaviour
 				m_onCloseBannerPopup();
 			}
 		}
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public void Show(string headerText, string bannerText, BannerManager.DelOnCloseBanner onCloseCallback = null)
@@ -89,6 +92,8 @@ public class BannerPopup : MonoBehaviour
 			m_dismissButton.AddEventListener(UIEventType.RELEASE, CloseBannerPopup);
 		}
 		m_showSpellComplete = false;
+
+		ReadPopup();
 	}
 
 	private void FadeEffectsIn()
@@ -185,4 +190,46 @@ public class BannerPopup : MonoBehaviour
 			m_HideSpell.Activate();
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+		if (m_header != null && m_header.Text != null)
+		{
+			AccessibilityMgr.Output(this, m_header.Text);
+		}
+
+		if (m_text != null && m_text.Text != null)
+		{
+			AccessibilityMgr.Output(this, m_text.Text);
+		}
+
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (m_dismissButton != null)
+            {
+                m_dismissButton?.TriggerRelease();
+            }
+			else
+            {
+				AccessibleInputMgr.ClickCenterOfScreen();
+            }
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BaseHeroSkinInfoManager.cs b/Decompiled/Assembly-CSharp/BaseHeroSkinInfoManager.cs
index 5b2140b..9cc8146 100644
--- a/Decompiled/Assembly-CSharp/BaseHeroSkinInfoManager.cs
+++ b/Decompiled/Assembly-CSharp/BaseHeroSkinInfoManager.cs
@@ -277,10 +277,13 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 			SetupHeroSkinStore();
 			UpdateView();
 		}
+
+		ReadHeroSkinPreview();
 	}
 
 	public void CancelPreview()
 	{
+		HideThis();
 		RemoveNavigateBack();
 		if (m_animating || !m_hasEnteredHeroSkinPreview)
 		{
@@ -355,7 +358,7 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 	protected void UpdateFavoriteButton()
 	{
 		bool flag = CanFavoriteCurrentHero();
-		UIBButton uIBButton = ((m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroFavoriteButton : m_newHeroFavoriteButton);
+		UIBButton uIBButton = GetDesiredFavoriteButton();
 		if (uIBButton.IsEnabled() != flag)
 		{
 			uIBButton.SetEnabled(flag);
@@ -389,16 +392,16 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 			m_userActionVisualController.BindDataModel(collectionManagerHeroSkinPriceDataModel);
 			if (!HeroSkinUtils.CanBuyHeroSkinFromCollectionManager(m_currentEntityDef.GetCardId()))
 			{
-				m_userActionVisualController.SetState("INSUFFICIENT_CURRENCY");
+				m_userActionVisualController.SetState(INSUFFICIENT_CURRENCY_STATE);
 			}
 			else
 			{
-				m_userActionVisualController.SetState("SUFFICIENT_CURRENCY");
+				m_userActionVisualController.SetState(SUFFICIENT_CURRENCY_STATE);
 				flag = true;
 			}
 		}
 		UpdateFavoriteButton();
-		UIBButton obj = ((m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroBuyButton : m_newHeroBuyButton);
+		UIBButton obj = GetDesiredBuyButton();
 		obj.SetEnabled(flag);
 		obj.Flip(faceUp: true);
 	}
@@ -737,4 +740,27 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 	{
 		return new CurrencyType[1] { CurrencyType.GOLD };
 	}
+
+	#region Accessibility
+
+	protected UIBButton GetDesiredFavoriteButton()
+	{
+		return (m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroFavoriteButton : m_newHeroFavoriteButton;
+	}
+
+	protected UIBButton GetDesiredBuyButton()
+	{
+		return (m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroBuyButton : m_newHeroBuyButton;
+	}
+
+	protected virtual void ReadHeroSkinPreview()
+	{
+	}
+
+	protected virtual void HideThis()
+	{
+
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BaseUI.cs b/Decompiled/Assembly-CSharp/BaseUI.cs
index 6e344d0..6551e21 100644
--- a/Decompiled/Assembly-CSharp/BaseUI.cs
+++ b/Decompiled/Assembly-CSharp/BaseUI.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.IO;
 using UnityEngine;
+using Accessibility;
 
 public class BaseUI : MonoBehaviour
 {
@@ -182,7 +183,11 @@ public class BaseUI : MonoBehaviour
 		if ((InputCollection.GetKey(KeyCode.LeftControl) || InputCollection.GetKey(KeyCode.RightControl) || InputCollection.GetKey(KeyCode.LeftCommand) || InputCollection.GetKey(KeyCode.RightCommand)) && (InputCollection.GetKey(KeyCode.LeftShift) || InputCollection.GetKey(KeyCode.RightShift)) && InputCollection.GetKeyDown(KeyCode.S) && Options.Get() != null)
 		{
 			bool @bool = Options.Get().GetBool(Option.STREAMER_MODE);
-			Options.Get().SetBool(Option.STREAMER_MODE, !@bool);
+			var streamerModeOn = !@bool;
+			Options.Get().SetBool(Option.STREAMER_MODE, streamerModeOn);
+
+			var key = streamerModeOn ? LocalizationKey.GLOBAL_STREAMER_MODE_ON : LocalizationKey.GLOBAL_STREAMER_MODE_OFF;
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(key));
 		}
 		return false;
 	}
diff --git a/Decompiled/Assembly-CSharp/BasicPopup.cs b/Decompiled/Assembly-CSharp/BasicPopup.cs
index 8a8d3a7..7f7e194 100644
--- a/Decompiled/Assembly-CSharp/BasicPopup.cs
+++ b/Decompiled/Assembly-CSharp/BasicPopup.cs
@@ -1,3 +1,5 @@
+using Accessibility;
+using System;
 using System.Collections.Generic;
 using UnityEngine;
 
@@ -27,6 +29,13 @@ public class BasicPopup : DialogBase
 		public bool m_disableBnetBar;
 
 		public bool m_blurWhenShown;
+
+		public string m_accessibleText;
+
+		public PopupInfo(string accessibleText)
+        {
+			m_accessibleText = accessibleText;
+        }
 	}
 
 	public UIBButton m_cancelButton;
@@ -45,6 +54,10 @@ public class BasicPopup : DialogBase
 
 	protected PopupInfo m_popupInfo;
 
+	#region Accessibility
+	private string m_accessibleText;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -101,10 +114,14 @@ public class BasicPopup : DialogBase
 		{
 			SoundManager.Get().LoadAndPlay(m_showAnimationSound);
 		}
+
+		ReadBasicPopup();
 	}
 
 	public override void Hide()
 	{
+		OnHide();
+
 		base.Hide();
 		if (m_popupInfo.m_blurWhenShown)
 		{
@@ -126,7 +143,7 @@ public class BasicPopup : DialogBase
 	{
 		if (m_popupInfo == null)
 		{
-			m_popupInfo = new PopupInfo();
+			m_popupInfo = new PopupInfo(LocalizationUtils.Get(LocalizationKey.UI_UNKNOWN_POPUP));
 		}
 		if (m_headerText != null && m_popupInfo.m_headerText != null)
 		{
@@ -136,6 +153,8 @@ public class BasicPopup : DialogBase
 		{
 			m_bodyText.Text = m_popupInfo.m_bodyText;
 		}
+
+		m_accessibleText = m_popupInfo.m_accessibleText;
 	}
 
 	private void ButtonPress(Response response)
@@ -146,4 +165,70 @@ public class BasicPopup : DialogBase
 		}
 		Hide();
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    protected void ReadBasicPopup()
+    {
+		if (IsFactionChoicePopup())
+		{
+			ReadFactionChoicePopup();
+			return;
+		}
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_customButton != null)
+        {
+			m_accessibleMenu.AddOption(m_customButton.GetText(), () => m_customButton.TriggerRelease());
+        }
+
+		if (m_cancelButton != null)
+        {
+			m_accessibleMenu.AddOption(m_cancelButton.GetText(), () => m_cancelButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, m_accessibleText);
+
+		m_accessibleMenu.StartReading();
+    }
+
+	private void ReadFactionChoicePopup()
+	{
+		GetFactionChoicePopup().ReadPopup();
+	}
+
+	private void OnHide()
+	{
+		if (IsFactionChoicePopup())
+		{
+			GetFactionChoicePopup().HidePopup();
+		}
+	}
+
+	private FactionChoicePopup GetFactionChoicePopup()
+	{
+		return base.gameObject.GetComponent<FactionChoicePopup>();
+	}
+
+	public override void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	protected bool IsFactionChoicePopup()
+	{
+		return base.gameObject.TryGetComponent<FactionChoicePopup>(out var component) && !component.HasFactionChoiceConfirmationBeenReceived;
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BigCard.cs b/Decompiled/Assembly-CSharp/BigCard.cs
index db0f642..f0c0f6a 100644
--- a/Decompiled/Assembly-CSharp/BigCard.cs
+++ b/Decompiled/Assembly-CSharp/BigCard.cs
@@ -92,7 +92,7 @@ public class BigCard : MonoBehaviour
 
 	private readonly PlatformDependentValue<float> PLATFORM_SCALING_FACTOR;
 
-	private EnchantmentBanner m_enchantmentBanner;
+	internal EnchantmentBanner m_enchantmentBanner;
 
 	private Actor m_extraBigCardActor;
 
diff --git a/Decompiled/Assembly-CSharp/BnetFriendMgr.cs b/Decompiled/Assembly-CSharp/BnetFriendMgr.cs
index d565cf8..901e38a 100644
--- a/Decompiled/Assembly-CSharp/BnetFriendMgr.cs
+++ b/Decompiled/Assembly-CSharp/BnetFriendMgr.cs
@@ -7,6 +7,7 @@ using Hearthstone;
 using PegasusClient;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class BnetFriendMgr
 {
@@ -40,7 +41,7 @@ public class BnetFriendMgr
 
 	private bool m_isRegisteredToFriendHandler;
 
-	private bool m_isFriendInviteFeatureEnabled;
+	private bool m_isFriendInviteFeatureEnabled = true;
 
 	private static ulong nextIdToken;
 
@@ -420,6 +421,15 @@ public class BnetFriendMgr
 
 	public bool RemoveFriend(BnetPlayer friend)
 	{
+		if (friend.IsCheatPlayer)
+		{
+			var changeList = new BnetFriendChangelist();
+			changeList.AddRemovedFriend(friend);
+			m_friends.Remove(friend);
+			ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+
+			return true;
+		}
 		bool flag = false;
 		for (int i = 0; i < m_friends.Count; i++)
 		{
@@ -495,6 +505,7 @@ public class BnetFriendMgr
 			{
 				flag = true;
 				m_friends.Add(friend);
+				DebugAddFriend(friend);
 			}
 		}
 		if (flag)
@@ -528,6 +539,7 @@ public class BnetFriendMgr
 				if (bnetPlayer.IsDisplayable())
 				{
 					m_friends.Add(bnetPlayer);
+							DebugAddFriend(bnetPlayer);
 					bnetFriendChangelist.AddAddedFriend(bnetPlayer);
 				}
 				else
@@ -720,7 +732,7 @@ public class BnetFriendMgr
 		return num;
 	}
 
-	public BnetInvitation Cheat_CreateReceivedInvite(ref ulong nextIdToken, BnetPlayer myself, string fullName, ulong creationTime, ulong expirationTime)
+	public BnetInvitation Cheat_CreateReceivedInvite(/*ref ulong nextIdToken,*/BnetPlayer myself, string fullName, ulong creationTime, ulong expirationTime)
 	{
 		BnetInvitationId id = new BnetInvitationId(nextIdToken++);
 		BnetAccountId bnetAccountId = new BnetAccountId();
@@ -734,10 +746,60 @@ public class BnetFriendMgr
 		bnetInvitation.SetInviteeName(myself.GetFullName());
 		bnetInvitation.SetCreationTimeMicrosec(creationTime);
 		bnetInvitation.SetExpirationTimeMicroSec(expirationTime);
+		bnetInvitation.m_isCheatInvite = true;
 		m_receivedInvites.Add(bnetInvitation);
 		return bnetInvitation;
 	}
 
+	public void Cheat_RemoveReceivedInvites()
+	{
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			changeList.AddRemovedReceivedInvite(invite);
+		}
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
+	public void Cheat_AddReceivedInvites()
+	{
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			changeList.AddAddedReceivedInvite(invite);
+		}
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
+	public void Cheat_AcceptInvite(BnetInvitationId bnetInvitationId)
+	{
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			if (invite.GetId() == bnetInvitationId)
+			{
+				changeList.AddRemovedReceivedInvite(invite);
+				changeList.AddAddedFriend(Cheat_HSACreatePlayer("InvFr#717", "Invited Friend", 0, 0, BnetProgramId.BNET, false, false));
+			}
+		}
+		m_receivedInvites.RemoveAll(i => i.GetId() == bnetInvitationId);
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
+	public void Cheat_DeclineInvite(BnetInvitationId bnetInvitationId)
+	{
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			if (invite.GetId() == bnetInvitationId)
+			{
+				changeList.AddRemovedReceivedInvite(invite);
+			}
+		}
+		m_receivedInvites.RemoveAll(i => i.GetId() == bnetInvitationId);
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
 	public BnetInvitation Cheat_CreateSentInvite(ref ulong nextIdToken, BnetPlayer myself, string fullName, ulong creationTime, ulong expirationTime)
 	{
 		BnetInvitationId id = new BnetInvitationId(nextIdToken++);
@@ -755,4 +817,125 @@ public class BnetFriendMgr
 		m_sentInvites.Add(bnetInvitation);
 		return bnetInvitation;
 	}
+
+    #region Accessibility Testing
+
+    public BnetPlayer Cheat_HSAAddFriend(string battleTag, string fullName, int leagueId, int starLevel, BnetProgramId programId, bool isOnline, bool isAvailable)
+	{
+		var alreadyExistingFriend = HSAGetFriend(battleTag);
+		if (alreadyExistingFriend != null)
+		{
+			return alreadyExistingFriend;
+		}
+
+		var bnetPlayer = Cheat_HSACreatePlayer(battleTag, fullName, leagueId, starLevel, programId, isOnline, isAvailable);
+		m_friends.Add(bnetPlayer);
+		DebugAddFriend(bnetPlayer);
+		return bnetPlayer;
+	}
+
+	private BnetPlayer HSAGetFriend(string battleTag)
+	{
+		foreach (var friend in m_friends)
+		{
+			if (friend.GetBattleTag().GetString().Equals(battleTag))
+			{
+				return friend;
+			}
+		}
+
+		return null;
+	}
+
+	public BnetPlayer Cheat_HSACreatePlayer(string battleTag, string fullName, int leagueId, int starLevel, BnetProgramId programId, bool isOnline, bool isAvailable)
+	{
+		BnetBattleTag bnetBattleTag = new BnetBattleTag();
+		bnetBattleTag.SetString(battleTag);
+		BnetAccountId bnetAccountId = new BnetAccountId();
+		bnetAccountId.SetHi(nextIdToken++);
+		bnetAccountId.SetLo(nextIdToken++);
+		BnetAccount bnetAccount = new BnetAccount();
+		bnetAccount.SetId(bnetAccountId);
+		bnetAccount.SetFullName(fullName);
+		bnetAccount.SetBattleTag(bnetBattleTag);
+		BnetGameAccountId bnetGameAccountId = new BnetGameAccountId();
+		bnetGameAccountId.SetHi(nextIdToken++);
+		bnetGameAccountId.SetLo(nextIdToken++);
+		BnetGameAccount bnetGameAccount = new BnetGameAccount();
+		bnetGameAccount.SetId(bnetGameAccountId);
+		bnetGameAccount.SetBattleTag(bnetBattleTag);
+		bnetGameAccount.SetOnline(isOnline);
+		bnetGameAccount.SetProgramId(programId);
+		GamePresenceRank gamePresenceRank = new GamePresenceRank();
+		foreach (FormatType value in Enum.GetValues(typeof(FormatType)))
+		{
+			if (value != 0)
+			{
+				GamePresenceRankData item = new GamePresenceRankData
+				{
+					FormatType = value,
+					LeagueId = leagueId,
+					StarLevel = starLevel,
+					LegendRank = 327
+				};
+				gamePresenceRank.Values.Add(item);
+			}
+		}
+		byte[] val = ProtobufUtil.ToByteArray(gamePresenceRank);
+
+		if (isAvailable)
+		{
+			bnetGameAccount.SetGameField(1u, true);
+		}
+
+		if (isOnline)
+		{
+			bnetGameAccount.SetGameField(18u, val);
+		}
+
+		BnetPlayer bnetPlayer = new BnetPlayer(BnetPlayerSource.CREATED_BY_CHEAT);
+		bnetPlayer.SetAccount(bnetAccount);
+		bnetPlayer.AddGameAccount(bnetGameAccount);
+		bnetPlayer.IsCheatPlayer = true;
+
+		return bnetPlayer;
+	}
+
+    private void DebugAddFriend(BnetPlayer friend)
+    {
+        if (!HearthstoneAccessConstants.DEV_MODE)
+        {
+			return;
+        }
+
+		var bnetAccount = friend.GetAccount();
+		var gameAccounts = friend.GetGameAccounts();
+
+		AccessibilityUtils.LogDebug($"DebugAddFriend({friend.GetBestName()})");
+
+		AccessibilityUtils.LogDebug($"BnetAccount FullName({bnetAccount.GetFullName()})");
+		AccessibilityUtils.LogDebug($"BnetAccount BattleTag({bnetAccount.GetBattleTag()})");
+
+		AccessibilityUtils.LogDebug($"GameAccounts:");
+
+		foreach (var gameAccount in gameAccounts)
+        {
+            AccessibilityUtils.LogDebug($"AccountId: {gameAccount.Key}");
+
+			var val = gameAccount.Value;
+
+            AccessibilityUtils.LogDebug($"ProgramId: {val.GetProgramId()}");
+            AccessibilityUtils.LogDebug($"IsOnline: {val.IsOnline()}");
+            AccessibilityUtils.LogDebug($"IsAvailable: {val.GetGameFieldBool(1u)}");
+            var bytes = val.GetGameFieldBytes(18u);
+            AccessibilityUtils.LogDebug($"18u: {bytes}");
+        }
+    }
+
+	internal ulong Cheat_HSAGetNextIdToken()
+	{
+		return nextIdToken++;
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BnetInvitation.cs b/Decompiled/Assembly-CSharp/BnetInvitation.cs
index 5ebad1c..776d7c9 100644
--- a/Decompiled/Assembly-CSharp/BnetInvitation.cs
+++ b/Decompiled/Assembly-CSharp/BnetInvitation.cs
@@ -19,6 +19,11 @@ public class BnetInvitation
 
 	private ulong m_expirationTimeMicrosec;
 
+	#region Accessibility Testing
+	internal bool m_isCheatInvite;
+	#endregion
+
+
 	public static BnetInvitation CreateFromFriendsUpdate(FriendsUpdate src)
 	{
 		BnetInvitation bnetInvitation = new BnetInvitation();
diff --git a/Decompiled/Assembly-CSharp/BnetNearbyPlayerMgr.cs b/Decompiled/Assembly-CSharp/BnetNearbyPlayerMgr.cs
index c59f761..9157278 100644
--- a/Decompiled/Assembly-CSharp/BnetNearbyPlayerMgr.cs
+++ b/Decompiled/Assembly-CSharp/BnetNearbyPlayerMgr.cs
@@ -1069,4 +1069,35 @@ public class BnetNearbyPlayerMgr
 		FireChangeEvent(changelist);
 		return num;
 	}
+
+	public BnetPlayer Cheat_CreateHSANearbyPlayer(string battleTag, string fullName, int leagueId, int starLevel, BnetProgramId programId, bool isFriend, bool isOnline, bool isAvailable)
+	{
+		BnetPlayer bnetPlayer;
+
+		if (isFriend)
+		{
+			bnetPlayer = BnetFriendMgr.Get().Cheat_HSAAddFriend(battleTag, fullName, leagueId, starLevel, programId, isOnline, isAvailable);
+		}
+		else
+		{
+			bnetPlayer = BnetFriendMgr.Get().Cheat_HSACreatePlayer(battleTag, fullName, leagueId, starLevel, programId, isOnline, isAvailable);
+		}
+
+		BnetNearbyPlayerChangelist bnetNearbyPlayerChangelist = new BnetNearbyPlayerChangelist();
+		if (isFriend)
+		{
+			bnetNearbyPlayerChangelist.AddAddedFriend(bnetPlayer);
+		}
+		else
+		{
+			bnetNearbyPlayerChangelist.AddAddedPlayer(bnetPlayer);
+		}
+		NearbyPlayer nearbyPlayer = new NearbyPlayer();
+		nearbyPlayer.m_bnetPlayer = bnetPlayer;
+		nearbyPlayer.m_availability = true;
+		nearbyPlayer.m_partyId = PartyId.Empty;
+		m_nearbyAdds.Add(nearbyPlayer);
+		ProcessAddedPlayers(bnetNearbyPlayerChangelist);
+		return bnetPlayer;
+	}
 }
diff --git a/Decompiled/Assembly-CSharp/BnetWhisperMgr.cs b/Decompiled/Assembly-CSharp/BnetWhisperMgr.cs
index 5d9298a..23c31a8 100644
--- a/Decompiled/Assembly-CSharp/BnetWhisperMgr.cs
+++ b/Decompiled/Assembly-CSharp/BnetWhisperMgr.cs
@@ -85,6 +85,12 @@ public class BnetWhisperMgr
 
 	public bool SendWhisper(BnetPlayer player, string message)
 	{
+		if (player.IsCheatPlayer)
+		{
+			// TODO: mock flow
+			return true;
+		}
+
 		if (player == null)
 		{
 			return false;
diff --git a/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs b/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs
index bebf08d..a7d6890 100644
--- a/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs
@@ -52,8 +52,6 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -259,46 +257,19 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_GULDAN_01",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -307,31 +278,4 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_GULDAN_01", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs b/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs
index c6026b4..b1603cb 100644
--- a/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs
@@ -56,8 +56,6 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -266,46 +264,19 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_GULDAN_01",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -314,31 +285,4 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_GULDAN_01", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs b/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs
index 0efae65..8772bff 100644
--- a/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs
@@ -80,8 +80,6 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -196,7 +194,13 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 			yield return MissionPlayVOOnce(enemyActor, m_InGame_BossUsesHeroPowerLines);
 			break;
 		case 105:
-			InitVisuals();
+			InitTurnCounterVisuals(
+				turnCounterKey: "BOH_ILLIDAN_08",
+				fsmRunningManVal: false,
+				fsmMineCartVal: false,
+				fsmAirshipVal: false,
+				fsmDestroyerVal: true
+			);
 			GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 			Gameplay.Get().GetNameBannerForSide(Player.Side.OPPOSING).UpdateHeroNameBanner();
 			break;
@@ -344,43 +348,10 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 		}
 	}
 
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
-	}
-
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = false;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = true;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -389,31 +360,4 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_ILLIDAN_08", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs b/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
index 6dc59e8..b863557 100644
--- a/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 {
@@ -296,7 +297,7 @@ public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 		switch (turn)
 		{
 		case 1:
-			yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
+            yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
 			yield return PlayLineAlways(enemyActor, VO_Story_Hero_Garrosh_Male_Orc_Story_Jaina_Mission6ExchangeA_01);
 			break;
 		case 5:
diff --git a/Decompiled/Assembly-CSharp/BoH_Uther_08.cs b/Decompiled/Assembly-CSharp/BoH_Uther_08.cs
index 03a8744..3612e51 100644
--- a/Decompiled/Assembly-CSharp/BoH_Uther_08.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Uther_08.cs
@@ -46,8 +46,6 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -228,46 +226,19 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_UTHER_08",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -277,33 +248,6 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
 
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_UTHER_08", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
-
 	public override void StartGameplaySoundtracks()
 	{
 		MusicManager.Get().StartPlaylist(MusicPlaylistType.InGame_ICCLichKing);
diff --git a/Decompiled/Assembly-CSharp/BoH_Valeera_08.cs b/Decompiled/Assembly-CSharp/BoH_Valeera_08.cs
index 8a0f0ee..c68eba4 100644
--- a/Decompiled/Assembly-CSharp/BoH_Valeera_08.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Valeera_08.cs
@@ -54,8 +54,6 @@ public class BoH_Valeera_08 : BoH_Valeera_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	public override void PreloadAssets()
@@ -270,46 +268,21 @@ public class BoH_Valeera_08 : BoH_Valeera_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
 
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		// Note: This isn't really a turn-based encounter but Blizzard reused most of the componentry.
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_VALEERA_08",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -319,33 +292,6 @@ public class BoH_Valeera_08 : BoH_Valeera_Dungeon
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
 
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_VALEERA_08", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
-
 	private IEnumerator ShowPopup(string displayString)
 	{
 		StartPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, popUpPos, TutorialEntity.GetTextScale(), GameStrings.Get(displayString), convertLegacyPosition: false);
diff --git a/Decompiled/Assembly-CSharp/Board.cs b/Decompiled/Assembly-CSharp/Board.cs
index e1aae35..8d83d61 100644
--- a/Decompiled/Assembly-CSharp/Board.cs
+++ b/Decompiled/Assembly-CSharp/Board.cs
@@ -274,6 +274,11 @@ public class Board : MonoBehaviour
 		return Gameplay.Get().GetBoardLayout().FindCollider(name);
 	}
 
+	public Collider GetTradeArea()
+	{
+		return FindCollider("TradeArea");
+	}
+
 	public GameObject GetMouseClickDustEffectPrefab()
 	{
 		return m_MouseClickDustEffect;
diff --git a/Decompiled/Assembly-CSharp/BookTab.cs b/Decompiled/Assembly-CSharp/BookTab.cs
index 64df88c..701adbe 100644
--- a/Decompiled/Assembly-CSharp/BookTab.cs
+++ b/Decompiled/Assembly-CSharp/BookTab.cs
@@ -95,6 +95,11 @@ public class BookTab : PegUIElement
 		return m_isVisible;
 	}
 
+	public bool IsSelected()
+	{
+		return m_selected;
+	}
+
 	public void SetTargetVisibility(bool visible)
 	{
 		m_shouldBeVisible = visible;
diff --git a/Decompiled/Assembly-CSharp/BoosterProductPage.cs b/Decompiled/Assembly-CSharp/BoosterProductPage.cs
index 67bf488..a696b09 100644
--- a/Decompiled/Assembly-CSharp/BoosterProductPage.cs
+++ b/Decompiled/Assembly-CSharp/BoosterProductPage.cs
@@ -71,10 +71,10 @@ public class BoosterProductPage : ProductPage
 		}
 	}
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		SetMusicOverride(MusicPlaylistType.Invalid);
-		base.Open();
+		base.Open(true);
 	}
 
 	protected override void OnProductSet()
diff --git a/Decompiled/Assembly-CSharp/Box.cs b/Decompiled/Assembly-CSharp/Box.cs
index a4339ba..30f4ab7 100644
--- a/Decompiled/Assembly-CSharp/Box.cs
+++ b/Decompiled/Assembly-CSharp/Box.cs
@@ -6,6 +6,7 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class Box : MonoBehaviour
@@ -1107,7 +1108,7 @@ public class Box : MonoBehaviour
 		else if (mode == SceneMgr.Mode.TOURNAMENT && flag)
 		{
 			ChangeState(State.SET_ROTATION_OPEN);
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 			m_transitioningToSceneMode = true;
 		}
 		else if (!SceneMgr.Get().IsDoingSceneDrivenTransition() && ChangeState(state))
@@ -1128,7 +1129,8 @@ public class Box : MonoBehaviour
 		{
 			yield return null;
 		}
-		BoxCamera.State state = ((!GameUtils.IsAnyTutorialComplete()) ? BoxCamera.State.CLOSED_TUTORIAL : BoxCamera.State.CLOSED);
+		//BoxCamera.State state = ((!GameUtils.IsAnyTutorialComplete()) ? BoxCamera.State.CLOSED_TUTORIAL : BoxCamera.State.CLOSED);
+		BoxCamera.State state = BoxCamera.State.CLOSED;
 		m_Camera.ChangeState(state);
 	}
 
@@ -1923,7 +1925,7 @@ public class Box : MonoBehaviour
 	private IEnumerator SetRotation_StartSetRotationIntro()
 	{
 		ResetSetRotationPopupProgress();
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.SET_ROTATION_INTRO);
 		NotificationManager.Get().DestroyAllPopUps();
 		PopupDisplayManager.Get().ReadyToShowPopups();
 		yield return StartCoroutine(PopupDisplayManager.Get().WaitForAllPopups());
@@ -2359,6 +2361,8 @@ public class Box : MonoBehaviour
 
 	public virtual void OnSetRotationButtonPressed(UIEvent e)
 	{
+		// Disallow this in case someone misclicks using OCR as they would be in trouble
+		return;
 		Log.Box.Print("Set Rotation Button Pressed!");
 		if (!HearthstoneServices.IsAvailable<SceneMgr>())
 		{
@@ -2622,6 +2626,7 @@ public class Box : MonoBehaviour
 		{
 			Log.Store.Print(reasonLogLevel, verbose: false, unableToOpenReason);
 			SoundManager.Get().LoadAndPlay("Store_closed_button_click.prefab:a6b74848e2c7e5748a20524b40fe6c1e", base.gameObject);
+			AccessibilityMgr.Output(AccessibleHub.Get(), GameStrings.Get("GLUE_SHOP_CLOSED_ALERT_HEADER"));
 			return;
 		}
 		FireButtonPressEvent(ButtonType.STORE);
diff --git a/Decompiled/Assembly-CSharp/ButtonListMenu.cs b/Decompiled/Assembly-CSharp/ButtonListMenu.cs
index a053c71..2d65637 100644
--- a/Decompiled/Assembly-CSharp/ButtonListMenu.cs
+++ b/Decompiled/Assembly-CSharp/ButtonListMenu.cs
@@ -9,7 +9,7 @@ public abstract class ButtonListMenu : MonoBehaviour
 
 	private bool m_isShown;
 
-	private List<UIBButton> m_allButtons = new List<UIBButton>();
+	protected List<UIBButton> m_allButtons = new List<UIBButton>();
 
 	private List<GameObject> m_horizontalDividers = new List<GameObject>();
 
diff --git a/Decompiled/Assembly-CSharp/Card.cs b/Decompiled/Assembly-CSharp/Card.cs
index 49d5483..537c625 100644
--- a/Decompiled/Assembly-CSharp/Card.cs
+++ b/Decompiled/Assembly-CSharp/Card.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Hearthstone;
 using PegasusGame;
 using UnityEngine;
@@ -5569,6 +5570,7 @@ public class Card : MonoBehaviour
 		m_actor.Show();
 		m_actor.TurnOffCollider();
 		deck.UpdateLayout();
+		AccessibleGameplay.Get().OnDrawCard(this);
 		PowerTask powerTaskToBlockCardDraw = GetPowerTaskToBlockCardDraw();
 		PowerTask cardDrawBlockingTask = powerTaskToBlockCardDraw;
 		while (iTween.Count(base.gameObject) > 0)
@@ -5645,6 +5647,7 @@ public class Card : MonoBehaviour
 	private IEnumerator DrawUnknownOpponentCard(ZoneHand handZone)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_and_add_to_hand_opp_1.prefab:5a05fbb2c5833a94182e1b454647d5c8", base.gameObject);
+		AccessibleGameplay.Get().OnDrawUnknownOpponentCard(this);
 		base.gameObject.transform.rotation = IN_DECK_HIDDEN_ROTATION;
 		DetermineIfOverrideDrawTimeScale();
 		Transform transform = Board.Get().FindBone("OpponentDrawCard");
@@ -5722,6 +5725,7 @@ public class Card : MonoBehaviour
 	private IEnumerator RevealDrawnOpponentCard(string handActorPath, Actor handActor, ZoneHand handZone)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_1.prefab:19dd221ebfed9754e85ef1f104e0fddb", base.gameObject);
+		AccessibleGameplay.Get().OnRevealDrawnOpponentCard(this);
 		handActor.transform.parent = m_actor.transform.parent;
 		TransformUtil.CopyLocal(handActor, m_actor);
 		m_actor.Hide();
@@ -6447,6 +6451,7 @@ public class Card : MonoBehaviour
 	public IEnumerator AnimatePlayToDeck(GameObject mover, ZoneDeck deckZone, bool hideBackSide = false, float timeScale = 1f)
 	{
 		SoundManager.Get().LoadAndPlay("MinionToDeck_transition.prefab:8063f1b133f28e34aaeade8fcabe250c");
+		AccessibleGameplay.Get().OnCardToDeck(this);
 		Vector3 vector = deckZone.GetThicknessForLayout().GetMeshRenderer().bounds.center + IN_DECK_OFFSET;
 		if (m_entity != null && m_entity.IsMercenary())
 		{
@@ -7152,7 +7157,7 @@ public class Card : MonoBehaviour
 		{
 			return false;
 		}
-		Collider collider = Board.Get().FindCollider("TradeArea");
+		Collider collider = Board.Get().GetTradeArea();
 		if (collider == null)
 		{
 			return false;
diff --git a/Decompiled/Assembly-CSharp/CardBackInfoManager.cs b/Decompiled/Assembly-CSharp/CardBackInfoManager.cs
index 8e2763e..9afd6a4 100644
--- a/Decompiled/Assembly-CSharp/CardBackInfoManager.cs
+++ b/Decompiled/Assembly-CSharp/CardBackInfoManager.cs
@@ -4,9 +4,10 @@ using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class CardBackInfoManager : MonoBehaviour, IStore
+public class CardBackInfoManager : MonoBehaviour, IStore, AccessibleUI
 {
 	private const string STATE_MAKE_FAVORITE = "MAKE_FAVORITE";
 
@@ -149,6 +150,7 @@ public class CardBackInfoManager : MonoBehaviour, IStore
 
 	private void OnDestroy()
 	{
+		HideThis();
 		s_instance = null;
 	}
 
@@ -241,6 +243,8 @@ public class CardBackInfoManager : MonoBehaviour, IStore
 				SoundManager.Get().LoadAndPlay(m_enterPreviewSound);
 			}
 			FullScreenFXMgr.Get().StartStandardBlurVignette(m_animationTime);
+
+			ReadCardBackPreview();
 		}
 	}
 
@@ -269,6 +273,8 @@ public class CardBackInfoManager : MonoBehaviour, IStore
 			}
 			FullScreenFXMgr.Get().EndStandardBlurVignette(m_animationTime);
 		}
+
+		HideThis();
 	}
 
 	private void OnUserActionVisualControllerReady(VisualController visualController)
@@ -571,4 +577,40 @@ public class CardBackInfoManager : MonoBehaviour, IStore
 	{
 		return new CurrencyType[1] { CurrencyType.GOLD };
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadCardBackPreview()
+	{
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleMenu = new AccessibleMenu(this, m_title.Text, CancelPreview);
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), () => AccessibilityMgr.Output(this, m_description.Text));
+
+		if (m_favoriteButton.IsEnabled())
+		{
+			m_accessibleMenu.AddOption(m_favoriteButton.GetText(), m_favoriteButton.TriggerRelease);
+		}
+
+		m_accessibleMenu.StartReading();
+	}
+
+	private void HideThis()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CardBackManager.cs b/Decompiled/Assembly-CSharp/CardBackManager.cs
index da601ba..cd4c407 100644
--- a/Decompiled/Assembly-CSharp/CardBackManager.cs
+++ b/Decompiled/Assembly-CSharp/CardBackManager.cs
@@ -12,6 +12,7 @@ using Hearthstone.Core;
 using Hearthstone.DataModels;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class CardBackManager : IService
 {
@@ -372,11 +373,14 @@ public class CardBackManager : IService
 			RequestSetFavoriteCardBack(cardBackId, !IsCardBackFavorited(cardBackId));
 			return;
 		}
+
 		foreach (int favoriteCardBack in GetCardBacks().FavoriteCardBacks)
 		{
 			RequestSetFavoriteCardBack(favoriteCardBack, isFavorite: false);
 		}
 		RequestSetFavoriteCardBack(cardBackId);
+
+		AccessibleCollectionManager.Get().WaitingForServerResponse();
 	}
 
 	public void RequestSetFavoriteCardBack(int cardBackID, bool isFavorite = true)
diff --git a/Decompiled/Assembly-CSharp/CardListPanel.cs b/Decompiled/Assembly-CSharp/CardListPanel.cs
index 6cfcd1c..b61ef90 100644
--- a/Decompiled/Assembly-CSharp/CardListPanel.cs
+++ b/Decompiled/Assembly-CSharp/CardListPanel.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CardListPanel : MonoBehaviour
@@ -18,11 +19,11 @@ public class CardListPanel : MonoBehaviour
 
 	private UIBButton m_rightArrow;
 
-	private const int MAX_CARDS_PER_PAGE = 3;
+	internal const int MAX_CARDS_PER_PAGE = 3;
 
 	private int m_numPages = 1;
 
-	private int m_pageNum;
+	internal int m_pageNum;
 
 	private List<int> m_cards = new List<int>();
 
@@ -55,7 +56,7 @@ public class CardListPanel : MonoBehaviour
 			m_cards = cards;
 		}
 		SetupPagingArrows();
-		m_numPages = (m_cards.Count + 3 - 1) / 3;
+		m_numPages = (m_cards.Count + MAX_CARDS_PER_PAGE - 1) / MAX_CARDS_PER_PAGE;
 		ShowPage(0);
 	}
 
@@ -90,8 +91,8 @@ public class CardListPanel : MonoBehaviour
 		}
 		m_cardActors.Clear();
 		list.Clear();
-		int num = m_pageNum * 3;
-		int num2 = Mathf.Min(3, m_cards.Count - num);
+		int num = m_pageNum * MAX_CARDS_PER_PAGE;
+		int num2 = Mathf.Min(MAX_CARDS_PER_PAGE, m_cards.Count - num);
 		for (int i = 0; i < num2; i++)
 		{
 			int num3 = m_cards[num + i];
@@ -154,7 +155,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void UpdateCardPositions()
+    private void UpdateCardPositions()
 	{
 		int count = m_cardActors.Count;
 		for (int i = 0; i < count; i++)
@@ -169,7 +170,7 @@ public class CardListPanel : MonoBehaviour
 
 	private void SetupPagingArrows()
 	{
-		if (m_cards.Count > 3)
+		if (m_cards.Count > MAX_CARDS_PER_PAGE)
 		{
 			m_leftArrowNested.gameObject.SetActive(value: true);
 			m_rightArrowNested.gameObject.SetActive(value: true);
@@ -200,7 +201,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void TurnPage(bool right)
+	internal void TurnPage(bool right)
 	{
 		HighlightState componentInChildren = m_rightArrow.GetComponentInChildren<HighlightState>();
 		if ((bool)componentInChildren)
diff --git a/Decompiled/Assembly-CSharp/CardListPopup.cs b/Decompiled/Assembly-CSharp/CardListPopup.cs
index 4f80863..10a50dd 100644
--- a/Decompiled/Assembly-CSharp/CardListPopup.cs
+++ b/Decompiled/Assembly-CSharp/CardListPopup.cs
@@ -1,4 +1,7 @@
+using System;
 using System.Collections.Generic;
+using Accessibility;
+using UnityEngine;
 
 [CustomEditClass]
 public class CardListPopup : DialogBase
@@ -31,7 +34,12 @@ public class CardListPopup : DialogBase
 
 	private Info m_info = new Info();
 
-	protected override void Awake()
+    #region Accessibility
+    private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleCards;
+	private CardListPanel m_curCardsContainer;
+    #endregion
+
+    protected override void Awake()
 	{
 		base.Awake();
 		m_okayButton.AddEventListener(UIEventType.RELEASE, delegate
@@ -66,18 +74,83 @@ public class CardListPopup : DialogBase
 		{
 			m_CardsContainer_MultiLineDescription.Show(m_info.m_cards);
 			m_descriptionMultiLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_MultiLineDescription;
 		}
 		else
 		{
 			m_CardsContainer_SingleLineDescription.Show(m_info.m_cards);
 			m_descriptionSingleLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_SingleLineDescription;
 		}
 		UniversalInputManager.Get().SetSystemDialogActive(active: true);
-	}
 
-	public override void Hide()
+		ReadPopup();
+    }
+
+    public override void Hide()
 	{
 		base.Hide();
 		DialogBase.EndBlur();
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+        var accessibleCards = new List<AccessibleCollectibleCard>();
+        foreach (var cardDbId in m_info.m_cards)
+        {
+			var cardId = GameUtils.TranslateDbIdToCardId(cardDbId);
+			CollectibleCard card = CollectionManager.Get().GetCard(cardId, TAG_PREMIUM.NORMAL); 
+            accessibleCards.Add(new AccessibleCollectibleCard(this, card, false, true));
+        }
+
+        m_accessibleCards = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, m_info.m_description);
+		m_accessibleCards.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+            m_okayButton.TriggerRelease();
+        }
+        else
+        {
+			if (m_accessibleCards.HandleAccessibleInput())
+			{
+				ChangePageIfNeeded();
+			}
+        }
+    }
+
+    private void ChangePageIfNeeded()
+    {
+		int curCardIndex = m_accessibleCards.GetItemBeingReadIndex();
+		int cardsPerPage = CardListPanel.MAX_CARDS_PER_PAGE;
+		int curPage = m_curCardsContainer.m_pageNum;
+
+		int realPage = curCardIndex / cardsPerPage;
+
+		if (curPage < realPage)
+        {
+            m_curCardsContainer.TurnPage(true);
+        }
+		else if (curPage > realPage)
+        {
+			m_curCardsContainer.TurnPage(false);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		var helpText = LocalizationUtils.Get(LocalizationKey.UI_CARD_LIST_POPUP_HELP);
+		return AccessibleSpeechUtils.CombineSentences(helpText, AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CardPopups.cs b/Decompiled/Assembly-CSharp/CardPopups.cs
index 5055cc5..9dd7c96 100644
--- a/Decompiled/Assembly-CSharp/CardPopups.cs
+++ b/Decompiled/Assembly-CSharp/CardPopups.cs
@@ -26,7 +26,7 @@ public class CardPopups : IDisposable
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowChangedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowChangedCards"))
 		{
 			return false;
 		}
@@ -39,11 +39,11 @@ public class CardPopups : IDisposable
 
 	public bool ShowFeaturedCards(string featuredCardsEvent, string headerText, DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowFeaturedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowFeaturedCards"))
 		{
 			return false;
 		}
-		MultiPagePopup.Info info = new MultiPagePopup.Info
+		MultiPagePopup.Info info = new MultiPagePopup.Info(true)
 		{
 			m_callbackOnHide = callbackOnHide,
 			m_blurWhenShown = true
@@ -51,7 +51,7 @@ public class CardPopups : IDisposable
 		List<int> cards = (from r in GameDbf.GetIndex().GetCardsWithFeaturedCardsEvent()
 			where r.FeaturedCardsEvent == featuredCardsEvent
 			select r.ID).ToList();
-		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo
+		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo(true)
 		{
 			m_pageType = MultiPagePopup.PageType.CARD_LIST,
 			m_cards = cards,
diff --git a/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs b/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
index 745be4f..a04faea 100644
--- a/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
+++ b/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
@@ -70,7 +70,7 @@ public class CastSpellCardFromHandSepll : Spell
 		targetCard.HideCard();
 		Entity entity = targetCard.GetEntity();
 		UpdateTags(entity);
-		HistoryManager.Get().CreatePlayedBigCard(entity, delegate
+		HistoryManager.Get().CreatePlayedBigCard(m_taskList, entity, delegate
 		{
 		}, delegate
 		{
@@ -126,7 +126,7 @@ public class CastSpellCardFromHandSepll : Spell
 		iTween.RotateTo(targetCard.gameObject, transform.rotation.eulerAngles, m_BigCardDisplayTime);
 		iTween.ScaleTo(targetCard.gameObject, new Vector3(1f, 1f, 1f), m_BigCardDisplayTime);
 		SoundManager.Get().LoadAndPlay("play_card_from_hand_1.prefab:ac4be75e319a97947a68308a08e54e88");
-		yield return new WaitForSeconds(m_BigCardDisplayTime);
+        yield return new WaitForSeconds(m_BigCardDisplayTime);
 	}
 
 	private IEnumerator PlayPowerUpSpell()
diff --git a/Decompiled/Assembly-CSharp/ChatBubbleFrame.cs b/Decompiled/Assembly-CSharp/ChatBubbleFrame.cs
index 828b58e..2552704 100644
--- a/Decompiled/Assembly-CSharp/ChatBubbleFrame.cs
+++ b/Decompiled/Assembly-CSharp/ChatBubbleFrame.cs
@@ -1,5 +1,6 @@
 using bgs;
 using UnityEngine;
+using Accessibility;
 
 public class ChatBubbleFrame : MonoBehaviour
 {
@@ -72,7 +73,8 @@ public class ChatBubbleFrame : MonoBehaviour
 			m_MyDecoration.SetActive(value: true);
 			m_TheirDecoration.SetActive(value: false);
 			BnetPlayer receiver = WhisperUtil.GetReceiver(m_whisper);
-			m_NameText.Text = GameStrings.Format("GLOBAL_CHAT_BUBBLE_RECEIVER_NAME", receiver.GetBestName());
+			m_receiverName = receiver.GetBestName();
+			m_NameText.Text = GameStrings.Format("GLOBAL_CHAT_BUBBLE_RECEIVER_NAME", m_receiverName);
 		}
 		else
 		{
@@ -87,9 +89,31 @@ public class ChatBubbleFrame : MonoBehaviour
 			{
 				m_NameText.TextColor = GameColors.PLAYER_NAME_OFFLINE;
 			}
-			m_NameText.Text = speaker.GetBestName();
+			m_speakerName = speaker.GetBestName();
+			m_NameText.Text = m_speakerName;
 		}
-		m_MessageText.Text = ChatUtils.GetMessage(m_whisper);
+		m_messageText = ChatUtils.GetMessage(m_whisper);
+		m_MessageText.Text = m_messageText;
 		m_MessageText.Text += " ";
 	}
+
+	#region Accessibility
+
+	private string m_receiverName = "";
+	private string m_speakerName = "";
+	private string m_messageText = "";
+
+	internal void ReadMessage()
+	{
+		if (m_receiverName.Length > 0)
+		{
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_SOCIAL_CHAT_MESSAGE_SENT, m_receiverName, m_messageText));
+		}
+		else if (m_speakerName.Length > 0)
+		{
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_SOCIAL_CHAT_MESSAGE_RECEIVED, m_speakerName, m_messageText));
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ChatMgr.cs b/Decompiled/Assembly-CSharp/ChatMgr.cs
index 3dddcdd..bfecff0 100644
--- a/Decompiled/Assembly-CSharp/ChatMgr.cs
+++ b/Decompiled/Assembly-CSharp/ChatMgr.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using bgs;
 using Hearthstone;
 using UnityEngine;
@@ -59,7 +60,7 @@ public class ChatMgr : MonoBehaviour
 
 	private bool m_chatLogFrameShown;
 
-	private bool m_isChatFeatureEnabled;
+	private bool m_isChatFeatureEnabled = true;
 
 	private PrivacyFeaturesPopup m_chatPrivacyPopup;
 
@@ -691,6 +692,15 @@ public class ChatMgr : MonoBehaviour
 
 	public void HandleGUIInput()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Chat is not implemented yet
+			return;
+        }
+
+		// Players were running into issues due to pressing Enter while using OCR so we'll disable this for now and rethink it later
+		return;
+
 		if (!m_fatalErrorMgr.HasError() && !IsMobilePlatform())
 		{
 			HandleGUIInputForQuickChat();
@@ -925,6 +935,7 @@ public class ChatMgr : MonoBehaviour
 		chatBubbleFrame.transform.parent = m_ChatBubbleInfo.m_Parent.transform;
 		chatBubbleFrame.transform.localScale = chatBubbleFrame.m_ScaleOverride;
 		SoundManager.Get().LoadAndPlay("receive_message.prefab:8e90a827cd4a0e849953158396cd1ee1");
+		chatBubbleFrame.ReadMessage();
 		Hashtable args = iTween.Hash("scale", chatBubbleFrame.m_VisualRoot.transform.localScale, "time", m_ChatBubbleInfo.m_ScaleInSec, "easeType", m_ChatBubbleInfo.m_ScaleInEaseType, "oncomplete", "OnChatBubbleScaleInComplete", "oncompleteparams", chatBubbleFrame, "oncompletetarget", base.gameObject);
 		chatBubbleFrame.m_VisualRoot.transform.localScale = new Vector3(0.0001f, 0.0001f, 0.0001f);
 		iTween.ScaleTo(chatBubbleFrame.m_VisualRoot, args);
diff --git a/Decompiled/Assembly-CSharp/CheatMgr.cs b/Decompiled/Assembly-CSharp/CheatMgr.cs
index be1e317..4cface0 100644
--- a/Decompiled/Assembly-CSharp/CheatMgr.cs
+++ b/Decompiled/Assembly-CSharp/CheatMgr.cs
@@ -7,6 +7,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class CheatMgr : IService
 {
@@ -121,7 +122,7 @@ public class CheatMgr : IService
 		{
 			return false;
 		}
-		if (!InputCollection.GetKeyUp(KeyCode.BackQuote))
+		if (!InputCollection.GetKeyUp(KeyCode.Backslash))
 		{
 			return false;
 		}
@@ -151,9 +152,10 @@ public class CheatMgr : IService
 			m_completedCallback = OnInputComplete
 		};
 		UniversalInputManager.Get().UseTextInput(parms);
-	}
+        AccessibilityMgr.AllowTextInput();
+    }
 
-	public void HideConsole()
+    public void HideConsole()
 	{
 		UniversalInputManager.Get().CancelTextInput(SceneObject);
 		m_inputActive = false;
@@ -472,6 +474,8 @@ public class CheatMgr : IService
 
 	private void OnInputComplete(string inputCommand)
 	{
+        AccessibilityMgr.DisallowTextInput();
+
 		m_inputActive = false;
 		inputCommand = inputCommand.TrimStart();
 		if (!string.IsNullOrEmpty(inputCommand))
@@ -568,6 +572,9 @@ public class CheatMgr : IService
 		{
 			return "\"" + text + "\" cheat command executed, but failed!";
 		}
+
+		AccessibilityUtils.LogDebug($"Processed cheat: {inputCommand}");
+
 		return null;
 	}
 
diff --git a/Decompiled/Assembly-CSharp/Cheats.cs b/Decompiled/Assembly-CSharp/Cheats.cs
index 3e7ad4c..2d6b771 100644
--- a/Decompiled/Assembly-CSharp/Cheats.cs
+++ b/Decompiled/Assembly-CSharp/Cheats.cs
@@ -42,6 +42,7 @@ using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
 using UnityEngine.SceneManagement;
+using Accessibility;
 
 public class Cheats : IService
 {
@@ -388,6 +389,55 @@ public class Cheats : IService
 		CheatMgr cheatMgr = serviceLocator.Get<CheatMgr>();
 		if (HearthstoneApplication.IsInternal())
 		{
+			cheatMgr.RegisterCategory("HSA core");
+			cheatMgr.RegisterCheatHandler("hsasetlevelsoverride", OnProcessCheat_hsasetlevelsoverride, "Overrides hero levels", "<true/false>", "true");
+			cheatMgr.RegisterCategory("HSA changed cards");
+			cheatMgr.RegisterCheatHandler("hsashowchangedcardspopup", OnProcessCheat_hsashowchangedcardspopup, "Show 'these cards have changed' popup", "<command name>", "");
+			cheatMgr.RegisterCheatHandler("hsashowaddedcardspopup", OnProcessCheat_hsashowaddedcardspopup, "Show 'these cards were added' popup", "<command name>", "");
+			cheatMgr.RegisterCategory("HSA reconnect");
+			cheatMgr.RegisterCheatHandler("hsashowreconnecthelperdialog", OnProcessCheat_hsashowreconnecthelperdialog, "Show the recconect helper dialog", "<command> [fullResetRequired] [wasKickedForInactivity] [updateRequired]", "");
+			cheatMgr.RegisterCategory("HSA Quests");
+			cheatMgr.RegisterCheatHandler("hsashowquesttoastmount", OnProcessCheat_hsashowquesttoastmount, "Show a quest toast which rewards a mount", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowquesttoastminiset", OnProcessCheat_hsashowquesttoastminiset, "Show a quest toast which rewards a mini set", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowwelcomequests", OnProcessCheat_hsashowwelcomequests, "Show welcome quests", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsamockquests", OnProcessCheat_hsamockquests, "Mock quests to test the daily popup and journal", "<scenarioID>", "");
+			cheatMgr.RegisterCheatHandler("hsatriggerrerollquestresponse", OnProcessCheat_hsatriggerrerollquestresponse, "Trigger a fake reroll quest response message", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsamocktrackrewards", OnProcessCheat_hsamocktrackrewards, "Mock track rewards", "<scenarioID>", "");
+			cheatMgr.RegisterCheatHandler("hsatriggertrackrewardclaimedresponse", OnProcessCheat_hsatriggertrackrewardclaimedresponse, "Trigger a fake track reward claimed response", "", "");
+			cheatMgr.RegisterCheatHandler("hsatriggertrackrewardackdresponse", OnProcessCheat_hsatriggertrackrewardackdresponse, "Trigger a fake track reward ACK'd response", "", "");
+			cheatMgr.RegisterCategory("HSA Returning player");
+			cheatMgr.RegisterCheatHandler("hsashowreturningplayerbanner", OnProcessCheat_hsashowreturningplayerbanner, "Show returning player banner", "<command>", "");
+			cheatMgr.RegisterCategory("HSA Basic popups");
+			cheatMgr.RegisterCheatHandler("hsashowstandardcomingsoonpopup", OnProcessCheat_hsashowstandardcomingsoonpopup, "Show Standard coming soon popup", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowcoresetavailablepopup", OnProcessCheat_hsashowcoresetavailablepopup, "Show core set available popup", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowwhizbangpopup", OnProcessCheat_hsashowwhizbangpopup, "Show Whizbang popup", "<command>", "");
+			cheatMgr.RegisterCategory("HSA others");
+			cheatMgr.RegisterCheatHandler("hsashowleaguepromotionrewards", OnProcessCheat_hsashowleaguepromotionrewards, "Show (legacy?) league promotion rewards", "<command> [rank]", "bronze10");
+			cheatMgr.RegisterCheatHandler("hsashowquestchestreward", OnProcessCheat_hsashowquestchestreward, "Show (legacy?) quest chest reward", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsatestfreedeck", OnProcessCheat_hsatestfreedeck, "Show choose a (free) deck popup (the one after apprenticeship)", "<command>", "");
+			cheatMgr.RegisterCategory("HSA pack opening");
+			cheatMgr.RegisterCheatHandler("hsasettestpacks1", OnProcessCheat_hsasettestpacks1, "Set test packs 1", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasettestpacks2", OnProcessCheat_hsasettestpacks2, "Set test packs 2", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasettestpacks3", OnProcessCheat_hsasettestpacks3, "Set test packs 3", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsaresettestpacks", OnProcessCheat_hsaresettestpacks, "Reset test packs", "<command>", "");
+			cheatMgr.RegisterCategory("HSA social");
+			cheatMgr.RegisterCheatHandler("hsasetupfriends", OnProcessCheat_hsasetupfriends, "Setup test friends", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasimulatereceivedinvite", OnProcessCheat_hsasimulatereceivedinvite, "Simulate received invite", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsaremovesimulatedinvites", OnProcessCheat_hsaremovesimulatedinvites, "Remove simulated invites", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsaaddsimulatedinvites", OnProcessCheat_hsaaddsimulatedinvites, "Add simulated invites", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasimulatereceivedchallengepopup", OnProcessCheat_hsasimulatereceivedchallengepopup, "Simulate received standard friendly challenge popup", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasimulatesocialtoast", OnProcessCheat_hsasimulatesocialtoast, "Simulate social toast", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasetupnearbyplayers", OnProcessCheat_hsasetupnearbyplayers, "Setup test nearby players", "<command>", "");
+			cheatMgr.RegisterCategory("HSA PvP");
+			cheatMgr.RegisterCheatHandler("hsasetpvp", OnProcessCheat_hsasetpvp, "Sets the PvP menu override", "<true/false>", "true");
+			cheatMgr.RegisterCheatHandler("hsasetwild", OnProcessCheat_hsasetwild, "Faked wild mode unlocked (includes classic)", "<true/false>", "true");
+			cheatMgr.RegisterCheatHandler("hsaresetpvpoverrides", OnProcessCheat_hsaresetpvpoverrides, "Resets PvP overrides", "<true/false>", "true");
+			cheatMgr.RegisterCheatHandler("hsasetformattype", OnProcessCheat_hsasetformattype, "Sets format type", "[standard|wild|classic]", "standard");
+			cheatMgr.RegisterCheatHandler("hsasetnumdecks", OnProcessCheat_hsasetnumdecks, "Overrides the number of decks for a given format", "[standard|wild|classic] <numDecks>", "standard 0");
+			cheatMgr.RegisterCheatHandler("hsaresetnumdecks", OnProcessCheat_hsaresetnumdecks, "Resets any num decks overrides", "<command>", "");
+			cheatMgr.RegisterCategory("HSA Crafting");
+			cheatMgr.RegisterCheatHandler("hsatriggercardsaleresponse", OnProcessCheat_hsatriggercardsaleresponse, "Triggers a fake card sale response", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsatriggermassdisenchantresponse", OnProcessCheat_hsatriggermassdisenchantresponse, "Triggers a fake mass disenchant response", "<command>", "");
 			cheatMgr.RegisterCategory("help");
 			cheatMgr.RegisterCheatHandler("help", OnProcessCheat_help, "Get help for a specific command or list of commands", "<command name>", "");
 			cheatMgr.RegisterCheatHandler("example", OnProcessCheat_example, "Run an example of this command if one exists", "<command name>");
@@ -481,7 +531,7 @@ public class Cheats : IService
 			cheatMgr.RegisterCheatHandler("iksaction", OnProcessCheat_iksgameaction, "Execute a game action as if IKS was clicked.");
 			cheatMgr.RegisterCheatHandler("iksseen", OnProcessCheat_iksseen, "Determine if an IKS message should be seen by its game action.");
 			cheatMgr.RegisterCategory("rank");
-			cheatMgr.RegisterCheatHandler("seasondialog", OnProcessCheat_seasondialog, "Open the season end dialog", "<rank> [standard|wild|classic]", "bronze5 wild");
+			cheatMgr.RegisterCheatHandler("seasondialog", OnProcessCheat_seasondialog, "Open the season end dialog", "<rank> [standard|wild|classic]", "bronze5 wild"); // BUG
 			cheatMgr.RegisterCheatHandler("rankrefresh", OnProcessCheat_rankrefresh, "Request medalinfo from server and show rankchange twoscoop after receiving it");
 			cheatMgr.RegisterCheatHandler("rankchange", OnProcessCheat_rankchange, "Show a fake rankchange twoscoop", "[rank] [up|down|win|loss] [wild] [winstreak] [chest]", "bronze5 up chest");
 			cheatMgr.RegisterCheatHandler("rankreward", OnProcessCheat_rankreward, "Show a fake RankedRewardDisplay for rank (or all ranks up to a rank)", "<rank> [standard|wild|classic|all]", "bronze5 all");
@@ -698,7 +748,7 @@ public class Cheats : IService
 		yield break;
 	}
 
-	public Type[] GetDependencies()
+    public Type[] GetDependencies()
 	{
 		return new Type[2]
 		{
@@ -3270,8 +3320,10 @@ public class Cheats : IService
 		}
 		if (flag)
 		{
-			achievement.SetDescription("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "");
-			achievement.SetName("Title Text", "");
+			//achievement.SetDescription("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "");
+			achievement.SetName("Example quest", "");
+			achievement.SetDescription("Kill 5 minions", "");
+			achievement.SetRewards(rewards);
 			QuestToast.ShowQuestToast(UserAttentionBlocker.ALL, null, updateCacheValues: false, achievement);
 		}
 		else
@@ -3662,7 +3714,7 @@ public class Cheats : IService
 
 	private bool OnProcessCheat_setRotationRotatedBoostersPopup(string func, string[] args, string rawArgs)
 	{
-		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo("");
 		DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, info);
 		return true;
 	}
@@ -10857,7 +10909,7 @@ public class Cheats : IService
 
 	private bool OnProcessCheat_showtrackreward(string func, string[] args, string rawArgs)
 	{
-		string message = "showtrackreward <level> <forPaidTrack>";
+		string message = "showtrackreward <level> <forPaidTrack> <tracklevelOverrideForAccessibilityTesting>";
 		if (!int.TryParse(args[0], out var level))
 		{
 			UIStatus.Get().AddInfo(message);
@@ -10868,6 +10920,7 @@ public class Cheats : IService
 		{
 			bool.TryParse(args[1], out result);
 		}
+
 		RewardTrackLevelDbfRecord rewardTrackLevelDbfRecord = RewardTrackManager.Get().RewardTrackAsset.Levels.Where((RewardTrackLevelDbfRecord r) => r.Level == level).FirstOrDefault();
 		if (rewardTrackLevelDbfRecord == null)
 		{
@@ -10887,6 +10940,11 @@ public class Cheats : IService
 			}
 			return true;
 		}
+		if (args.Length > 2)
+        {
+			int.TryParse(args[2], out num);
+        }
+		/*RewardScroll.DebugShowFake(RewardTrackFactory.CreateRewardScrollDataModel(num, level));*/ // This broke but think Blizz fixed it
 		RewardTrackManager.Get().Cheat_ShowRewardScroll(num, level);
 		return true;
 	}
@@ -11380,4 +11438,534 @@ public class Cheats : IService
 		mercenaryDetailDisplay.Show(lettuceMercenary);
 		return true;
 	}
+
+	#region Accessibility
+	private bool OnProcessCheat_hsashowchangedcardspopup(string func, string[] args, string rawArgs)
+	{
+        CheatMgr.Get().ProcessCheat("cardresetchange");
+        Vars.Key("Cheats.ShowFakeNerfedCards").Set(true.ToString(), false);
+        CheatMgr.Get().ProcessCheat("cardchangepopup false true 5");
+        return true;
+	}
+
+	private bool OnProcessCheat_hsashowaddedcardspopup(string func, string[] args, string rawArgs)
+	{
+        CheatMgr.Get().ProcessCheat("cardresetchange");
+        Vars.Key("Cheats.ShowFakeAddedCards").Set(true.ToString(), false);
+        CheatMgr.Get().ProcessCheat("cardchangepopup true true 5");
+        return true;
+	}
+	
+	private bool OnProcessCheat_hsashowreconnecthelperdialog(string func, string[] args, string rawArgs)
+	{
+		bool fullResetRequired = false;
+		bool wasKickedForInactivity = false;
+		bool updateRequired = false;
+
+		if (args.Length < 3)
+		{
+			UIStatus.Get().AddInfo("Usage: hsashowreconnecthelperdialog [fullResetRequired] [wasKickedForInactivity] [updateRequired] \nExample: hsashowreconnecthelperdialog true false true");
+			return false;
+		}
+
+		if (!bool.TryParse(args[0], out fullResetRequired))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[0]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (!bool.TryParse(args[1], out wasKickedForInactivity))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[1]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (!bool.TryParse(args[2], out updateRequired))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[2]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (fullResetRequired)
+        {
+			ReconnectMgr.Get().FullResetRequired = true;
+        }
+
+		if (wasKickedForInactivity)
+        {
+			InactivePlayerKicker.Get().WasKickedForInactivity = true;
+        }
+
+		if (updateRequired)
+        {
+			ReconnectMgr.Get().UpdateRequired = true;
+        }
+
+        DialogManager.Get().ShowReconnectHelperDialog();
+        return true;
+	}
+
+    private bool OnProcessCheat_hsashowquesttoastmount(string func, string[] args, string rawArgs)
+    {
+        RewardData rwd = new MountRewardData(MountRewardData.MountType.WOW_HEARTHSTEED);
+        ShowQuestToast(rwd);
+		return true;
+    }
+
+    private bool OnProcessCheat_hsashowquesttoastminiset(string func, string[] args, string rawArgs)
+    {
+		RewardData rwd = new MiniSetRewardData(36, 1);
+        ShowQuestToast(rwd);
+		return true;
+    }
+
+    private void ShowQuestToast(RewardData rwd)
+    {
+        QuestToast.ShowGenericRewardQuestToast(UserAttentionBlocker.NONE, null, rwd, "Example quest", "Kill 5 minions");
+    }
+
+    private bool OnProcessCheat_hsashowwelcomequests(string func, string[] args, string rawArgs)
+    {
+        Achievement achievement = AchieveManager.Get().GetAchievement(58);
+        WelcomeQuests.ShowSpecialQuest(UserAttentionBlocker.ALL, achievement);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsamockquests(string func, string[] args, string rawArgs)
+    {
+		if (args.Length != 1)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(args[0], out var intVal))
+		{
+			return false;
+		}
+
+		return AccessibleQuestsTestingUtils.SetScenario(intVal);
+    }
+
+    private bool OnProcessCheat_hsamocktrackrewards(string func, string[] args, string rawArgs)
+    {
+		if (args.Length != 1)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(args[0], out var intVal))
+		{
+			return false;
+		}
+
+		return AccessibleRewardsTrackTestingUtils.SetScenario(intVal);
+    }
+
+    private bool OnProcessCheat_hsatriggerrerollquestresponse(string func, string[] args, string rawArgs)
+    {
+		AccessibleQuestsTestingUtils.ReceiveRerollQuestResponseMessage();
+		return true;
+    }
+
+    private bool OnProcessCheat_hsatriggertrackrewardclaimedresponse(string func, string[] args, string rawArgs)
+    {
+		return AccessibleRewardsTrackTestingUtils.TriggerClaimedRewardResponse();
+    }
+
+    private bool OnProcessCheat_hsatriggertrackrewardackdresponse(string func, string[] args, string rawArgs)
+    {
+		return AccessibleRewardsTrackTestingUtils.TriggerAckdRewardResponse();
+    }
+
+    private bool OnProcessCheat_hsashowreturningplayerbanner(string func, string[] args, string rawArgs)
+    {
+        BannerManager.Get().ShowBanner("WoodenSign_Paint_Welcome_Back.prefab:4cb64d2b8c67feb45b4e17042d58f1ba", null, GameStrings.Get("GLUE_RETURNING_PLAYER_WELCOME_DESC"), delegate
+        {
+        });
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowstandardcomingsoonpopup(string func, string[] args, string rawArgs)
+    {
+        var popupText = LocalizationUtils.Get(LocalizationKey.UI_STANDARD_FORMAT_POPUP_TEXT);
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
+        popupInfo.m_prefabAssetRefs.Add("RotationPopUp_ComingSoon.prefab:afff670e4001e11429c04d2e0c27dd76");
+        DialogManager.Get().ShowStandardComingSoonPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowcoresetavailablepopup(string func, string[] args, string rawArgs)
+    {
+		// TODO: This seems to have been deprecated in 22.2.0. Leaving it up for a few versions just in case but should be safe to delete afterwards
+		// Note: Delete LocalizationKey.UI_CORE_SET_POPUP_* keys and tests as well
+		var popupText = AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_HEADER), LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_SUBHEADER));
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
+        popupInfo.m_blurWhenShown = true;
+        popupInfo.m_prefabAssetRefs.Add("CoreSetIntroPopup.prefab:32fcd0d9c45bc9449af825460fac647b");
+        DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowwhizbangpopup(string func, string[] args, string rawArgs)
+    {
+        var headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
+        var bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", "Mage", "My whizbang deck");
+        var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
+        popupInfo.m_prefabAssetRefs.Add("WhizbangDialog_notification.prefab:89912cf72b2d5cf47820d2328de40f3f");
+        popupInfo.m_headerText = headerText;
+        popupInfo.m_bodyText = bodyText;
+        popupInfo.m_disableBnetBar = true;
+        DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.NONE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowleaguepromotionrewards(string func, string[] args, string rawArgs)
+    {
+		string cheatName = "bronze10";
+		if (args.Length != 0 && !string.IsNullOrEmpty(args[0]))
+		{
+			cheatName = args[0];
+		}
+
+        var leagueRecord = RankMgr.Get().GetLeagueRankRecordByCheatName(cheatName);
+		var leagueId = leagueRecord.LeagueId;
+
+		var rewards = GenerateFakeRewards();
+
+		var rewardBone = PopupDisplayManager.Get().RewardPopups.GetChestRewardBoneForScene();
+
+        RewardUtils.ShowLeaguePromotionRewards(leagueId, rewards, rewardBone, () => DialogManager.Get().ShowRankedIntroPopUp(null));
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowquestchestreward(string func, string[] args, string rawArgs)
+    {
+		string questName = "Quest name";
+		string questDesc = "Kill 5 Murlocs";
+
+		var rewards = GenerateFakeRewards();
+
+		var rewardBone = PopupDisplayManager.Get().RewardPopups.GetChestRewardBoneForScene(PopupDisplayManager.Get().RewardPopups.QuestChestBones);
+
+        RewardUtils.ShowQuestChestReward(questName, questDesc, rewards, rewardBone, () => { });
+        return true;
+    }
+
+	private bool OnProcessCheat_hsatestfreedeck(string func, string[] args, string rawArgs)
+	{
+		// Must cancel
+		AssetLoader.Get().InstantiatePrefab(RewardPopups.CHOOSE_A_DECK_PREFAB, (assetRef, go, cb) => { OverlayUI.Get().AddGameObject(go); });
+		return true;
+	}
+
+    private List<RewardData> GenerateFakeRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        GoldRewardData goldRewardData = new GoldRewardData();
+        goldRewardData.Amount = 327;
+        list.Add(goldRewardData);
+        list.Add(RewardUtils.CreateArcaneOrbRewardData(327));
+        ArcaneDustRewardData arcaneDustRewardData = new ArcaneDustRewardData();
+        arcaneDustRewardData.Amount = 327;
+        list.Add(arcaneDustRewardData);
+
+		return list;
+    }
+
+    #region Test Pack Opening
+
+    private bool OnProcessCheat_hsasettestpacks1(string func, string[] args, string rawArgs)
+    {
+        NetCache.NetCacheBoosters netCacheBoosters = new NetCache.NetCacheBoosters();
+        AddTestPack(netCacheBoosters.BoosterStacks, 1, 1);
+        AddTestPack(netCacheBoosters.BoosterStacks, 23, 1);
+        NetCache.Get().SetTestDataNetCacheBoosters(netCacheBoosters);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasettestpacks2(string func, string[] args, string rawArgs)
+    {
+        NetCache.NetCacheBoosters netCacheBoosters = new NetCache.NetCacheBoosters();
+        AddTestPack(netCacheBoosters.BoosterStacks, 616, 2);
+        AddTestPack(netCacheBoosters.BoosterStacks, 633, 1);
+        NetCache.Get().SetTestDataNetCacheBoosters(netCacheBoosters);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasettestpacks3(string func, string[] args, string rawArgs)
+    {
+        NetCache.NetCacheBoosters netCacheBoosters = new NetCache.NetCacheBoosters();
+        NetCache.Get().SetTestDataNetCacheBoosters(netCacheBoosters);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsaresettestpacks(string func, string[] args, string rawArgs)
+    {
+        NetCache.Get().SetTestDataNetCacheBoosters(null);
+
+		return true;
+    }
+
+    private void AddTestPack(List<NetCache.BoosterStack> boosterStacks, int packId, int packCount)
+    {
+		NetCache.BoosterStack item = new NetCache.BoosterStack
+		{
+			Id = packId,
+			Count = packCount
+		};
+		boosterStacks.Add(item);
+    }
+
+	#endregion
+
+	#region Test HSA social
+
+	private BnetPlayer m_realFriend;
+
+    private bool OnProcessCheat_hsasetupfriends(string func, string[] args, string rawArgs)
+    {
+		var apprenticeship40 = RankMgr.Get().GetLeagueRankRecordByCheatName("npr40");
+		var bronze10 = RankMgr.Get().GetLeagueRankRecordByCheatName("bronze10");
+		var silver5 = RankMgr.Get().GetLeagueRankRecordByCheatName("silver5");
+		var gold3 = RankMgr.Get().GetLeagueRankRecordByCheatName("gold3");
+		var plat7 = RankMgr.Get().GetLeagueRankRecordByCheatName("plat7");
+		var diamond1 = RankMgr.Get().GetLeagueRankRecordByCheatName("diamond1");
+		var legend = RankMgr.Get().GetLeagueRankRecordByCheatName("legend");
+
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TBeginner#912", null, apprenticeship40.LeagueId, apprenticeship40.StarLevel, BnetProgramId.HEARTHSTONE, true, true);
+        m_realFriend = BnetFriendMgr.Get().Cheat_HSAAddFriend("TRealFrnd#115", "Real Friend", apprenticeship40.LeagueId, apprenticeship40.StarLevel, BnetProgramId.HEARTHSTONE, true, false);
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TOffline#180", null, 0, 0, BnetProgramId.HEARTHSTONE, false, false);
+
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TWoW#120", null, 0, 0, BnetProgramId.WOW, true, true);
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TBnet#120", null, 0, 0, BnetProgramId.BNET, true, false);
+
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TBronze#327", null, bronze10.LeagueId, bronze10.StarLevel, BnetProgramId.HEARTHSTONE, true, true);
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TSilver#327", null, silver5.LeagueId, silver5.StarLevel, BnetProgramId.HEARTHSTONE, true, true);
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TGold#327", null, gold3.LeagueId, gold3.StarLevel, BnetProgramId.HEARTHSTONE, true, true);
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TPlat#327", null, plat7.LeagueId, plat7.StarLevel, BnetProgramId.HEARTHSTONE, true, true);
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TDiamond#327", null, diamond1.LeagueId, diamond1.StarLevel, BnetProgramId.HEARTHSTONE, true, true);
+
+        BnetFriendMgr.Get().Cheat_HSAAddFriend("TLegend#123", null, legend.LeagueId, legend.StarLevel, BnetProgramId.HEARTHSTONE, true, false);
+
+        BnetBarFriendButton.Get().UpdateOnlineCount();
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasetupnearbyplayers(string func, string[] args, string rawArgs)
+    {
+		var apprenticeship40 = RankMgr.Get().GetLeagueRankRecordByCheatName("npr40");
+		var legend = RankMgr.Get().GetLeagueRankRecordByCheatName("legend");
+
+        BnetNearbyPlayerMgr.Get().Cheat_CreateHSANearbyPlayer("TBeginner#912", null, apprenticeship40.LeagueId, apprenticeship40.StarLevel, BnetProgramId.HEARTHSTONE, true, true, true);
+        BnetNearbyPlayerMgr.Get().Cheat_CreateHSANearbyPlayer("TNearby#115", "Nearby Player", legend.LeagueId, legend.StarLevel, BnetProgramId.HEARTHSTONE, false, true, false);
+
+        BnetBarFriendButton.Get().UpdateOnlineCount();
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasimulatereceivedinvite(string func, string[] args, string rawArgs)
+    {
+		BnetFriendMgr.Get().Cheat_CreateReceivedInvite(BnetPresenceMgr.Get().GetMyPlayer(), "Inviter name", 0, 0);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsaremovesimulatedinvites(string func, string[] args, string rawArgs)
+    {
+		BnetFriendMgr.Get().Cheat_RemoveReceivedInvites();
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsaaddsimulatedinvites(string func, string[] args, string rawArgs)
+    {
+		BnetFriendMgr.Get().Cheat_AddReceivedInvites();
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasimulatereceivedchallengepopup(string func, string[] args, string rawArgs)
+    {
+		OnProcessCheat_hsasetupfriends(func, args, rawArgs); // args don't matter
+
+		BnetAccountId challengerId = new BnetAccountId();
+		challengerId.SetHi(BnetFriendMgr.Get().Cheat_HSAGetNextIdToken());
+		challengerId.SetLo(BnetFriendMgr.Get().Cheat_HSAGetNextIdToken());
+
+		BnetBattleTag challengerBattleTag = new BnetBattleTag();
+		challengerBattleTag.SetString("Challenger#327");
+
+		BnetAccount challengerAccount = new BnetAccount();
+		challengerAccount.SetId(challengerId);
+		challengerAccount.SetFullName("Challenger");
+		challengerAccount.SetBattleTag(challengerBattleTag);
+
+		BnetPlayer challenger = new BnetPlayer(BnetPlayerSource.CREATED_BY_CHEAT);
+		challenger.SetAccount(challengerAccount);
+		challenger.IsCheatPlayer = true;
+
+		FriendChallengeMgr.Get().Cheat_SimulateChallenge(m_realFriend, FormatType.FT_STANDARD);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasimulatesocialtoast(string func, string[] args, string rawArgs)
+    {
+		SocialToastMgr.Get().AddToast(UserAttentionBlocker.NONE, "Real Friend", SocialToastMgr.TOAST_TYPE.FRIEND_ONLINE);
+
+		return true;
+    }
+
+	#endregion
+
+	#region PvP
+    private bool OnProcessCheat_hsasetpvp(string func, string[] args, string rawArgs)
+    {
+		if (args.Length != 1)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseBool(args[0], out var boolVal))
+		{
+			return false;
+		}
+
+		AccessibilityUtils.Cheat_SetPvPOverride(boolVal);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasetwild(string func, string[] args, string rawArgs)
+    {
+		if (args.Length != 1)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseBool(args[0], out var boolVal))
+		{
+			return false;
+		}
+
+		CollectionManager.Cheat_SetWildOverride(boolVal);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsaresetpvpoverrides(string func, string[] args, string rawArgs)
+    {
+		AccessibilityUtils.Cheat_SetPvPOverride(false);
+		CollectionManager.Cheat_SetWildOverride(false);
+		CollectionManager.Cheat_ResetNumDecks();
+
+		return true;
+    }
+
+	private bool OnProcessCheat_hsasetformattype(string func, string[] args, string rawArgs)
+	{
+		if (args.Length != 1)
+		{
+			return false;
+		}
+
+		FormatType formatType = FormatType.FT_STANDARD;
+		switch (args[0].ToLower())
+		{
+			case "1":
+			case "wild":
+				formatType = FormatType.FT_WILD;
+				break;
+			case "2":
+			case "standard":
+				formatType = FormatType.FT_STANDARD;
+				break;
+			case "3":
+			case "classic":
+				formatType = FormatType.FT_CLASSIC;
+				break;
+			default:
+				UIStatus.Get().AddInfo("please enter a valid value for 1st parameter <format type>");
+				return false;
+		}
+
+		Options.SetFormatType(formatType);
+
+		return true;
+	}
+
+	private bool OnProcessCheat_hsasetnumdecks(string func, string[] args, string rawArgs)
+	{
+		if (args.Length != 3)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(args[0], out var numStandardDecks))
+		{
+			UIStatus.Get().AddInfo("please enter a valid value for 2nd parameter <num standard decks>");
+			return false;
+		}
+
+		if (!GeneralUtils.TryParseInt(args[1], out var numWildDecks))
+		{
+			UIStatus.Get().AddInfo("please enter a valid value for 3rd parameter <num wild decks>");
+			return false;
+		}
+
+		if (!GeneralUtils.TryParseInt(args[2], out var numClassicDecks))
+		{
+			UIStatus.Get().AddInfo("please enter a valid value for 4th parameter <num classic decks>");
+			return false;
+		}
+
+		CollectionManager.Cheat_SetNumDecks(numStandardDecks, numWildDecks, numClassicDecks);
+
+		return true;
+	}
+
+	private bool OnProcessCheat_hsaresetnumdecks(string func, string[] args, string rawArgs)
+	{
+		CollectionManager.Cheat_ResetNumDecks();
+
+		return true;
+	}
+	#endregion
+
+	#region Crafting
+    private bool OnProcessCheat_hsatriggercardsaleresponse(string func, string[] args, string rawArgs)
+    {
+		bool boolVal = false;
+		if (args.Length == 1 && !GeneralUtils.TryParseBool(args[0], out boolVal))
+		{
+			return false;
+		}
+
+		return AccessibleCraftingTestingUtils.TriggerOnCardSaleResponse(boolVal);
+    }
+
+    private bool OnProcessCheat_hsatriggermassdisenchantresponse(string func, string[] args, string rawArgs)
+    {
+		return AccessibleCraftingTestingUtils.TriggerMassDisenchantResponse();
+    }
+	#endregion
+
+	private bool OnProcessCheat_hsasetlevelsoverride(string func, string[] args, string rawArgs)
+    {
+		if (args.Length != 1)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseBool(args[0], out var boolVal))
+		{
+			return false;
+		}
+
+		GameUtils.Cheat_SetLevelsOverride(boolVal);
+
+		return true;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs b/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
index 766a92b..19c14a8 100644
--- a/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
+++ b/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
@@ -1,8 +1,9 @@
 using System;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class ChestRewardDisplay : MonoBehaviour
+public class ChestRewardDisplay : MonoBehaviour, AccessibleUI
 {
 	public const string DEFAULT_PREFAB = "RewardChest_Lock.prefab:06ffa33e82036694e8cacb96aa7b48e8";
 
@@ -90,7 +91,13 @@ public class ChestRewardDisplay : MonoBehaviour
 		m_bannerUberText.Text = title;
 		m_descText.SetActive(value: true);
 		m_descText.GetComponent<UberText>().Text = desc;
-		ShowRewardChest();
+		ShowRewardChest(true);
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+		AccessibilityMgr.Output(this, title);
+		AccessibilityMgr.Output(this, desc);
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 		return true;
 	}
 
@@ -109,7 +116,7 @@ public class ChestRewardDisplay : MonoBehaviour
 			UnityEngine.Object.Destroy(m_bannerObject);
 		}
 		m_descText?.SetActive(value: false);
-		ShowRewardChest();
+		ShowRewardChest(false);
 		if (autoOpenChest)
 		{
 			ShowRewardBags(null);
@@ -122,7 +129,7 @@ public class ChestRewardDisplay : MonoBehaviour
 		m_doneCallbacks.Add(action);
 	}
 
-	private void ShowRewardChest()
+	private void ShowRewardChest(bool accessible)
 	{
 		if (FullScreenFXMgr.Get() != null)
 		{
@@ -135,17 +142,29 @@ public class ChestRewardDisplay : MonoBehaviour
 
 	private void ShowRewardChest_TavernBrawl()
 	{
-		ShowRewardChest();
+		ShowRewardChest(true);
 		string text = ((m_wins != 0) ? GameStrings.Format("GLUE_BRAWLISEUM_REWARDS_WIN_BANNER_TEXT", m_wins, m_wins) : GameStrings.Get("GLUE_BRAWLISEUM_NO_WINS_REWARD_PACK_TEXT"));
 		m_bannerUberText.Text = text;
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+		AccessibilityMgr.Output(this, text);
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 	}
 
 	private void ShowRewardChest_LeaguePromotion()
 	{
-		ShowRewardChest();
+		ShowRewardChest(true);
 		LeagueRankDbfRecord record = GameDbf.LeagueRank.GetRecord((LeagueRankDbfRecord r) => r.LeagueId == m_leagueId && r.StarLevel == 1);
 		m_bannerUberText.Text = record.RankName.GetString();
-		m_descText.GetComponent<UberText>().Text = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
+		var desc = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
+		m_descText.GetComponent<UberText>().Text = desc;
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+		AccessibilityMgr.Output(this, m_bannerUberText.Text);
+		AccessibilityMgr.Output(this, desc);
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 	}
 
 	private void OnRollover(UIEvent e)
@@ -234,6 +253,8 @@ public class ChestRewardDisplay : MonoBehaviour
 
 	public void OnSummonOutAnimationDone()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		foreach (Action doneCallback in m_doneCallbacks)
 		{
 			doneCallback?.Invoke();
@@ -250,4 +271,21 @@ public class ChestRewardDisplay : MonoBehaviour
 		}
 		return m_rewardBoxBone;
 	}
+
+    #region Accessibility
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_rewardChest.TriggerRelease();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return LocalizationUtils.Format(LocalizationKey.UI_CHEST_REWARD_DISPLAY_HELP, AccessibleKey.CONFIRM);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs b/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
index 7c07a45..dff651f 100644
--- a/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
+++ b/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
@@ -1351,6 +1351,7 @@ public class ChoiceCardMgr : MonoBehaviour
 		ShowChoiceBanner(choiceState.m_cards);
 		ShowChoiceButtons();
 		HideEnlargedHand();
+		Accessibility.AccessibleGameplay.Get().OnChoice(choiceState.m_cards, m_choiceBanner, m_confirmChoiceButton);
 	}
 
 	private void HideChoiceUI()
@@ -1625,6 +1626,7 @@ public class ChoiceCardMgr : MonoBehaviour
 			}
 		}
 		HideEnlargedHand();
+		Accessibility.AccessibleGameplay.Get().OnSubOption(m_subOptionState.m_cards);
 	}
 
 	private void HideSubOptions(Entity chosenEntity = null)
diff --git a/Decompiled/Assembly-CSharp/ChooseDeckReward.cs b/Decompiled/Assembly-CSharp/ChooseDeckReward.cs
index 7034f2a..80b163d 100644
--- a/Decompiled/Assembly-CSharp/ChooseDeckReward.cs
+++ b/Decompiled/Assembly-CSharp/ChooseDeckReward.cs
@@ -2,8 +2,9 @@ using System;
 using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
+using Accessibility;
 
-public class ChooseDeckReward : CustomVisualReward
+public class ChooseDeckReward : CustomVisualReward, AccessibleUI
 {
 	public AsyncReference m_chooseDeckReference;
 
@@ -29,6 +30,10 @@ public class ChooseDeckReward : CustomVisualReward
 
 	private long m_noticeId;
 
+	#region Accessibility
+	private int m_numButtonsLoading;
+	#endregion
+
 	private TAG_CLASS[] m_classByButtonIndex = new TAG_CLASS[10]
 	{
 		TAG_CLASS.DRUID,
@@ -47,6 +52,7 @@ public class ChooseDeckReward : CustomVisualReward
 	{
 		m_classButtonWidgets = new Widget[m_classButtonReferences.Length];
 		m_buttonDataModels = new DeckChoiceDataModel[m_classButtonReferences.Length];
+		m_numButtonsLoading = m_classButtonReferences.Length;
 		for (int i = 0; i < m_classButtonReferences.Length; i++)
 		{
 			int classIndex = i;
@@ -118,5 +124,65 @@ public class ChooseDeckReward : CustomVisualReward
 		m_classButtonWidgets[index] = w;
 		m_buttonDataModels[index] = deckChoiceDataModel;
 		w.BindDataModel(deckChoiceDataModel);
+
+		// Accessibility
+		m_numButtonsLoading--;
+
+		if (m_numButtonsLoading == 0)
+        {
+			ReadChooseDeckUI();
+        }
 	}
+
+	#region Accessibility
+
+	private enum State { LOADING, CHOOSING };
+
+	private AccessibleMenu m_chooseDeckMenu;
+	private State m_curState = State.LOADING;
+
+	private void ReadChooseDeckUI()
+    {
+		m_curState = State.LOADING;
+
+		m_chooseDeckMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.UI_CHOOSE_FREE_DECK_TITLE), null);
+
+		for (int i = 0; i < m_buttonDataModels.Length; i++)
+        {
+			var classIndex = i;
+			m_chooseDeckMenu.AddOption(GameStrings.GetClassName(m_classByButtonIndex[i]), () => ChooseDeck(classIndex));
+        }
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		m_chooseDeckMenu.StartReading();
+		m_curState = State.CHOOSING;
+    }
+
+    private void ChooseDeck(int index)
+    {
+		SetSelectedButtonIndex(index);
+		ChoiceConfirmed();
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == State.LOADING)
+        {
+			return;
+        }
+		m_chooseDeckMenu?.HandleAccessibleInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_curState == State.CHOOSING)
+        {
+			return m_chooseDeckMenu?.GetHelp();
+        }
+
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ClientOption.cs b/Decompiled/Assembly-CSharp/ClientOption.cs
index 03a2a11..a87c04f 100644
--- a/Decompiled/Assembly-CSharp/ClientOption.cs
+++ b/Decompiled/Assembly-CSharp/ClientOption.cs
@@ -125,6 +125,10 @@ public enum ClientOption
 	APKINSTALL_START,
 	APKINSTALL_FAILURE_REPORTED,
 	INTERNET_UNREACHABLE,
+	#region Accessibility
+	ACCESSIBILITY_GAME_SPEED,
+	ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS,
+	#endregion
 	DEBUG_SHOW_BATTLEGROUND_SKIN_IDS,
 	AADC_LOCAL_SAVE_TIME_STAMP,
 	AADC_SERVER_SAVE_TIME_STAMP,
diff --git a/Decompiled/Assembly-CSharp/CoinManager.cs b/Decompiled/Assembly-CSharp/CoinManager.cs
index 11b8b3c..0292921 100644
--- a/Decompiled/Assembly-CSharp/CoinManager.cs
+++ b/Decompiled/Assembly-CSharp/CoinManager.cs
@@ -11,6 +11,7 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class CoinManager : IService
 {
@@ -287,11 +288,17 @@ public class CoinManager : IService
 	public void RequestSetFavoriteCoin(int newFavoriteCoinID)
 	{
 		Network.Get().SetFavoriteCoin(newFavoriteCoinID);
+
+		if (Network.IsLoggedIn())
+		{
+			AccessibleCollectionManager.Get().WaitingForServerResponse();
+		}
 	}
 
 	public void OnFavoriteCoinChanged(int newFavoriteCoinID)
 	{
 		Log.CoinManager.Print(string.Format("CoinManager - Favorite Coin Changed" + $" ID: {newFavoriteCoinID}"));
+		AccessibleCollectionManager.Get().OnFavoriteCoinChanged();
 	}
 
 	public bool IsCoinCardFavorited(string coinCardId)
@@ -421,4 +428,39 @@ public class CoinManager : IService
 	{
 		m_searchText = searchText?.ToLower();
 	}
+
+	#region Accesibility
+
+	internal bool IsCoinCard(CollectibleCard card)
+	{
+		foreach (var coin in m_coinCards)
+		{
+			if (coin.CardId.Equals(card.CardId))
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	internal CoinDbfRecord GetCoinRecord(CollectibleCard card)
+	{
+		if (!m_cardIdCoinIdMap.TryGetValue(card.CardDbId, out var coinId))
+		{
+			AccessibilityUtils.LogFatalError($"Could not find coin record for coin with DB ID: {card.CardDbId}");
+			return null;
+		}
+
+		CoinDbfRecord coinRecord = GameDbf.Coin.GetRecord(coinId);
+		if (coinRecord == null)
+		{
+			AccessibilityUtils.LogFatalError($"Could not find coin record for coin with coin ID: {coinId} (coin DB IS was {card.CardDbId})");
+			return null;
+		}
+
+		return coinRecord;
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectibleBattlegroundsBoard.cs b/Decompiled/Assembly-CSharp/CollectibleBattlegroundsBoard.cs
index 87fa753..1116ed9 100644
--- a/Decompiled/Assembly-CSharp/CollectibleBattlegroundsBoard.cs
+++ b/Decompiled/Assembly-CSharp/CollectibleBattlegroundsBoard.cs
@@ -99,4 +99,12 @@ public class CollectibleBattlegroundsBoard : ICollectible, IComparable
 		battlegroundsBoardSkinDataModel.IsNew = CollectionManager.Get().ShouldShowNewBattlegroundsBoardSkinGlow(BoardSkinId);
 		return battlegroundsBoardSkinDataModel;
 	}
+
+	#region Accessibility
+	public bool IsAccessible()
+	{
+		// TODO
+		return false;
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs b/Decompiled/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs
index f4104c2..2a198c1 100644
--- a/Decompiled/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs
+++ b/Decompiled/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs
@@ -101,4 +101,12 @@ public class CollectibleBattlegroundsFinisher : ICollectible, IComparable
 		battlegroundsFinisherDataModel.IsNew = CollectionManager.Get().ShouldShowNewBattlegroundsFinisherGlow(FinisherId);
 		return battlegroundsFinisherDataModel;
 	}
+
+	#region Accessibility
+	public bool IsAccessible()
+	{
+		// TODO
+		return false;
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectibleCard.cs b/Decompiled/Assembly-CSharp/CollectibleCard.cs
index f52ad8b..fe22012 100644
--- a/Decompiled/Assembly-CSharp/CollectibleCard.cs
+++ b/Decompiled/Assembly-CSharp/CollectibleCard.cs
@@ -316,4 +316,11 @@ public class CollectibleCard : ICollectible, IComparable
 		}
 		return CollectionManager.EntityDefSortComparison(m_EntityDef, collectibleCard.m_EntityDef);
 	}
+
+	#region Accessibility
+	public bool IsAccessible()
+	{
+		return true;
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectibleDisplay.cs b/Decompiled/Assembly-CSharp/CollectibleDisplay.cs
index 6162a34..457c6d3 100644
--- a/Decompiled/Assembly-CSharp/CollectibleDisplay.cs
+++ b/Decompiled/Assembly-CSharp/CollectibleDisplay.cs
@@ -5,6 +5,7 @@ using System.Linq;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 public abstract class CollectibleDisplay : AbsSceneDisplay
 {
@@ -95,7 +96,7 @@ public abstract class CollectibleDisplay : AbsSceneDisplay
 
 	protected CraftingTrayBase m_craftingTray;
 
-	protected SetFilterTray m_setFilterTray;
+	internal SetFilterTray m_setFilterTray;
 
 	protected List<OnSwitchViewMode> m_switchViewModeListeners = new List<OnSwitchViewMode>();
 
@@ -217,7 +218,11 @@ public abstract class CollectibleDisplay : AbsSceneDisplay
 
 	public void SetViewMode(CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata = null)
 	{
+		var modeBeforeSet = m_currentViewMode;
+
 		SetViewMode(mode, triggerResponse: true, userdata);
+
+		AccessibleCollectionManager.Get().OnChangeViewMode(modeBeforeSet, mode);
 	}
 
 	public CollectionUtils.ViewMode GetViewMode()
diff --git a/Decompiled/Assembly-CSharp/CollectiblePageManager.cs b/Decompiled/Assembly-CSharp/CollectiblePageManager.cs
index f702cbf..23f391d 100644
--- a/Decompiled/Assembly-CSharp/CollectiblePageManager.cs
+++ b/Decompiled/Assembly-CSharp/CollectiblePageManager.cs
@@ -325,4 +325,11 @@ public abstract class CollectiblePageManager : TabbedBookPageManager
 	protected abstract void AssembleEmptyPageUI(CollectiblePageDisplay page, bool displayNoMatchesText);
 
 	protected abstract void OnCollectionManagerViewModeChanged(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata, bool triggerResponse);
+
+	#region Accessibility
+	internal CollectionPageDisplay GetCollectionPageDisplay()
+	{
+		return GetCurrentCollectiblePage() as CollectionPageDisplay;
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs b/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs
index 6973680..b4ef19e 100644
--- a/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs
+++ b/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs
@@ -5,6 +5,7 @@ using System.Linq;
 using Assets;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionDeckBoxVisual : PegUIElement, IDraggableCollectionVisual
@@ -1121,6 +1122,10 @@ public class CollectionDeckBoxVisual : PegUIElement, IDraggableCollectionVisual
 				DecksContent.DeleteDeck(GetDeckID());
 			}
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void PlayPopAnimation(string animationName)
diff --git a/Decompiled/Assembly-CSharp/CollectionDeckTray.cs b/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
index 5818991..0d8e156 100644
--- a/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
+++ b/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using System.Linq;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionDeckTray : EditableDeckTray
@@ -764,7 +765,7 @@ public class CollectionDeckTray : EditableDeckTray
 		{
 			flag = deckRuleset.IsDeckValid(editedDeck);
 		}
-		if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
+		if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
 		{
 			Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
 			Options.Get().SetLong(Option.LAST_CUSTOM_DECK_CHOSEN, editedDeck.ID);
@@ -773,7 +774,7 @@ public class CollectionDeckTray : EditableDeckTray
 			Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, relativePosition, NotificationManager.NOTIFICATITON_WORLD_SCALE, GameStrings.Get("GLUE_COLLECTION_TUTORIAL16"), convertLegacyPosition: false);
 			notification.ShowPopUpArrow(Notification.PopUpArrowDirection.RightDown);
 			notification.PulseReminderEveryXSeconds(3f);
-			UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 			m_doneButton.GetComponentInChildren<HighlightState>().ChangeState(ActorStateType.HIGHLIGHT_PRIMARY_ACTIVE);
 		}
 		SaveCurrentDeckAndEnterDeckListMode();
@@ -1086,6 +1087,7 @@ public class CollectionDeckTray : EditableDeckTray
 		CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: true);
 		AllowInput(allowed: true);
 		completedCallback?.Invoke(addedCards, removedCards);
+		AccessibleCollectionManager.Get().OnFinishAutoAddCardsWithTiming();
 	}
 
 	public override void UpdateDoneButtonText()
diff --git a/Decompiled/Assembly-CSharp/CollectionHeroPickerButtons.cs b/Decompiled/Assembly-CSharp/CollectionHeroPickerButtons.cs
index d864533..78949fc 100644
--- a/Decompiled/Assembly-CSharp/CollectionHeroPickerButtons.cs
+++ b/Decompiled/Assembly-CSharp/CollectionHeroPickerButtons.cs
@@ -2,6 +2,7 @@ using System.Collections.Generic;
 using Assets;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionHeroPickerButtons : AbsHeroPickerButtons
@@ -25,6 +26,17 @@ public class CollectionHeroPickerButtons : AbsHeroPickerButtons
 		GenerateHeroCounters();
 	}
 
+	public override void Show()
+	{
+		base.Show();
+		AccessibleCollectionManager.Get().OnBrowsingHeroSkinClasses();
+	}
+
+	public override void Hide()
+	{
+		base.Hide();
+	}
+
 	private void GenerateHeroCounters()
 	{
 		m_heroClasses = new List<TAG_CLASS>(GameUtils.ORDERED_HERO_CLASSES);
diff --git a/Decompiled/Assembly-CSharp/CollectionInputMgr.cs b/Decompiled/Assembly-CSharp/CollectionInputMgr.cs
index ede387b..5d2c69d 100644
--- a/Decompiled/Assembly-CSharp/CollectionInputMgr.cs
+++ b/Decompiled/Assembly-CSharp/CollectionInputMgr.cs
@@ -1,3 +1,4 @@
+using System;
 using System.Collections.Generic;
 using Hearthstone;
 using Hearthstone.DataModels;
@@ -39,23 +40,7 @@ public class CollectionInputMgr : InputMgr
 			bool flag = CollectionDeckTray.Get().IsShowingDeckContents();
 			if (InputCollection.GetKeyDown(KeyCode.C) && flag)
 			{
-				CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-				if (editedDeck != null && UIStatus.Get() != null)
-				{
-					if (editedDeck.CanCopyAsShareableDeck(out var topViolation))
-					{
-						ClipboardUtils.CopyToClipboard(editedDeck.GetShareableDeck().Serialize());
-						UIStatus.Get().AddInfo(GameStrings.Get("GLUE_COLLECTION_DECK_COPIED_TOAST"));
-					}
-					else
-					{
-						string userFriendlyCopyErrorMessageFromDeckRuleViolation = CollectionDeck.GetUserFriendlyCopyErrorMessageFromDeckRuleViolation(topViolation);
-						if (!string.IsNullOrEmpty(userFriendlyCopyErrorMessageFromDeckRuleViolation))
-						{
-							UIStatus.Get().AddInfo(userFriendlyCopyErrorMessageFromDeckRuleViolation);
-						}
-					}
-				}
+				CopyEditedDeck();
 			}
 			if (InputCollection.GetKeyDown(KeyCode.V))
 			{
@@ -98,7 +83,7 @@ public class CollectionInputMgr : InputMgr
 		return false;
 	}
 
-	public static void PasteDeckFromClipboard()
+    public static void PasteDeckFromClipboard()
 	{
 		ShareableDeck shareableDeck = ShareableDeck.DeserializeFromClipboard();
 		if (shareableDeck != null)
@@ -724,4 +709,29 @@ public class CollectionInputMgr : InputMgr
 			m_heldCardOffscreen = true;
 		}
 	}
+
+    #region Accessibility
+    public void CopyEditedDeck()
+    {
+      // Used to export decks in the accessible menu
+				CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+				if (editedDeck != null && UIStatus.Get() != null)
+				{
+					if (editedDeck.CanCopyAsShareableDeck(out var topViolation))
+					{
+						ClipboardUtils.CopyToClipboard(editedDeck.GetShareableDeck().Serialize());
+						UIStatus.Get().AddInfo(GameStrings.Get("GLUE_COLLECTION_DECK_COPIED_TOAST"));
+					}
+					else
+					{
+						string userFriendlyCopyErrorMessageFromDeckRuleViolation = CollectionDeck.GetUserFriendlyCopyErrorMessageFromDeckRuleViolation(topViolation);
+						if (!string.IsNullOrEmpty(userFriendlyCopyErrorMessageFromDeckRuleViolation))
+						{
+							UIStatus.Get().AddInfo(userFriendlyCopyErrorMessageFromDeckRuleViolation);
+						}
+					}
+				}
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionManager.cs b/Decompiled/Assembly-CSharp/CollectionManager.cs
index 4bececd..0965dc9 100644
--- a/Decompiled/Assembly-CSharp/CollectionManager.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManager.cs
@@ -10,6 +10,7 @@ using PegasusLettuce;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class CollectionManager
 {
@@ -400,8 +401,12 @@ public class CollectionManager
 
 	private bool m_accountHasWildCards;
 
+	private bool m_accountHasClassicCards;
+
 	private float m_lastSearchForWildCardsTime;
 
+	private float m_lastSearchForClassicCardsTime;
+
 	private bool m_accountHasRotatedItems;
 
 	private bool m_showStandardComingSoonNotice;
@@ -1009,6 +1014,10 @@ public class CollectionManager
 		{
 			return netCacheCollection;
 		}
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			collection = AccessibleCraftingTestingUtils.AddFakeCards(collection);
+		}
 		List<string> list = new List<string>();
 		for (int i = 0; i < collection.Stacks.Count; i++)
 		{
@@ -1051,9 +1060,17 @@ public class CollectionManager
 		return netCacheCollection;
 	}
 
-	private void OnCardSale()
+	internal void OnCardSale()
 	{
-		Network.CardSaleResult cardSaleResult = Network.Get().GetCardSaleResult();
+		Network.CardSaleResult cardSaleResult;
+		if (AccessibleCraftingTestingUtils.IsTestingCrafting())
+		{
+			cardSaleResult = AccessibleCraftingTestingUtils.GetCardSaleResult();
+		}
+		else
+		{
+			cardSaleResult = Network.Get().GetCardSaleResult();
+		}
 		bool flag = false;
 		switch (cardSaleResult.Action)
 		{
@@ -1108,9 +1125,19 @@ public class CollectionManager
 		OnCollectionChanged();
 	}
 
-	private void OnMassDisenchantResponse()
+	internal void OnMassDisenchantResponse()
 	{
-		Network.MassDisenchantResponse massDisenchantResponse = Network.Get().GetMassDisenchantResponse();
+		Network.MassDisenchantResponse massDisenchantResponse;
+
+		if (AccessibleCraftingTestingUtils.IsTestingCrafting())
+		{
+			massDisenchantResponse = AccessibleCraftingTestingUtils.GetMassDisenchantResponse();
+		}
+		else
+		{
+			massDisenchantResponse = Network.Get().GetMassDisenchantResponse();
+		}
+
 		if (massDisenchantResponse.Amount == 0)
 		{
 			Debug.LogError("CollectionManager.OnMassDisenchantResponse(): Amount is 0. This means the backend failed to mass disenchant correctly.");
@@ -1183,6 +1210,8 @@ public class CollectionManager
 				array[i].Fire(heroClass, cardDefinition);
 			}
 		}
+
+		AccessibleCollectionManager.Get().OnFavoriteHeroSkinChanged();
 	}
 
 	private void OnPVPDRSessionInfoResponse()
@@ -1220,6 +1249,11 @@ public class CollectionManager
 		m_onNetCacheDecksProcessed.Remove(a);
 	}
 
+	public void OnFavoriteCardBackChanged(int newFavoriteCardBackID, bool isFavorite)
+	{
+		AccessibleCollectionManager.Get().OnFavoriteCardBackChanged(isFavorite);
+	}
+
 	public void OnFavoriteBattlegroundsGuideSkinChanged(BattlegroundsGuideSkinId? newFavoriteBattlegroundsGuideSkinID)
 	{
 	}
@@ -1577,6 +1611,7 @@ public class CollectionManager
 		{
 			s_instance = new CollectionManager();
 			HearthstoneApplication.Get().WillReset += s_instance.WillReset;
+			NetCache.Get().FavoriteCardBackChanged += s_instance.OnFavoriteCardBackChanged;
 			NetCache.Get().FavoriteBattlegroundsGuideSkinChanged += s_instance.OnFavoriteBattlegroundsGuideSkinChanged;
 			s_instance.InitImpl();
 		}
@@ -2775,6 +2810,11 @@ public class CollectionManager
 
 	public bool ShouldAccountSeeStandardWild()
 	{
+		if (s_cheatUnlockedWild)
+		{
+			return true;
+		}
+
 		if (!RankMgr.Get().WildCardsAllowedInCurrentLeague())
 		{
 			return false;
@@ -2829,6 +2869,11 @@ public class CollectionManager
 
 	public bool AccountHasUnlockedWild()
 	{
+		if (s_cheatUnlockedWild)
+		{
+			return true;
+		}
+
 		long value = 0L;
 		if (!GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_UNLOCKED_WILD, out value))
 		{
@@ -2893,6 +2938,7 @@ public class CollectionManager
 		{
 			return true;
 		}
+
 		if (m_lastSearchForWildCardsTime > m_collectionLastModifiedTime)
 		{
 			return m_accountHasWildCards;
@@ -2902,18 +2948,49 @@ public class CollectionManager
 		return m_accountHasWildCards;
 	}
 
+	// A11y only
+	public bool AccountHasClassicCards()
+	{
+		if (GetNumberOfClassicDecks() > 0)
+		{
+			return true;
+		}
+		if (m_lastSearchForClassicCardsTime > m_collectionLastModifiedTime)
+		{
+			return m_accountHasClassicCards;
+		}
+		m_accountHasClassicCards = m_collectibleCards.Any((CollectibleCard c) => c.OwnedCount > 0 && GameUtils.IsClassicCard(c.GetEntityDef()));
+		m_lastSearchForClassicCardsTime = Time.realtimeSinceStartup;
+		return m_accountHasClassicCards;
+	}
+
 	public int GetNumberOfWildDecks()
 	{
+		if (s_cheatFakingNumDecks)
+		{
+			return s_cheatNumWildDecks;
+		}
+
 		return m_decks.Values.Count((CollectionDeck deck) => deck.FormatType == FormatType.FT_WILD);
 	}
 
 	public int GetNumberOfStandardDecks()
 	{
+		if (s_cheatFakingNumDecks)
+		{
+			return s_cheatNumStandardDecks;
+		}
+
 		return m_decks.Values.Count((CollectionDeck deck) => deck.FormatType == FormatType.FT_STANDARD);
 	}
 
 	public int GetNumberOfClassicDecks()
 	{
+		if (s_cheatFakingNumDecks)
+		{
+			return s_cheatNumClassicDecks;
+		}
+
 		return m_decks.Values.Count((CollectionDeck deck) => deck.FormatType == FormatType.FT_CLASSIC);
 	}
 
@@ -3534,6 +3611,9 @@ public class CollectionManager
 
 	public bool ShouldShowWildToStandardTutorial(bool checkPrevSceneIsPlayMode = true)
 	{
+		// Prevent problems when using OCR
+		return false;
+
 		if (!ShouldAccountSeeStandardWild())
 		{
 			return false;
@@ -3639,6 +3719,7 @@ public class CollectionManager
 		m_netCacheLoaded = false;
 		m_collectionLoaded = false;
 		HearthstoneApplication.Get().WillReset -= s_instance.WillReset;
+    NetCache.Get().FavoriteCardBackChanged -= s_instance.OnFavoriteCardBackChanged;
 		NetCache.Get().FavoriteBattlegroundsGuideSkinChanged -= s_instance.OnFavoriteBattlegroundsGuideSkinChanged;
 		NetCache.Get().RemoveUpdatedListener(typeof(NetCache.NetCacheDecks), s_instance.NetCache_OnDecksReceived);
 		m_decks.Clear();
@@ -5817,4 +5898,63 @@ public class CollectionManager
 		}
 		return result;
 	}
+
+    #region Accessibility
+
+    public bool IsDeleteDeckPending()
+    {
+		return m_pendingDeckDeleteList?.Count > 0;
+    }
+
+	public bool AccountCanSeeWild()
+	{
+		// ShouldAccountSeeStandardWild blocks if we're in apprentice as well
+		return ShouldAccountSeeStandardWild();
+	}
+
+	public bool AccountCanSeeClassic()
+	{
+		// ShouldAccountSeeStandardWild blocks if we're in apprentice as well
+		return ShouldAccountSeeStandardWild() && AccountHasClassicCards();
+	}
+
+	#region Accessibility Testing
+	private static bool s_cheatUnlockedWild;
+
+	private static bool s_cheatFakingNumDecks;
+
+	private static int s_cheatNumStandardDecks;
+	private static int s_cheatNumWildDecks;
+	private static int s_cheatNumClassicDecks;
+
+	internal static bool Cheat_IsNewPlayer()
+	{
+		// Need this for testing the format selection picker
+		return !s_cheatUnlockedWild;
+	}
+
+	internal static void Cheat_SetWildOverride(bool val)
+	{
+		s_cheatUnlockedWild = val;
+	}
+
+	internal static void Cheat_SetNumDecks(int numStandardDecks, int numWildDecks, int numClassicDecks)
+	{
+		s_cheatFakingNumDecks = true;
+		s_cheatNumStandardDecks = numStandardDecks;
+		s_cheatNumWildDecks = numWildDecks;
+		s_cheatNumClassicDecks = numClassicDecks;
+	}
+
+	internal static void Cheat_ResetNumDecks()
+	{
+		s_cheatNumStandardDecks = 0;
+		s_cheatNumWildDecks = 0;
+		s_cheatNumClassicDecks = 0;
+		s_cheatFakingNumDecks = false;
+	}
+
+	#endregion
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs b/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
index 20050ba..35d78d6 100644
--- a/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
@@ -10,6 +10,7 @@ using Hearthstone;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerDisplay : CollectibleDisplay
@@ -200,7 +201,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		}
 		if (CollectionManager.Get().ShouldShowWildToStandardTutorial())
 		{
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
 		SetTavernBrawlTexturesIfNecessary();
 		SetDuelsTexturesIfNecessary();
@@ -238,13 +239,13 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			UnityEngine.Object.Destroy(m_deckTemplatePickerPhone.gameObject);
 			m_deckTemplatePickerPhone = null;
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
 	private void Update()
 	{
-		if (HearthstoneApplication.IsInternal())
+		if (HearthstoneApplication.IsInternal() && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
 			if (InputCollection.GetKeyDown(KeyCode.Alpha1))
 			{
@@ -416,6 +417,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 				m_cardActors.Add(new CollectionCardActors(component));
 			}
 		}
+		AccessibleCollectionManager.Get().OnPageChanged(m_pageManager.CurrentPageNum, collectiblesToDisplay, m_cardActors);
 		callback?.Invoke(m_cardActors, list, callbackData);
 	}
 
@@ -468,6 +470,10 @@ public class CollectionManagerDisplay : CollectibleDisplay
 				}
 			}
 			numCardBacksToLoad--;
+			if (numCardBacksToLoad == 0)
+			{
+				AccessibleCollectionManager.Get().OnCardBacksPageChanged(m_pageManager.CurrentPageNum, result);
+			}
 			if (numCardBacksToLoad == 0 && callback != null)
 			{
 				callback(result, nonActorResult, callbackData);
@@ -1694,7 +1700,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void ShowCraftingTipIfNeeded()
 	{
-		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
+		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_DISENCHANT_31"), "VO_INNKEEPER_DISENCHANT_31.prefab:4a0246488dc2d8146b1db88de5c603ff");
 			Options.Get().SetBool(Option.TIP_CRAFTING_UNLOCKED, val: true);
@@ -1777,7 +1783,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			yield return null;
 		}
 		int deckCount = CollectionManager.Get().GetDecks(DeckType.NORMAL_DECK).Count;
-		if (CollectionManager.Get().ShouldShowWildToStandardTutorial() && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial"))
+		if (CollectionManager.Get().ShouldShowWildToStandardTutorial() && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial"))
 		{
 			CollectionDeckTray deckTray = CollectionDeckTray.Get();
 			while (deckTray.IsUpdatingTrayMode() || !deckTray.GetDecksContent().IsDoneEntering())
@@ -1803,7 +1809,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER_AFTER_PRACTICE, val: true);
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_WELCOME"), "VO_INNKEEPER_Male_Dwarf_CM_WELCOME_23.prefab:c8afdeaaf2189eb42aad9d29f6a97994");
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER, val: true);
@@ -1813,18 +1819,28 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			yield return new WaitForSeconds(1f);
 		}
-		bool num = UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK);
+		bool num = UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK);
 		bool @bool = Options.Get().GetBool(Option.HAS_STARTED_A_DECK, defaultVal: false);
 		if (num && !@bool && deckCount > 0)
 		{
-			m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_editDeckTutorialBone.position, m_editDeckTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL07"));
-			m_deckHelpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
-			m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+			{
+				// Visual notif - ignore
+				m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_editDeckTutorialBone.position, m_editDeckTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL07"));
+				m_deckHelpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
+				m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+			}
 		}
 	}
 
 	private void ShowDeckTemplateTipsIfNeeded()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// All of these tips are very visual which is just confusing
+			return;
+        }
+
 		bool flag = m_deckHelpPopup != null && m_deckHelpPopup.gameObject != null;
 		Notification deckHelpPopup = CollectionDeckTray.Get().GetCardsContent().GetDeckHelpPopup();
 		bool flag2 = deckHelpPopup != null && deckHelpPopup.gameObject != null;
@@ -1848,7 +1864,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			}
 			else
 			{
-				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
+				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
 				{
 					return;
 				}
@@ -1958,7 +1974,10 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void EnableCraftingByViewMode(CollectionUtils.ViewMode viewMode)
 	{
-		bool flag = viewMode == CollectionUtils.ViewMode.CARDS || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT;
+		// TODO: Do this properly: the crafting button is hidden since 21.6.0 when browsing cardBacks/coins/skins but we currently rely on it to enter crafting
+    // Note: This was refactored on 22.2.0 but the logic doesn't seem to have changed
+		// bool flag = viewMode == CollectionUtils.ViewMode.CARDS || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT;
+		bool flag = viewMode == CollectionUtils.ViewMode.CARDS || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT || viewMode == CollectionUtils.ViewMode.COINS || viewMode == CollectionUtils.ViewMode.CARD_BACKS || viewMode == CollectionUtils.ViewMode.HERO_SKINS;
 		m_craftingModeButton.Enable(flag);
 		bool flag2 = m_viewModeHidingCraftingTray || m_searchTriggeredCraftingInBackground;
 		if (!flag)
@@ -2025,7 +2044,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowConvertTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
 		{
 			m_showConvertTutorialCoroutine = ShowConvertTutorialCoroutine(blocker);
 			StartCoroutine(m_showConvertTutorialCoroutine);
@@ -2071,7 +2090,13 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowSetFilterTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Very visual
+			return;
+		}
+
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
 		{
 			m_showSetFilterTutorialCoroutine = ShowSetFilterTutorialCoroutine(blocker);
 			StartCoroutine(m_showSetFilterTutorialCoroutine);
@@ -2294,6 +2319,8 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void CreateDeckFromClipboard(ShareableDeck shareableDeck)
 	{
+		AccessibleCollectionManager.Get().OnCreateDeckFromClipboard();
+
 		bool num = SceneMgr.Get().GetMode() == SceneMgr.Mode.COLLECTIONMANAGER;
 		TAG_CLASS @class = DefLoader.Get().GetEntityDef(shareableDeck.HeroCardDbId).GetClass();
 		NetCache.CardDefinition favoriteHero = CollectionManager.Get().GetFavoriteHero(@class);
diff --git a/Decompiled/Assembly-CSharp/CollectionManagerScene.cs b/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
index 91be04c..79674a3 100644
--- a/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerScene : PegasusScene
@@ -13,6 +14,7 @@ public class CollectionManagerScene : PegasusScene
 	{
 		base.Awake();
 		AssetLoader.Get().InstantiatePrefab((string)m_CollectionManagerPrefab, OnUIScreenLoaded);
+		AccessibleCollectionManager.Get().OnCollectionManagerOpened();
 	}
 
 	private void Update()
@@ -27,6 +29,7 @@ public class CollectionManagerScene : PegasusScene
 
 	public override void Unload()
 	{
+		AccessibleCollectionManager.Get().OnCollectionManagerClosed();
 		if ((bool)UniversalInputManager.UsePhoneUI)
 		{
 			BnetBar.Get().ToggleActive(active: true);
@@ -56,6 +59,7 @@ public class CollectionManagerScene : PegasusScene
 		{
 			yield return null;
 		}
+		AccessibleCollectionManager.Get().OnCollectibleDisplayReady();
 		SceneMgr.Get().NotifySceneLoaded();
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionPageDisplay.cs b/Decompiled/Assembly-CSharp/CollectionPageDisplay.cs
index b416fa7..eb49455 100644
--- a/Decompiled/Assembly-CSharp/CollectionPageDisplay.cs
+++ b/Decompiled/Assembly-CSharp/CollectionPageDisplay.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using System.Linq;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class CollectionPageDisplay : CollectiblePageDisplay
 {
@@ -102,7 +103,7 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 
 	public void UpdatePageWithHeroPicker(int[] allHeroCounts, int[] ownedHeroCounts)
 	{
-		CollectionHeroPickerButtons componentInChildren = m_heroPicker.GetComponentInChildren<CollectionHeroPickerButtons>();
+		var componentInChildren = GetCollectionHeroPickerButtons();
 		if (componentInChildren != null)
 		{
 			componentInChildren.LoadHeroButtonsForFavoriteHeroes();
@@ -113,7 +114,7 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 
 	public void HideHeroPicker()
 	{
-		CollectionHeroPickerButtons componentInChildren = m_heroPicker.GetComponentInChildren<CollectionHeroPickerButtons>();
+		var componentInChildren = GetCollectionHeroPickerButtons();
 		if (componentInChildren != null && componentInChildren.IsReady())
 		{
 			componentInChildren.Hide();
@@ -148,24 +149,8 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 				EntityDef entityDef = actor.GetEntityDef();
 				if (entityDef != null)
 				{
-					TAG_CLASS @class = entityDef.GetClass();
-					entityDef.GetCardId();
-					component.SetClass(@class);
-					bool show = false;
-					if (m_cachedHeroInfo.TryGetValue(@class, out var value))
-					{
-						show = value.Item1 > 1 && !string.IsNullOrEmpty(value.Item2.Name) && value.Item2.Name == entityDef.GetCardId();
-					}
-					else
-					{
-						NetCache.CardDefinition favoriteHero = CollectionManager.Get().GetFavoriteHero(@class);
-						if (favoriteHero != null)
-						{
-							int countOfHeroClassPlayerOwns = CollectionManager.Get().GetCountOfHeroClassPlayerOwns(@class);
-							show = countOfHeroClassPlayerOwns > 1 && !string.IsNullOrEmpty(favoriteHero.Name) && favoriteHero.Name == entityDef.GetCardId();
-							m_cachedHeroInfo.Add(@class, (countOfHeroClassPlayerOwns, favoriteHero));
-						}
-					}
+					component.SetClass(entityDef.GetClass());
+					bool show = AccessibleCardUtils.ShouldShowFavoriteHeroText(entityDef);
 					component.ShowFavoriteBanner(show);
 				}
 			}
@@ -325,6 +310,11 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 			}
 		}
 		m_noMatchExplanationText.Text = GameStrings.Get(key);
+
+		if (show)
+		{
+			AccessibleCollectionManager.Get().OnShowNoMatchesFound(key);
+		}
 	}
 
 	public void HideHeroSkinsDecor()
@@ -661,4 +651,11 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 			CollectiblePageDisplay.SetPageFlavorTextures(header, new UnityEngine.Vector2(x, y));
 		}
 	}
+
+	#region Accessibility
+	internal CollectionHeroPickerButtons GetCollectionHeroPickerButtons()
+	{
+		return m_heroPicker.GetComponentInChildren<CollectionHeroPickerButtons>();
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionPageManager.cs b/Decompiled/Assembly-CSharp/CollectionPageManager.cs
index 111c203..07abc0b 100644
--- a/Decompiled/Assembly-CSharp/CollectionPageManager.cs
+++ b/Decompiled/Assembly-CSharp/CollectionPageManager.cs
@@ -153,7 +153,7 @@ public class CollectionPageManager : CollectiblePageManager
 
 	private static Map<TAG_CLASS, int> CLASS_TO_TAB_IDX = null;
 
-	private List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
+	internal List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
 
 	private MassDisenchant m_massDisenchant;
 
@@ -171,7 +171,7 @@ public class CollectionPageManager : CollectiblePageManager
 
 	private int m_numPageFlipsThisSession;
 
-	protected TAG_CLASS m_currentClassContext;
+	internal TAG_CLASS m_currentClassContext;
 
 	private ICollectible m_lastCollectibleAnchor;
 
diff --git a/Decompiled/Assembly-CSharp/CollectionSearch.cs b/Decompiled/Assembly-CSharp/CollectionSearch.cs
index a99b395..a2c5638 100644
--- a/Decompiled/Assembly-CSharp/CollectionSearch.cs
+++ b/Decompiled/Assembly-CSharp/CollectionSearch.cs
@@ -1,5 +1,6 @@
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class CollectionSearch : MonoBehaviour
 {
@@ -276,6 +277,7 @@ public class CollectionSearch : MonoBehaviour
 		};
 		textInputParams.m_showVirtualKeyboard = fromActivate;
 		UniversalInputManager.Get().UseTextInput(textInputParams);
+        AccessibilityMgr.AllowTextInput();
 	}
 
 	private void HideInput()
@@ -301,6 +303,9 @@ public class CollectionSearch : MonoBehaviour
 
 	private void OnInputComplete(string input)
 	{
+        AccessibilityMgr.DisallowTextInput();
+		AccessibilityMgr.Output(AccessibleCollectionManager.Get(), input);
+
 		m_text = input;
 		UpdateSearchText();
 		SoundManager.Get().LoadAndPlay("text_commit.prefab:05a794ae046d3e842b87893629a826f1");
@@ -309,6 +314,7 @@ public class CollectionSearch : MonoBehaviour
 
 	private void OnInputCanceled(bool userRequested, GameObject requester)
 	{
+        AccessibilityMgr.DisallowTextInput();
 		Cancel();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/CraftingManager.cs b/Decompiled/Assembly-CSharp/CraftingManager.cs
index c9d5ba7..afafb99 100644
--- a/Decompiled/Assembly-CSharp/CraftingManager.cs
+++ b/Decompiled/Assembly-CSharp/CraftingManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CraftingManager : MonoBehaviour
@@ -298,18 +299,20 @@ public class CraftingManager : MonoBehaviour
 			Name = entityDef.GetCardId(),
 			Premium = premium
 		};
-		int numOwnedIncludePending = GetNumOwnedIncludePending();
 		long arcaneDustBalance = NetCache.Get().GetArcaneDustBalance();
 		bool flag = GetNumClientTransactions() < 0;
-		int num = (entityDef.IsElite() ? 1 : 2);
-		if (numOwnedIncludePending >= num && arcaneDustBalance >= GetCardBuyValue(cardDefinition.Name, cardDefinition.Premium))
+		bool hasReachedCardLimit = HasReachedCardLimit(entityDef, GetNumOwnedIncludePending());
+
+		if (hasReachedCardLimit || arcaneDustBalance < GetCardBuyValue(cardDefinition.Name, cardDefinition.Premium))
 		{
-			if (RankMgr.Get().IsCardLockedInCurrentLeague(entityDef))
-			{
-				return !flag;
-			}
 			return false;
 		}
+
+		if (RankMgr.Get().IsCardLockedInCurrentLeague(entityDef))
+		{
+			return !flag;
+		}
+
 		return true;
 	}
 
@@ -483,6 +486,8 @@ public class CraftingManager : MonoBehaviour
 			}
 			return result;
 		});
+
+		AccessibleCollectionManager.Get().OnEnterCraftMode(m_cardInfoPane, m_craftingUI);
 	}
 
 	private void SetupActor(Actor collectionCardActor, TAG_PREMIUM premium)
@@ -575,6 +580,7 @@ public class CraftingManager : MonoBehaviour
 		iTween.ScaleTo(m_switchPremiumButton.gameObject, m_cardCountTabHideScale, 0.4f);
 		TellServerAboutWhatUserDid();
 		IsInCraftingMode = false;
+		AccessibleCollectionManager.Get().OnCancelCraftMode(m_cardInfoPane, m_craftingUI);
 		return true;
 	}
 
@@ -721,6 +727,8 @@ public class CraftingManager : MonoBehaviour
 
 	public void OnCardDisenchanted(Network.CardSaleResult sale)
 	{
+		AccessibleCollectionManager.Get().OnCardDisenchanted();
+
 		m_pendingServerTransaction = null;
 		CollectionCardVisual cardVisual = CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
 			.GetCardVisual(sale.AssetName, sale.Premium);
@@ -732,6 +740,8 @@ public class CraftingManager : MonoBehaviour
 
 	public void OnCardCreated(Network.CardSaleResult sale)
 	{
+		AccessibleCollectionManager.Get().OnCardCreated();
+
 		m_pendingServerTransaction = null;
 		CollectionCardVisual cardVisual = CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
 			.GetCardVisual(sale.AssetName, sale.Premium);
@@ -1528,4 +1538,12 @@ public class CraftingManager : MonoBehaviour
 	{
 		CardBackManager.Get().LoadRandomCardBackFavoritedByPlayer(updateScene: true);
 	}
+
+  #region Accessibility
+  public bool HasReachedCardLimit(EntityDef entityDef, int numOwnedIncludePending) 
+  {
+    int cardLimit = (entityDef.IsElite() ? 1 : 2);
+    return numOwnedIncludePending >= cardLimit;
+  }
+  #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CraftingTray.cs b/Decompiled/Assembly-CSharp/CraftingTray.cs
index cef539b..b4fe9d5 100644
--- a/Decompiled/Assembly-CSharp/CraftingTray.cs
+++ b/Decompiled/Assembly-CSharp/CraftingTray.cs
@@ -3,6 +3,7 @@ using System.Collections;
 using System.Collections.Generic;
 using Assets;
 using UnityEngine;
+using Accessibility;
 
 public class CraftingTray : CraftingTrayBase
 {
@@ -141,6 +142,8 @@ public class CraftingTray : CraftingTrayBase
 			CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
 				.ShowCraftingModeCards(m_showSoulboundCheckbox.IsChecked(), m_showGoldenCheckbox.IsChecked(), m_showDiamondCheckbox.IsChecked(), null, null, updatePage);
 		}
+
+		AccessibleCollectionManager.Get().OnCraftingTrayOpened();
 	}
 
 	public override void Hide()
@@ -171,6 +174,8 @@ public class CraftingTray : CraftingTrayBase
 			{
 				CollectionManager.Get().GetCollectibleDisplay().SetViewMode(m_previousViewMode);
 			}
+
+			AccessibleCollectionManager.Get().OnCraftingTrayClosed();
 		}
 	}
 
diff --git a/Decompiled/Assembly-CSharp/CraftingUI.cs b/Decompiled/Assembly-CSharp/CraftingUI.cs
index b7758e6..b6aa185 100644
--- a/Decompiled/Assembly-CSharp/CraftingUI.cs
+++ b/Decompiled/Assembly-CSharp/CraftingUI.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class CraftingUI : MonoBehaviour
 {
@@ -58,6 +59,16 @@ public class CraftingUI : MonoBehaviour
 
 	private bool m_initializedPositions;
 
+	#region Accessibility
+	internal int m_craftCost;
+
+	internal int m_disenchantDustGain;
+
+	internal int m_numOwnedIncludePending; // Num owned cards -> used for error messages
+
+	internal bool m_reachedCardLimit; // True if we're already at cap for this card (and can't craft more)
+	#endregion
+
 	private void Update()
 	{
 		if (!m_enabled)
@@ -116,7 +127,7 @@ public class CraftingUI : MonoBehaviour
 			Name = entityDef.GetCardId(),
 			Premium = premium
 		};
-		int numOwnedIncludePending = CraftingManager.Get().GetNumOwnedIncludePending();
+		m_numOwnedIncludePending = CraftingManager.Get().GetNumOwnedIncludePending();
 		bool flag = false;
 		string empty = string.Empty;
 		string empty2 = string.Empty;
@@ -124,7 +135,7 @@ public class CraftingUI : MonoBehaviour
 		string cardSetName = GameStrings.GetCardSetName(cardSet);
 		NetCache.CardValue cardValue = CraftingManager.Get().GetCardValue(cardDefinition.Name, cardDefinition.Premium);
 		empty = GameStrings.Get("GLUE_CRAFTING_SOULBOUND");
-		if (numOwnedIncludePending <= 0)
+		if (m_numOwnedIncludePending <= 0)
 		{
 			empty = cardSetName;
 			empty2 = (Network.IsLoggedIn() ? entityDef.GetHowToEarnText(cardDefinition.Premium) : GameStrings.Get("GLUE_CRAFTING_SOULBOUND_OFFLINE_DESC"));
@@ -152,8 +163,9 @@ public class CraftingUI : MonoBehaviour
 			{
 				num2 = cardValue.GetBuyValue();
 			}
-			m_disenchantValue.Text = "+" + num2;
-			m_craftValue.Text = "-" + num;
+
+			SetDisenchantValue(num2);
+			SetCraftValue(num);
 			flag = true;
 		}
 		else
@@ -185,7 +197,7 @@ public class CraftingUI : MonoBehaviour
 		}
 		m_soulboundNotification.SetActive(value: false);
 		m_activeObject = base.gameObject;
-		if (numOwnedIncludePending <= 0)
+		if (m_numOwnedIncludePending <= 0)
 		{
 			m_buttonDisenchant.DisableButton();
 		}
@@ -193,9 +205,7 @@ public class CraftingUI : MonoBehaviour
 		{
 			m_buttonDisenchant.EnableButton();
 		}
-		entityDef.IsElite();
-		NetCache.Get().GetArcaneDustBalance();
-		CraftingManager.Get().GetNumClientTransactions();
+		m_reachedCardLimit = CraftingManager.Get().HasReachedCardLimit(entityDef, m_numOwnedIncludePending);
 		if (!CraftingManager.Get().GetCanUpgradeCardToGolden(cardDefinition.Name, cardDefinition.Premium) && !CraftingManager.Get().GetCanCraftCardRightNow(entityDef, premium))
 		{
 			m_buttonCreate.DisableButton();
@@ -256,9 +266,9 @@ public class CraftingUI : MonoBehaviour
 		{
 			return;
 		}
-		int numOwnedIncludePending = CraftingManager.Get().GetNumOwnedIncludePending();
+		m_numOwnedIncludePending = CraftingManager.Get().GetNumOwnedIncludePending();
 		int num = (entityDef.IsElite() ? 1 : 2);
-		if (numOwnedIncludePending < num)
+		if (m_numOwnedIncludePending < num)
 		{
 			UpdateTips();
 			CraftingManager.Get().AdjustUnCommitedArcaneDustChanges(-CraftingManager.Get().GetCardBuyValue(CraftingManager.Get().GetShownActor().GetEntityDef()
@@ -330,7 +340,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void ShowFirstTimeTips()
 	{
-		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber("CraftingUI.ShowFirstTimeTips"))
+		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.ShowFirstTimeTips"))
 		{
 			CreateDisenchantNotification();
 			CreateCraftNotification();
@@ -344,6 +354,12 @@ public class CraftingUI : MonoBehaviour
 
 	private void CreateCraftNotification()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Not relevant given the TTS menu will convey the same info
+			return;
+		}
+
 		if (m_buttonCreate.IsButtonEnabled())
 		{
 			Vector3 position;
@@ -371,7 +387,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void UpdateTips()
 	{
-		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber("CraftingUI.UpdateTips"))
+		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.UpdateTips"))
 		{
 			HideTips();
 		}
@@ -496,6 +512,8 @@ public class CraftingUI : MonoBehaviour
 
 	private IEnumerator DoDisenchantAnims()
 	{
+		AccessibleCollectionManager.Get().OnDisenchantAnimStarted();
+
 		SoundManager.Get().Play(m_disenchantSound.GetComponent<AudioSource>());
 		SoundManager.Get().Stop(m_craftingSound.GetComponent<AudioSource>());
 		m_isAnimating = true;
@@ -529,6 +547,7 @@ public class CraftingUI : MonoBehaviour
 			playmaker.SendEvent("Action");
 			yield return new WaitForSeconds(1f);
 			m_isAnimating = false;
+			AccessibleCollectionManager.Get().OnDisenchantAnimDone();
 			yield return new WaitForSeconds(10f);
 			if (oldActor != null)
 			{
@@ -539,6 +558,8 @@ public class CraftingUI : MonoBehaviour
 
 	private IEnumerator DoCreateAnims()
 	{
+		AccessibleCollectionManager.Get().OnCreateAnimStarted();
+
 		Actor shownActor = CraftingManager.Get().GetShownActor();
 		SoundManager.Get().Play(m_craftingSound.GetComponent<AudioSource>());
 		SoundManager.Get().Stop(m_disenchantSound.GetComponent<AudioSource>());
@@ -563,5 +584,21 @@ public class CraftingUI : MonoBehaviour
 			yield return new WaitForSeconds(1f);
 			m_isAnimating = false;
 		}
+
+		AccessibleCollectionManager.Get().OnCreateAnimDone();
+	}
+
+	#region Accessibility
+	private void SetDisenchantValue(int val)
+	{
+		m_disenchantDustGain = val;
+		m_disenchantValue.Text = "+" + val;
+	}
+
+	private void SetCraftValue(int val)
+	{
+		m_craftCost = val;
+		m_craftValue.Text = "-" + val;
 	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CreateButton.cs b/Decompiled/Assembly-CSharp/CreateButton.cs
index 846c821..bca7c7e 100644
--- a/Decompiled/Assembly-CSharp/CreateButton.cs
+++ b/Decompiled/Assembly-CSharp/CreateButton.cs
@@ -94,7 +94,7 @@ public class CreateButton : CraftingButton
 					Options.Get().SetBool(Option.HAS_SEEN_STANDARD_MODE_TUTORIAL, val: true);
 					Options.Get().SetInt(Option.SET_ROTATION_INTRO_PROGRESS, 6);
 					Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
-					UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+					UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 					Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_PLAY_SCREEN, val: true);
 					Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_CREATE_DECK, val: true);
 				}
diff --git a/Decompiled/Assembly-CSharp/CurrencyConversionPage.cs b/Decompiled/Assembly-CSharp/CurrencyConversionPage.cs
index 9994fb8..53c24ed 100644
--- a/Decompiled/Assembly-CSharp/CurrencyConversionPage.cs
+++ b/Decompiled/Assembly-CSharp/CurrencyConversionPage.cs
@@ -63,7 +63,7 @@ public class CurrencyConversionPage : ProductPage
 
 	public void OpenToSKU(float desiredAmount)
 	{
-		Open();
+		Open(false);
 		if (m_baseQuantity > 0f)
 		{
 			m_selectedQuantity = ClampSelection(Mathf.CeilToInt(desiredAmount / m_baseQuantity));
@@ -71,9 +71,9 @@ public class CurrencyConversionPage : ProductPage
 		}
 	}
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
-		base.Open();
+		base.Open(false);
 		if (m_productImmutable == null)
 		{
 			ProductDataModel dataModel = m_widget.GetDataModel<ProductDataModel>();
diff --git a/Decompiled/Assembly-CSharp/CustomDeckPage.cs b/Decompiled/Assembly-CSharp/CustomDeckPage.cs
index 4055b67..78e6a3e 100644
--- a/Decompiled/Assembly-CSharp/CustomDeckPage.cs
+++ b/Decompiled/Assembly-CSharp/CustomDeckPage.cs
@@ -34,7 +34,7 @@ public class CustomDeckPage : MonoBehaviour
 
 	protected int m_numCustomDecks;
 
-	protected List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
+	public List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
 
 	protected DeckButtonCallback m_deckButtonCallback;
 
diff --git a/Decompiled/Assembly-CSharp/DeckHelper.cs b/Decompiled/Assembly-CSharp/DeckHelper.cs
index 280f6a5..51f972c 100644
--- a/Decompiled/Assembly-CSharp/DeckHelper.cs
+++ b/Decompiled/Assembly-CSharp/DeckHelper.cs
@@ -345,7 +345,7 @@ public class DeckHelper : MonoBehaviour
 			Navigation.PushUnique(OnNavigateBack);
 			m_shown = true;
 			m_rootObject.SetActive(value: true);
-			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
+			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_ANNOUNCER_CM_HELP_DECK_50"), "VO_ANNOUNCER_CM_HELP_DECK_50.prefab:450881875d33d094e9a27f6260fb06d9");
 				Options.Get().SetBool(Option.HAS_SEEN_DECK_HELPER, val: true);
diff --git a/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs b/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs
index f135d45..04b79f6 100644
--- a/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs
+++ b/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class DeckOptionsMenu : MonoBehaviour
 {
@@ -176,6 +177,10 @@ public class DeckOptionsMenu : MonoBehaviour
 				collectionManagerDisplay.OnDoneEditingDeck();
 			}
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void OnRetireButtonReleased(UIEvent e)
diff --git a/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
index 9d9b9ce..ac0b8a1 100644
--- a/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
@@ -10,9 +10,10 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
+public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay, AccessibleScreen
 {
 	[Serializable]
 	public class ModeTextures
@@ -429,6 +430,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_currentMedalInfo = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentMedalForCurrentFormatType();
 		m_formatTypePickerWidget = WidgetInstance.Create(FORMAT_TYPE_PICKER_POPUP_PREFAB);
 		m_formatTypePickerWidget.Hide();
+		AccessibleFormatTypePickerPopup.Hide();
 		m_formatTypePickerWidget.RegisterReadyListener(delegate
 		{
 			OnFormatTypePickerPopupReady();
@@ -752,7 +754,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 
 	public void ShowSwitchToWildTutorialIfNecessary()
 	{
-		if (!(m_switchFormatPopup != null) && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
+		if (!(m_switchFormatPopup != null) && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
 		{
 			if (Options.GetFormatType() == PegasusShared.FormatType.FT_WILD)
 			{
@@ -891,6 +893,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		InitDeckPages();
 		SetPageDecks(decks);
 		UpdateDeckVisuals();
+
+		OnSetupDeckPages();
 	}
 
 	private void UpdateDeckVisuals()
@@ -1014,13 +1018,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			if (SceneMgr.Get().GetMode() == SceneMgr.Mode.TOURNAMENT && SetRotationManager.HasSeenStandardModeTutorial())
 			{
-				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_WILD_GAME"), "VO_INNKEEPER_Male_Dwarf_SetRotation_35.prefab:db2f6e3818fa49b4d8423121eba762f6");
 					Options.Get().SetBool(Option.HAS_SEEN_WILD_MODE_VO, val: true);
 				}
-				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_CLASSIC_TAKES_YOU_BACK_ORIGINAL_HEARTHSTONE"), "VO_Innkeeper_Male_Dwarf_ClassicMode_06.prefab:f91da6f7e66fd754fb4e568d15d49116");
@@ -1685,7 +1689,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		if (m_showStandardComingSoonNotice)
 		{
-			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+			var popupText = LocalizationUtils.Get(LocalizationKey.UI_STANDARD_FORMAT_POPUP_TEXT);
+			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 			popupInfo.m_responseCallback = OnStandardComingSoonResponse;
 			popupInfo.m_prefabAssetRefs.Add(STANDARD_COMING_SOON_POPUP_NAME);
 			DialogManager.Get().ShowStandardComingSoonPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
@@ -1703,6 +1708,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			{
 				Payload = m_visualsFormatType
 			});
+
+			AccessibleFormatTypePickerPopup.Show(m_formatTypePickerWidget);
 		}
 	}
 
@@ -1714,6 +1721,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			Payload = (int)visualsFormatType
 		});
+
+		AccessibleFormatTypePickerPopup.Show(m_formatTypePickerWidget);
 	}
 
 	private void SwitchFormatTypeAndRankedPlayMode(VisualsFormatType newVisualsFormatType)
@@ -1879,7 +1888,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		ShowPage(m_currentPageIndex - 1, skipTraySlidingAnimation);
 	}
 
-	private void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
+	internal void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
 	{
 		if (iTween.Count(m_randomDeckPickerTray) > 0 || pageNum < 0 || pageNum >= m_customPages.Count)
 		{
@@ -2153,6 +2162,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			m_slidingTray.ToggleTraySlider(show: true);
 		}
+
+		OnSelectedDeck(deckbox);
 	}
 
 	private bool HandleClickToFixDeck(CollectionDeck deck, HeroPickerButton button, bool isClickToConvertCase, bool IsMissingCards)
@@ -2380,7 +2391,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_heroActor.SetUnlit();
 		NetCache.HeroLevel heroLevel = ((!locked) ? GameUtils.GetHeroLevel(fullDef.EntityDef.GetClass()) : null);
 		int totalLevel = GameUtils.GetTotalHeroLevel() ?? 0;
-		m_xpBar.UpdateDisplay(heroLevel, totalLevel);
+		m_xpBar.UpdateDisplay(null, heroLevel, totalLevel, false);
 		string heroPowerCardIdFromHero = GameUtils.GetHeroPowerCardIdFromHero(fullDef.EntityDef.GetCardId());
 		if (!locked && ShouldShowHeroPower() && !string.IsNullOrEmpty(heroPowerCardIdFromHero))
 		{
@@ -3186,6 +3197,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			PlayEnterModeDialogues();
 		}
+
+		ReadPickerTrayDisplay();
 	}
 
 	private bool CustomPagesReady()
@@ -3260,7 +3273,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		return GetDeckboxWithDeckID(deckId) != null;
 	}
 
-	private long GetLastChosenDeckId()
+	internal long GetLastChosenDeckId()
 	{
 		if (SceneMgr.Get().GetMode() != SceneMgr.Mode.FRIENDLY)
 		{
@@ -3464,7 +3477,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		bool result = false;
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
-		if (mode == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber("DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
+		if (mode == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, NotificationManager.DEFAULT_CHARACTER_POS, GameStrings.Get("VO_INNKEEPER_PLAY_STANDARD_TO_WILD"), "VO_INNKEEPER_Male_Dwarf_SetRotation_43.prefab:4b4ce858139927946905ec0d40d5b3c1");
 			Options.Get().SetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK, val: false);
@@ -3497,7 +3510,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		bool result = false;
 		if (num == 0 || num == 2 || num == 6)
 		{
-			if (UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
+			if (UserAttentionManager.CanShowAttentionGrabber(false, "DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
 			{
 				StartCoroutine(ShowWhizbangPopup(templateDeck));
 				num++;
@@ -3517,10 +3530,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		if (whizbangDeck != null)
 		{
 			yield return new WaitForSeconds(1f);
-			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+			var headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
+			var bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 			popupInfo.m_prefabAssetRefs.Add("WhizbangDialog_notification.prefab:89912cf72b2d5cf47820d2328de40f3f");
-			popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
-			popupInfo.m_bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			popupInfo.m_headerText = headerText;
+			popupInfo.m_bodyText = bodyText;
 			popupInfo.m_disableBnetBar = true;
 			DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.NONE, popupInfo);
 		}
@@ -3791,9 +3807,9 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	private IEnumerator ShowRotatedBoostersPopup(Action callbackOnHide = null)
 	{
 		yield return new WaitForSeconds(1f);
-		if (UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
 		{
-			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo("");
 			setRotationRotatedBoostersPopupInfo.m_onHiddenCallback = callbackOnHide;
 			DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, setRotationRotatedBoostersPopupInfo);
 			GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
@@ -3909,7 +3925,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			m_switchFormatButton.Enable();
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 	}
 
 	private bool ShouldShowStandardDeckVO(VisualsFormatType newVisualsFormatType)
@@ -3952,4 +3968,486 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			gameSaveDataManager.SaveSubkeys(list);
 		}
 	}
+
+    #region Accessibility
+
+	private enum AccessibleState {
+		LOADING,
+		CREATE_DECK_MAIN_MENU,
+		CREATE_DECK_SWITCHING_FORMAT,
+		CREATE_DECK_CHOOSING_CLASS,
+		CREATE_DECK_CLASS_CHOSEN,
+		FRIENDLY_MAIN_MENU,
+		FRIENDLY_CHOOSING_DECK,
+		RANKED_MAIN_MENU,
+		RANKED_CHOOSING_DECK,
+		RANKED_READING_RANK_MEDAL
+	};
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleHorizontalMenu<AccessibleHeroPickerButton> m_accessibleHeroPickerButtons;
+
+	private bool m_chosenDeck; // Used to stop the game from starting immediately if we already have a deck selected
+
+	private void ReadPickerTrayDisplay()
+	{
+		if (CreatingDeck())
+        {
+			ReadCreateDeckScreen();
+			return;
+        }
+	}
+
+	private bool CreatingDeck()
+    {
+		return SceneMgr.Get().GetMode() == SceneMgr.Mode.COLLECTIONMANAGER;
+    }
+
+    internal int GetCurrentPageIndex()
+    {
+		return m_currentPageIndex;
+    }
+
+	private void OnSetupDeckPages()
+	{
+		// TODO: Refactor Practice vs AI to do this properly
+		// Merge ranked with friendly when that happens as most things are similar
+
+		switch (SceneMgr.Get().GetMode())
+		{
+			case SceneMgr.Mode.ADVENTURE:
+				// Practice vs AI
+				AccessibleAdventureScene.Get().OnDeckPickerTrayDisplayReady(m_customPages);
+				break;
+			case SceneMgr.Mode.FRIENDLY:
+				FriendlyOnDeckPickerTrayDisplayReady();
+				break;
+			case SceneMgr.Mode.TOURNAMENT:
+				RankedOnDeckPickerTrayDisplayReady();
+				break;
+			default:
+				break;
+		}
+	}
+
+	private void OnSelectedDeck(CollectionDeckBoxVisual deckbox)
+	{
+		// TODO: Refactor Practice vs AI to do this properly
+
+		switch (SceneMgr.Get().GetMode())
+		{
+			case SceneMgr.Mode.ADVENTURE:
+				// Practice vs AI
+				AccessibleAdventureScene.Get().OnSelectedDeck(deckbox);
+				break;
+			case SceneMgr.Mode.FRIENDLY:
+			case SceneMgr.Mode.TOURNAMENT:
+				PvPOnSelectedDeck();
+				break;
+			default:
+				break;
+		}
+	}
+
+    protected override void OnChosenHero()
+    {
+		if (CreatingDeck())
+        {
+			m_curAccessibleState = AccessibleState.CREATE_DECK_CLASS_CHOSEN;
+			AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+			return;
+        }
+    }
+
+	#region Deck creation
+	private AccessibleMenu m_createDeckMainMenu;
+
+    private void ReadCreateDeckScreen()
+    {
+		AccessibilityMgr.SetScreen(this);
+
+        SetupCreateDeckMenu();
+    }
+
+    private void SetupCreateDeckMenu()
+    {
+		if (m_switchFormatButton.IsCovered())
+		{
+			SetupCreateDeckChooseClassMenu(false);
+		}
+		else
+		{
+			SetupCreateDeckMainMenu();
+		}
+    }
+
+	private void SetupCreateDeckMainMenu()
+	{
+		m_createDeckMainMenu = new AccessibleMenu(this, "", AccessibilityUtils.GoBackToHub);
+		m_createDeckMainMenu.AddOption(m_modeName.Text, () => SetupCreateDeckChooseClassMenu(true));
+		m_createDeckMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_SWITCH_FORMAT), OnSwitchFormat);
+
+		ReadCreateDeckMainMenu();
+	}
+
+	private void ReadCreateDeckMainMenu()
+	{
+		m_createDeckMainMenu.StartReading();
+		m_curAccessibleState = AccessibleState.CREATE_DECK_MAIN_MENU;
+	}
+
+	private void OnSwitchFormat()
+	{
+		m_curAccessibleState = AccessibleState.CREATE_DECK_SWITCHING_FORMAT;
+		m_switchFormatButton.TriggerRelease();
+	}
+
+	// isSubMenu -> true if we can switch format / false if we haven't unlocked wild yet
+	private void SetupCreateDeckChooseClassMenu(bool isSubMenu)
+	{
+		if (isSubMenu)
+		{
+			m_accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, "", ReadCreateDeckMainMenu);
+		}
+		else
+		{
+			m_accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, m_modeName.Text, AccessibilityUtils.GoBackToHub);
+		}
+
+		foreach (var hb in m_heroButtons)
+        {
+			if (!hb.IsLocked())
+            {
+                m_accessibleHeroPickerButtons.AddOption(new AccessibleHeroPickerButton(this, hb, true), () => hb.TriggerRelease());
+            }
+        }
+
+		m_accessibleHeroPickerButtons.StartReading();
+
+		m_curAccessibleState = AccessibleState.CREATE_DECK_CHOOSING_CLASS;
+	}
+
+	#endregion
+
+	#region Friendly
+
+	private AccessibleMenu m_friendlyMainMenu;
+
+	private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_friendlyChooseDeckMenu;
+
+	private void FriendlyOnDeckPickerTrayDisplayReady()
+	{
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, m_modeName.Text);
+
+		m_friendlyMainMenu = new AccessibleMenu(this, "", m_backButton.TriggerRelease);
+		m_friendlyMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), FriendlyReadChooseDeck);
+
+		if (m_DeckShareRequestButton.isActiveAndEnabled)
+		{
+			m_friendlyMainMenu.AddOption(m_DeckShareRequestButton.GetText(), m_DeckShareRequestButton.TriggerRelease);
+		}
+
+		m_friendlyMainMenu.AddOption(m_backButton.GetText(), m_backButton.TriggerRelease);
+
+		FriendlyReadMainMenu();
+	}
+
+	private void FriendlyReadChooseDeck()
+	{
+		m_chosenDeck = false;
+		m_curAccessibleState = AccessibleState.FRIENDLY_CHOOSING_DECK;
+		m_friendlyChooseDeckMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), FriendlyReadMainMenu);
+
+		var selectedDeckId = GetLastChosenDeckId();
+		var selectedDeckIdx = 0;
+
+		for (int i = 0, curIdx = 0; i < m_customPages.Count; i++)
+		{
+			var page = m_customPages[i];
+			var pageDecks = page.m_customDecks;
+
+			for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+			{
+				var deck = pageDecks[j];
+				var deckId = deck.GetDeckID();
+
+				if (deckId == -1L)
+				{
+					break;
+				}
+				else if (deckId == selectedDeckId)
+				{
+					selectedDeckIdx = curIdx;
+				}
+
+				var deckPageIdx = i;
+
+				var accessibleDeck = new AccessibleCollectionDeckBoxVisual(this, deck);
+
+				m_friendlyChooseDeckMenu.AddOption(accessibleDeck, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+			}
+		}
+
+		m_friendlyChooseDeckMenu.SetIndex(selectedDeckIdx);
+		m_friendlyChooseDeckMenu.StartReading();
+	}
+
+	private void SelectDeck(CollectionDeckBoxVisual deck)
+	{
+		m_chosenDeck = true;
+		deck.TriggerRelease();
+	}
+
+	private void ShowDeckPage(int pageIndex)
+	{
+		if (m_currentPageIndex != pageIndex)
+		{
+			ShowPage(pageIndex);
+		}
+	}
+
+	private void FriendlyReadMainMenu()
+	{
+		m_friendlyMainMenu.StartReading();
+		m_curAccessibleState = AccessibleState.FRIENDLY_MAIN_MENU;
+	}
+
+	private void PvPOnSelectedDeck()
+	{
+		if (AccessibilityMgr.IsAccessibilityEnabled() && m_chosenDeck)
+		{
+			m_playButton.TriggerRelease();
+		}
+	}
+
+	internal void OnWaitingForSharedDeck()
+	{
+		// Stop the refocus message from coming up while we wait for the deck to arrive
+		m_curAccessibleState = AccessibleState.LOADING;
+	}
+
+	#endregion
+
+	#region Ranked
+
+	private AccessibleMenu m_rankedMainMenu;
+
+	private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_rankedChooseDeckMenu;
+
+	private AccessibleMultilineText m_accessibleRankedMedal;
+
+	private void RankedOnDeckPickerTrayDisplayReady()
+	{
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, m_modeName.Text);
+
+		m_rankedMainMenu = new AccessibleMenu(this, "", m_backButton.TriggerRelease);
+		m_rankedMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), RankedReadChooseDeck);
+
+		if (Options.GetInRankedPlayMode())
+		{
+			m_rankedMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_RANKED_READ_RANK), ReadCurrentRank);
+		}
+
+		m_rankedMainMenu.AddOption(m_backButton.GetText(), m_backButton.TriggerRelease);
+
+		RankedReadMainMenu();
+	}
+
+	private void ReadCurrentRank()
+	{
+		var lines = new List<string>();
+
+		var curMedal = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentMedal(Options.GetFormatType());
+		lines.Add(AccessibleRankedUtils.GetRankText(curMedal));
+		AccessibleCardUtils.AddLineIfExists(AccessibleRankedUtils.GetRankStarsText(curMedal), lines);
+		AccessibleCardUtils.AddLineIfExists(AccessibleRankedUtils.GetStarBonusText(curMedal), lines);
+
+		m_accessibleRankedMedal = new AccessibleMultilineText(this, lines);
+		m_accessibleRankedMedal.ReadAllLines();
+		m_curAccessibleState = AccessibleState.RANKED_READING_RANK_MEDAL;
+	}
+
+	private void RankedReadChooseDeck()
+	{
+		m_chosenDeck = false;
+		m_curAccessibleState = AccessibleState.RANKED_CHOOSING_DECK;
+		m_rankedChooseDeckMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), RankedReadMainMenu);
+
+		var selectedDeckId = GetLastChosenDeckId();
+		var selectedDeckIdx = 0;
+
+		for (int i = 0, curIdx = 0; i < m_customPages.Count; i++)
+		{
+			var page = m_customPages[i];
+			var pageDecks = page.m_customDecks;
+
+			for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+			{
+				var deck = pageDecks[j];
+				var deckId = deck.GetDeckID();
+
+				if (deckId == -1L)
+				{
+					break;
+				}
+				else if (deckId == selectedDeckId)
+				{
+					selectedDeckIdx = curIdx;
+				}
+
+				var deckPageIdx = i;
+
+				var accessibleDeck = new AccessibleCollectionDeckBoxVisual(this, deck);
+
+				m_rankedChooseDeckMenu.AddOption(accessibleDeck, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+			}
+		}
+
+		m_rankedChooseDeckMenu.SetIndex(selectedDeckIdx);
+		m_rankedChooseDeckMenu.StartReading();
+	}
+
+	private void RankedReadMainMenu()
+	{
+		m_rankedMainMenu.StartReading();
+		m_curAccessibleState = AccessibleState.RANKED_MAIN_MENU;
+	}
+
+	#endregion
+
+    public void HandleInput()
+    {
+		if (m_curAccessibleState == AccessibleState.CREATE_DECK_MAIN_MENU)
+        {
+			m_createDeckMainMenu?.HandleAccessibleInput();
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+        {
+			m_accessibleHeroPickerButtons?.HandleAccessibleInput();
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CLASS_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_playButton.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				AccessibilityUtils.GoBackToHub();
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_MAIN_MENU)
+		{
+			m_friendlyMainMenu?.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_CHOOSING_DECK)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				FriendlyReadMainMenu();
+			}
+			else
+			{
+				m_friendlyChooseDeckMenu?.HandleAccessibleInput();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_MAIN_MENU)
+		{
+			m_rankedMainMenu?.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_CHOOSING_DECK)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				RankedReadMainMenu();
+			}
+			else
+			{
+				m_rankedChooseDeckMenu?.HandleAccessibleInput();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_READING_RANK_MEDAL)
+		{
+			m_accessibleRankedMedal?.HandleAccessibleInput();
+
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				RankedReadMainMenu();
+			}
+		}
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.CREATE_DECK_MAIN_MENU)
+		{
+			return m_createDeckMainMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+        {
+			return m_accessibleHeroPickerButtons?.GetHelp();
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CLASS_CHOSEN)
+        {
+			// Click to start seems fine and easier on translators
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        }
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_MAIN_MENU)
+		{
+			return m_friendlyMainMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_CHOOSING_DECK)
+		{
+			return m_friendlyChooseDeckMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_MAIN_MENU)
+		{
+			return m_rankedMainMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_CHOOSING_DECK)
+		{
+			return m_rankedChooseDeckMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_READING_RANK_MEDAL)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+		if (m_curAccessibleState == AccessibleState.CREATE_DECK_SWITCHING_FORMAT)
+		{
+			m_curAccessibleState = AccessibleState.CREATE_DECK_MAIN_MENU;
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_MAIN_MENU)
+		{
+			m_friendlyMainMenu?.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_CHOOSING_DECK)
+		{
+			m_friendlyChooseDeckMenu?.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_MAIN_MENU)
+		{
+			m_createDeckMainMenu?.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+        {
+			if (AccessibleCollectionManager.Get().IsCreatingDeckFromClipboard())
+            {
+				AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+            }
+			else
+            {
+                m_accessibleHeroPickerButtons?.StartReading();
+            }
+        }
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs b/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
index 16292b6..2e8d9f5 100644
--- a/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
+++ b/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
@@ -5,8 +5,9 @@ using Blizzard.T5.Core;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class DeckTemplatePicker : MonoBehaviour
+public class DeckTemplatePicker : MonoBehaviour, AccessibleScreen
 {
 	public delegate void OnTemplateDeckChosen();
 
@@ -233,6 +234,8 @@ public class DeckTemplatePicker : MonoBehaviour
 					yield return null;
 				}
 			}
+
+			ReadDeckTemplatePicker();
 		}
 		else if (m_root.activeSelf)
 		{
@@ -243,7 +246,7 @@ public class DeckTemplatePicker : MonoBehaviour
 		}
 	}
 
-	private void SetupTemplateButtons(CollectionManager.TemplateDeck refDeck)
+    private void SetupTemplateButtons(CollectionManager.TemplateDeck refDeck)
 	{
 		List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
 		if (nonStarterTemplateDecks == null)
@@ -369,7 +372,7 @@ public class DeckTemplatePicker : MonoBehaviour
 	{
 		yield return new WaitForSeconds(0.5f);
 		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
+		if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
 		{
 			Transform deckTemplateTutorialWelcomeBone = collectionManagerDisplay.m_deckTemplateTutorialWelcomeBone;
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, deckTemplateTutorialWelcomeBone.localPosition, GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_WELCOME"), "VO_INNKEEPER_Male_Dwarf_RECIPE1_01.prefab:0261ef622a5e2b945a8f89e87cbe01a7", 3f);
@@ -484,6 +487,8 @@ public class DeckTemplatePicker : MonoBehaviour
 		{
 			action();
 		}
+
+		OnAccessibleDeckTemplateChosen(false);
 	}
 
 	public IEnumerator ShowTips()
@@ -578,6 +583,8 @@ public class DeckTemplatePicker : MonoBehaviour
 		{
 			collectionManagerDisplay.ShowStandardInfoTutorial(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
+
+		AccessibleCollectionManager.Get().OnEditDeckScreen();
 	}
 
 	private void ShowLowCardsPopup(Action confirmAction, Action cancelAction = null)
@@ -595,12 +602,14 @@ public class DeckTemplatePicker : MonoBehaviour
 				{
 				case AlertPopup.Response.CONFIRM:
 					confirmAction();
+						SetupTemplateChosen();
 					break;
 				case AlertPopup.Response.CANCEL:
 					if (cancelAction != null)
 					{
 						cancelAction();
 					}
+						m_curState = State.CHOOSING_TEMPLATE;
 					break;
 				}
 			}
@@ -637,6 +646,8 @@ public class DeckTemplatePicker : MonoBehaviour
 		{
 			ChooseRecipeAndFillInCards();
 		}
+
+		OnAccessibleDeckTemplateChosen(true);
 	}
 
 	public IEnumerator EnterDeckPhone()
@@ -644,4 +655,130 @@ public class DeckTemplatePicker : MonoBehaviour
 		yield return StartCoroutine(ShowPacks(show: false));
 		yield return StartCoroutine(HideTrays());
 	}
+
+	#region Accessibility
+
+	private enum State { LOADING, CHOOSING_TEMPLATE, TEMPLATE_CHOSEN, CUSTOM_DECK_CHOSEN };
+
+	private State m_curState;
+
+	private AccessibleHorizontalMenu<AccessibleDeckTemplatePickerButton> m_accessibleButtons;
+
+	private void ReadDeckTemplatePicker()
+    {
+		m_curState = State.LOADING;
+
+		AccessibilityMgr.SetScreen(this);
+
+		SetupChooseTemplateMenu();
+    }
+
+	private void SetupChooseTemplateMenu()
+    {
+		m_accessibleButtons = new AccessibleHorizontalMenu<AccessibleDeckTemplatePickerButton>(this, m_pageHeaderText.Text, () => AccessibilityUtils.GoBackToHub());
+
+		foreach (var deck in m_pickerButtons)
+        {
+			m_accessibleButtons.AddOption(new AccessibleDeckTemplatePickerButton(this, deck), () => deck.TriggerRelease());
+        }
+
+		m_accessibleButtons.AddOption(new AccessibleDeckTemplatePickerButton(this, m_customDeckButton, true), () => m_customDeckButton.TriggerRelease());
+
+		m_accessibleButtons.StartReading();
+
+		m_curState = State.CHOOSING_TEMPLATE;
+    }
+
+	private void OnAccessibleDeckTemplateChosen(bool isCustomDeck)
+    {
+		if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+			// Race conditions on preselect. It doesn't make sense to say this out loud unless we're choosing though
+			if (isCustomDeck)
+            {
+				SetupCustomDeckChosen();
+            }
+			else
+            {
+                SetupTemplateChosen();
+            }
+        }
+    }
+
+	private void SetupCustomDeckChosen()
+    {
+        AccessibilityMgr.Output(this, GetCustomDeckChooseHelpMessage());
+        m_curState = State.CUSTOM_DECK_CHOSEN;
+    }
+
+	private void SetupTemplateChosen()
+    {
+        AccessibilityMgr.Output(this, GetTemplateChooseHelpMessage());
+        m_curState = State.TEMPLATE_CHOSEN;
+    }
+
+    public void HandleInput()
+    {
+		if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            m_accessibleButtons?.HandleAccessibleInput();
+        }
+		else if (m_curState == State.TEMPLATE_CHOSEN || m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_chooseButton?.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				SetupChooseTemplateMenu();
+            }
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curState == State.TEMPLATE_CHOSEN)
+        {
+			return GetTemplateChooseHelpMessage();
+        }
+		else if (m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+			return GetCustomDeckChooseHelpMessage();
+        }
+		else if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            return m_accessibleButtons?.GetHelp();
+        }
+
+		return "";
+    }
+
+	private string GetCustomDeckChooseHelpMessage()
+    {
+        return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+    }
+
+	private string GetTemplateChooseHelpMessage()
+    {
+        return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+    }
+
+    public void OnGainedFocus()
+    {
+		if (m_curState == State.TEMPLATE_CHOSEN)
+        {
+            AccessibilityMgr.Output(this, GetTemplateChooseHelpMessage());
+        }
+		else if (m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+            AccessibilityMgr.Output(this, GetCustomDeckChooseHelpMessage());
+        }
+		else if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+			m_accessibleButtons.StartReading();
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs b/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
index 699e563..bd14eaf 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class DeckTrayCardListContent : DeckTrayContent
@@ -543,10 +544,13 @@ public class DeckTrayCardListContent : DeckTrayContent
 			CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks(playSound: true);
 		}
 		DeckHelper.Get().OnCardAdded(editingDeck);
-		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber("DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
+		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber(false, "DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
 		{
-			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_PAGEFLIP_28"), "VO_INNKEEPER_CM_PAGEFLIP_28.prefab:47bb7bdb89ad93443ab7d031bbe666fb");
-			Options.Get().SetBool(Option.HAS_ADDED_CARDS_TO_DECK, val: true);
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_PAGEFLIP_28"), "VO_INNKEEPER_CM_PAGEFLIP_28.prefab:47bb7bdb89ad93443ab7d031bbe666fb");
+            }
+            Options.Get().SetBool(Option.HAS_ADDED_CARDS_TO_DECK, val: true);
 		}
 		return true;
 	}
@@ -897,12 +901,16 @@ public class DeckTrayCardListContent : DeckTrayContent
 		Transform removeCardTutorialBone = CollectionDeckTray.Get().m_removeCardTutorialBone;
 		if (m_deckHelpPopup == null)
 		{
-			m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, removeCardTutorialBone.position, removeCardTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL08"));
-			if (m_deckHelpPopup != null)
-			{
-				m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
-			}
-		}
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                // Visual notification
+                m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, removeCardTutorialBone.position, removeCardTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL08"));
+                if (m_deckHelpPopup != null)
+                {
+                    m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+                }
+            }
+        }
 	}
 
 	private void ShowDeckHelpButtonIfNeeded()
diff --git a/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs b/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
index 0345f02..a57d5be 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
@@ -6,6 +6,7 @@ using Hearthstone;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class DeckTrayDeckListContent : DeckTrayReorderableContent
@@ -61,9 +62,9 @@ public class DeckTrayDeckListContent : DeckTrayReorderableContent
 
 	protected CollectionDeckInfo m_deckInfoTooltip;
 
-	protected List<TraySection> m_traySections = new List<TraySection>();
+	internal List<TraySection> m_traySections = new List<TraySection>();
 
-	protected TraySection m_editingTraySection;
+	internal TraySection m_editingTraySection;
 
 	protected int m_centeringDeckList = -1;
 
@@ -557,6 +558,7 @@ public class DeckTrayDeckListContent : DeckTrayReorderableContent
 				UniversalInputManager.Get().CancelTextInput(base.gameObject);
 			}
 			deckBox.ShowDeckName();
+      AccessibleCollectionManager.Get().OnFinishRenamingDeck();
 		}
 	}
 
diff --git a/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs b/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs
index f2dc593..31c79f4 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs
@@ -157,7 +157,7 @@ public class DeckTrayDeckTileVisual : PegUIElement
 		m_actor.UpdateGhostTileEffect();
 	}
 
-	private CollectionDeckTileActor.GhostedState GetGhostedState()
+	public CollectionDeckTileActor.GhostedState GetGhostedState()
 	{
 		if (m_deck != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/DialogBase.cs b/Decompiled/Assembly-CSharp/DialogBase.cs
index 73d74f2..33bf5a8 100644
--- a/Decompiled/Assembly-CSharp/DialogBase.cs
+++ b/Decompiled/Assembly-CSharp/DialogBase.cs
@@ -1,8 +1,10 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
+using System;
 
-public class DialogBase : MonoBehaviour
+public abstract class DialogBase : MonoBehaviour, AccessibleUI
 {
 	public delegate void HideCallback(DialogBase dialog, object userData);
 
@@ -88,6 +90,7 @@ public class DialogBase : MonoBehaviour
 
 	public virtual void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
 		m_shown = false;
 		StartCoroutine(HideWhenAble());
 	}
@@ -217,4 +220,8 @@ public class DialogBase : MonoBehaviour
 		fullScreenFXMgr.StopVignette();
 		fullScreenFXMgr.StopBlur();
 	}
+
+    public abstract void HandleAccessibleInput();
+
+    public abstract string GetAccessibleHelp();
 }
diff --git a/Decompiled/Assembly-CSharp/DialogManager.cs b/Decompiled/Assembly-CSharp/DialogManager.cs
index 019f67c..7cb0def 100644
--- a/Decompiled/Assembly-CSharp/DialogManager.cs
+++ b/Decompiled/Assembly-CSharp/DialogManager.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using bgs;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
@@ -45,12 +46,13 @@ public class DialogManager : MonoBehaviour
 		GAME_MODES,
 		BACON_CHALLENGE,
 		PRIVACY_POLICY,
-		MERCENARIES_COOP_CHALLENGE,
-		MERCENARIES_FRIENDLY_CHALLENGE,
-		MERCENARIES_SEASON_REWARDS,
+		MERCENARIES_COOP_CHALLENGE, // TODO
+		MERCENARIES_FRIENDLY_CHALLENGE, // TODO
+		MERCENARIES_SEASON_REWARDS, // TODO
 		EXISTING_ACCOUNT_CN,
-		MERCENARIES_ZONE_UNLOCK,
-		GENERIC_BASIC_POPUP
+		MERCENARIES_ZONE_UNLOCK, // TODO
+		GENERIC_BASIC_POPUP,
+		EOE
 	}
 
 	public class DialogRequest
@@ -211,7 +213,7 @@ public class DialogManager : MonoBehaviour
 	public bool AddToQueue(DialogRequest request)
 	{
 		UserAttentionBlocker attentionCategory = request?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
 		{
 			return false;
 		}
@@ -220,14 +222,14 @@ public class DialogManager : MonoBehaviour
 		return true;
 	}
 
-	private void UpdateQueue()
+    private void UpdateQueue()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
 		{
 			return;
 		}
 		DialogRequest dialogRequest = m_dialogRequests.Peek();
-		if (!UserAttentionManager.CanShowAttentionGrabber(dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
 		{
 			Processor.ScheduleCallback(0.5f, realTime: false, delegate
 			{
@@ -243,7 +245,7 @@ public class DialogManager : MonoBehaviour
 	public void ShowPopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (!UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (!UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			DialogRequest dialogRequest = new DialogRequest();
 			dialogRequest.m_type = DialogType.ALERT;
@@ -268,7 +270,7 @@ public class DialogManager : MonoBehaviour
 	public bool ShowUniquePopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			return false;
 		}
@@ -613,7 +615,7 @@ public class DialogManager : MonoBehaviour
 		AddToQueue(dialogRequest);
 	}
 
-	public void ShowClassUpcomingPopup()
+    public void ShowClassUpcomingPopup()
 	{
 		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 		popupInfo.m_showAlertIcon = false;
@@ -626,7 +628,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowBonusStarsPopup(RankedPlayDataModel dataModel, Action onHiddenCallback)
 	{
-		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo
+		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -643,7 +645,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowRankedIntroPopUp(Action onHiddenCallback)
 	{
-		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo
+		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -710,7 +712,7 @@ public class DialogManager : MonoBehaviour
 			return;
 		}
 		NetCache.ProfileNoticeMedal profileNoticeMedal = profileNotice as NetCache.ProfileNoticeMedal;
-		if (profileNoticeMedal == null || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("DialogManager.MaybeShowSeasonEndDialog"))
+		if (profileNoticeMedal == null || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "DialogManager.MaybeShowSeasonEndDialog"))
 		{
 			return;
 		}
@@ -837,7 +839,7 @@ public class DialogManager : MonoBehaviour
 	{
 		DialogRequest dialogRequest = ((m_dialogRequests.Count == 0) ? null : m_dialogRequests.Peek());
 		UserAttentionBlocker attentionCategory = dialogRequest?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
+		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
 		{
 			m_loadingDialog = false;
 			UnityEngine.Object.DestroyImmediate(go);
@@ -1129,7 +1131,7 @@ public class DialogManager : MonoBehaviour
 		loginPopupSequencePopup.LoadAssetsAndShowWhenReady();
 	}
 
-	private void ProcessPrivacyPolicyRequest(DialogRequest request, PrivacyPolicyPopup privacyPolicyPopup)
+    private void ProcessPrivacyPolicyRequest(DialogRequest request, PrivacyPolicyPopup privacyPolicyPopup)
 	{
 		privacyPolicyPopup.SetInfo((PrivacyPolicyPopup.Info)request.m_info);
 		privacyPolicyPopup.Show();
@@ -1225,4 +1227,16 @@ public class DialogManager : MonoBehaviour
 		};
 		AddToQueue(request);
 	}
+
+    #region Accessibility
+    internal AccessibleUI GetCurrentDialog()
+    {
+		return m_currentDialog;
+    }
+
+	internal int GetNumQueuedDialogs()
+    {
+		return m_dialogRequests.Count;
+    }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DisenchantButton.cs b/Decompiled/Assembly-CSharp/DisenchantButton.cs
index cc78547..76bf1cb 100644
--- a/Decompiled/Assembly-CSharp/DisenchantButton.cs
+++ b/Decompiled/Assembly-CSharp/DisenchantButton.cs
@@ -2,6 +2,7 @@ using System.Collections.Generic;
 using System.Linq;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class DisenchantButton : CraftingButton
 {
@@ -124,6 +125,7 @@ public class DisenchantButton : CraftingButton
 		if (response == AlertPopup.Response.CANCEL)
 		{
 			PendingDisenchantWarnings.Clear();
+			AccessibleCollectionManager.Get().OnCancelDisenchantPopup();
 		}
 		else if (PendingDisenchantWarnings.Count > 0)
 		{
diff --git a/Decompiled/Assembly-CSharp/DraftDisplay.cs b/Decompiled/Assembly-CSharp/DraftDisplay.cs
index 0743ede..e0c688f 100644
--- a/Decompiled/Assembly-CSharp/DraftDisplay.cs
+++ b/Decompiled/Assembly-CSharp/DraftDisplay.cs
@@ -811,7 +811,7 @@ public class DraftDisplay : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
+		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
 		{
 			while (SceneMgr.Get().IsTransitioning())
 			{
@@ -1243,7 +1243,7 @@ public class DraftDisplay : MonoBehaviour
 
 	public void ShowInnkeeperInstructions()
 	{
-		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
+		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
 		{
 			if (!m_draftManager.HasSlotType(DraftSlotType.DRAFT_SLOT_HERO_POWER))
 			{
@@ -1251,13 +1251,13 @@ public class DraftDisplay : MonoBehaviour
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			}
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST2_20"), "VO_INNKEEPER_FORGE_INST2_20.prefab:242b6a30031534e47b1f8ddd69370eac", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, val: true);
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST3_21"), "VO_INNKEEPER_FORGE_INST3_21.prefab:06182dd3360965d4ea48952a6dd4a720", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, val: true);
@@ -1467,7 +1467,7 @@ public class DraftDisplay : MonoBehaviour
 			yield return new WaitForSeconds(0.3f);
 		}
 		ArenaTrayDisplay.Get().UpdateTray();
-		if (!UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowActiveDraftScreen"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowActiveDraftScreen"))
 		{
 			yield break;
 		}
@@ -1512,7 +1512,7 @@ public class DraftDisplay : MonoBehaviour
 		if (m_draftManager.ShouldActivateKey())
 		{
 			int maxWins = m_draftManager.GetMaxWins();
-			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
+			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_MAX_ARENA_WINS_04"), "VO_INNKEEPER_MAX_ARENA_WINS_04.prefab:cdf8e488f2d17604499f2cc358cb35f6");
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_MAX_WIN, val: true);
diff --git a/Decompiled/Assembly-CSharp/DraftManager.cs b/Decompiled/Assembly-CSharp/DraftManager.cs
index 310829d..cd42a76 100644
--- a/Decompiled/Assembly-CSharp/DraftManager.cs
+++ b/Decompiled/Assembly-CSharp/DraftManager.cs
@@ -8,6 +8,7 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class DraftManager : IService
 {
@@ -434,11 +435,14 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_responseUserData = CurrentSeasonId;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseCallback = delegate
@@ -468,11 +472,14 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseUserData = m_currentSeason.NextSeasonId;
 		popupInfo.m_responseCallback = delegate
@@ -634,7 +641,7 @@ public class DraftManager : IService
 		sessionRecord.RunFinished = true;
 		sessionRecord.SessionRecordType = SessionRecordType.ARENA;
 		BnetPresenceMgr.Get().SetGameFieldBlob(22u, sessionRecord);
-		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
+		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_1ST_REWARD"), "VO_INNKEEPER_ARENA_1ST_REWARD.prefab:660e915849550ae4085735866647d529");
 			Options.Get().SetBool(Option.HAS_ACKED_ARENA_REWARDS, val: true);
@@ -697,7 +704,7 @@ public class DraftManager : IService
 		{
 			DemoMgr.Get().CreateDemoText(GameStrings.Get("GLUE_BLIZZCON2013_ARENA_5_WINS"), unclickable: false, shouldDoArenaInstruction: false);
 		}
-		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
+		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_3RD_LOSS"), "VO_INNKEEPER_ARENA_3RD_LOSS.prefab:6b2af024c9980d344a087295afb5e3df");
 			Options.Get().SetBool(Option.HAS_LOST_IN_ARENA, val: true);
diff --git a/Decompiled/Assembly-CSharp/DropdownControl.cs b/Decompiled/Assembly-CSharp/DropdownControl.cs
index 4169bba..50003bd 100644
--- a/Decompiled/Assembly-CSharp/DropdownControl.cs
+++ b/Decompiled/Assembly-CSharp/DropdownControl.cs
@@ -43,7 +43,7 @@ public class DropdownControl : PegUIElement
 	{
 	};
 
-	private List<DropdownMenuItem> m_items = new List<DropdownMenuItem>();
+	internal List<DropdownMenuItem> m_items = new List<DropdownMenuItem>();
 
 	private Font m_overrideFont;
 
diff --git a/Decompiled/Assembly-CSharp/EmoteHandler.cs b/Decompiled/Assembly-CSharp/EmoteHandler.cs
index 4de0ab6..9b9badd 100644
--- a/Decompiled/Assembly-CSharp/EmoteHandler.cs
+++ b/Decompiled/Assembly-CSharp/EmoteHandler.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using UnityEngine;
+using Accessibility;
 
 public class EmoteHandler : MonoBehaviour
 {
@@ -245,6 +246,8 @@ public class EmoteHandler : MonoBehaviour
 		{
 			availableEmote.Enable();
 		}
+
+		AccessibleGameplay.Get().OnEmotesShown(m_availableEmotes);
 	}
 
 	public void HideEmotes()
diff --git a/Decompiled/Assembly-CSharp/EnchantmentBanner.cs b/Decompiled/Assembly-CSharp/EnchantmentBanner.cs
index 794f565..bf8cd40 100644
--- a/Decompiled/Assembly-CSharp/EnchantmentBanner.cs
+++ b/Decompiled/Assembly-CSharp/EnchantmentBanner.cs
@@ -20,7 +20,7 @@ public class EnchantmentBanner : MonoBehaviour
 
 	private Vector3 m_initialBannerTextScale;
 
-	private readonly Pool<BigCardEnchantmentPanel> m_enchantmentPool = new Pool<BigCardEnchantmentPanel>();
+	internal readonly Pool<BigCardEnchantmentPanel> m_enchantmentPool = new Pool<BigCardEnchantmentPanel>();
 
 	private Map<Tuple<string, string>, BigCardEnchantmentPanel> m_uniqueEnchantmentLookup = new Map<Tuple<string, string>, BigCardEnchantmentPanel>();
 
diff --git a/Decompiled/Assembly-CSharp/EndGameScreen.cs b/Decompiled/Assembly-CSharp/EndGameScreen.cs
index dddb5a2..ca11f94 100644
--- a/Decompiled/Assembly-CSharp/EndGameScreen.cs
+++ b/Decompiled/Assembly-CSharp/EndGameScreen.cs
@@ -9,6 +9,7 @@ using PegasusLettuce;
 using PegasusShared;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class EndGameScreen : MonoBehaviour
@@ -188,6 +189,8 @@ public class EndGameScreen : MonoBehaviour
 	{
 		if (GameState.Get() == null || !GameState.Get().WasRestartRequested())
 		{
+			AccessibleEndGameScreen.Get().OnShow();
+
 			m_shown = true;
 			m_endGameScreenStartTime = Time.time;
 			Network.Get().DisconnectFromGameServer();
@@ -202,6 +205,8 @@ public class EndGameScreen : MonoBehaviour
 			}
 			ShowScoreScreen();
 			ShowStandardFlowIfReady();
+
+			AccessibleEndGameScreen.Get().OnShown(m_hitbox);
 		}
 	}
 
@@ -338,7 +343,7 @@ public class EndGameScreen : MonoBehaviour
 		{
 			return true;
 		}
-		if (ShowNextRewardTrackAutoClaimedReward())
+		if (ShowNextRewardTrackAutoClaimedReward()) // TODO
 		{
 			return true;
 		}
@@ -350,7 +355,7 @@ public class EndGameScreen : MonoBehaviour
 		{
 			return true;
 		}
-		if (ShowRankedCardBackProgress())
+		if (ShowRankedCardBackProgress()) // TODO Ranked only
 		{
 			return true;
 		}
@@ -358,11 +363,11 @@ public class EndGameScreen : MonoBehaviour
 		{
 			return true;
 		}
-		if (ShowRankedRewards())
+		if (ShowRankedRewards()) // TODO Ranked only
 		{
 			return true;
 		}
-		if (ShowNextProgressionQuestReward())
+		if (ShowNextProgressionQuestReward()) // TODO
 		{
 			return true;
 		}
@@ -732,7 +737,7 @@ public class EndGameScreen : MonoBehaviour
 			}
 			yield return null;
 		}
-		m_twoScoop.Show();
+		m_twoScoop.Show(AccessibleEndGameScreen.Get());
 		if (!SpectatorManager.Get().IsSpectatingOrWatching && ShouldMakeUtilRequests())
 		{
 			InitGoldRewardUI();
diff --git a/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs b/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
index c564d4a..894e779 100644
--- a/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
+++ b/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class EndGameTwoScoop : MonoBehaviour
 {
@@ -54,7 +55,7 @@ public class EndGameTwoScoop : MonoBehaviour
 		return m_isShown;
 	}
 
-	public void Show(bool showXPBar = true)
+	public void Show(AccessibleComponent parent, bool showXPBar = true)
 	{
 		m_isShown = true;
 		base.gameObject.SetActive(value: true);
@@ -72,8 +73,9 @@ public class EndGameTwoScoop : MonoBehaviour
 			if (heroLevel == null)
 			{
 				HideXpBar();
-			}
-			else if (m_xpBarPrefab != null)
+                AccessibilityMgr.Output(parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+            }
+            else if (m_xpBarPrefab != null)
 			{
 				m_xpBar = Object.Instantiate(m_xpBarPrefab);
 				m_xpBar.transform.parent = m_heroActor.transform;
@@ -84,9 +86,13 @@ public class EndGameTwoScoop : MonoBehaviour
 				m_xpBar.m_isAnimated = true;
 				m_xpBar.m_delay = BAR_ANIMATION_DELAY;
 				m_xpBar.m_levelUpCallback = PlayLevelUpEffect;
-				m_xpBar.UpdateDisplay(heroLevel, totalLevel);
+				m_xpBar.UpdateDisplay(AccessibleEndGameScreen.Get(), heroLevel, totalLevel, true);
 			}
 		}
+		else
+        {
+			AccessibilityMgr.Output(parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
 	}
 
 	public void Hide()
diff --git a/Decompiled/Assembly-CSharp/EnemyEmoteHandler.cs b/Decompiled/Assembly-CSharp/EnemyEmoteHandler.cs
index 68ba437..f9ab0d3 100644
--- a/Decompiled/Assembly-CSharp/EnemyEmoteHandler.cs
+++ b/Decompiled/Assembly-CSharp/EnemyEmoteHandler.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class EnemyEmoteHandler : MonoBehaviour
 {
@@ -97,6 +98,8 @@ public class EnemyEmoteHandler : MonoBehaviour
 			m_SquelchEmote.GetComponent<Collider>().enabled = true;
 			iTween.Stop(m_SquelchEmote);
 			iTween.ScaleTo(m_SquelchEmote, iTween.Hash("scale", m_squelchEmoteStartingScale, "time", 0.5f, "ignoretimescale", true, "easetype", iTween.EaseType.easeOutElastic));
+
+			AccessibleGameplay.Get().OnEnemyEmotesShown(m_SquelchEmoteText.Text);
 		}
 	}
 
@@ -164,7 +167,7 @@ public class EnemyEmoteHandler : MonoBehaviour
 		iTween.ScaleTo(m_SquelchEmote, iTween.Hash("scale", m_squelchEmoteStartingScale, "time", 0.2f, "ignoretimescale", true));
 	}
 
-	private void DoSquelchClick()
+	internal void DoSquelchClick()
 	{
 		m_squelched[GameState.Get().GetOpposingPlayerId()] = !m_squelched[GameState.Get().GetOpposingPlayerId()];
 		HideEmotes();
diff --git a/Decompiled/Assembly-CSharp/Entity.cs b/Decompiled/Assembly-CSharp/Entity.cs
index 817daea..b31d9d9 100644
--- a/Decompiled/Assembly-CSharp/Entity.cs
+++ b/Decompiled/Assembly-CSharp/Entity.cs
@@ -1756,6 +1756,22 @@ public class Entity : EntityBase
 		return entity;
 	}
 
+	public Entity CloneForAccessibility()
+	{
+		Entity entity = new Entity();
+		entity.m_duplicateForHistory = true;
+		entity.m_staticEntityDef = GetEntityDef();
+		entity.m_dynamicEntityDef = null;
+		entity.m_card = m_card;
+		entity.m_cardId = base.m_cardId;
+		entity.ReplaceTags(m_tags);
+		entity.m_subCardIDs = m_subCardIDs;
+		entity.m_loadState = m_loadState;
+		entity.m_displayedCreatorName = m_displayedCreatorName;
+		entity.m_enchantmentCreatorCardIDForPortrait = m_enchantmentCreatorCardIDForPortrait;
+		return entity;
+	}
+
 	public bool IsHistoryDupe()
 	{
 		return m_duplicateForHistory;
diff --git a/Decompiled/Assembly-CSharp/EntityBase.cs b/Decompiled/Assembly-CSharp/EntityBase.cs
index 871c958..614e3d5 100644
--- a/Decompiled/Assembly-CSharp/EntityBase.cs
+++ b/Decompiled/Assembly-CSharp/EntityBase.cs
@@ -1047,4 +1047,13 @@ public abstract class EntityBase
 	{
 		return GetTag<TAG_SPELL_SCHOOL>(GAME_TAG.SPELL_SCHOOL);
 	}
+
+	#region Accessibility
+
+	public bool HasReborn()
+	{
+		return HasTag(GAME_TAG.REBORN);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs b/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
index 711b7e1..6aa4892 100644
--- a/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
+++ b/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using UnityEngine;
 
-public class ExistingAccountPopup : DialogBase
+public class ExistingAccountPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool hasAccount);
 
diff --git a/Decompiled/Assembly-CSharp/FactionChoicePopup.cs b/Decompiled/Assembly-CSharp/FactionChoicePopup.cs
index 2507c9f..94ad82f 100644
--- a/Decompiled/Assembly-CSharp/FactionChoicePopup.cs
+++ b/Decompiled/Assembly-CSharp/FactionChoicePopup.cs
@@ -2,8 +2,9 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
-public class FactionChoicePopup : MonoBehaviour
+public class FactionChoicePopup : MonoBehaviour, AccessibleUI
 {
 	[CustomEditField(Sections = "Buttons")]
 	public AsyncReference m_ChooseHorde;
@@ -37,6 +38,11 @@ public class FactionChoicePopup : MonoBehaviour
 
 	public bool HasFactionChoiceConfirmationBeenReceived => m_FactionChoiceConfirmationReceived;
 
+	#region Accessibility
+	private UIBButton m_chooseHordeButton;
+	private UIBButton m_chooseAllianceButton;
+	#endregion
+
 	private void Start()
 	{
 		if (m_ConfirmationPopup == null)
@@ -69,11 +75,13 @@ public class FactionChoicePopup : MonoBehaviour
 		}
 		m_ChooseHorde.RegisterReadyListener(delegate(UIBButton button)
 		{
+			m_chooseHordeButton = button;
 			button.AddEventListener(UIEventType.RELEASE, OnReleaseHorde);
 			button.gameObject.GetComponentInChildren<UberText>()?.SetGameStringText(m_HordeButtonGlueString);
 		});
 		m_ChooseAlliance.RegisterReadyListener(delegate(UIBButton button)
 		{
+			m_chooseAllianceButton = button;
 			button.AddEventListener(UIEventType.RELEASE, OnReleaseAlliance);
 			button.gameObject.GetComponentInChildren<UberText>()?.SetGameStringText(m_AllianceButtonGlueString);
 		});
@@ -120,6 +128,7 @@ public class FactionChoicePopup : MonoBehaviour
 	private void ShowConfirmation()
 	{
 		m_stateMachine.SendEvent("Birth");
+		ReadConfirmation();
 	}
 
 	private void HideConfirmation()
@@ -127,6 +136,7 @@ public class FactionChoicePopup : MonoBehaviour
 		if (m_ConfirmationPopup.activeSelf)
 		{
 			m_stateMachine.SendEvent("Death");
+			ReadPopup();
 		}
 	}
 
@@ -144,4 +154,54 @@ public class FactionChoicePopup : MonoBehaviour
 		}
 		m_FactionChoiceConfirmationReceived = true;
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	public void ReadPopup()
+	{
+		AccessibilityMgr.ShowUI(this);
+
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_CARD_SET_AV"));
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_PROGRESSION_AV_POPUP_MESSAGE"));
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null);
+		m_accessibleMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_AV_POPUP_CHOICE_HORDE"), m_chooseHordeButton.TriggerRelease);
+		m_accessibleMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_AV_POPUP_CHOICE_ALLIANCE"), m_chooseAllianceButton.TriggerRelease);
+
+		m_accessibleMenu.StartReading();
+	}
+
+	public void ReadConfirmation()
+	{
+        AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_ALERT_POPUP_TITLE), true);
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_PROGRESSION_AV_POPUP_CHOICE_CONFIRMATION_TITLE"));
+		AccessibilityMgr.Output(this, GameStrings.Get(m_ConfirmationMessage.Text));
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null);
+		m_accessibleMenu.AddOption(m_ConfirmationConfirm.GetText(), m_ConfirmationConfirm.TriggerRelease);
+		m_accessibleMenu.AddOption(m_ConfirmationCancel.GetText(), m_ConfirmationCancel.TriggerRelease);
+
+		m_accessibleMenu.StartReading();
+	}
+
+	public void HidePopup()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_accessibleMenu.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_accessibleMenu.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FatalErrorScene.cs b/Decompiled/Assembly-CSharp/FatalErrorScene.cs
index bf13053..b90b717 100644
--- a/Decompiled/Assembly-CSharp/FatalErrorScene.cs
+++ b/Decompiled/Assembly-CSharp/FatalErrorScene.cs
@@ -11,7 +11,7 @@ public class FatalErrorScene : PegasusScene
 		{
 			service.AppAbort();
 		}
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 		if (DialogManager.Get() != null)
 		{
 			DialogManager.Get().ClearAllImmediately();
@@ -34,7 +34,7 @@ public class FatalErrorScene : PegasusScene
 
 	public override void Unload()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StopBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 	}
 
 	private void OnFatalErrorScreenLoaded(AssetReference assetRef, GameObject go, object callbackData)
diff --git a/Decompiled/Assembly-CSharp/FatalErrorScreen.cs b/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
index d2b3512..809c0e0 100644
--- a/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
+++ b/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
@@ -3,8 +3,9 @@ using System.Collections;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
-public class FatalErrorScreen : MonoBehaviour
+public class FatalErrorScreen : MonoBehaviour, AccessibleScreen
 {
 	public UberText m_closedSignText;
 
@@ -125,6 +126,8 @@ public class FatalErrorScreen : MonoBehaviour
 		{
 			Processor.TerminateAllProcessing();
 		}
+
+		ReadScreen();
 	}
 
 	private void OnClick(UIEvent e)
@@ -164,4 +167,43 @@ public class FatalErrorScreen : MonoBehaviour
 		yield return new WaitForSeconds(waitDuration);
 		HearthstoneApplication.Get().Reset();
 	}
+
+    #region Accessibility
+
+	private void ReadScreen()
+    {
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_FATAL_ERROR_SCREEN_TITLE));
+
+		if (m_closedSignTitle != null && m_closedSignTitle.Text != null)
+        {
+			AccessibilityMgr.Output(this, m_closedSignTitle.Text);
+        }
+
+		if (m_closedSignText != null && m_closedSignText.Text != null)
+        {
+			AccessibilityMgr.Output(this, m_closedSignText.Text);
+        }
+
+        AccessibilityMgr.Output(this, GetHelp());
+    }
+
+    public void HandleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			HearthstoneApplication.Get().Exit();
+        }
+    }
+
+    public string GetHelp()
+    {
+		return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_EXIT, AccessibleKey.CONFIRM);
+    }
+
+    public void OnGainedFocus()
+    {
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs b/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
index 1fd1226..d4b8178 100644
--- a/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using PegasusShared;
 
-public class FiresideBrawlChoiceDialog : DialogBase
+public class FiresideBrawlChoiceDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(BrawlType choice);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs b/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
index e0b7eee..62167a6 100644
--- a/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideBrawlOkDialog : DialogBase
+using Accessibility;
+
+public class FiresideBrawlOkDialog : InaccessibleDialogBase
 {
 	public UIBButton m_okBrawlButton;
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
index e92d6c0..e693e45 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringFindEventDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringFindEventDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool search);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
index 213822a..4cdf1f6 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringInnkeeperSetupDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringInnkeeperSetupDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool search);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
index 5cad85e..4312358 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringJoinDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringJoinDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool joinFSG);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
index 8aab063..1dbaa12 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using System;
 using System.Collections.Generic;
 using UnityEngine;
 
-public class FiresideGatheringLocationHelperDialog : DialogBase
+public class FiresideGatheringLocationHelperDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs b/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
index 2b7d3e3..72fe43c 100644
--- a/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
+++ b/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
@@ -122,7 +122,7 @@ public class FixedRewardsMgr : IService
 
 	public bool ShowFixedRewards(UserAttentionBlocker blocker, HashSet<Achieve.RewardTiming> rewardVisualTimings, DelOnAllFixedRewardsShown allRewardsShownCallback, DelPositionNonToastReward positionNonToastRewardCallback)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs b/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
index 869b7b1..9adbc09 100644
--- a/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
+++ b/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
@@ -1,7 +1,8 @@
+using Accessibility;
 using System.Collections;
 using UnityEngine;
 
-public class FreeArenaWinDialog : DialogBase
+public class FreeArenaWinDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs b/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
index 3798bf0..3c709e0 100644
--- a/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
+++ b/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
@@ -12,6 +12,7 @@ using PegasusShared;
 using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 public class FriendChallengeMgr
 {
@@ -181,7 +182,7 @@ public class FriendChallengeMgr
 		BnetPresenceMgr.Get().SetGameField(20u, BattleNet.GetEnvironment());
 	}
 
-	private void BnetParty_OnJoined(OnlineEventType evt, PartyInfo party, LeaveReason? reason)
+	internal void BnetParty_OnJoined(OnlineEventType evt, PartyInfo party, LeaveReason? reason)
 	{
 		if (party.Type != PartyType.FRIENDLY_CHALLENGE)
 		{
@@ -299,7 +300,7 @@ public class FriendChallengeMgr
 		}
 	}
 
-	private void BnetParty_OnPartyAttributeChanged(PartyInfo party, string attributeKey, Variant value)
+	internal void BnetParty_OnPartyAttributeChanged(PartyInfo party, string attributeKey, Variant value)
 	{
 		if (party.Type != PartyType.FRIENDLY_CHALLENGE || m_data.m_partyId != party.Id.ToBnetEntityId())
 		{
@@ -365,6 +366,7 @@ public class FriendChallengeMgr
 			}
 		}
 		string data = (value.HasStringValue ? value.StringValue : string.Empty);
+
 		PushPartyEvent(party.Id.ToBnetEntityId(), attributeKey, data, bnetGameAccountId);
 	}
 
@@ -837,6 +839,7 @@ public class FriendChallengeMgr
 			m_data.m_challengeeAccepted = true;
 			string attributeKey = (DidSendChallenge() ? "s1" : "s2");
 			BnetParty.SetPartyAttributeString(m_data.m_partyId, attributeKey, "deck");
+			AccessibilityMgr.TransitioningScreens();
 			FireChangedEvent(FriendChallengeEvent.I_ACCEPTED_CHALLENGE, m_data.m_challenger);
 		}
 	}
@@ -991,6 +994,11 @@ public class FriendChallengeMgr
 
 	public bool IsDeckShareEnabled()
 	{
+		if (m_simulatingChallenge)
+		{
+			return true;
+		}
+
 		if (!HasChallenge())
 		{
 			return false;
@@ -1370,6 +1378,11 @@ public class FriendChallengeMgr
 
 	private void SelectMyDeck_InternalParty(long deckId)
 	{
+		if (m_simulatingChallenge)
+		{
+			return;
+		}
+
 		string val = ((deckId == 0L) ? "deck" : "ready");
 		Attribute[] attributeV;
 		if (DidSendChallenge())
@@ -1397,6 +1410,11 @@ public class FriendChallengeMgr
 
 	private void SelectMyHero_InternalParty(long heroCardDbId)
 	{
+		if (m_simulatingChallenge)
+		{
+			return;
+		}
+
 		string val = ((heroCardDbId == 0L) ? "deck" : "ready");
 		Attribute[] attributeV;
 		if (DidSendChallenge())
@@ -2203,6 +2221,7 @@ public class FriendChallengeMgr
 			FriendlyChallengeHelper.Get().ShowDeckShareRequestDialog(OnFriendChallengeDeckShareRequestDialogResponse);
 			break;
 		case FriendChallengeEvent.OPPONENT_ACCEPTED_DECK_SHARE_REQUEST:
+			DeckPickerTrayDisplay.Get().OnWaitingForSharedDeck();
 			FriendlyChallengeHelper.Get().HideDeckShareRequestWaitingDialog();
 			break;
 		case FriendChallengeEvent.OPPONENT_DECLINED_DECK_SHARE_REQUEST:
@@ -2241,7 +2260,7 @@ public class FriendChallengeMgr
 
 	private bool CanPromptReceivedChallenge()
 	{
-		bool flag = !UserAttentionManager.CanShowAttentionGrabber("FriendlyChallengeMgr.CanPromptReceivedChallenge");
+        bool flag = !UserAttentionManager.CanShowAttentionGrabber(false, "FriendlyChallengeMgr.CanPromptReceivedChallenge");
 		if (!flag)
 		{
 			if (GameMgr.Get().IsFindingGame())
@@ -2429,6 +2448,7 @@ public class FriendChallengeMgr
 
 	private void ShowOpponentDeclinedChallengeDialog(BnetPlayer challengee, FriendlyChallengeData challengeData)
 	{
+		AccessibilityMgr.TransitioningUIs();
 		if (m_challengeDialog != null)
 		{
 			m_challengeDialog.Hide();
@@ -2660,7 +2680,7 @@ public class FriendChallengeMgr
 		}
 		if (availabilityBlockerReasons == AvailabilityBlockerReasons.NONE)
 		{
-			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: true);
+			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: true);
 		}
 		if (availabilityBlockerReasons != 0)
 		{
@@ -2698,6 +2718,7 @@ public class FriendChallengeMgr
 		bool flag = (!DidSendChallenge() && m_data.m_challengeeDeckOrHeroSelected) || (DidSendChallenge() && m_data.m_challengerDeckOrHeroSelected);
 		if (m_challengeDialog != null && !flag)
 		{
+			AccessibilityMgr.TransitioningScreens();
 			m_challengeDialog.Hide();
 			m_challengeDialog = null;
 		}
@@ -2765,4 +2786,53 @@ public class FriendChallengeMgr
 		}
 		return false;
 	}
+
+	#region Accessibility testing
+
+	private bool m_simulatingChallenge;
+
+	internal void Cheat_SimulateChallenge(BnetPlayer challenger, FormatType formatType)
+	{
+		m_data = new FriendlyChallengeData();
+		m_data.m_challenger = challenger;
+		m_data.m_challengee = BnetPresenceMgr.Get().GetMyPlayer();
+		m_data.m_challengerId = m_data.m_challenger.GetHearthstoneGameAccount().GetId();
+		m_hasSeenDeclinedReason = false;
+		m_data.m_scenarioId = 2;
+		m_data.m_seasonId = 0;
+		m_data.m_challengeFormatType = formatType;
+
+		m_simulatingChallenge = true;
+
+		DialogManager.Get().ShowFriendlyChallenge(formatType, challenger, false, PartyType.FRIENDLY_CHALLENGE, Cheat_OnChallengeReceivedDialogResponse, Cheat_OnChallengeReceivedDialogProcessed);
+	}
+
+	internal void Cheat_Cleanup()
+	{
+		m_data = null;
+		m_simulatingChallenge = false;
+	}
+
+	private bool Cheat_OnChallengeReceivedDialogProcessed(DialogBase dialog, object userData)
+	{
+		m_challengeDialog = dialog;
+		return true;
+	}
+
+	private void Cheat_OnChallengeReceivedDialogResponse(bool accept)
+	{
+		if (accept)
+		{
+			AccessibilityMgr.TransitioningScreens();
+
+			m_challengeDialog?.Hide();
+			m_challengeDialog = null;
+
+			Navigation.Clear();
+			Options.SetFormatType(FormatType.FT_STANDARD);
+			SceneMgr.Get().SetNextMode(SceneMgr.Mode.FRIENDLY);
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FriendListChallengeButton.cs b/Decompiled/Assembly-CSharp/FriendListChallengeButton.cs
index 46b0ed3..6fc9c56 100644
--- a/Decompiled/Assembly-CSharp/FriendListChallengeButton.cs
+++ b/Decompiled/Assembly-CSharp/FriendListChallengeButton.cs
@@ -62,8 +62,78 @@ public class FriendListChallengeButton : MonoBehaviour
 		{
 			return;
 		}
+
+		var dataModel = GetChallengeButtonDataModel();
+		var text = dataModel.text;
+		var text2 = dataModel.text2;
+
+		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
+		{
+			string headline = FormatHeadline(text);
+			string bodytext = FormatBodytext(text2);
+			m_tooltipZone.ShowSocialTooltip(this, headline, bodytext, 75f, GameLayer.BattleNetDialog);
+		}
+	}
+
+	public void HideTooltip()
+	{
+		m_tooltipZone.HideTooltip();
+	}
+
+	public void OpenChallengeMenu()
+	{
+		m_widget.TriggerEvent("OPEN_CHALLENGE_MENU");
+		ChatMgr.Get().FriendListFrame.CloseFlyoutMenu();
+	}
+
+	public void CloseChallengeMenu()
+	{
+		m_widget.TriggerEvent("CLOSE_CHALLENGE_MENU");
+		HideTooltip();
+	}
+
+	public void CloseFriendsListMenu()
+	{
+		ChatMgr.Get().CloseFriendsList();
+	}
+
+	#region Accessibility
+
+	internal enum ChallengeButtonState
+	{
+		UNKNOWN,
+		CHALLENGE,
+		SPECTATE,
+		KICK_SPECTATOR,
+		REVEAL_CARDS_TO_OPPONENT_SPECTATOR,
+		INVITE_PLAYER_TO_SPECTATE,
+		INVITED_PLAYER_TO_SPECTATE,
+		CANNOT_INTERACT,
+	};
+
+	internal class ChallengeButtonDataModel
+    {
+		internal string text;
+		internal string text2;
+		internal ChallengeButtonState state;
+		internal bool canClickButton;
+
+		internal ChallengeButtonDataModel(string text, string text2, ChallengeButtonState state, bool canClickButton)
+        {
+			this.text = text;
+			this.text2 = text2;
+			this.state = state;
+			this.canClickButton = canClickButton;
+        }
+    }
+
+	internal ChallengeButtonDataModel GetChallengeButtonDataModel()
+    {
 		string text = string.Empty;
 		string text2 = string.Empty;
+		ChallengeButtonState state = ChallengeButtonState.UNKNOWN;
+		bool canClickButton = true;
+
 		BnetGameAccountId hearthstoneGameAccountId = m_player.GetHearthstoneGameAccountId();
 		SpectatorManager spectatorManager = SpectatorManager.Get();
 		bool flag = PartyManager.Get().IsInBattlegroundsParty() && !SceneMgr.Get().IsInGame() && !GameMgr.Get().IsFindingGame();
@@ -73,21 +143,29 @@ public class FriendListChallengeButton : MonoBehaviour
 			{
 				text = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_INVITE_HEADER";
 				text2 = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_INVITE_BODY";
+				state = ChallengeButtonState.CANNOT_INTERACT;
+				canClickButton = false;
 			}
 			else if (flag && PartyManager.Get().CanKick(hearthstoneGameAccountId))
 			{
 				text = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_KICK_HEADER";
 				text2 = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_KICK_BODY";
+				state = ChallengeButtonState.CANNOT_INTERACT;
+				canClickButton = false;
 			}
 			else if (flag && !PartyManager.Get().IsPartyLeader() && BnetFriendMgr.Get().IsFriend(m_player))
 			{
 				text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
 				text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_BATTLEGROUNDS_PARTY_MEMBER";
+				state = ChallengeButtonState.CANNOT_INTERACT;
+				canClickButton = false;
 			}
 			else if (spectatorManager.HasInvitedMeToSpectate(hearthstoneGameAccountId))
 			{
 				text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_AVAILABLE_HEADER";
 				text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_RECEIVED_INVITE_TEXT";
+				state = ChallengeButtonState.SPECTATE;
+				canClickButton = true;
 			}
 			else if (!spectatorManager.CanSpectate(m_player))
 			{
@@ -95,42 +173,98 @@ public class FriendListChallengeButton : MonoBehaviour
 				{
 					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_KICK_HEADER";
 					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_KICK_TEXT";
-				}
-				else if (spectatorManager.CanInviteToSpectateMyGame(hearthstoneGameAccountId))
+					state = ChallengeButtonState.KICK_SPECTATOR;
+                    canClickButton = true;
+                }
+                else if (spectatorManager.CanInviteToSpectateMyGame(hearthstoneGameAccountId))
 				{
 					if (spectatorManager.IsPlayerSpectatingMyGamesOpposingSide(hearthstoneGameAccountId))
 					{
 						text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_OTHER_SIDE_HEADER";
 						text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_OTHER_SIDE_TEXT";
-					}
-					else
+						state = ChallengeButtonState.REVEAL_CARDS_TO_OPPONENT_SPECTATOR;
+                        canClickButton = true;
+                    }
+                    else
 					{
 						text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_HEADER";
 						text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_TEXT";
+						state = ChallengeButtonState.INVITE_PLAYER_TO_SPECTATE;
+                        canClickButton = true;
 					}
 				}
 				else if (spectatorManager.IsInvitedToSpectateMyGame(hearthstoneGameAccountId))
 				{
 					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITED_HEADER";
 					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITED_TEXT";
-				}
-				else if (spectatorManager.IsSpectatingPlayer(hearthstoneGameAccountId))
+					state = ChallengeButtonState.INVITED_PLAYER_TO_SPECTATE;
+                    canClickButton = false;
+                }
+                else if (spectatorManager.IsSpectatingPlayer(hearthstoneGameAccountId))
 				{
 					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_SPECTATING_HEADER";
 					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_SPECTATING_TEXT";
+					state = ChallengeButtonState.CANNOT_INTERACT;
+                    canClickButton = false;
 				}
 				else if (spectatorManager.HasPreviouslyKickedMeFromGame(hearthstoneGameAccountId, SpectatorManager.GetSpectatorGameHandleFromPlayer(m_player)))
 				{
 					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_PREVIOUSLY_KICKED_HEADER";
 					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_PREVIOUSLY_KICKED_TEXT";
+					state = ChallengeButtonState.SPECTATE;
+                    canClickButton = false;
 				}
 				else
 				{
-					text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
-					text2 = ((!FriendChallengeMgr.Get().AmIAvailable()) ? (BnetPresenceMgr.Get().GetMyPlayer().IsAppearingOffline() ? "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_APPEARING_OFFLINE" : ((!flag || BnetFriendMgr.Get().IsFriend(m_player)) ? "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_UNAVAILABLE" : "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_AVAILABLE")) : ((FriendChallengeMgr.Get().CanChallenge(m_player) || !BnetFriendMgr.Get().IsFriend(m_player)) ? "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_AVAILABLE" : "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_THEYRE_UNAVAILABLE"));
-				}
-			}
-		}
+                    text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+
+                    if (!FriendChallengeMgr.Get().AmIAvailable())
+                    {
+                        if (BnetPresenceMgr.Get().GetMyPlayer().IsAppearingOffline())
+                        {
+                            text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_APPEARING_OFFLINE";
+							state = ChallengeButtonState.CHALLENGE;
+							canClickButton = false;
+                        }
+                        else
+                        {
+                            if (!flag || BnetFriendMgr.Get().IsFriend(m_player))
+                            {
+                                text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_UNAVAILABLE";
+                                state = ChallengeButtonState.CHALLENGE;
+                                canClickButton = false;
+                            }
+                            else
+                            {
+                                text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_AVAILABLE";
+								state = ChallengeButtonState.CHALLENGE;
+								canClickButton = true;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (FriendChallengeMgr.Get().CanChallenge(m_player) || !BnetFriendMgr.Get().IsFriend(m_player))
+                        {
+                            text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_AVAILABLE";
+                            state = ChallengeButtonState.CHALLENGE;
+                            canClickButton = true;
+                        }
+                        else
+                        {
+                            text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_THEYRE_UNAVAILABLE";
+                            state = ChallengeButtonState.CHALLENGE;
+                            canClickButton = false;
+                        }
+                    }
+                }
+            }
+			else
+            {
+				state = ChallengeButtonState.SPECTATE;
+				canClickButton = true;
+            }
+        }
 		if (UniversalInputManager.Get().IsTouchMode())
 		{
 			if (GameStrings.HasKey(text + "_TOUCH"))
@@ -142,33 +276,19 @@ public class FriendListChallengeButton : MonoBehaviour
 				text2 += "_TOUCH";
 			}
 		}
-		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
-		{
-			string headline = GameStrings.Get(text);
-			string bodytext = GameStrings.Format(text2, m_player.GetBestName());
-			m_tooltipZone.ShowSocialTooltip(this, headline, bodytext, 75f, GameLayer.BattleNetDialog);
-		}
-	}
 
-	public void HideTooltip()
-	{
-		m_tooltipZone.HideTooltip();
-	}
+		return new ChallengeButtonDataModel(text, text2, state, canClickButton);
+    }
 
-	public void OpenChallengeMenu()
-	{
-		m_widget.TriggerEvent("OPEN_CHALLENGE_MENU");
-		ChatMgr.Get().FriendListFrame.CloseFlyoutMenu();
-	}
+	internal string FormatHeadline(string text)
+    {
+        return GameStrings.Get(text);
+    }
 
-	public void CloseChallengeMenu()
-	{
-		m_widget.TriggerEvent("CLOSE_CHALLENGE_MENU");
-		HideTooltip();
-	}
+	internal string FormatBodytext(string text2)
+    {
+        return GameStrings.Format(text2, m_player.GetBestName());
+    }
 
-	public void CloseFriendsListMenu()
-	{
-		ChatMgr.Get().CloseFriendsList();
-	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FriendListChallengeMenu.cs b/Decompiled/Assembly-CSharp/FriendListChallengeMenu.cs
index 1c5a220..a6cb969 100644
--- a/Decompiled/Assembly-CSharp/FriendListChallengeMenu.cs
+++ b/Decompiled/Assembly-CSharp/FriendListChallengeMenu.cs
@@ -1,5 +1,6 @@
 using bgs;
 using PegasusShared;
+using System;
 using UnityEngine;
 
 public class FriendListChallengeMenu : MonoBehaviour
@@ -489,71 +490,17 @@ public class FriendListChallengeMenu : MonoBehaviour
 
 	private void OnStandardDuelButtonReleased(UIEvent e)
 	{
-		if (!m_bHasStandardDeck)
-		{
-			AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
-			{
-				m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
-				m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_STANDARD_DECK"),
-				m_showAlertIcon = true,
-				m_responseDisplay = AlertPopup.ResponseDisplay.OK
-			};
-			DialogManager.Get().ShowPopup(info);
-			m_challengeButton.CloseChallengeMenu();
-		}
-		else
-		{
-			FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
-			BnetPlayer player = m_challengeButton.GetPlayer();
-			FriendChallengeMgr.Get().SendChallenge(player, FormatType.FT_STANDARD, enableDeckShare: true);
-			m_challengeButton.CloseFriendsListMenu();
-		}
+		SendStartStandardDuelChallenge();
 	}
 
-	private void OnWildDuelButtonReleased(UIEvent e)
+    private void OnWildDuelButtonReleased(UIEvent e)
 	{
-		if (!m_bHasWildDeck)
-		{
-			AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
-			{
-				m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
-				m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_DECK"),
-				m_showAlertIcon = true,
-				m_responseDisplay = AlertPopup.ResponseDisplay.OK
-			};
-			DialogManager.Get().ShowPopup(info);
-			m_challengeButton.CloseChallengeMenu();
-		}
-		else
-		{
-			FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
-			BnetPlayer player = m_challengeButton.GetPlayer();
-			FriendChallengeMgr.Get().SendChallenge(player, FormatType.FT_WILD, enableDeckShare: true);
-			m_challengeButton.CloseFriendsListMenu();
-		}
+		SendStartWildDuelChallenge();
 	}
 
 	private void OnClassicDuelButtonReleased(UIEvent e)
 	{
-		if (!m_bHasClassicDeck)
-		{
-			AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
-			{
-				m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
-				m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_CLASSIC_DECK"),
-				m_showAlertIcon = true,
-				m_responseDisplay = AlertPopup.ResponseDisplay.OK
-			};
-			DialogManager.Get().ShowPopup(info);
-			m_challengeButton.CloseChallengeMenu();
-		}
-		else
-		{
-			FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
-			BnetPlayer player = m_challengeButton.GetPlayer();
-			FriendChallengeMgr.Get().SendChallenge(player, FormatType.FT_CLASSIC, enableDeckShare: true);
-			m_challengeButton.CloseFriendsListMenu();
-		}
+		SendStartClassicDuelChallenge();
 	}
 
 	private void OnRegularTavernBrawlButtonReleased(UIEvent e)
@@ -694,4 +641,119 @@ public class FriendListChallengeMenu : MonoBehaviour
 			m_MercenariesFriendlyTooltipZone.HideTooltip();
 		}
 	}
+
+	#region Accessibility
+    public void SendStartStandardDuelChallenge()
+    {
+		if (!m_bHasStandardDeck)
+		{
+			FireNoStandardDeckPopup();
+			m_challengeButton?.CloseChallengeMenu();
+		}
+		else
+		{
+            BnetPlayer player = m_challengeButton.GetPlayer();
+            SendFriendlyChallenge(player, FormatType.FT_STANDARD);
+			m_challengeButton?.CloseFriendsListMenu();
+		}
+    }
+
+    public void SendStartWildDuelChallenge()
+    {
+		if (!m_bHasWildDeck)
+		{
+			FireNoWildDeckPopup();
+			m_challengeButton.CloseChallengeMenu();
+		}
+		else
+		{
+			FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
+			BnetPlayer player = m_challengeButton.GetPlayer();
+			FriendChallengeMgr.Get().SendChallenge(player, FormatType.FT_WILD, enableDeckShare: true);
+			m_challengeButton.CloseFriendsListMenu();
+		}
+    }
+
+	public void SendStartClassicDuelChallenge()
+    {
+		if (!m_bHasClassicDeck)
+		{
+			FireNoClassicDeckPopup();
+			m_challengeButton.CloseChallengeMenu();
+		}
+		else
+		{
+			FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
+			BnetPlayer player = m_challengeButton.GetPlayer();
+			FriendChallengeMgr.Get().SendChallenge(player, FormatType.FT_CLASSIC, enableDeckShare: true);
+			m_challengeButton.CloseFriendsListMenu();
+		}
+    }
+
+	public static void ClickVirtualChallengeButton(BnetPlayer player, FormatType format)
+    {
+		// Only used by accessibility when the menu isn't even open
+		if (!CollectionManager.Get().AccountHasValidDeck(format))
+        {
+			if (format == FormatType.FT_STANDARD)
+			{
+				FireNoStandardDeckPopup();
+			}
+			else if (format == FormatType.FT_CLASSIC)
+			{
+				FireNoClassicDeckPopup();
+			}
+			else
+			{
+				FireNoWildDeckPopup(); // Wild == all so good as a catch-all for players who might be using OCR for something else
+			}
+		}
+		else
+        {
+			SendFriendlyChallenge(player, format);
+        }
+    }
+
+    private static void FireNoStandardDeckPopup()
+    {
+        AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+        {
+            m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+            m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_STANDARD_DECK"),
+            m_showAlertIcon = true,
+            m_responseDisplay = AlertPopup.ResponseDisplay.OK
+        };
+        DialogManager.Get().ShowPopup(info);
+    }
+
+	private static void FireNoWildDeckPopup()
+	{
+		AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+		{
+			m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+			m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_DECK"),
+			m_showAlertIcon = true,
+			m_responseDisplay = AlertPopup.ResponseDisplay.OK
+		};
+		DialogManager.Get().ShowPopup(info);
+	}
+
+	private static void FireNoClassicDeckPopup()
+	{
+		AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+		{
+			m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+			m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_CLASSIC_DECK"),
+			m_showAlertIcon = true,
+			m_responseDisplay = AlertPopup.ResponseDisplay.OK
+		};
+		DialogManager.Get().ShowPopup(info);
+	}
+
+    private static void SendFriendlyChallenge(BnetPlayer player, FormatType format)
+    {
+        FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
+        FriendChallengeMgr.Get().SendChallenge(player, format, enableDeckShare: true);
+    }
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs b/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
index 022dbc0..acb78fe 100644
--- a/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
+++ b/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
@@ -147,7 +147,7 @@ public class FriendListFSGFrame : FriendListUIElement
 	private bool ShouldEnableEnterButton()
 	{
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
-		if (UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: false) != 0 || mode == SceneMgr.Mode.FIRESIDE_GATHERING)
+		if (UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: false) != 0 || mode == SceneMgr.Mode.FIRESIDE_GATHERING)
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/FriendListFrame.cs b/Decompiled/Assembly-CSharp/FriendListFrame.cs
index 0290d09..5cc5564 100644
--- a/Decompiled/Assembly-CSharp/FriendListFrame.cs
+++ b/Decompiled/Assembly-CSharp/FriendListFrame.cs
@@ -8,8 +8,9 @@ using Hearthstone.UI;
 using PegasusFSG;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class FriendListFrame : MonoBehaviour
+public class FriendListFrame : MonoBehaviour, AccessibleUI
 {
 	public enum FriendListEditMode
 	{
@@ -851,6 +852,8 @@ public class FriendListFrame : MonoBehaviour
 
 	private void Start()
 	{
+		m_curState = State.LOADING; // Important for handling added invites properly
+
 		UpdateMyself();
 		InitItems();
 		UpdateRAFState();
@@ -863,10 +866,14 @@ public class FriendListFrame : MonoBehaviour
 			this.OnStarted();
 		}
 		FatalErrorMgr.Get().AddErrorListener(OnFatalError);
+
+		ReadFriendsMenu();
 	}
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		UnregisterFriendEvents();
 		CloseAddFriendFrame();
 		if (m_longListBehavior != null && m_longListBehavior.FreeList != null)
@@ -997,12 +1004,20 @@ public class FriendListFrame : MonoBehaviour
 		{
 			m_addFriendFrame.SetPlayer(player);
 		}
+		AccessibilityMgr.AllowTextInput();
 	}
 
 	public void CloseAddFriendFrame()
 	{
+		AccessibilityMgr.DisallowTextInput();
+
 		if (!(m_addFriendFrame == null))
 		{
+			if (AccessibilityMgr.IsCurrentlyFocused(this) && m_addFriendFrame.gameObject.activeInHierarchy)
+			{
+				ReadFriendsMenu();
+			}
+
 			m_addFriendFrame.Close();
 			if (this.AddFriendFrameClosed != null)
 			{
@@ -1153,7 +1168,7 @@ public class FriendListFrame : MonoBehaviour
 		}
 	}
 
-	public void CloseFlyoutMenu()
+    public void CloseFlyoutMenu()
 	{
 		if (!(flyoutMenu == null))
 		{
@@ -1479,45 +1494,55 @@ public class FriendListFrame : MonoBehaviour
 		m_allItems.RemoveAll((FriendListItem item) => item.ItemMainType == MobileFriendListItem.TypeFlags.FiresideGatheringPlayer || item.ItemMainType == MobileFriendListItem.TypeFlags.FiresideGatheringFooter);
 	}
 
-	private void UpdateRequests(List<BnetInvitation> addedList, List<BnetInvitation> removedList)
+	private bool UpdateRequests(List<BnetInvitation> addedList, List<BnetInvitation> removedList)
 	{
+		var ret = false;
+
 		if (removedList == null && addedList == null)
 		{
-			return;
+			return false;
 		}
 		if (removedList != null)
 		{
 			foreach (BnetInvitation removed in removedList)
 			{
 				RemoveItem(isHeader: false, MobileFriendListItem.TypeFlags.Request, removed);
+				ret = true;
 			}
 		}
 		foreach (FriendListRequestFrame renderedItem in GetRenderedItems<FriendListRequestFrame>())
 		{
 			renderedItem.UpdateInvite();
 		}
+
 		if (addedList == null)
 		{
-			return;
+			return ret;
 		}
+
 		foreach (BnetInvitation added in addedList)
 		{
 			FriendListItem itemToAdd = new FriendListItem(isHeader: false, MobileFriendListItem.TypeFlags.Request, added);
 			AddItem(itemToAdd);
+			ret = true;
 		}
+
+		return ret;
 	}
 
-	private void UpdateAllFriends(List<BnetPlayer> addedList, List<BnetPlayer> removedList)
+	private bool UpdateAllFriends(List<BnetPlayer> addedList, List<BnetPlayer> removedList)
 	{
+		var ret = false;
 		if (removedList == null && addedList == null)
 		{
-			return;
+			return ret;
 		}
 		if (removedList != null)
 		{
 			foreach (BnetPlayer removed in removedList)
 			{
 				RemoveItem(isHeader: false, MobileFriendListItem.TypeFlags.Friend, removed);
+				ret = true;
 			}
 		}
 		UpdateFriendItems();
@@ -1530,10 +1555,13 @@ public class FriendListFrame : MonoBehaviour
 					added.GetPersistentGameId();
 					FriendListItem itemToAdd = new FriendListItem(isHeader: false, MobileFriendListItem.TypeFlags.Friend, added);
 					AddItem(itemToAdd);
+					ret = true;
 				}
 			}
 		}
 		SortAndRefreshTouchList();
+
+		return ret;
 	}
 
 	private void UpdateAllNearbyPlayers(List<BnetPlayer> addedList, List<BnetPlayer> removedList)
@@ -1669,14 +1697,7 @@ public class FriendListFrame : MonoBehaviour
 
 	private void UpdateNearbyPlayersHeader(FriendListItemHeader header = null)
 	{
-		int num = 0;
-		foreach (FriendListItem allItem in m_allItems)
-		{
-			if (allItem.ItemMainType == MobileFriendListItem.TypeFlags.NearbyPlayer && !FiresideGatheringManager.Get().IsPlayerInMyFSGAndDisplayable(allItem.GetNearbyPlayer()))
-			{
-				num++;
-			}
-		}
+		int num = GetNearbyPlayersCount();
 		string text = GameStrings.Format("GLOBAL_FRIENDLIST_NEARBY_PLAYERS_HEADER", num);
 		if (header == null)
 		{
@@ -1718,19 +1739,7 @@ public class FriendListFrame : MonoBehaviour
 
 	private void UpdateFriendsHeader(FriendListItemHeader header = null)
 	{
-		List<FriendListItem> friendItems = GetFriendItems();
-		int num = 0;
-		foreach (FriendListItem item in friendItems)
-		{
-			BnetPlayer friend = item.GetFriend();
-			if (friend.IsOnline() && !FiresideGatheringManager.Get().IsPlayerInMyFSGAndDisplayable(friend))
-			{
-				num++;
-			}
-		}
-		int count = friendItems.Count;
-		string text = null;
-		text = ((num != count) ? GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER", num, count) : GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER_ALL_ONLINE", num));
+		var text = GetFriendsHeaderText();
 		if (header == null)
 		{
 			header = FindOrAddHeader(MobileFriendListItem.TypeFlags.Friend);
@@ -1744,7 +1753,7 @@ public class FriendListFrame : MonoBehaviour
 		header.SetToggleEnabled(enabled: false);
 	}
 
-	private void UpdateHeaderBackground(FriendListItemHeader itemHeader)
+    private void UpdateHeaderBackground(FriendListItemHeader itemHeader)
 	{
 		if (itemHeader == null)
 		{
@@ -2118,16 +2127,21 @@ public class FriendListFrame : MonoBehaviour
 		NetCache.Get()?.RemoveUpdatedListener(typeof(FSGFeatureConfig), UpdateFSGState);
 	}
 
-	private void OnFriendsChanged(BnetFriendChangelist changelist, object userData)
+	internal void OnFriendsChanged(BnetFriendChangelist changelist, object userData)
 	{
 		SuspendItemsLayout();
-		UpdateRequests(changelist.GetAddedReceivedInvites(), changelist.GetRemovedReceivedInvites());
-		UpdateAllFriends(changelist.GetAddedFriends(), changelist.GetRemovedFriends());
+		var friendsChanged = UpdateRequests(changelist.GetAddedReceivedInvites(), changelist.GetRemovedReceivedInvites());
+		friendsChanged |= UpdateAllFriends(changelist.GetAddedFriends(), changelist.GetRemovedFriends());
 		UpdateAllHeaders();
 		ResumeItemsLayout();
 		SortAndRefreshTouchList();
 		UpdateAllHeaderBackgrounds();
 		UpdateSelectedItem();
+
+		if (friendsChanged)
+		{
+			ReadFriendsMenu();
+		}
 	}
 
 	private void OnNearbyPlayersChanged(BnetNearbyPlayerChangelist changelist, object userData)
@@ -2454,6 +2468,12 @@ public class FriendListFrame : MonoBehaviour
 		{
 			BnetFriendMgr.Get().RemoveFriend(m_friendToRemove);
 		}
+		else if (response == AlertPopup.Response.CANCEL)
+		{
+			AccessibilityMgr.HideUI(m_removeFriendPopup);
+			RereadRemoveFriendsList();
+		}
+
 		m_friendToRemove = null;
 		m_removeFriendPopup = null;
 		if (this.RemoveFriendPopupClosed != null)
@@ -2620,4 +2640,658 @@ public class FriendListFrame : MonoBehaviour
 			m_mySelectableMedalWidget.Show();
 		});
 	}
+
+	#region Accessibility
+
+	private enum State {
+		LOADING,
+		MAIN_MENU,
+		READING_FRIEND_INVITES,
+		READING_FRIEND_INVITE,
+		READING_PROFILE,
+		READING_FRIENDS_LIST,
+		CHALLENGING_FRIEND,
+		ADDING_FRIENDS,
+		REMOVING_FRIENDS,
+		INTERACTING_WITH_FRIEND,
+		READING_NEARBY_LIST,
+	}
+
+	private State m_curState;
+
+	private AccessibleMenu m_mainMenu;
+
+	private AccessibleMenu m_interactWithFriendMenu;
+
+	private AccessibleMenu m_challengeFriendMenu;
+
+	private AccessibleMenu m_handleRequestMenu;
+
+	private AccessibleListOfItems<AccessibleFriendListFriendFrame> m_accessibleFriends;
+
+	private AccessibleListOfItems<AccessibleFriendListRequestFrame> m_accessibleRequests;
+
+	private AccessiblePlayerProfile m_accessibleProfile;
+
+	private void ReadFriendsMenu()
+    {
+		if (m_flyoutOpen)
+        {
+			CloseFlyoutMenu();
+        }
+
+		m_curState = State.LOADING;
+
+		AccessibilityMgr.ShowUI(this);
+
+		m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_MENU_NAME), BnetBar.Get().m_friendButton.TriggerRelease);
+
+		if (DoesHeaderExist(MobileFriendListItem.TypeFlags.Request))
+        {
+            var requestsHeader = FindOrAddHeader(MobileFriendListItem.TypeFlags.Request);
+			m_mainMenu.AddOption(requestsHeader.m_Text.Text, ReadFriendRequests);
+        }
+
+		if (DoesHeaderExist(MobileFriendListItem.TypeFlags.NearbyPlayer) && GetNearbyPlayersCount() > 0)
+        {
+            var nearbyHeader = FindOrAddHeader(MobileFriendListItem.TypeFlags.NearbyPlayer);
+			m_mainMenu.AddOption(nearbyHeader.m_Text.Text, ReadNearbyList);
+        }
+
+		var numFriends = BnetFriendMgr.Get().GetFriendCount();
+		var haveFriends = numFriends > 0;
+		var friendlistIsFull = numFriends >= BnetFriendMgr.Get().GetMaxFriends();
+		var sentInvitesFull = BnetFriendMgr.Get().GetSentInvites().Count >= BnetFriendMgr.Get().GetMaxSentInvites();
+		var canAddFriends = !friendlistIsFull && !sentInvitesFull;
+
+		if (haveFriends && !AreAllFriendsNearby())
+        {
+            m_mainMenu.AddOption(GetFriendsHeaderText(false), ReadFriendsList);
+        }
+
+        m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_PROFILE_TITLE"), ReadProfile);
+
+		if (canAddFriends)
+        {
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_FRIEND_LIST_ADD_FRIENDS"), AddFriend);
+        }
+
+        if (haveFriends)
+        {
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_FRIEND_LIST_REMOVE_FRIENDS"), ReadRemoveFriendsMenu);
+        }
+
+		m_mainMenu.StartReading();
+
+		m_curState = State.MAIN_MENU;
+    }
+
+	private bool AreAllFriendsNearby()
+	{
+		var friends = BnetFriendMgr.Get().GetFriends();
+		foreach (var friend in friends)
+		{
+			if (!BnetNearbyPlayerMgr.Get().IsNearbyPlayer(friend))
+			{
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	private void AddFriend()
+    {
+		addFriendButton.TriggerRelease();
+    }
+
+    private void ReadRemoveFriendsMenu()
+    {
+		ReadRemoveFriendsList();
+    }
+
+    private void ReadRemoveFriendsList()
+    {
+		var friends = GetRenderedItems<FriendListFriendFrame>();
+
+		var accessibleFriends = new List<AccessibleFriendListFriendFrame>();
+
+		foreach(var friend in friends)
+        {
+			// Nearby "friends" aren't necessarily friends
+			if (BnetFriendMgr.Get().IsFriend(friend.GetFriend()))
+			{
+				accessibleFriends.Add(new AccessibleFriendListFriendFrame(this, friend));
+			}
+        }
+
+		m_accessibleFriends = new AccessibleListOfItems<AccessibleFriendListFriendFrame>(this, accessibleFriends);
+		m_accessibleFriends.StartReading();
+
+		if (m_accessibleFriends.Count == 0)
+		{
+			AccessibilityUtils.LogFatalError("ReadRemoveFriendsList() reached an empty list");
+			return;
+		}
+
+		m_curState = State.REMOVING_FRIENDS;
+    }
+
+    private void ReadFriendRequests()
+    {
+		var requests = GetRenderedItems<FriendListRequestFrame>();
+
+		var accessibleRequests = new List<AccessibleFriendListRequestFrame>();
+
+		foreach(var request in requests)
+        {
+			accessibleRequests.Add(new AccessibleFriendListRequestFrame(this, request));
+        }
+
+		m_accessibleRequests = new AccessibleListOfItems<AccessibleFriendListRequestFrame>(this, accessibleRequests);
+		RereadRequestsList();
+    }
+
+    private void RereadRequestsList()
+    {
+		m_accessibleRequests.StartReading();
+		m_curState = State.READING_FRIEND_INVITES;
+    }
+
+    private void ReadFriendsList()
+    {
+		var nearbyFriends = GetNearbyFriends();
+		var renderedFriends = GetRenderedItems<FriendListFriendFrame>();
+
+		var friends = new List<FriendListFriendFrame>();
+		foreach (var rf in renderedFriends)
+		{
+			if (!nearbyFriends.Contains(rf.GetFriend()))
+			{
+				friends.Add(rf);
+			}
+		}
+
+		var accessibleFriends = new List<AccessibleFriendListFriendFrame>();
+
+		foreach(var friend in friends)
+        {
+			accessibleFriends.Add(new AccessibleFriendListFriendFrame(this, friend));
+        }
+
+		m_accessibleFriends = new AccessibleListOfItems<AccessibleFriendListFriendFrame>(this, accessibleFriends);
+		m_accessibleFriends.StartReading();
+
+		if (m_accessibleFriends.Count == 0)
+		{
+			return;
+		}
+
+		m_curState = State.READING_FRIENDS_LIST;
+    }
+
+    private void RereadFriendsList()
+    {
+		if (m_accessibleFriends.Count == 0)
+		{
+			ReadFriendsMenu();
+			return;
+		}
+
+		m_accessibleFriends.StartReading();
+		m_curState = State.READING_FRIENDS_LIST;
+    }
+
+    private void RereadRemoveFriendsList()
+    {
+		if (m_accessibleFriends.Count == 0)
+		{
+			ReadFriendsMenu();
+			return;
+		}
+
+		m_accessibleFriends.StartReading();
+		m_curState = State.REMOVING_FRIENDS;
+    }
+
+    private void ReadNearbyList()
+    {
+		var nearbyFriends = GetNearbyFriends();
+		var renderedFriends = GetRenderedItems<FriendListFriendFrame>();
+
+		var nearbyPlayers = new List<FriendListFriendFrame>();
+		foreach (var rf in renderedFriends)
+		{
+			if (nearbyFriends.Contains(rf.GetFriend()))
+			{
+				nearbyPlayers.Add(rf);
+			}
+		}
+
+		var accessibleNearbyPlayers = new List<AccessibleFriendListFriendFrame>();
+
+		foreach(var player in nearbyPlayers)
+        {
+			accessibleNearbyPlayers.Add(new AccessibleFriendListFriendFrame(this, player));
+        }
+
+		m_accessibleFriends = new AccessibleListOfItems<AccessibleFriendListFriendFrame>(this, accessibleNearbyPlayers);
+		m_accessibleFriends.StartReading();
+
+		if (m_accessibleFriends.Count == 0)
+		{
+			return;
+		}
+
+		m_curState = State.READING_NEARBY_LIST;
+    }
+
+    private void RereadNearbyList()
+    {
+		if (m_accessibleFriends.Count == 0)
+		{
+			ReadFriendsMenu();
+			return;
+		}
+
+		m_accessibleFriends.StartReading();
+		m_curState = State.READING_NEARBY_LIST;
+    }
+
+    private void ReadProfile()
+    {
+		m_accessibleProfile = new AccessiblePlayerProfile(this, me);
+		m_accessibleProfile.ReadLine();
+		m_curState = State.READING_PROFILE;
+    }
+
+    private void OnDisable()
+    {
+		AccessibilityMgr.HideUI(this);
+    }
+
+    private string GetFriendsHeaderText(bool useXOfY=true)
+    {
+		List<FriendListItem> friendItems = GetFriendItems();
+		int num = 0;
+		foreach (FriendListItem item in friendItems)
+		{
+			BnetPlayer friend = item.GetFriend();
+			if (friend.IsOnline() && !FiresideGatheringManager.Get().IsPlayerInMyFSGAndDisplayable(friend))
+			{
+				num++;
+			}
+		}
+		int count = friendItems.Count;
+
+        return (useXOfY && num != count) ? GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER", num, count) : GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER_ALL_ONLINE", num);
+    }
+
+	private int GetNearbyPlayersCount()
+	{
+		int num = 0;
+		foreach (FriendListItem allItem in m_allItems)
+		{
+			if (allItem.ItemMainType == MobileFriendListItem.TypeFlags.NearbyPlayer && !FiresideGatheringManager.Get().IsPlayerInMyFSGAndDisplayable(allItem.GetNearbyPlayer()))
+			{
+				num++;
+			}
+		}
+		return num;
+	}
+
+	private List<FriendListItem> GetNearbyItems()
+	{
+		List<FriendListItem> list = new List<FriendListItem>();
+		foreach (FriendListItem allItem in m_allItems)
+		{
+			if (allItem.ItemMainType == MobileFriendListItem.TypeFlags.NearbyPlayer)
+			{
+				list.Add(allItem);
+			}
+		}
+		return list;
+	}
+
+	private List<BnetPlayer> GetNearbyFriends()
+	{
+		var ret = new List<BnetPlayer>();
+
+		var nearbyItems = GetNearbyItems();
+
+		foreach (var item in nearbyItems)
+		{
+			ret.Add(item.GetNearbyPlayer());
+		}
+
+		return ret;
+	}
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_mainMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_FRIENDS_LIST)
+        {
+            var curFriend = m_accessibleFriends.GetItemBeingRead().GetFriendListFriendFrame();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				if (m_accessibleFriends.Count == 0)
+				{
+					m_accessibleFriends.StartReading();
+				}
+				else
+				{
+					InteractWithFriend(curFriend);
+				}
+			}
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleFriends?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.CHALLENGING_FRIEND)
+		{
+			m_challengeFriendMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_NEARBY_LIST)
+        {
+            var curPlayer = m_accessibleFriends.GetItemBeingRead().GetFriendListFriendFrame();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				if (m_accessibleFriends.Count == 0)
+				{
+					m_accessibleFriends.StartReading();
+				}
+				else
+				{
+					InteractWithNearbyPlayer(curPlayer);
+				}
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleFriends?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.REMOVING_FRIENDS)
+        {
+            var curFriend = m_accessibleFriends.GetItemBeingRead().GetFriendListFriendFrame();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				curFriend.OnDeleteFriendButtonPressed();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleFriends?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.READING_PROFILE)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_accessibleProfile.CopyBattleTagToClipboard();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleProfile?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.INTERACTING_WITH_FRIEND)
+        {
+			m_interactWithFriendMenu?.HandleAccessibleInput();
+        }
+		else if (m_curState == State.READING_FRIEND_INVITES)
+        {
+            var curRequest = m_accessibleRequests.GetItemBeingRead().GetFriendListRequestFrame();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				ReadFriendInvite(curRequest);
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleRequests?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.READING_FRIEND_INVITE)
+		{
+			m_handleRequestMenu?.HandleAccessibleInput();
+		}
+    }
+
+	private void InteractWithFriend(FriendListFriendFrame curFriend)
+    {
+		InteractWithFriendOrNearbyPlayer(curFriend, RereadFriendsList);
+    }
+
+	private void InteractWithNearbyPlayer(FriendListFriendFrame curPlayer)
+    {
+		InteractWithFriendOrNearbyPlayer(curPlayer, RereadNearbyList);
+    }
+
+	private void InteractWithFriendOrNearbyPlayer(FriendListFriendFrame curFriend, Action goBackAction)
+    {
+		m_interactWithFriendMenu = new AccessibleMenu(this, "", goBackAction);
+
+		if (BnetFriendMgr.Get().IsFriend(curFriend.GetFriend()))
+		{
+			// Nearby "friends" aren't necessarily friends and you can't challenge them
+			SetupInteractWithFriendMenu(m_interactWithFriendMenu, curFriend);
+		}
+		else
+		{
+			SetupInteractWithNearbyPlayerMenu(m_interactWithFriendMenu, curFriend);
+		}
+
+        m_interactWithFriendMenu.StartReading();
+
+		m_curState = State.INTERACTING_WITH_FRIEND;
+    }
+
+	private void SetupInteractWithNearbyPlayerMenu(AccessibleMenu friendMenu, FriendListFriendFrame player)
+	{
+		friendMenu.AddOption(GameStrings.Get("GLOBAL_ADDFRIEND_BUTTON"), () => AddNearbyPlayerAsFriend(player));
+	}
+
+	private void AddNearbyPlayerAsFriend(FriendListFriendFrame player)
+	{
+		var bnetPlayer = player.GetFriend();
+
+		if (bnetPlayer.IsCheatPlayer)
+		{
+			string message = GameStrings.Get("GLOBAL_ADDFRIEND_SENT_CONFIRMATION");
+			UIStatus.Get().AddInfo(message);
+			return;
+		}
+		else
+		{
+			BnetFriendMgr.Get().SendInvite(bnetPlayer.GetBattleTag().GetString());
+		}
+	}
+
+	private void SetupInteractWithFriendMenu(AccessibleMenu friendMenu, FriendListFriendFrame friend)
+	{
+		if (GameUtils.IsTraditionalTutorialComplete())
+		{
+			var challengeFriendButton = friend.m_challengeButton;
+
+			var dataModel = challengeFriendButton.GetChallengeButtonDataModel();
+
+			switch (dataModel.state)
+			{
+				case FriendListChallengeButton.ChallengeButtonState.CHALLENGE:
+					friendMenu.AddOption(GameStrings.Get("GLOBAL_CHAT_CHALLENGE"), () => ChallengeFriend(friend));
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.CANNOT_INTERACT:
+					friendMenu.AddOption(GameStrings.Get("GLOBAL_CHAT_CHALLENGE"), () => ClickFriendChallengeButton(friend));
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.SPECTATE:
+				case FriendListChallengeButton.ChallengeButtonState.INVITED_PLAYER_TO_SPECTATE: // Doesn't really matter since it's just text
+					friendMenu.AddOption(GameStrings.Get("GLOBAL_SPECTATE"), () => ClickFriendChallengeButton(friend));
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.KICK_SPECTATOR:
+					friendMenu.AddOption(challengeFriendButton.FormatBodytext(dataModel.text2), () => ClickFriendChallengeButton(friend)); // meh
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.REVEAL_CARDS_TO_OPPONENT_SPECTATOR:
+					friendMenu.AddOption(challengeFriendButton.FormatBodytext(dataModel.text2), () => ClickFriendChallengeButton(friend)); // meh
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.INVITE_PLAYER_TO_SPECTATE:
+					friendMenu.AddOption(challengeFriendButton.FormatBodytext(dataModel.text2), () => ClickFriendChallengeButton(friend));
+					break;
+				default:
+					AccessibilityUtils.LogFatalError($"FriendListFrame.InteractWithFriend() reached unknown state: {dataModel.state}");
+					friendMenu.AddOption(GameStrings.Get("GLOBAL_CHAT_CHALLENGE"), () => ClickFriendChallengeButton(friend));
+					break;
+			}
+		}
+
+		friendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_CHAT_SEND_MESSAGE), () => friend.OpenChatWithFriend());
+	}
+
+	private void ReadFriendInvite(FriendListRequestFrame curRequest)
+	{
+		m_handleRequestMenu = new AccessibleMenu(this, "", RereadRequestsList);
+
+		var acceptRequestButton = curRequest.m_AcceptButton;
+		var declineRequestButton = curRequest.m_DeclineButton;
+
+		m_handleRequestMenu.AddOption(GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_ACCEPT"), acceptRequestButton.TriggerRelease);
+		m_handleRequestMenu.AddOption(GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_DECLINE"), declineRequestButton.TriggerRelease);
+
+        m_handleRequestMenu.StartReading();
+
+		m_curState = State.READING_FRIEND_INVITE;
+	}
+
+    private void ChallengeFriend(FriendListFriendFrame curFriend)
+    {
+		var challengeFriendButton = curFriend.m_challengeButton;
+		var dataModel = challengeFriendButton.GetChallengeButtonDataModel();
+
+		if (!dataModel.canClickButton)
+        {
+			AccessibilityUtils.LogDebug($"ChallengeFriend canClickButton=false");
+			var text = challengeFriendButton.FormatBodytext(dataModel.text2);
+			AccessibilityMgr.Output(this, text);
+        }
+		else
+        {
+			SetupChallengeFriendMenu(curFriend);
+        }
+    }
+
+	private void SetupChallengeFriendMenu(FriendListFriendFrame curFriend)
+	{
+		m_challengeFriendMenu = new AccessibleMenu(this, "", RereadFriendsList);
+
+		AccessibilityUtils.LogDebug($"SetupChallengeFriendMenu");
+
+		m_challengeFriendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_STANDARD), () => ClickVirtualChallengeButton(curFriend, FormatType.FT_STANDARD));
+
+		if (CollectionManager.Get().ShouldAccountSeeStandardWild())
+		{
+			m_challengeFriendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_WILD), () => ClickVirtualChallengeButton(curFriend, FormatType.FT_WILD));
+			m_challengeFriendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_CLASSIC), () => ClickVirtualChallengeButton(curFriend, FormatType.FT_CLASSIC));
+		}
+
+		m_challengeFriendMenu.StartReading();
+		m_curState = State.CHALLENGING_FRIEND;
+	}
+
+	private void ClickVirtualChallengeButton(FriendListFriendFrame friend, FormatType format)
+	{
+		var challengeFriendButton = friend.m_challengeButton;
+
+		FriendListChallengeMenu.ClickVirtualChallengeButton(friend.GetFriend(), format);
+
+		challengeFriendButton.CloseFriendsListMenu();
+	}
+
+	private void ClickFriendChallengeButton(FriendListFriendFrame curFriend)
+    {
+		var challengeFriendButton = curFriend.m_challengeButton;
+		var dataModel = challengeFriendButton.GetChallengeButtonDataModel();
+		var challengeFriendButtonClickable = curFriend.m_challengeButtonClickable;
+
+		if (!dataModel.canClickButton)
+        {
+			AccessibilityUtils.LogDebug($"ClickFriendChallengeButton canClickButton=true");
+			var text = challengeFriendButton.FormatBodytext(dataModel.text2);
+			AccessibilityMgr.Output(this, text);
+        }
+		else
+        {
+			AccessibilityUtils.LogDebug($"ClickFriendChallengeButton canClickButton=false");
+			challengeFriendButtonClickable?.GetPegUIElement()?.TriggerRelease();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_curState == State.MAIN_MENU)
+		{
+			return m_mainMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_FRIENDS_LIST)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+		}
+		else if (m_curState == State.READING_NEARBY_LIST)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+		}
+		else if (m_curState == State.REMOVING_FRIENDS)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+        }
+		else if (m_curState == State.READING_PROFILE)
+        {
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+        }
+		else if (m_curState == State.INTERACTING_WITH_FRIEND)
+        {
+			return m_interactWithFriendMenu?.GetHelp();
+        }
+		else if (m_curState == State.CHALLENGING_FRIEND)
+		{
+			return m_interactWithFriendMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_FRIEND_INVITES)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+        }
+		else if (m_curState == State.READING_FRIEND_INVITE)
+		{
+			return m_handleRequestMenu?.GetHelp();
+		}
+
+		return "";
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FriendListFriendFrame.cs b/Decompiled/Assembly-CSharp/FriendListFriendFrame.cs
index 254b713..b28db2b 100644
--- a/Decompiled/Assembly-CSharp/FriendListFriendFrame.cs
+++ b/Decompiled/Assembly-CSharp/FriendListFriendFrame.cs
@@ -22,15 +22,15 @@ public class FriendListFriendFrame : MonoBehaviour
 
 	private Clickable m_clickable;
 
-	private FriendListChallengeButton m_challengeButton;
+	internal FriendListChallengeButton m_challengeButton;
 
 	private VisualController m_challengeButtonVisualController;
 
-	private Clickable m_challengeButtonClickable;
+	internal Clickable m_challengeButtonClickable;
 
 	private BnetPlayer m_player;
 
-	private MedalInfoTranslator m_rankedMedalInfo;
+	internal MedalInfoTranslator m_rankedMedalInfo;
 
 	private SelectableMedal m_selectableMedal;
 
@@ -38,7 +38,7 @@ public class FriendListFriendFrame : MonoBehaviour
 
 	private bool m_isRankedDataModelUpdatePending;
 
-	private FriendDataModel m_friendDataModel;
+	internal FriendDataModel m_friendDataModel;
 
 	private Coroutine m_friendUpdateCoroutine;
 
@@ -221,14 +221,7 @@ public class FriendListFriendFrame : MonoBehaviour
 
 	private void OnFriendFrameReleased(UIEvent e)
 	{
-		if (!ChatMgr.Get().FriendListFrame.IsInEditMode)
-		{
-			FriendMgr.Get().SetSelectedFriend(m_player);
-			if (BnetFriendMgr.Get().IsFriend(m_player.GetAccountId()))
-			{
-				ChatMgr.Get().OnFriendListFriendSelected(m_player);
-			}
-		}
+		OpenChatWithFriend();
 	}
 
 	private void OnAvailableButtonPressed()
@@ -243,7 +236,7 @@ public class FriendListFriendFrame : MonoBehaviour
 		}
 	}
 
-	private void OnDeleteFriendButtonPressed()
+	internal void OnDeleteFriendButtonPressed()
 	{
 		ChatMgr.Get().FriendListFrame.ShowRemoveFriendPopup(m_player);
 	}
@@ -560,4 +553,19 @@ public class FriendListFriendFrame : MonoBehaviour
 	{
 		UpdateInteractionState();
 	}
+
+	#region Accessibility
+	internal void OpenChatWithFriend()
+	{
+		if (!ChatMgr.Get().FriendListFrame.IsInEditMode)
+		{
+			FriendMgr.Get().SetSelectedFriend(m_player);
+			if (BnetFriendMgr.Get().IsFriend(m_player.GetAccountId()))
+			{
+				ChatMgr.Get().OnFriendListFriendSelected(m_player);
+			}
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FriendListRequestFrame.cs b/Decompiled/Assembly-CSharp/FriendListRequestFrame.cs
index 5326e4b..b343821 100644
--- a/Decompiled/Assembly-CSharp/FriendListRequestFrame.cs
+++ b/Decompiled/Assembly-CSharp/FriendListRequestFrame.cs
@@ -61,11 +61,23 @@ public class FriendListRequestFrame : MonoBehaviour
 
 	private void OnAcceptButtonPressed(UIEvent e)
 	{
+		if (m_invite.m_isCheatInvite)
+		{
+			BnetFriendMgr.Get().Cheat_AcceptInvite(m_invite.GetId());
+			return;
+		}
+
 		BnetFriendMgr.Get().AcceptInvite(m_invite.GetId());
 	}
 
 	private void OnDeclineButtonPressed(UIEvent e)
 	{
+		if (m_invite.m_isCheatInvite)
+		{
+			BnetFriendMgr.Get().Cheat_DeclineInvite(m_invite.GetId());
+			return;
+		}
+
 		BnetFriendMgr.Get().IgnoreInvite(m_invite.GetId());
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs b/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
index 06db697..683674e 100644
--- a/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
+++ b/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
@@ -1,5 +1,6 @@
 using System;
 using System.Collections;
+using Accessibility;
 using bgs;
 using Hearthstone.Core;
 using Hearthstone.DataModels;
@@ -86,6 +87,8 @@ public class FriendlyChallengeDialog : DialogBase
 				SoundManager.Get().LoadAndPlay(m_friendQuestSliderSound2);
 			});
 		}
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -274,4 +277,32 @@ public class FriendlyChallengeDialog : DialogBase
 			m_friendlyQuestFrame.m_rewardMesh.gameObject.SetActive(value: false);
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadPopup()
+	{
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, $"{m_challengeText.Text} {m_challengerName.Text}");
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null);
+		m_accessibleMenu.AddOption(m_acceptButton.GetText(), m_acceptButton.TriggerRelease);
+		m_accessibleMenu.AddOption(m_denyButton.GetText(), m_denyButton.TriggerRelease);
+		m_accessibleMenu.StartReading();
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GAME_TAG.cs b/Decompiled/Assembly-CSharp/GAME_TAG.cs
index 69066d3..6953bf7 100644
--- a/Decompiled/Assembly-CSharp/GAME_TAG.cs
+++ b/Decompiled/Assembly-CSharp/GAME_TAG.cs
@@ -665,5 +665,6 @@ public enum GAME_TAG
 	LETTUCE_SHOW_OPPOSING_FAKE_HAND = 2224,
 	LETTUCE_VERSUS_SPELL_STATE = 2228,
 	LETTUCE_START_OF_GAME_ABILITY = 2241,
-	LETTUCE_CURSED_ABILITY_VISUAL = 2381
+	LETTUCE_CURSED_ABILITY_VISUAL = 2381,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/Game/PackOpening/HiddenCards.cs b/Decompiled/Assembly-CSharp/Game/PackOpening/HiddenCards.cs
index 5c71b0f..276b10e 100644
--- a/Decompiled/Assembly-CSharp/Game/PackOpening/HiddenCards.cs
+++ b/Decompiled/Assembly-CSharp/Game/PackOpening/HiddenCards.cs
@@ -11,7 +11,7 @@ namespace Game.PackOpening
 {
 	public class HiddenCards
 	{
-		private readonly List<PackOpeningCard> m_cards = new List<PackOpeningCard>();
+		internal readonly List<PackOpeningCard> m_cards = new List<PackOpeningCard>();
 
 		public event EventHandler OnCardRevealedEvent;
 
diff --git a/Decompiled/Assembly-CSharp/GameEntity.cs b/Decompiled/Assembly-CSharp/GameEntity.cs
index e6cebf1..3e93ba4 100644
--- a/Decompiled/Assembly-CSharp/GameEntity.cs
+++ b/Decompiled/Assembly-CSharp/GameEntity.cs
@@ -1537,4 +1537,13 @@ public class GameEntity : Entity
 		isInZone = false;
 		return false;
 	}
+
+    #region Turn Counter missions
+
+    public virtual bool IsTurnCounterBasedMission()
+    {
+		return false;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMenu.cs b/Decompiled/Assembly-CSharp/GameMenu.cs
index beab2cd..b5759a5 100644
--- a/Decompiled/Assembly-CSharp/GameMenu.cs
+++ b/Decompiled/Assembly-CSharp/GameMenu.cs
@@ -3,9 +3,11 @@ using bgs;
 using Hearthstone;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class GameMenu : ButtonListMenu, GameMenuInterface
+public class GameMenu : ButtonListMenu, GameMenuInterface, AccessibleUI
 {
 	[CustomEditField(Sections = "Template Items")]
 	public Vector3 m_ratingsObjectMinPadding = new Vector3(0f, 0f, -0.06f);
@@ -79,22 +81,22 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		ButtonListMenu.MakeButtonRed(m_endGameButton, m_redButtonMaterial);
 		m_leaveButton = CreateMenuButton("LeaveButton", "GLOBAL_LEAVE_SPECTATOR_MODE", LeaveButtonPressed);
 		m_restartButton = CreateMenuButton("RestartButton", "GLOBAL_RESTART", RestartButtonPressed);
-		if ((bool)HearthstoneApplication.CanQuitGame)
-		{
-			m_quitButton = CreateMenuButton("QuitButton", "GLOBAL_QUIT", QuitButtonPressed);
-		}
 		if (PlatformSettings.IsMobile())
 		{
 			m_loginButton = CreateMenuButton("LogoutButton", Network.ShouldBeConnectedToAurora() ? "GLOBAL_SWITCH_ACCOUNT" : "GLOBAL_LOGIN", LogoutButtonPressed);
 		}
+		if (m_menu.m_templateSignUpButton != null)
+		{
+			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+		}
 		m_optionsButton = CreateMenuButton("OptionsButton", "GLOBAL_OPTIONS", OptionsButtonPressed);
 		if (m_menu.m_templateDownloadButton != null)
 		{
 			m_downloadButton = CreateMenuButton("AssetDownloadButton", "GLOBAL_ASSET_DOWNLOAD", AssetDownloadButtonPressed, m_menu.m_templateDownloadButton);
 		}
-		if (m_menu.m_templateSignUpButton != null)
+		if ((bool)HearthstoneApplication.CanQuitGame)
 		{
-			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+			m_quitButton = CreateMenuButton("QuitButton", "GLOBAL_QUIT", QuitButtonPressed);
 		}
 		m_menu.m_headerText.Text = GameStrings.Get("GLOBAL_GAME_MENU");
 		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
@@ -171,6 +173,8 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		ShowCursorIfNeeded();
 		ShowLoginTooltipIfNeeded();
 		BnetBar.Get().m_menuButton.SetSelected(enable: true);
+
+		ReadMenu();
 	}
 
 	public override void Hide()
@@ -178,7 +182,13 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		base.Hide();
 		HideLoginTooltip();
 		BnetBar.Get().m_menuButton.SetSelected(enable: false);
-	}
+
+		if (!m_gameMenuBase.TransitioningToOptionsMenu)
+        {
+			// Don't hide when transitioning as we would just regain + lose focus on the main menu screen instantly (causing us to start reading it)
+            AccessibilityMgr.HideUI(this);
+        }
+    }
 
 	public void ShowCursorIfNeeded()
 	{
@@ -507,4 +517,41 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 			}
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadMenu()
+    {
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GAME_MENU_TITLE, CloseMainMenu, true);
+
+		foreach (var btn in m_allButtons)
+        {
+			if (btn.gameObject.activeInHierarchy && btn.IsEnabled())
+            {
+                m_accessibleMenu.AddOption(btn.GetText(), () => btn.TriggerRelease());
+            }
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleMenu.StartReading();
+    }
+
+    public void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    private void CloseMainMenu()
+    {
+		BnetBar.Get().HideGameMenu();
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMenuBase.cs b/Decompiled/Assembly-CSharp/GameMenuBase.cs
index f436c1b..64fc087 100644
--- a/Decompiled/Assembly-CSharp/GameMenuBase.cs
+++ b/Decompiled/Assembly-CSharp/GameMenuBase.cs
@@ -18,7 +18,9 @@ public class GameMenuBase
 
 	public void ShowOptionsMenu()
 	{
-		if (m_hideCallback != null)
+        TransitioningToOptionsMenu = true;
+
+        if (m_hideCallback != null)
 		{
 			m_hideCallback();
 		}
@@ -35,9 +37,11 @@ public class GameMenuBase
 		{
 			SwitchToOptionsMenu();
 		}
-	}
 
-	public void DestroyOptionsMenu()
+        TransitioningToOptionsMenu = false;
+    }
+
+    public void DestroyOptionsMenu()
 	{
 		if (m_optionsMenu != null)
 		{
@@ -74,4 +78,8 @@ public class GameMenuBase
 			m_showCallback();
 		}
 	}
+
+	#region Accessibility
+	internal bool TransitioningToOptionsMenu { get; set; }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMgr.cs b/Decompiled/Assembly-CSharp/GameMgr.cs
index 8c00904..696704d 100644
--- a/Decompiled/Assembly-CSharp/GameMgr.cs
+++ b/Decompiled/Assembly-CSharp/GameMgr.cs
@@ -14,6 +14,7 @@ using PegasusShared;
 using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 public class GameMgr : IService
 {
@@ -677,22 +678,64 @@ public class GameMgr : IService
 		switch (m_missionId)
 		{
 		case 3:
-			gameEntity = new Tutorial_01();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_01();
+            }
+            else
+            {
+                gameEntity = new Tutorial_01();
+            }
 			break;
 		case 4:
-			gameEntity = new Tutorial_02();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_02();
+            }
+            else
+            {
+                gameEntity = new Tutorial_02();
+            }
 			break;
 		case 181:
-			gameEntity = new Tutorial_03();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_03();
+            }
+            else
+            {
+                gameEntity = new Tutorial_03();
+            }
 			break;
 		case 201:
-			gameEntity = new Tutorial_04();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_04();
+            }
+            else
+            {
+                gameEntity = new Tutorial_04();
+            }
 			break;
 		case 248:
-			gameEntity = new Tutorial_05();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_05();
+            }
+            else
+            {
+                gameEntity = new Tutorial_05();
+            }
 			break;
 		case 249:
-			gameEntity = new Tutorial_06();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_06();
+            }
+            else
+            {
+                gameEntity = new Tutorial_06();
+            }
 			break;
 		case 273:
 		case 300:
@@ -2407,7 +2450,7 @@ public class GameMgr : IService
 			{
 				presenceMgr.SetStatus(Global.PresenceStatus.SPECTATING_GAME_TUTORIAL);
 			}
-			else if (IsBattlegrounds() || m_missionId == 3539)
+			else if (IsPlayingBattlegrounds())
 			{
 				PresenceMgr.Get().SetStatus(Global.PresenceStatus.SPECTATING_GAME_BATTLEGROUNDS);
 			}
@@ -3259,4 +3302,13 @@ public class GameMgr : IService
 		m_gameSetup = null;
 		m_lastDisplayedPlayerNames.Clear();
 	}
+
+	#region Accessibility
+
+	internal bool IsPlayingBattlegrounds()
+	{
+		return IsBattlegrounds() || m_missionId == 3539;
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameModeDisplay.cs b/Decompiled/Assembly-CSharp/GameModeDisplay.cs
index fca9703..f91efc2 100644
--- a/Decompiled/Assembly-CSharp/GameModeDisplay.cs
+++ b/Decompiled/Assembly-CSharp/GameModeDisplay.cs
@@ -4,6 +4,7 @@ using System.Linq;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class GameModeDisplay : MonoBehaviour
 {
@@ -29,9 +30,9 @@ public class GameModeDisplay : MonoBehaviour
 
 	public List<string> m_tavernBrawlEnterCrowdSounds;
 
-	private PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
-	private UIBButton m_backButton;
+	internal UIBButton m_backButton;
 
 	private bool m_playButtonFinishedLoading;
 
@@ -226,6 +227,8 @@ public class GameModeDisplay : MonoBehaviour
 				IsBeta = isBeta
 			});
 		}
+
+		AccessibleGameModeScene.Get().OnDisplayReady(gameModeSceneDataModel);
 	}
 
 	private bool ShouldShowNewBanner(GameModeDbfRecord gameModeRecord)
@@ -242,7 +245,7 @@ public class GameModeDisplay : MonoBehaviour
 		switch (EnumUtils.Parse<SceneMgr.Mode>(gameModeRecord.LinkedScene))
 		{
 		case SceneMgr.Mode.TAVERN_BRAWL:
-			if (UserAttentionManager.CanShowAttentionGrabber("Hub.TavernBrawl.IsFirstTimeSeeingCurrentSeason") && ShouldSeeNewTavernBrawlBanner())
+			if (UserAttentionManager.CanShowAttentionGrabber(false, "Hub.TavernBrawl.IsFirstTimeSeeingCurrentSeason") && ShouldSeeNewTavernBrawlBanner())
 			{
 				s_hasAlreadyShownTavernBrawlNewBanner = true;
 				return true;
@@ -418,6 +421,12 @@ public class GameModeDisplay : MonoBehaviour
 
 	public static bool ShouldSeeNewTavernBrawlBanner()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Not implemented yet
+			return false;
+		}
+
 		if (s_hasAlreadyShownTavernBrawlNewBanner)
 		{
 			return false;
@@ -461,26 +470,11 @@ public class GameModeDisplay : MonoBehaviour
 			return;
 		}
 		m_selectedGameModeButtonDataModel = (GameModeButtonDataModel)eventDataModel.Payload;
-		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.GAME_MODE_SCENE, GameSaveKeySubkeyId.GAME_MODE_SCENE_LAST_SELECTED_GAME_MODE, m_selectedGameModeButtonDataModel.GameModeRecordId));
-		GameModeSceneDataModel gameModeSceneDataModel = GetGameModeSceneDataModel();
-		if (gameModeSceneDataModel != null)
-		{
-			gameModeSceneDataModel.LastSelectedGameModeRecordId = m_selectedGameModeButtonDataModel.GameModeRecordId;
-		}
-		if (!CanEnterMode(out var reason))
-		{
-			m_playButton.Disable(keepLabelTextVisible: true);
-			m_lockedNameText.Text = GameStrings.Format(reason, m_selectedGameModeButtonDataModel.Name);
-			m_gameModeButtonController.SetState("GAME_MODE_LOCKED");
-		}
-		else
-		{
-			m_playButton.Enable();
-			m_gameModeButtonController.SetState("GAME_MODE_ACTIVE");
-		}
+
+		OnGameModeSelectedPart2();
 	}
 
-	private void ShowDisabledPopupForCurrentMode(string lockReason)
+    private void ShowDisabledPopupForCurrentMode(string lockReason)
 	{
 		if (!string.IsNullOrEmpty(lockReason))
 		{
@@ -504,4 +498,34 @@ public class GameModeDisplay : MonoBehaviour
 		};
 		DialogManager.Get().ShowPopup(info);
 	}
+
+	#region Accessibility
+	internal void SelectMode(GameModeButtonDataModel gameModeButtonDataModel)
+    {
+		m_selectedGameModeButtonDataModel = gameModeButtonDataModel;
+		OnGameModeSelectedPart2();
+    } 
+
+    private void OnGameModeSelectedPart2()
+    {
+		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.GAME_MODE_SCENE, GameSaveKeySubkeyId.GAME_MODE_SCENE_LAST_SELECTED_GAME_MODE, m_selectedGameModeButtonDataModel.GameModeRecordId));
+		GameModeSceneDataModel gameModeSceneDataModel = GetGameModeSceneDataModel();
+		if (gameModeSceneDataModel != null)
+		{
+			gameModeSceneDataModel.LastSelectedGameModeRecordId = m_selectedGameModeButtonDataModel.GameModeRecordId;
+		}
+		if (!CanEnterMode(out var reason))
+		{
+			m_playButton.Disable(keepLabelTextVisible: true);
+			m_lockedNameText.Text = GameStrings.Format(reason, m_selectedGameModeButtonDataModel.Name);
+			m_gameModeButtonController.SetState("GAME_MODE_LOCKED");
+		}
+		else
+		{
+			m_playButton.Enable();
+			m_gameModeButtonController.SetState("GAME_MODE_ACTIVE");
+		}
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameModeUtils.cs b/Decompiled/Assembly-CSharp/GameModeUtils.cs
index 1263ae0..57b6811 100644
--- a/Decompiled/Assembly-CSharp/GameModeUtils.cs
+++ b/Decompiled/Assembly-CSharp/GameModeUtils.cs
@@ -4,6 +4,8 @@ public static class GameModeUtils
 {
 	public static bool CanAccessGameModes()
 	{
+		return true;
+
 		if (!AchieveManager.Get().HasUnlockedDefaultHeroes())
 		{
 			return TavernBrawlManager.Get().HasUnlockedTavernBrawl(BrawlType.BRAWL_TYPE_TAVERN_BRAWL);
@@ -13,6 +15,8 @@ public static class GameModeUtils
 
 	public static bool ShouldSeeSoloAdventuresMovedPopup()
 	{
+		return false;
+
 		GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.FTUE_SHOULD_SEE_SOLO_ADVENTURES_MOVED_POPUP, out long value);
 		return value > 0;
 	}
diff --git a/Decompiled/Assembly-CSharp/GameState.cs b/Decompiled/Assembly-CSharp/GameState.cs
index ac0292f..86149cb 100644
--- a/Decompiled/Assembly-CSharp/GameState.cs
+++ b/Decompiled/Assembly-CSharp/GameState.cs
@@ -10,6 +10,7 @@ using Assets;
 using Cysharp.Threading.Tasks;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class GameState
 {
@@ -19,14 +20,16 @@ public class GameState
 		OPTION,
 		SUB_OPTION,
 		OPTION_TARGET,
-		CHOICE
+		CHOICE,
+		EOE
 	}
 
 	public enum CreateGamePhase
 	{
 		INVALID,
 		CREATING,
-		CREATED
+		CREATED,
+		EOE
 	}
 
 	public delegate void GameStateInitializedCallback(GameState instance, object userData);
@@ -1492,6 +1495,12 @@ public class GameState
 
 	public bool CanShowScoreScreen()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            // The modes that use this screen are not implemented yet
+            return false;
+        }
+
 		if (HasScoreLabels(m_gameEntity))
 		{
 			return true;
@@ -1910,6 +1919,14 @@ public class GameState
 		{
 			return false;
 		}
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePowerTaskListDescriber.Get().IsBusy())
+        {
+			return false;
+        }
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePlayDescriber.Get().IsBusy())
+        {
+			return false;
+        }
 		return true;
 	}
 
@@ -2592,6 +2609,7 @@ public class GameState
 
 	private void FireCreateGameEvent()
 	{
+		AccessiblePowerTaskListDescriber.Get().OnGameStart();
 		CreateGameListener[] array = m_createGameListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
@@ -4384,6 +4402,7 @@ public class GameState
 				m_createGameListeners.Clear();
 			}
 		}
+		taskList.FireCompleteEvent();
 		RemoveQueuedEntitiesFromGame();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/GameStringTable.cs b/Decompiled/Assembly-CSharp/GameStringTable.cs
index 8772c8b..8dfabe8 100644
--- a/Decompiled/Assembly-CSharp/GameStringTable.cs
+++ b/Decompiled/Assembly-CSharp/GameStringTable.cs
@@ -83,7 +83,7 @@ public class GameStringTable
 		return true;
 	}
 
-	public string Get(string key)
+    public string Get(string key)
 	{
 		m_table.TryGetValue(key, out var value);
 		return value;
diff --git a/Decompiled/Assembly-CSharp/GameStrings.cs b/Decompiled/Assembly-CSharp/GameStrings.cs
index d6df141..f29dbc4 100644
--- a/Decompiled/Assembly-CSharp/GameStrings.cs
+++ b/Decompiled/Assembly-CSharp/GameStrings.cs
@@ -937,6 +937,8 @@ public class GameStrings
 		}
 		float realtimeSinceStartup2 = Time.realtimeSinceStartup;
 		Log.Performance.Print($"Loading All GameStrings took {realtimeSinceStartup2 - realtimeSinceStartup}s)");
+
+		DefaultGameStrings.LoadAll(); // Accessibility
 	}
 
 	public static IEnumerator<IAsyncJobResult> Job_LoadAll()
@@ -947,7 +949,12 @@ public class GameStrings
 			if (value != 0)
 			{
 				jobResultCollection.Add(CreateLoadCategoryJob(value, native: false));
-			}
+
+				if (value == Global.GameStringCategory.ACCESSIBILITY)
+                {
+                    jobResultCollection.Add(DefaultGameStrings.CreateLoadCategoryJob(value, native: false));
+                }
+            }
 		}
 		yield return jobResultCollection;
 	}
@@ -993,6 +1000,7 @@ public class GameStrings
 	public static void LoadNative()
 	{
 		ReloadAllInternal(native: true);
+		DefaultGameStrings.LoadNative();
 	}
 
 	public static string GetAssetPath(Locale locale, string fileName, bool native = false)
@@ -2046,4 +2054,31 @@ public class GameStrings
 			return 1;
 		}
 	}
+
+	#region Accessibility - Used for regression testing
+
+	public static List<string> FindKeysWithValue(string value)
+	{
+		var ret = new List<string>();
+		foreach (GameStringTable table in s_tables.Values)
+		{
+			var values = table.GetAll();
+
+			foreach (var entry in values)
+            {
+				if (entry.Value.Equals(value))
+                {
+					ret.Add(entry.Key);
+                }
+            }
+		}
+		return ret;
+	}
+
+    internal static string Get(string v, object readProfile)
+    {
+        throw new NotImplementedException();
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameUtils.cs b/Decompiled/Assembly-CSharp/GameUtils.cs
index 3bc13b9..480c877 100644
--- a/Decompiled/Assembly-CSharp/GameUtils.cs
+++ b/Decompiled/Assembly-CSharp/GameUtils.cs
@@ -13,6 +13,7 @@ using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
 using UnityEngine.Events;
+using Accessibility;
 
 public class GameUtils
 {
@@ -675,6 +676,16 @@ public class GameUtils
 		return TranslateDbIdToCardId(cardTagValue);
 	}
 
+	public static string GetHeroBuddyCardIdFromHero(string heroCardId)
+	{
+		int cardTagValue = GetCardTagValue(heroCardId, GAME_TAG.BACON_COMPANION_ID);
+		if (cardTagValue == 0)
+		{
+			return string.Empty;
+		}
+		return TranslateDbIdToCardId(cardTagValue);
+	}
+
 	public static string GetHeroPowerCardIdFromHero(int heroDbId)
 	{
 		if (GameDbf.Card.GetRecord(heroDbId) == null)
@@ -854,6 +865,11 @@ public class GameUtils
 
 	public static NetCache.HeroLevel GetHeroLevel(TAG_CLASS heroClass)
 	{
+		if (s_cheatMockLevels)
+		{
+			return Cheat_GetHeroLevel(heroClass);
+		}
+
 		NetCache.NetCacheHeroLevels netObject = NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>();
 		if (netObject == null)
 		{
@@ -1834,6 +1850,9 @@ public class GameUtils
 
 	public static bool TutorialPreviewVideosEnabled()
 	{
+		// These videos are not accessible and they break tutorials
+		return false;
+
 		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
 		if (netObject == null)
 		{
@@ -2359,6 +2378,12 @@ public class GameUtils
 		{
 			return false;
 		}
+
+		if (HearthstoneAccessConstants.DEV_MODE)
+        {
+			return true;
+        }
+
 		return Options.Get().GetBool(Option.FAKE_PACK_OPENING);
 	}
 
@@ -2368,6 +2393,12 @@ public class GameUtils
 		{
 			return 0;
 		}
+
+		if (HearthstoneAccessConstants.DEV_MODE)
+        {
+			return 17;
+        }
+
 		return Options.Get().GetInt(Option.FAKE_PACK_COUNT);
 	}
 
@@ -3054,4 +3085,79 @@ public class GameUtils
 		}
 		return false;
 	}
+
+	#region Accessibility testing
+	private static bool s_cheatMockLevels;
+
+	private static Dictionary<TAG_CLASS, int> CHEAT_LEVELS_BY_CLASS = new Dictionary<TAG_CLASS, int>
+	{
+		{
+			TAG_CLASS.DRUID,
+			10
+		},
+		{
+			TAG_CLASS.HUNTER,
+			1
+		},
+		{
+			TAG_CLASS.MAGE,
+			7
+		},
+		{
+			TAG_CLASS.PALADIN,
+			3
+		},
+		{
+			TAG_CLASS.PRIEST,
+			1
+		},
+		{
+			TAG_CLASS.ROGUE,
+			1
+		},
+		{
+			TAG_CLASS.SHAMAN,
+			1
+		},
+		{
+			TAG_CLASS.WARLOCK,
+			1
+		},
+		{
+			TAG_CLASS.WARRIOR,
+			1
+		},
+		{
+			TAG_CLASS.DEMONHUNTER,
+			0 // Locked
+		},
+	};
+
+	private static NetCache.HeroLevel Cheat_GetHeroLevel(TAG_CLASS heroClass)
+	{
+		var ret = new NetCache.HeroLevel();
+		ret.Class = heroClass;
+
+		int level;
+		var ok = CHEAT_LEVELS_BY_CLASS.TryGetValue(heroClass, out level);
+
+		if (!ok)
+		{
+			return null;
+		}
+
+		var heroLevel = new NetCache.HeroLevel.LevelInfo();
+		heroLevel.Level = level;
+
+		ret.CurrentLevel = heroLevel;
+
+		return ret;
+	}
+
+	internal static void Cheat_SetLevelsOverride(bool val)
+	{
+		s_cheatMockLevels = val;
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Gameplay.cs b/Decompiled/Assembly-CSharp/Gameplay.cs
index 0ed2c53..2b6f6bc 100644
--- a/Decompiled/Assembly-CSharp/Gameplay.cs
+++ b/Decompiled/Assembly-CSharp/Gameplay.cs
@@ -211,6 +211,7 @@ public class Gameplay : PegasusScene
 
 	private void Start()
 	{
+		Accessibility.AccessibleGameplay.Get().OnGameplayScreenStart();
 		Log.LoadingScreen.Print("Gameplay.Start()");
 		CheckBattleNetConnection();
 		Network network = Network.Get();
diff --git a/Decompiled/Assembly-CSharp/GameplayErrorManager.cs b/Decompiled/Assembly-CSharp/GameplayErrorManager.cs
index 7467096..42a320f 100644
--- a/Decompiled/Assembly-CSharp/GameplayErrorManager.cs
+++ b/Decompiled/Assembly-CSharp/GameplayErrorManager.cs
@@ -3,6 +3,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
 using UnityEngine;
+using Accessibility;
 
 public class GameplayErrorManager : IService
 {
@@ -79,6 +80,7 @@ public class GameplayErrorManager : IService
 		m_uberText.gameObject.transform.localPosition = Data.m_mobileTextAdjustment;
 		s_messageInstance.ShowMessage(m_message, m_displaySecsLeft);
 		SoundManager.Get().LoadAndPlay("UI_no_can_do.prefab:7b1a22774f818544387c0f2ca4fea02c");
+		AccessibilityMgr.Output(AccessibleGameplay.Get(), message);
 	}
 
 	private void HideMessage()
diff --git a/Decompiled/Assembly-CSharp/GeneralStore.cs b/Decompiled/Assembly-CSharp/GeneralStore.cs
index 6177f53..acdc5a7 100644
--- a/Decompiled/Assembly-CSharp/GeneralStore.cs
+++ b/Decompiled/Assembly-CSharp/GeneralStore.cs
@@ -495,7 +495,7 @@ public class GeneralStore : Store
 		FriendChallengeMgr.Get().OnStoreOpened();
 		PreRender();
 		PresenceMgr.Get().SetStatus(Global.PresenceStatus.STORE);
-		if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_SEEN_GOLD_QTY_INSTRUCTION, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("GeneralStore.Show:" + Option.HAS_SEEN_GOLD_QTY_INSTRUCTION) && NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().GetTotal() >= MIN_GOLD_FOR_CHANGE_QTY_TOOLTIP)
+		if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_SEEN_GOLD_QTY_INSTRUCTION, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "GeneralStore.Show:" + Option.HAS_SEEN_GOLD_QTY_INSTRUCTION) && NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().GetTotal() >= MIN_GOLD_FOR_CHANGE_QTY_TOOLTIP)
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 			popupInfo.m_attentionCategory = UserAttentionBlocker.NONE;
@@ -897,7 +897,7 @@ public class GeneralStore : Store
 			yield return null;
 		}
 		int currencyChangedVersion = StoreManager.Get().GetCurrencyChangedVersion();
-		if (currencyChangedVersion != 0 && currencyChangedVersion != Options.Get().GetInt(Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION) && UserAttentionManager.CanShowAttentionGrabber("GeneralStore.AnimateAndUpdateStoreMode:" + Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION))
+		if (currencyChangedVersion != 0 && currencyChangedVersion != Options.Get().GetInt(Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION) && UserAttentionManager.CanShowAttentionGrabber(false, "GeneralStore.AnimateAndUpdateStoreMode:" + Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION))
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 			popupInfo.m_attentionCategory = UserAttentionBlocker.NONE;
diff --git a/Decompiled/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs
index 760d6f8..f280d14 100644
--- a/Decompiled/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs
@@ -5,9 +5,10 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay
+public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay, AccessibleScreen
 {
 	public delegate void GuestHeroSelectedCallback(TAG_CLASS classId, GuestHeroDbfRecord record);
 
@@ -101,6 +102,8 @@ public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			SetBackButtonEnabled(enable: false);
 		}
 		ShowFirstPage();
+
+		ReadPickerTrayDisplay();
 	}
 
 	protected override void InitForMode(SceneMgr.Mode mode)
@@ -675,4 +678,102 @@ public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			component.Owner.BindDataModel(heroClassIconsDataModel);
 		}
 	}
+
+	#region Accessibility
+	private enum AccessibleState {
+		LOADING,
+		ADVENTURE_CHOOSING_HERO,
+		ADVENTURE_HERO_CHOSEN,
+	};
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleHorizontalMenu<AccessibleHeroPickerButton> m_accessibleHeroPickerButtons;
+
+	private void ReadPickerTrayDisplay()
+	{
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+		AccessibilityMgr.SetScreen(this);
+
+		var menuTitle = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE);
+		var accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, menuTitle, PressBackButton);
+
+		var numSupportedBoHHeroes = 7; // Jaina, Rexxar, Garrosh, Uther, Anduin, Valeera, Thrall
+
+		//foreach (var hb in m_heroButtons)
+		for (var i = 0; i < numSupportedBoHHeroes; i++)
+        {
+			var hb = m_heroButtons[i];
+
+			accessibleHeroPickerButtons.AddOption(new AccessibleHeroPickerButton(this, hb), () => ChooseHero(hb));
+        }
+
+		m_accessibleHeroPickerButtons = accessibleHeroPickerButtons;
+		m_accessibleHeroPickerButtons.StartReading();
+
+		m_curAccessibleState = AccessibleState.ADVENTURE_CHOOSING_HERO;
+	}
+
+    private void ChooseHero(HeroPickerButton hb)
+    {
+		hb.TriggerRelease();
+    }
+
+    protected override void OnChosenHero()
+    {
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+        m_curAccessibleState = AccessibleState.ADVENTURE_HERO_CHOSEN;
+        AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+    }
+
+	public void HandleInput()
+	{
+		if (m_curAccessibleState == AccessibleState.LOADING)
+		{
+			return;
+		}
+		else if (m_curAccessibleState == AccessibleState.ADVENTURE_CHOOSING_HERO)
+        {
+            m_accessibleHeroPickerButtons?.HandleAccessibleInput();
+        }
+        else if (m_curAccessibleState == AccessibleState.ADVENTURE_HERO_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_playButton.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				PressBackButton();
+            }
+        }
+	}
+
+	public string GetHelp()
+	{
+		if (m_curAccessibleState == AccessibleState.ADVENTURE_CHOOSING_HERO)
+        {
+			return m_accessibleHeroPickerButtons?.GetHelp();
+        }
+        else if (m_curAccessibleState == AccessibleState.ADVENTURE_HERO_CHOSEN)
+        {
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        }
+
+		return "";
+	}
+
+	public void OnGainedFocus()
+	{
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE));
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs b/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
index 7568b4e..b7bb836 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
@@ -96,6 +96,37 @@ namespace Hearthstone
 			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
 		}
 
+		public void ExceptionReportInitializeDebug()
+		{
+			ExceptionReporter.Get().Initialize(PlatformFilePaths.PersistentDataPath, m_logger, HearthstoneApplication.Get());
+			ExceptionReporter.Get().IsInDebugMode = true;
+			ExceptionReporter.Get().SendExceptions = false;
+			ExceptionReporter.Get().SendAsserts = false;
+			ExceptionReporter.Get().SendErrors = false;
+			ExceptionSettings exceptionSettings = new ExceptionSettings();
+			exceptionSettings.m_projectID = 70;
+			exceptionSettings.m_moduleName = "Hearthstone Client";
+			exceptionSettings.m_version = "20.8";
+			exceptionSettings.m_branchName = Network.BranchName;
+			exceptionSettings.m_buildNumber = 86601;
+			exceptionSettings.m_locale = Localization.GetLocaleName();
+			exceptionSettings.m_jiraProjectName = "HSTN";
+			exceptionSettings.m_jiraComponent = "T5QA Confirmation";
+			exceptionSettings.m_jiraVersion = "20.8 Patch";
+			exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.BUG] = -1;
+			if (HearthstoneApplication.IsInternal())
+			{
+				exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.EXCEPTION] = 0;
+			}
+			exceptionSettings.m_logPathsCallback = GetLogPaths;
+			exceptionSettings.m_attachableFilesCallback = GetAttachableFiles;
+			exceptionSettings.m_additionalInfoCallback = GetAdditionalInfo;
+			exceptionSettings.m_readFileMethodCallback = ReadLogFileSharing;
+			ExceptionReporter.Get().BeforeZipping += FlushAllLogs;
+			ExceptionReporter.Get().SetSettings(exceptionSettings);
+			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
+		}
+
 		public void ControlANRMonitor(bool on)
 		{
 			if (PlatformSettings.IsMobileRuntimeOS && (on ^ m_ANRMonitorOn))
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs b/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
index 57f85ff..d006bc5 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
@@ -5,6 +5,7 @@ using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Threading;
+using Accessibility;
 using Blizzard.BlizzardErrorMobile;
 using Blizzard.T5.Configuration;
 using Blizzard.T5.Core;
@@ -53,6 +54,10 @@ namespace Hearthstone
 		};
 
 		private static bool s_initializedMode = false;
+		//private static bool s_initializedMode = true; // Dev mode
+
+		private static ApplicationMode s_mode = ApplicationMode.PUBLIC;
+		//private static ApplicationMode s_mode = ApplicationMode.INTERNAL; // Dev mode
 
 		private static string[] s_cachedCmdLineArgs = null;
 
@@ -80,8 +85,6 @@ namespace Hearthstone
 
 		private float m_unloadUnusedAssetsDelay;
 
-		private static ApplicationMode s_mode = ApplicationMode.INVALID;
-
 		private static HearthstoneApplication s_instance = null;
 
 		private static int s_mainThreadId = -1;
@@ -170,8 +173,10 @@ namespace Hearthstone
 			UpdateWorkingDirectory();
 			LocalOptions.Get().Initialize();
 			Localization.Initialize();
+			AccessibilityMgr.Initialize(gameObject);
+			//AccessibleHearthstoneApplication.OnLoading();
 			LaunchArguments.ReadLaunchArgumentsFromDeeplink();
-			ApplyInitializationSettingsFromConfig();
+            ApplyInitializationSettingsFromConfig();
 			Processor.UseJobQueueAlerts = !IsPublic();
 			PreviousInstanceStatus.ReportAppStatus();
 			new JobQueueTelemetry(Processor.JobQueue, Processor.JobQueueAlerts, TestType);
@@ -200,7 +205,8 @@ namespace Hearthstone
 			HsAppsFlyer.Initialize(60);
 			TelemetryManager.Initialize();
 			TracertReporter.SendTelemetry();
-			ExceptionReporterControl.Get().ExceptionReportInitialize();
+			// ExceptionReporterControl.Get().ExceptionReportInitialize(); // Remove so we don't send Blizzard exceptions that may be caused by us
+			ExceptionReporterControl.Get().ExceptionReportInitializeDebug();
 			HearthstonePerformance.Initialize(TestType, 2738135.ToString());
 			HearthstonePerformance.Get()?.CaptureAppStartTime();
 			AppLaunchTracker.TrackAppLaunch();
@@ -214,6 +220,8 @@ namespace Hearthstone
 
 		private void OnApplicationQuit()
 		{
+			AccessibleHearthstoneApplication.OnClosing();
+			AccessibilityMgr.Shutdown();
 			IsHearthstoneClosing = true;
 			UberText.StoreCachedData();
 			if (this.OnShutdown != null)
@@ -461,6 +469,7 @@ namespace Hearthstone
 		{
 			WaitForGameDownloadManagerState waitForGameDownloadManagerState = new WaitForGameDownloadManagerState();
 			JobDefinition jobDefinition = new JobDefinition("GameStrings.LoadAll", GameStrings.Job_LoadAll(), waitForGameDownloadManagerState);
+			jobDefinition.AddJobFinishedEventListener(OnGameStringsLoaded);
 			Processor.QueueJob("HearthstoneApplication.InitializeMode", Job_InitializeMode());
 			Processor.QueueJob(jobDefinition);
 			Processor.QueueJob("UberText.LoadCachedData", UberText.Job_LoadCachedData());
@@ -484,7 +493,12 @@ namespace Hearthstone
 			yield break;
 		}
 
-		private void InitializeGlobalDataContext()
+        private void OnGameStringsLoaded(JobDefinition job, bool success)
+        {
+			AccessibleHearthstoneApplication.OnLoading();
+        }
+
+        private void InitializeGlobalDataContext()
 		{
 			DataContext dataContext = GlobalDataContext.Get();
 			dataContext.BindDataModel(new DeviceDataModel
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs b/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
index 9883340..ef40b4e 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
@@ -7,10 +7,11 @@ using Blizzard.T5.Services;
 using Hearthstone.Core;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.InGameMessage.UI
 {
-	public class MessagePopupDisplay : IService
+	public class MessagePopupDisplay : IService, AccessibleUI
 	{
 		private MessageUIData m_currentlyDisplayedMessage;
 
@@ -340,6 +341,7 @@ namespace Hearthstone.InGameMessage.UI
 			{
 				m_messageModal.SetMessageList(messagesToDisplay, OnSetCurrentMessage);
 				m_modalWidget.Show();
+				ReadMessages(messagesToDisplay);
 			}
 			catch (Exception ex)
 			{
@@ -389,6 +391,7 @@ namespace Hearthstone.InGameMessage.UI
 
 		private void OnMessageClosed()
 		{
+			AccessibilityMgr.HideUI(this);
 			m_messageDisplayList.Clear();
 			m_currentlyDisplayedMessage = null;
 			m_onClosed?.Invoke();
@@ -473,5 +476,82 @@ namespace Hearthstone.InGameMessage.UI
 				m_messageModal.ForceClose();
 			}
 		}
+
+		#region Accessibility
+
+		private Queue<MessageUIData> s_messagesToRead;
+
+		private void ReadMessages(List<MessageUIData> messages)
+		{
+			s_messagesToRead = new Queue<MessageUIData>(messages);
+
+			AccessibilityMgr.ShowUI(this);
+
+			ReadNextMessage();
+		}
+
+		private void ReadNextMessage()
+		{
+			if (s_messagesToRead.Count == 0)
+			{
+				m_messageModal.OnClosePressed();
+			}
+			else
+			{
+				var nextMessage = s_messagesToRead.Dequeue();
+				ReadMessage(nextMessage);
+			}
+		}
+
+		private void ReadMessage(MessageUIData data)
+		{
+			List<IDataModel> list = MessageDataModelFactory.CreateDataModel(data);
+
+			if (list == null)
+			{
+				ReadNextMessage();
+				return;
+			}
+
+			foreach (var item in list)
+			{
+				switch (item)
+				{
+					case TextMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TextBody);
+						break;
+					case ShopMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TextBody);
+						break;
+					case TestDebugMessageUIData i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TestString);
+						break;
+					default:
+						ReadNextMessage();
+						return;
+				}
+			}
+		}
+
+		public void HandleAccessibleInput()
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				ReadNextMessage();
+			}
+		}
+
+		public string GetAccessibleHelp()
+		{
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+		}
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/LettuceVillage.cs b/Decompiled/Assembly-CSharp/Hearthstone/LettuceVillage.cs
index bac9da6..76dcdd1 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/LettuceVillage.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/LettuceVillage.cs
@@ -431,7 +431,7 @@ namespace Hearthstone
 					break;
 				}
 			}
-			if (lettuceVillageTutorialBone != null && UserAttentionManager.CanShowAttentionGrabber("VillageDisplay.HandleTutorialAttentionEvent:" + tutEvent))
+			if (lettuceVillageTutorialBone != null && UserAttentionManager.CanShowAttentionGrabber(false, "VillageDisplay.HandleTutorialAttentionEvent:" + tutEvent))
 			{
 				Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, lettuceVillageTutorialBone.transform.localPosition, lettuceVillageTutorialBone.transform.localScale, GameStrings.Get(lettuceVillageTutorialBone.LocalizationKey));
 				notification.ShowPopUpArrow(lettuceVillageTutorialBone.ArrowDirection);
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs
index 3bce4fd..f781da3 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs
@@ -1,11 +1,12 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class CoinPreview : MonoBehaviour
+	public class CoinPreview : MonoBehaviour, AccessibleUI
 	{
 		public UIBButton m_favoriteButton;
 
@@ -56,10 +57,14 @@ namespace Hearthstone.Progression
 				m_favoriteButton.Flip(faceUp: false, forceImmediate: true);
 				m_favoriteButton.SetEnabled(enabled: false);
 			}
+
+			ReadCoinPreview(cardDataModel);
 		}
 
 		public void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			FullScreenFXMgr.Get().EndStandardBlurVignette(0f);
 			UIContext.GetRoot().DismissPopup(base.gameObject);
 			if (!(m_widget == null))
@@ -73,5 +78,36 @@ namespace Hearthstone.Progression
 		{
 			m_widget.BindDataModel(cardDataModel);
 		}
+
+		#region Accessibility
+
+		private AccessibleMenu m_accessibleMenu;
+
+		private void ReadCoinPreview(CardDataModel cardDataModel)
+		{
+			AccessibilityMgr.ShowUI(this);
+
+			m_accessibleMenu = new AccessibleMenu(this, cardDataModel.Name, Hide);
+			m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), () => AccessibilityMgr.Output(this, cardDataModel.FlavorText));
+
+			if (m_favoriteButton.IsEnabled())
+			{
+				m_accessibleMenu.AddOption(m_favoriteButton.GetText(), m_favoriteButton.TriggerRelease);
+			}
+
+			m_accessibleMenu.StartReading();
+		}
+
+		public void HandleAccessibleInput()
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+
+		public string GetAccessibleHelp()
+		{
+			return m_accessibleMenu?.GetHelp();
+		}
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/EndGameHonorDisplay.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/EndGameHonorDisplay.cs
index 13f24e5..eb69534 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/EndGameHonorDisplay.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/EndGameHonorDisplay.cs
@@ -1,5 +1,6 @@
 using System;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -32,16 +33,24 @@ namespace Hearthstone.Progression
 			vector.z = relativePosition.z;
 			if (m_win)
 			{
+				var honorGainedStr = GameStrings.Format("GLUE_PROGRESSION_AV_HONOR_GAINED", honorGained);
+				var rankStr = GameStrings.Format("GLUE_PROGRESSION_AV_WIN_OPPONENT_RANK", opponentRankString);
 				m_WinFsm.FsmVariables.GetFsmVector3("HonorPosition").Value = vector;
-				m_WinFsm.FsmVariables.GetFsmString("HonorGained").Value = GameStrings.Format("GLUE_PROGRESSION_AV_HONOR_GAINED", honorGained);
-				m_WinFsm.FsmVariables.GetFsmString("Rank").Value = GameStrings.Format("GLUE_PROGRESSION_AV_WIN_OPPONENT_RANK", opponentRankString);
+				m_WinFsm.FsmVariables.GetFsmString("HonorGained").Value = honorGainedStr;
+				m_WinFsm.FsmVariables.GetFsmString("Rank").Value = rankStr;
 				m_WinFsm.SendEvent("Birth");
+
+				AccessibilityMgr.OutputNotification(rankStr);
+				AccessibilityMgr.OutputNotification(honorGainedStr);
 			}
 			else
 			{
+				var honorGainedStr = GameStrings.Format("GLUE_PROGRESSION_AV_HONOR_GAINED", honorGained);
 				m_LossFsm.FsmVariables.GetFsmVector3("HonorPosition").Value = vector;
-				m_LossFsm.FsmVariables.GetFsmString("HonorGained").Value = GameStrings.Format("GLUE_PROGRESSION_AV_HONOR_GAINED", honorGained);
+				m_LossFsm.FsmVariables.GetFsmString("HonorGained").Value = honorGainedStr;
 				m_LossFsm.SendEvent("Birth");
+
+				AccessibilityMgr.OutputNotification(honorGainedStr);
 			}
 		}
 
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs
index 536fbf2..067150e 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs
@@ -3,6 +3,7 @@ using Assets;
 using Blizzard.Telemetry.WTCG.Client;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -76,9 +77,11 @@ namespace Hearthstone.Progression
 			{
 				FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
 			}
-		}
 
-		public void Show()
+            AccessibleJournal.Get().OnJournalClosed();
+        }
+
+        public void Show()
 		{
 			s_isShowing = true;
 			HearthstonePerformance.Get()?.StartPerformanceFlow(new FlowPerformance.SetupConfig
@@ -93,10 +96,12 @@ namespace Hearthstone.Progression
 				OverlayUI.Get().AddGameObject(m_owner);
 				UIContext.GetRoot().RegisterPopup(m_owner, UIContext.RenderCameraType.OrthographicUI);
 				m_widget.TriggerEvent("SHOW");
+
+				AccessibleJournal.Get().OnJournalOpened(m_widget);
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 		}
 
-		public void Close()
+        public void Close()
 		{
 			HearthstonePerformance.Get()?.StopCurrentFlow();
 			UnityEngine.Object.Destroy(m_owner);
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs
index a374db0..4a5dac0 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs
@@ -2,6 +2,7 @@ using System;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -67,6 +68,7 @@ namespace Hearthstone.Progression
 					}
 					m_isChangingTab = false;
 				}, null, callImmediatelyIfSet: true, doOnce: true);
+				AccessibleJournal.Get().OnTabChanged(m_journalMetaData);
 				return;
 			}
 			m_widget.Hide();
@@ -86,6 +88,7 @@ namespace Hearthstone.Progression
 				}
 				m_widget.Show();
 				m_isChangingTab = false;
+				AccessibleJournal.Get().OnTabChanged(m_journalMetaData);
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 		}
 	}
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs
index 74383c4..e27ffc3 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs
@@ -10,6 +10,8 @@ namespace Hearthstone.Progression
 
 		private readonly Func<int, T> m_defaultProvider;
 
+		private Map<int, T> m_cheatState;
+
 		public event Action<T, T> OnStateChanged = delegate
 		{
 		};
@@ -21,6 +23,11 @@ namespace Hearthstone.Progression
 
 		public T GetState(int id)
 		{
+			if (m_cheatState != null)
+			{
+				return m_cheatState[id];
+			}
+
 			if (!m_playerState.TryGetValue(id, out var value))
 			{
 				Func<int, T> defaultProvider = m_defaultProvider;
@@ -36,23 +43,53 @@ namespace Hearthstone.Progression
 		public void UpdateState(int id, T newState)
 		{
 			T state = GetState(id);
-			m_playerState[id] = newState;
+
+			if (m_cheatState != null)
+			{
+				m_cheatState[id] = newState;
+			}
+			else
+			{
+				m_playerState[id] = newState;
+			}
 			this.OnStateChanged(state, newState);
 		}
 
 		public void Reset()
 		{
-			m_playerState.Clear();
+			if (m_cheatState != null)
+			{
+				m_cheatState.Clear();
+			}
+			else
+			{
+				m_playerState.Clear();
+			}
 		}
 
 		IEnumerator<T> IEnumerable<T>.GetEnumerator()
 		{
+			if (m_cheatState != null)
+			{
+				return m_cheatState.Values.GetEnumerator();
+			}
 			return m_playerState.Values.GetEnumerator();
 		}
 
 		public IEnumerator GetEnumerator()
 		{
+			if (m_cheatState != null)
+			{
+				return m_cheatState.Values.GetEnumerator();
+			}
 			return m_playerState.Values.GetEnumerator();
 		}
+
+		#region Accessibility Testing
+		public void Cheat_SetCheatState(Map<int, T> cheatState)
+		{
+			m_cheatState = cheatState;
+		}
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs
index 2cbea81..13ef6e3 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
+using Accessibility;
 using Assets;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
@@ -31,7 +32,8 @@ namespace Hearthstone.Progression
 		public enum QuestTileDisplayMode
 		{
 			DEFAULT,
-			NEXT_QUEST_TIME
+			NEXT_QUEST_TIME,
+			EOE
 		}
 
 		public delegate void OnQuestRerolledHandler(int rerolledQuestId, int grantedQuestId, bool success);
@@ -153,6 +155,11 @@ namespace Hearthstone.Progression
 
 		public QuestListDataModel CreateActiveQuestsDataModel(QuestPool.QuestPoolType questPoolType, bool appendTimeUntilNextQuest)
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.GetQuestsForPoolType(questPoolType);
+			}
+
 			QuestListDataModel questListDataModel = new QuestListDataModel();
 			List<int> list2 = new List<int>();
 			if (questPoolType == QuestPool.QuestPoolType.NONE)
@@ -256,6 +263,36 @@ namespace Hearthstone.Progression
 			return true;
 		}
 
+		private void DebugQuestListDataModel(QuestListDataModel questListDataModel)
+		{
+			if (!HearthstoneAccessConstants.DEV_MODE)
+			{
+				return;
+			}
+			AccessibilityUtils.LogDebug("Debugging QuestListDataModel");
+			foreach (var quest in questListDataModel.Quests)
+			{
+				AccessibilityUtils.LogDebug("-");
+				AccessibilityUtils.LogDebug($"--- QuestId: {quest.QuestId}");
+				AccessibilityUtils.LogDebug($"--- PoolId: {quest.PoolId}");
+				AccessibilityUtils.LogDebug($"--- PoolType: {quest.PoolType}");
+				AccessibilityUtils.LogDebug($"--- DisplayMode: {quest.DisplayMode}");
+				AccessibilityUtils.LogDebug($"--- Name: {quest.Name}");
+				AccessibilityUtils.LogDebug($"--- Description: {quest.Description}");
+				AccessibilityUtils.LogDebug($"--- Icon: {quest.Icon}");
+				AccessibilityUtils.LogDebug($"--- Progress: {quest.Progress}");
+				AccessibilityUtils.LogDebug($"--- Quota: {quest.Quota}");
+				AccessibilityUtils.LogDebug($"--- RerollCount: {quest.RerollCount}");
+				AccessibilityUtils.LogDebug($"--- Rewards: {quest.Rewards}");
+				AccessibilityUtils.LogDebug($"--- RewardTrackXp: {quest.RewardTrackXp}");
+				AccessibilityUtils.LogDebug($"--- ProgressMessage: {quest.ProgressMessage}");
+				AccessibilityUtils.LogDebug($"--- Status: {quest.Status}");
+				AccessibilityUtils.LogDebug($"--- Abandonable: {quest.Abandonable}");
+				AccessibilityUtils.LogDebug($"--- NextInChain: {quest.NextInChain}");
+				AccessibilityUtils.LogDebug("-");
+			}
+		}
+
 		public bool AckQuest(int questId)
 		{
 			if (!m_questState.TryGetValue(questId, out var value))
@@ -275,12 +312,21 @@ namespace Hearthstone.Progression
 				value.Status = 5;
 				break;
 			}
-			Network.Get().AckQuest(questId);
+
+			if (!AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				Network.Get().AckQuest(questId);
+			}
 			return false;
 		}
 
 		public bool RerollQuest(int questId)
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.RerollQuest(questId);
+			}
+
 			if (!m_questState.TryGetValue(questId, out var value))
 			{
 				return false;
@@ -304,6 +350,10 @@ namespace Hearthstone.Progression
 
 		public bool AbandonQuest(int questId)
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.AbandonQuest(questId);
+			}
 			if (!m_questState.TryGetValue(questId, out var value))
 			{
 				return false;
@@ -328,6 +378,11 @@ namespace Hearthstone.Progression
 
 		public bool CanBeGrantedPoolQuests()
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.CanBeGrantedPoolQuests();
+			}
+
 			foreach (PlayerQuestState value in m_questState.Values)
 			{
 				if (value.QuestId >= 104 && value.QuestId <= 108 && IsQuestActive(value))
@@ -342,7 +397,7 @@ namespace Hearthstone.Progression
 			return true;
 		}
 
-		private QuestDataModel CreateQuestDataModel(PlayerQuestState questState)
+		internal QuestDataModel CreateQuestDataModel(PlayerQuestState questState)
 		{
 			QuestDbfRecord record = GameDbf.Quest.GetRecord(questState.QuestId);
 			if (record == null)
@@ -379,12 +434,18 @@ namespace Hearthstone.Progression
 			};
 		}
 
-		private QuestDataModel CreateNextQuestTimeDataModel(QuestPoolDbfRecord questPoolRecord)
+		internal QuestDataModel CreateNextQuestTimeDataModel(QuestPoolDbfRecord questPoolRecord)
+		{
+			var timeUntilNextQuestString = GetTimeUntilNextQuestString(questPoolRecord.ID);
+			return CreateNextQuestTimeDataModel(questPoolRecord, timeUntilNextQuestString);
+		}
+
+		internal QuestDataModel CreateNextQuestTimeDataModel(QuestPoolDbfRecord questPoolRecord, string timeUntilNextQuestString)
 		{
 			QuestDataModel questDataModel = new QuestDataModel();
 			questDataModel.DisplayMode = QuestTileDisplayMode.NEXT_QUEST_TIME;
 			questDataModel.PoolType = questPoolRecord.QuestPoolType;
-			questDataModel.TimeUntilNextQuest = GameStrings.Format("GLOBAL_PROGRESSION_QUEST_TIME_UNTIL_NEXT", GetTimeUntilNextQuestString(questPoolRecord.ID));
+			questDataModel.TimeUntilNextQuest = GameStrings.Format("GLOBAL_PROGRESSION_QUEST_TIME_UNTIL_NEXT", timeUntilNextQuestString);
 			return questDataModel;
 		}
 
@@ -417,9 +478,19 @@ namespace Hearthstone.Progression
 			}
 		}
 
-		private void ReceivePlayerQuestStateUpdateMessage()
+		internal void ReceivePlayerQuestStateUpdateMessage()
 		{
-			PlayerQuestStateUpdate playerQuestStateUpdate = Network.Get().GetPlayerQuestStateUpdate();
+			PlayerQuestStateUpdate playerQuestStateUpdate;
+
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				playerQuestStateUpdate = AccessibleQuestsTestingUtils.GetPlayerQuestStateUpdate();
+			}
+			else
+			{
+				playerQuestStateUpdate = Network.Get().GetPlayerQuestStateUpdate();
+			}
+
 			if (playerQuestStateUpdate == null)
 			{
 				return;
@@ -485,9 +556,19 @@ namespace Hearthstone.Progression
 			}
 		}
 
-		private void ReceivePlayerQuestPoolStateUpdateMessage()
+		internal void ReceivePlayerQuestPoolStateUpdateMessage()
 		{
-			PlayerQuestPoolStateUpdate playerQuestPoolStateUpdate = Network.Get().GetPlayerQuestPoolStateUpdate();
+			PlayerQuestPoolStateUpdate playerQuestPoolStateUpdate;
+
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				playerQuestPoolStateUpdate = AccessibleQuestsTestingUtils.GetPlayerQuestPoolStateUpdate();
+			}
+			else
+			{
+				playerQuestPoolStateUpdate = Network.Get().GetPlayerQuestPoolStateUpdate();
+			}
+
 			if (playerQuestPoolStateUpdate == null)
 			{
 				return;
@@ -503,9 +584,19 @@ namespace Hearthstone.Progression
 			ScheduleCheckForNewQuests();
 		}
 
-		private void ReceiveRerollQuestResponseMessage()
+		internal void ReceiveRerollQuestResponseMessage()
 		{
-			RerollQuestResponse rerollQuestResponse = Network.Get().GetRerollQuestResponse();
+			RerollQuestResponse rerollQuestResponse;
+
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				rerollQuestResponse = AccessibleQuestsTestingUtils.GetRerollQuestResponse();
+			}
+			else
+			{
+				rerollQuestResponse = Network.Get().GetRerollQuestResponse();
+			}
+
 			if (rerollQuestResponse != null && GameDbf.Quest.GetRecord(rerollQuestResponse.RerolledQuestId) != null)
 			{
 				this.OnQuestRerolled?.Invoke(rerollQuestResponse.RerolledQuestId, rerollQuestResponse.GrantedQuestId, rerollQuestResponse.Success);
@@ -550,6 +641,12 @@ namespace Hearthstone.Progression
 			{
 				return "";
 			}
+
+			return GetElapsedTimeString(timeSpan);
+		}
+
+		internal string GetElapsedTimeString(TimeSpan timeSpan)
+		{
 			return TimeUtils.GetElapsedTimeString((long)timeSpan.TotalSeconds, TimeUtils.SPLASHSCREEN_DATETIME_STRINGSET, roundUp: true);
 		}
 
@@ -603,7 +700,10 @@ namespace Hearthstone.Progression
 			{
 				if (!GameMgr.Get().IsFindingGame())
 				{
-					Network.Get().CheckForNewQuests();
+					if (!AccessibleQuestsTestingUtils.IsMockingQuests())
+					{
+						Network.Get().CheckForNewQuests();
+					}
 				}
 				ScheduleCheckForNewQuests();
 			}
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
index 5a26c98..4b3bca4 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
@@ -4,11 +4,13 @@ using Assets;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class QuestNotificationPopup : MonoBehaviour
+	public class QuestNotificationPopup : MonoBehaviour, AccessibleUI
 	{
 		public Widget m_questList;
 
@@ -28,12 +30,18 @@ namespace Hearthstone.Progression
 
 		private const int RETURNING_PLAYER_PROXY_QUEST_ID = 99;
 
+		#region Accessibility
+		private QuestListDataModel m_questListDataModel;
+
+		private AccessibleListOfItems<AccessibleQuest> m_accessibleQuests;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == CODE_HIDE)
 				{
 					Hide();
 				}
@@ -43,6 +51,8 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			m_callback?.Invoke();
 			InnKeepersSpecial.UnregisterClickCallback(Hide);
 			if (m_IKSShown)
@@ -53,6 +63,9 @@ namespace Hearthstone.Progression
 
 		public void Initialize(RewardTrackDataModel rewardTrackDataModel, QuestListDataModel questListDataModel, Action callback, bool showIKS)
 		{
+			questListDataModel = OverrideQuestsIfNecessary(questListDataModel);
+
+			m_questListDataModel = questListDataModel;
 			m_callback = callback;
 			m_shouldShowIKS = showIKS;
 			if (rewardTrackDataModel != null)
@@ -61,6 +74,19 @@ namespace Hearthstone.Progression
 			}
 			if (questListDataModel != null)
 			{
+				// Accessiblity getting the pool type
+				for (int i = 0; i < questListDataModel.Quests.Count; i++)
+				{
+					var quest = questListDataModel.Quests[i];
+
+					if (i > 0 && m_questPoolType != quest.PoolType)
+					{
+						m_questPoolType = QuestPool.QuestPoolType.NONE;
+						break;
+					}
+					m_questPoolType = quest.PoolType;
+				}
+
 				m_widget.BindDataModel(new QuestListDataModel
 				{
 					Quests = questListDataModel.Quests.Take(m_maxQuestsPerRow).Aggregate(new DataModelList<QuestDataModel>(), delegate(DataModelList<QuestDataModel> acc, QuestDataModel dataModel)
@@ -87,10 +113,14 @@ namespace Hearthstone.Progression
 				}
 				m_widget.TriggerEvent("SHOW");
 			}, null, callImmediatelyIfSet: true, doOnce: true);
+
+			ReadPopup();
 		}
 
 		public void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			AckQuests();
 			SceneMgr.Get().UnregisterScenePreLoadEvent(OnPreLoadNextScene);
 			FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
@@ -147,5 +177,69 @@ namespace Hearthstone.Progression
 		{
 			Hide();
 		}
+
+        #region Accessibility
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(CODE_HIDE);
+            }
+			else
+            {
+				m_accessibleQuests.HandleAccessibleInput();
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.UI_QUEST_NOTIFICATION_POPUP_HELP);
+			var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+			return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+        }
+
+        private void ReadPopup()
+        {
+			AccessibilityMgr.ShowUI(this);
+			AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+			var accessibleQuests = new List<AccessibleQuest>();
+			foreach(var quest in m_questListDataModel.Quests)
+            {
+				accessibleQuests.Add(new AccessibleQuest(this, quest));
+            }
+
+			m_accessibleQuests = new AccessibleListOfItems<AccessibleQuest>(this, accessibleQuests);
+
+			if (m_questPoolType == QuestPool.QuestPoolType.WEEKLY)
+			{
+				AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_PROGRESSION_WEEKLY_QUESTS_POPUP_TITLE"));
+			}
+			else
+			{
+				AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_PROGRESSION_DAILY_QUESTS_POPUP_TITLE"));
+			}
+
+			m_accessibleQuests.StartReading();
+        }
+
+		#region Accessibility Testing
+		private QuestListDataModel OverrideQuestsIfNecessary(QuestListDataModel original)
+		{
+			var testingModel = AccessibleQuestsTestingUtils.GetQuests();
+
+			if (testingModel == null)
+			{
+				return original;
+			}
+
+			return testingModel;
+		}
+
+		#endregion
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
index 24cda7e..d39e39f 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
@@ -1,6 +1,7 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -17,6 +18,10 @@ namespace Hearthstone.Progression
 
 		private const string CODE_HIDE = "CODE_HIDE";
 
+		#region Accessibility
+		private QuestDataModel m_questDataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_toast = GetComponent<WidgetTemplate>();
@@ -31,6 +36,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(QuestDataModel questDataModel)
 		{
+			m_questDataModel = questDataModel;
 			m_toast.BindDataModel(questDataModel);
 		}
 
@@ -38,12 +44,13 @@ namespace Hearthstone.Progression
 		{
 			if (!(m_toast == null))
 			{
+				ReadToast();
 				OverlayUI.Get().AddGameObject(base.gameObject.transform.parent.gameObject);
 				m_toast.Show();
 			}
 		}
 
-		public void Hide()
+        public void Hide()
 		{
 			if (!(m_toast == null))
 			{
@@ -68,5 +75,22 @@ namespace Hearthstone.Progression
 				componentInChildren.Show();
 			});
 		}
+
+        #region Accessibility
+
+        private void ReadToast()
+        {
+			var quota = m_questDataModel.Quota;
+			var progress = m_questDataModel.Progress;
+
+			if (quota > 0)
+            {
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+				AccessibilityMgr.OutputNotification(m_questDataModel.Description);
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, progress, quota));
+            }
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs
index dac4704..c454e23 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs
@@ -1,6 +1,7 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -58,7 +59,7 @@ namespace Hearthstone.Progression
 
 		private void RerollQuest()
 		{
-			QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+			QuestDataModel dataModel = GetQuestDataModel();
 			if (dataModel != null && !m_isRerollPending)
 			{
 				if (!Network.IsLoggedIn())
@@ -76,7 +77,7 @@ namespace Hearthstone.Progression
 
 		private void AbandonQuest()
 		{
-			QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+			QuestDataModel dataModel = GetQuestDataModel();
 			if (dataModel != null)
 			{
 				if (!Network.IsLoggedIn())
@@ -104,15 +105,20 @@ namespace Hearthstone.Progression
 				{
 					m_widget.TriggerEvent("CODE_REROLLED");
 					m_isRerollAnimPlaying = true;
+					AccessibleJournal.Get().OnQuestAbandoned(this);
 				}
 			}
+			else
+			{
+				AccessibleJournal.Get().OnQuestAbandonCancel();
+			}
 		}
 
 		private void OnQuestRerolled(int rerolledQuestId, int grantedQuestId, bool success)
 		{
 			if (m_isRerollPending)
 			{
-				QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+				QuestDataModel dataModel = GetQuestDataModel();
 				if (dataModel != null && dataModel.QuestId == rerolledQuestId)
 				{
 					m_isRerollPending = false;
@@ -125,7 +131,7 @@ namespace Hearthstone.Progression
 
 		private void OnQuestRerollCountChanged(int questPoolId, int rerollCount)
 		{
-			QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+			QuestDataModel dataModel = GetQuestDataModel();
 			if (dataModel != null && dataModel.PoolId == questPoolId)
 			{
 				dataModel.RerollCount = rerollCount;
@@ -151,6 +157,7 @@ namespace Hearthstone.Progression
 				{
 					m_widget.TriggerEvent("CODE_GRANTED_BY_REROLL");
 				}, null, callImmediatelyIfSet: true, doOnce: true);
+				AccessibleJournal.Get().OnQuestRerolled(this);
 			}
 			else
 			{
@@ -160,7 +167,17 @@ namespace Hearthstone.Progression
 
 		private void UpdateQuestDataModelByQuestId(int questId)
 		{
-			m_widget.GetDataModel<QuestDataModel>()?.CopyFromDataModel(QuestManager.Get().CreateQuestDataModelById(questId));
+			GetQuestDataModel()?.CopyFromDataModel(QuestManager.Get().CreateQuestDataModelById(questId));
 		}
+
+		#region Accessibility
+
+		internal QuestDataModel GetQuestDataModel()
+        {
+			return m_widget.GetDataModel<QuestDataModel>();
+
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs
index 89577f3..ebb6a8e 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs
@@ -7,6 +7,7 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -60,6 +61,12 @@ namespace Hearthstone.Progression
 
 		private const string SETUP_MODE_MERCENARIES = "MERCENARIES";
 
+		#region Accessibility
+		private int m_curLevel;
+
+		private int m_introXpGained;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
@@ -109,6 +116,9 @@ namespace Hearthstone.Progression
 		{
 			if (xpChanges.Count != 0)
 			{
+				// A11y
+				m_curLevel = xpChanges[0].PrevLevel;
+
 				m_pauseOnNext = false;
 				m_isShowing = true;
 				m_gameXpCausedLevel = false;
@@ -213,7 +223,7 @@ namespace Hearthstone.Progression
 					}
 					questDataModel.RerollCount = 0;
 					m_questTileWidget.BindDataModel(questDataModel);
-					AnimateQuestTile();
+					AnimateQuestTile(questDataModel);
 				}
 			}
 			else if (flag)
@@ -364,8 +374,10 @@ namespace Hearthstone.Progression
 			}
 		}
 
-		private void AnimateQuestTile()
+		private void AnimateQuestTile(QuestDataModel questDataModel)
 		{
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_TRACK_REWARD_XP_GAIN_FROM_QUEST, questDataModel.RewardTrackXp));
+			AccessibilityMgr.OutputNotification(questDataModel.Description);
 			m_fsm.SendEvent("AnimateQuestTile");
 		}
 
@@ -386,12 +398,27 @@ namespace Hearthstone.Progression
 
 		private void ShowIntroXp()
 		{
-			UpdateIntroXpVar(CalculateIntroXpGained());
+			m_introXpGained = CalculateIntroXpGained();
+
+			UpdateIntroXpVar(m_introXpGained);
 			AnimateIntroXp();
 		}
 
 		private void OnPlayMakerFinished()
 		{
+			if (m_curLevel < m_dataModel.Level)
+			{
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_TRACK_REWARD_LEVEL_UP, m_dataModel.Level));
+			}
+
+			if (m_introXpGained > 0)
+			{
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_TRACK_REWARD_XP_GAIN, m_introXpGained));
+				m_introXpGained = 0;
+			}
+
+			m_curLevel = m_dataModel.Level;
+
 			if (m_isIntro)
 			{
 				m_isIntro = false;
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs
index 121da53..d7a953e 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs
@@ -102,7 +102,7 @@ namespace Hearthstone.Progression
 			rewardWidget.RegisterDoneChangingStatesListener(delegate
 			{
 				RewardScroll componentInChildren = rewardWidget.GetComponentInChildren<RewardScroll>();
-				componentInChildren.Initialize(delegate
+				componentInChildren.Initialize(rewardScrollDataModel, delegate
 				{
 					onHiddenCallback?.Invoke();
 				});
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
index 83d0b4e..beb95af 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
@@ -2,11 +2,13 @@ using System;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class RewardScroll : MonoBehaviour
+	public class RewardScroll : MonoBehaviour, AccessibleUI
 	{
 		private const string HIDE = "CODE_HIDE";
 
@@ -20,12 +22,16 @@ namespace Hearthstone.Progression
 
 		private event Action OnRewardScrollShown;
 
+        #region Accessibility
+        private RewardScrollDataModel m_dataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == HIDE)
 				{
 					Hide();
 				}
@@ -40,20 +46,25 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (FatalErrorMgr.IsInitialized())
 			{
 				FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
 			}
 		}
 
-		public void Initialize(Action onHiddenCallback, Action onShownCallback = null)
+		public void Initialize(RewardScrollDataModel dataModel, Action onHiddenCallback, Action onShownCallback = null)
 		{
+			m_dataModel = dataModel;
 			this.OnRewardScrollHidden = onHiddenCallback;
 			this.OnRewardScrollShown = onShownCallback;
 		}
 
 		public void Show()
 		{
+			ReadScroll();
+
 			OverlayUI.Get().AddGameObject(m_owner);
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
@@ -66,8 +77,10 @@ namespace Hearthstone.Progression
 			this.OnRewardScrollShown?.Invoke();
 		}
 
-		private void Hide()
+        private void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
 				UIContext.GetRoot().DismissPopup(base.gameObject);
@@ -87,8 +100,91 @@ namespace Hearthstone.Progression
 			widget.BindDataModel(dataModel);
 			widget.RegisterDoneChangingStatesListener(delegate
 			{
-				widget.GetComponentInChildren<RewardScroll>().Show();
+				RewardScroll componentInChildren = widget.GetComponentInChildren<RewardScroll>();
+				componentInChildren.Initialize(dataModel, null);
+				componentInChildren.Show();
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 		}
+
+        #region Accessibility
+
+		private void ReadScroll()
+        {
+			if (m_dataModel == null)
+			{
+				// Mercenaries scroll probably - this is not accessible
+				return;
+			}
+
+			AccessibilityMgr.ShowUI(this);
+
+            AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+            AccessibilityMgr.Output(this, m_dataModel.DisplayName);
+			AccessibilityMgr.Output(this, m_dataModel.Description);
+
+			ReadRewards();
+        }
+
+		private AccessibleListOfItems<AccessibleRewardItemDataModel> m_accessibleRewards;
+
+		private AccessibleRewardItemDataModel m_accessibleReward;
+
+        private void ReadRewards()
+        {
+            AccessibilityMgr.Output(this, LocalizedText.UI_REWARDS_TITLE);
+
+			m_accessibleRewards = null; // Reset in case of reuse
+			m_accessibleReward = null; // Reset in case of reuse
+
+			var rewards = m_dataModel.RewardList.Items;
+			var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+
+			foreach (var reward in rewards)
+            {
+				accessibleRewards.Add(new AccessibleRewardItemDataModel(this, reward));
+            }
+
+			m_accessibleRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(this, accessibleRewards);
+
+			if (m_accessibleRewards.Count == 1)
+            {
+				m_accessibleReward = m_accessibleRewards.Items[0];
+				m_accessibleReward.ReadAllLines();
+            }
+			else
+            {
+                m_accessibleRewards.StartReading();
+            }
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(HIDE);
+            }
+			else
+            {
+				if (m_accessibleReward != null)
+                {
+					m_accessibleReward.HandleAccessibleInput();
+                }
+				else
+                {
+                    m_accessibleRewards.HandleAccessibleInput();
+                }
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.UI_REWARD_SCROLL_HELP);
+			var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+			return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs
index 2ce91ec..fe6f0b7 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs
@@ -2,11 +2,14 @@ using System.Linq;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
+using System;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class RewardTrackChooseOneItemPopup : MonoBehaviour
+	public class RewardTrackChooseOneItemPopup : MonoBehaviour, AccessibleUI
 	{
 		public const string TURN_PAGE_LEFT = "CODE_TURN_PAGE_LEFT";
 
@@ -47,8 +50,11 @@ namespace Hearthstone.Progression
 					m_rewardListDataModel = m_widget.GetDataModel<RewardTrackNodeRewardsDataModel>().Items.CloneDataModel();
 					SetPageData(1);
 					break;
-				}
-			});
+                case "SHOW_POPUP_AFTER_CONFIRM": // A11y
+						ChooseHeroSkin();
+						break;
+                }
+            });
 			m_numberOfItemsPerPage = Mathf.Max(1, m_numberOfItemsPerPage);
 		}
 
@@ -88,5 +94,139 @@ namespace Hearthstone.Progression
 				m_rewardListDataModel.Items = rewardListDataModel.Items.OrderBy((RewardItemDataModel item) => item, new RewardUtils.RewardOwnedItemComparer()).ToDataModelList();
 			}
 		}
-	}
+
+        #region Accessibility
+
+		private enum State { LOADING, CHOOSING_SKIN, CONFIRMING };
+
+		private State m_curState;
+
+        private AccessibleListOfItems<AccessibleRewardItemDataModel> m_accessibleRewards;
+
+        public void ReadPopup()
+        {
+			m_curState = State.LOADING;
+
+            AccessibilityMgr.ShowUI(this);
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_POPUP), true);
+
+			var text = AccessibleWidgetUtils.GetUberText(gameObject, "Root/ItemTitle_Text");
+
+            if (text.gameObject.activeInHierarchy)
+            {
+                AccessibilityMgr.Output(this, GameStrings.Get(text.Text));
+            }
+
+			var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+			
+			foreach (var item in m_rewardListDataModel.Items)
+            {
+				accessibleRewards.Add(new AccessibleRewardItemDataModel(this, item, false));
+            }
+
+			m_accessibleRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(this, accessibleRewards);
+
+			ChooseHeroSkin();
+        }
+
+        private void ChooseHeroSkin()
+        {
+            AccessibilityMgr.ShowUI(this);
+
+			m_accessibleRewards.StartReading();
+
+			m_curState = State.CHOOSING_SKIN;
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (m_curState == State.LOADING)
+            {
+				return;
+            }
+
+			if (m_curState == State.CHOOSING_SKIN)
+            {
+                if (m_accessibleRewards?.HandleAccessibleInput() ?? false)
+                {
+                    var itemBeingReadIndex = m_accessibleRewards.GetItemBeingReadIndex();
+
+                    TurnPageIfNeeded(itemBeingReadIndex);
+                }
+                else if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    ChooseReward(m_accessibleRewards.GetItemBeingReadIndex());
+                }
+            }
+			else if (m_curState == State.CONFIRMING)
+            {
+				if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    ClickClaimButton();
+                }
+				else if (AccessibleKey.BACK.IsPressed())
+                {
+					m_curState = State.CHOOSING_SKIN;
+					m_accessibleRewards.StartReading();
+                }
+            }
+        }
+
+        private void ChooseReward(int rewardIndex)
+        {
+			var rewardLayout = AccessibleUnityUtils.GetChildObject(gameObject, "Root/PageContainer/RewardLayout/");
+
+			if (rewardLayout == null)
+            {
+				return;
+            }
+
+			var rewardElements = new List<PegUIElement>();
+			foreach (var child in AccessibleUnityUtils.GetChildren(rewardLayout))
+            {
+				rewardElements.Add(AccessibleWidgetUtils.GetPegUIElement(child, "RewardTrackSkinChoiceItem/Root/Clickables/RegularHover_Clickable"));
+            }
+
+			var rewardInPageIndex = rewardIndex % m_numberOfItemsPerPage;
+			AccessibleWidgetUtils.ClickButton(rewardElements[rewardInPageIndex]);
+
+			m_curState = State.CONFIRMING;
+			AccessibilityMgr.Output(this, GetAccessibleHelp());
+        }
+
+        private void ClickClaimButton()
+        {
+			var bottomContent = AccessibleUnityUtils.GetChildObject(gameObject, "Root/BottomContent");
+
+			if (bottomContent != null)
+            {
+				var button = bottomContent.GetComponentInChildren<PegUIElement>();
+
+				AccessibleWidgetUtils.ClickButton(button);
+            }
+        }
+
+        private void TurnPageIfNeeded(int curItemIndex)
+        {
+			var pageIndex = Mathf.CeilToInt(curItemIndex / m_numberOfItemsPerPage);
+            var page = Mathf.Clamp(pageIndex + 1, 1, m_pageInfo.TotalPages);
+            SetPageData(page);
+        }
+
+        public string GetAccessibleHelp()
+        {
+			if (m_curState == State.CHOOSING_SKIN)
+            {
+                return m_accessibleRewards?.GetHelp(false);
+            }
+			else if (m_curState == State.CONFIRMING)
+            {
+				return LocalizedText.GLOBAL_PRESS_ENTER_TO_CONFIRM_OR_BACKSPACE_TO_CANCEL;
+            }
+
+			return "";
+        }
+
+        #endregion
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
index 39aefa2..c5525ea 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Text;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusUtil;
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs
index 271ad43..6208542 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
+using Accessibility;
 using Assets;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
@@ -133,6 +134,12 @@ namespace Hearthstone.Progression
 
 		public bool ClaimRewardTrackReward(int rewardTrackId, int level, bool forPaidTrack, int chooseOneRewardItemId = 0)
 		{
+			if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+				m_pendingRewardClaimRequests[(rewardTrackId, level, forPaidTrack)] = chooseOneRewardItemId;
+				return AccessibleRewardsTrackTestingUtils.ClaimRewardTrackReward(rewardTrackId, level, forPaidTrack, chooseOneRewardItemId);
+			}
+
 			if (rewardTrackId == TrackDataModel.RewardTrackId)
 			{
 				if (!RewardExistsAtLevel(level, forPaidTrack))
@@ -157,12 +164,20 @@ namespace Hearthstone.Progression
 				return false;
 			}
 			m_pendingRewardClaimRequests[(rewardTrackId, level, forPaidTrack)] = chooseOneRewardItemId;
+
 			Network.Get().ClaimRewardTrackReward(rewardTrackId, level, forPaidTrack, chooseOneRewardItemId);
+
 			return true;
 		}
 
 		public bool AckRewardTrackReward(int rewardTrackId, int level, bool forPaidTrack)
 		{
+			if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+				AccessibleJournal.Get().OnTrackRewardAckd(rewardTrackId, level, forPaidTrack);
+				return true;
+			}
+
 			if (TrackDataModel.RewardTrackId == rewardTrackId)
 			{
 				if (!RewardExistsAtLevel(level, forPaidTrack))
@@ -188,13 +203,14 @@ namespace Hearthstone.Progression
 				}
 			}
 			Network.Get().AckRewardTrackReward(rewardTrackId, level, forPaidTrack);
+			AccessibleJournal.Get().OnTrackRewardAckd(rewardTrackId, level, forPaidTrack);
 			return true;
 		}
 
 		public bool HasUnclaimedRewardsForLevel(RewardTrackLevelDbfRecord record)
 		{
-			PlayerRewardTrackLevelState state = m_rewardTrackLevelState.GetState(record.Level);
-			bool premiumRewardsUnlocked = TrackDataModel.PremiumRewardsUnlocked;
+			PlayerRewardTrackLevelState state = GetPlayerRewardTrackLevelState(record.Level);
+			bool premiumRewardsUnlocked = ArePremiumRewardsUnlocked();
 			RewardListDbfRecord freeRewardListRecord = record.FreeRewardListRecord;
 			bool flag = freeRewardListRecord != null && freeRewardListRecord.RewardItems?.Count > 0;
 			int num;
@@ -369,7 +385,7 @@ namespace Hearthstone.Progression
 			}
 		}
 
-		private void HandleRewardTrackStateUpdate(PlayerRewardTrackState stateUpdate)
+		internal void HandleRewardTrackStateUpdate(PlayerRewardTrackState stateUpdate)
 		{
 			if (stateUpdate.HasIsActiveRewardTrack && !stateUpdate.IsActiveRewardTrack)
 			{
@@ -484,6 +500,12 @@ namespace Hearthstone.Progression
 			case RewardStatus.RESET:
 				break;
 			}
+
+			// Outside the switch as that would be dangerous
+			if (status == RewardStatus.ACKED)
+			{
+				AccessibleJournal.Get().OnTrackRewardAckd(rewardTrackId, level, forPaidTrack);
+			}
 		}
 
 		private void OnRewardTrackUnclaimedNotification()
@@ -592,5 +614,27 @@ namespace Hearthstone.Progression
 			{
 			});
 		}
+
+		#region Accessibility
+		public PlayerRewardTrackLevelState GetPlayerRewardTrackLevelState(int level)
+		{
+			return m_rewardTrackLevelState.GetState(level);
+		}
+
+		public bool ArePremiumRewardsUnlocked()
+		{
+			if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+				return AccessibleRewardsTrackTestingUtils.ArePremiumRewardsUnlocked();
+			}
+			return TrackDataModel.PremiumRewardsUnlocked;
+		}
+
+		internal void Cheat_SetPlayerRewardTrackLevelState(Map<int, PlayerRewardTrackLevelState> state)
+		{
+			m_rewardTrackLevelState.Cheat_SetCheatState(state);
+		}
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/UI/Clickable.cs b/Decompiled/Assembly-CSharp/Hearthstone/UI/Clickable.cs
index 771c0cc..6f826e8 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/UI/Clickable.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/UI/Clickable.cs
@@ -543,5 +543,14 @@ namespace Hearthstone.UI
 		{
 			Hearthstone.UI.Logging.Log.Get().AddMessage(message, this, LogLevel.Info, type);
 		}
+
+        #region Accessibility
+
+        internal PegUIElement GetPegUIElement()
+        {
+			return m_pegUiElement;
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs b/Decompiled/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs
index 330fed6..f6737c3 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs
@@ -34,7 +34,7 @@ namespace Hearthstone.UI
 		[SerializeField]
 		private LoadingPolicy m_loadingPolicy;
 
-		private PrefabInstance m_prefabInstance;
+		internal PrefabInstance m_prefabInstance;
 
 		private bool m_startedInitialization;
 
@@ -42,7 +42,7 @@ namespace Hearthstone.UI
 
 		private List<Action> m_pendingPreInitializeActions;
 
-		private DataContext m_pendingDataContext = new DataContext();
+		public DataContext m_pendingDataContext = new DataContext();
 
 		private WidgetTemplate m_parentWidgetTemplate;
 
diff --git a/Decompiled/Assembly-CSharp/HeroDbId.cs b/Decompiled/Assembly-CSharp/HeroDbId.cs
index 79c6983..1bb1e15 100644
--- a/Decompiled/Assembly-CSharp/HeroDbId.cs
+++ b/Decompiled/Assembly-CSharp/HeroDbId.cs
@@ -14,5 +14,6 @@ public enum HeroDbId
 	ALLERIA,
 	MEDIVH,
 	LIADRIN,
-	KHADGAR
+	KHADGAR,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs b/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs
index 56ebc5e..2cc7a73 100644
--- a/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs
+++ b/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class HeroPickerDisplay : MonoBehaviour
 {
diff --git a/Decompiled/Assembly-CSharp/HeroSkinInfoManager.cs b/Decompiled/Assembly-CSharp/HeroSkinInfoManager.cs
index 41d73b3..dd42cb3 100644
--- a/Decompiled/Assembly-CSharp/HeroSkinInfoManager.cs
+++ b/Decompiled/Assembly-CSharp/HeroSkinInfoManager.cs
@@ -1,9 +1,11 @@
 using Blizzard.T5.AssetManager;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class HeroSkinInfoManager : BaseHeroSkinInfoManager
+public class HeroSkinInfoManager : BaseHeroSkinInfoManager, AccessibleUI
 {
 	private static HeroSkinInfoManager s_instance;
 
@@ -101,6 +103,10 @@ public class HeroSkinInfoManager : BaseHeroSkinInfoManager
 		{
 			CollectionManager.Get().UpdateFavoriteHero(@class, cardDefinition.Name, m_currentPremium);
 		}
+		else
+		{
+			AccessibleCollectionManager.Get().WaitingForServerResponse();
+		}
 	}
 
 	protected override bool CanFavoriteCurrentHero()
@@ -130,4 +136,67 @@ public class HeroSkinInfoManager : BaseHeroSkinInfoManager
 			BnetBar.Get()?.RefreshCurrency();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	protected override void ReadHeroSkinPreview()
+	{
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleMenu = new AccessibleMenu(this, m_currentEntityDef.GetName(), CancelPreview);
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), () => AccessibilityMgr.Output(this, m_currentHeroRecord.Description));
+
+		AddFavoriteAndBuyButtons(m_accessibleMenu);
+
+		m_accessibleMenu.StartReading();
+	}
+
+	private void AddFavoriteAndBuyButtons(AccessibleMenu menu)
+	{
+		// The logic around favorite and buy buttons is pretty tangled so there's no great way of doing this. This is covered by tests anyways so should be fine
+		if (CanFavoriteCurrentHero())
+		{
+			AddButton(menu, GetDesiredFavoriteButton());
+		}
+
+		var buyBtn = GetDesiredBuyButton();
+
+		if (m_userActionVisualController.State == INSUFFICIENT_CURRENCY_STATE)
+		{
+			menu.AddOption(FormatBuyMessage(buyBtn), () => AccessibilityMgr.Output(this, GameStrings.Get("GAMEPLAY_PlayErrors_REQ_ENOUGH_COIN")));
+		}
+		else if (m_userActionVisualController.State == SUFFICIENT_CURRENCY_STATE)
+		{
+			menu.AddOption(FormatBuyMessage(buyBtn), buyBtn.TriggerRelease);
+		}
+	}
+
+	private string FormatBuyMessage(UIBButton btn)
+	{
+		return LocalizationUtils.Format(LocalizationKey.UI_SHOP_ITEM_BUY_FOR_N_GOLD, btn.GetText());
+	}
+
+	private void AddButton(AccessibleMenu menu, UIBButton btn)
+	{
+		menu.AddOption(btn.GetText(), btn.TriggerRelease);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	protected override void HideThis()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/HeroXPBar.cs b/Decompiled/Assembly-CSharp/HeroXPBar.cs
index dacc299..50b6b89 100644
--- a/Decompiled/Assembly-CSharp/HeroXPBar.cs
+++ b/Decompiled/Assembly-CSharp/HeroXPBar.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class HeroXPBar : PegUIElement
 {
@@ -33,6 +34,12 @@ public class HeroXPBar : PegUIElement
 
 	private string m_rewardDesc;
 
+	#region Accessibility
+	private bool m_fromEndGameScreen;
+
+	private AccessibleComponent m_parent;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -44,12 +51,16 @@ public class HeroXPBar : PegUIElement
 	{
 	}
 
-	public void UpdateDisplay(NetCache.HeroLevel heroLevel, int totalLevel)
+	public void UpdateDisplay(AccessibleComponent parent, NetCache.HeroLevel heroLevel, int totalLevel, bool fromEndGameScreen)
 	{
+		m_fromEndGameScreen = fromEndGameScreen;
+		m_parent = parent;
+
 		if (heroLevel == null)
 		{
 			base.gameObject.SetActive(value: false);
-			return;
+            SignalEnterToContinue();
+            return;
 		}
 		m_heroLevel = heroLevel;
 		m_totalLevel = totalLevel;
@@ -72,6 +83,7 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.PrevLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
+				SignalEnterToContinue();
 				return;
 			}
 			SetBarValue((float)m_heroLevel.PrevLevel.XP / (float)m_heroLevel.PrevLevel.MaxXP);
@@ -83,12 +95,14 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.CurrentLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
-			}
-			else
+                SignalEnterToContinue();
+            }
+            else
 			{
 				SetBarValue((float)m_heroLevel.CurrentLevel.XP / (float)m_heroLevel.CurrentLevel.MaxXP);
-			}
-		}
+                SignalEnterToContinue();
+            }
+        }
 	}
 
 	public void AnimateBar(NetCache.HeroLevel.LevelInfo previousLevelInfo, NetCache.HeroLevel.LevelInfo currentLevelInfo)
@@ -110,9 +124,10 @@ public class HeroXPBar : PegUIElement
 			currVal2 = 1f;
 		}
 		m_progressBar.AnimateProgress(prevVal2, currVal2);
-	}
+        SignalEnterToContinue();
+    }
 
-	public void SetBarValue(float barValue)
+    public void SetBarValue(float barValue)
 	{
 		m_progressBar.SetProgressBar(barValue);
 	}
@@ -128,7 +143,7 @@ public class HeroXPBar : PegUIElement
 	private IEnumerator AnimatePostLevelUpXp(float delayTime, NetCache.HeroLevel.LevelInfo currentLevelInfo)
 	{
 		yield return new WaitForSeconds(delayTime);
-		if (currentLevelInfo.Level == 3 && !Options.Get().GetBool(Option.HAS_SEEN_LEVEL_3, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("HeroXPBar.AnimatePostLevelUpXp:" + Option.HAS_SEEN_LEVEL_3))
+		if (currentLevelInfo.Level == 3 && !Options.Get().GetBool(Option.HAS_SEEN_LEVEL_3, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "HeroXPBar.AnimatePostLevelUpXp:" + Option.HAS_SEEN_LEVEL_3))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_LEVEL3_TIP"), "VO_INNKEEPER_LEVEL3_TIP.prefab:0f82ce6c91fccf249b6abcc9f153ff1e");
 			Options.Get().SetBool(Option.HAS_SEEN_LEVEL_3, val: true);
@@ -140,6 +155,8 @@ public class HeroXPBar : PegUIElement
 		{
 			m_levelUpCallback();
 		}
+		AccessibilityMgr.Output(m_parent, LocalizationUtils.Format(LocalizationKey.SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP, currentLevelInfo.Level));
+		SignalEnterToContinue();
 	}
 
 	private IEnumerator DelayBarAnimation(NetCache.HeroLevel.LevelInfo prevInfo, NetCache.HeroLevel.LevelInfo currInfo)
@@ -171,4 +188,16 @@ public class HeroXPBar : PegUIElement
 	{
 		base.gameObject.GetComponent<TooltipZone>().HideTooltip();
 	}
+
+	#region Accessibility
+
+	private void SignalEnterToContinue()
+    {
+		if (m_fromEndGameScreen)
+        {
+            AccessibilityMgr.Output(m_parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/HistoryCard.cs b/Decompiled/Assembly-CSharp/HistoryCard.cs
index 905b12e..35fe9b8 100644
--- a/Decompiled/Assembly-CSharp/HistoryCard.cs
+++ b/Decompiled/Assembly-CSharp/HistoryCard.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
@@ -93,7 +94,9 @@ public class HistoryCard : HistoryItem
 
 	private int m_displayTimeMS;
 
-	private HistoryInfoType m_historyInfoType;
+	internal HistoryInfoType m_historyInfoType;
+
+	internal PowerTaskList OriginTaskList { get; private set; }
 
 	public void LoadMainCardActor()
 	{
@@ -676,8 +679,10 @@ public class HistoryCard : HistoryItem
 		return -1.404475f + num2 * (float)num3;
 	}
 
-	public void LoadBigCard(HistoryBigCardInitInfo info)
+	public void LoadBigCard(PowerTaskList origin, HistoryBigCardInitInfo info)
 	{
+		OriginTaskList = origin;
+
 		m_entity = info.m_entity;
 		m_historyInfoType = info.m_historyInfoType;
 		m_portraitTexture = info.m_portraitTexture;
@@ -792,10 +797,11 @@ public class HistoryCard : HistoryItem
 			{
 				ShowDisplayedCreator();
 			}
-		}
-	}
+            AccessibleGameplay.Get().OnShowBigCard(this);
+        }
+    }
 
-	private void OnBigCardPathComplete()
+    private void OnBigCardPathComplete()
 	{
 		ShowDisplayedCreator();
 	}
diff --git a/Decompiled/Assembly-CSharp/HistoryInfoType.cs b/Decompiled/Assembly-CSharp/HistoryInfoType.cs
index 23926a8..8ba672c 100644
--- a/Decompiled/Assembly-CSharp/HistoryInfoType.cs
+++ b/Decompiled/Assembly-CSharp/HistoryInfoType.cs
@@ -7,5 +7,6 @@ public enum HistoryInfoType
 	TRIGGER,
 	WEAPON_BREAK,
 	FATIGUE,
-	BURNED_CARDS
+	BURNED_CARDS,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/HistoryManager.cs b/Decompiled/Assembly-CSharp/HistoryManager.cs
index 55e0749..5b4db1d 100644
--- a/Decompiled/Assembly-CSharp/HistoryManager.cs
+++ b/Decompiled/Assembly-CSharp/HistoryManager.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class HistoryManager : CardTileListDisplay
 {
@@ -24,6 +25,14 @@ public class HistoryManager : CardTileListDisplay
 		public bool m_waitForSecretSpell;
 
 		public int m_displayTimeMS;
+
+		public PowerTaskList m_origin;
+
+		public BigCardEntry(PowerTaskList origin)
+        {
+			// Required to arbitrate TTS between big cards and power list parsing
+			m_origin = origin;
+        }
 	}
 
 	private enum BigCardTransformState
@@ -1556,26 +1565,27 @@ public class HistoryManager : CardTileListDisplay
 		return m_pendingBigCardEntry.m_info.GetOriginalEntity();
 	}
 
-	public void CreateFastBigCardFromMetaData(Entity entity)
+	public void CreateFastBigCardFromMetaData(PowerTaskList origin, Entity entity)
 	{
 		int displayTimeMS = 1000;
-		CreatePlayedBigCard(entity, delegate
+		CreatePlayedBigCard(origin, entity, delegate
 		{
 		}, delegate
 		{
 		}, fromMetaData: true, countered: false, displayTimeMS);
 	}
 
-	public void CreatePlayedBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
+	public void CreatePlayedBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard())
-		{
-			finishedCallback();
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard())
+        {
+            // Some tutorials don't show big cards but we depend on it for accessibility atm
+            finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		if (entity.IsWeapon())
@@ -1594,16 +1604,17 @@ public class HistoryManager : CardTileListDisplay
 		StartCoroutine("WaitForCardLoadedAndCreateBigCard", bigCardEntry);
 	}
 
-	public void CreateTriggeredBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
+	public void CreateTriggeredBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard())
-		{
-			finishedCallback();
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard())
+        {
+            // Some tutorials don't show big cards but we depend on it for accessibility atm
+            finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		bigCardEntry.m_info.m_infoType = HistoryInfoType.TRIGGER;
@@ -1752,7 +1763,7 @@ public class HistoryManager : CardTileListDisplay
 			historyBigCardInitInfo.m_postTransformedEntity = postTransformedEntity;
 			historyBigCardInitInfo.m_displayTimeMS = bigCardEntry.m_displayTimeMS;
 			HistoryCard component = go.GetComponent<HistoryCard>();
-			component.LoadBigCard(historyBigCardInitInfo);
+			component.LoadBigCard(bigCardEntry.m_origin, historyBigCardInitInfo);
 			if ((bool)m_currentBigCard)
 			{
 				InterruptCurrentBigCard();
diff --git a/Decompiled/Assembly-CSharp/Hub.cs b/Decompiled/Assembly-CSharp/Hub.cs
index 5eb9d22..861bef9 100644
--- a/Decompiled/Assembly-CSharp/Hub.cs
+++ b/Decompiled/Assembly-CSharp/Hub.cs
@@ -8,6 +8,7 @@ using Hearthstone.Core;
 using Hearthstone.InGameMessage.UI;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class Hub : PegasusScene
 {
@@ -53,6 +54,10 @@ public class Hub : PegasusScene
 		{
 			Box.Get().DisableAllButtons();
 		}
+		else
+        {
+			AccessibleHub.Get().OnHubOpened();
+        }
 		yield break;
 	}
 
@@ -296,16 +301,18 @@ public class Hub : PegasusScene
 		{
 			return;
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_HUB))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_HUB))
 		{
 			StartCoroutine(DoFirstTimeHubWelcome());
 		}
-		else if (!Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_MODE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_PRACTICE_MODE))
+		else if (!Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_MODE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "Hub.Start:" + Option.HAS_SEEN_PRACTICE_MODE) && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
+			// This is visual and doesn't really help. Need to ask for translations to do this properly
 			ShowModesButtonNotification("GLUE_PRACTICE_HINT");
 		}
-		else if (GameModeUtils.ShouldSeeSoloAdventuresMovedPopup() && GameModeUtils.CanAccessGameModes() && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + GameSaveKeySubkeyId.FTUE_SHOULD_SEE_SOLO_ADVENTURES_MOVED_POPUP))
+		else if (GameModeUtils.ShouldSeeSoloAdventuresMovedPopup() && GameModeUtils.CanAccessGameModes() && UserAttentionManager.CanShowAttentionGrabber(false, "Hub.Start:" + GameSaveKeySubkeyId.FTUE_SHOULD_SEE_SOLO_ADVENTURES_MOVED_POPUP) && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
+			// This is visual and doesn't really help. Need to ask for translations to do this properly
 			ShowModesButtonNotification("GLUE_SOLO_ADVENTURES_MOVED_HINT");
 		}
 		else if (!Options.Get().GetBool(Option.HAS_SEEN_100g_REMINDER, defaultVal: false))
@@ -315,7 +322,7 @@ public class Hub : PegasusScene
 			{
 				Debug.LogError("Hub.Start Error - NetCache.NetCacheGoldBalance is null");
 			}
-			if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
+			if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FIRST_100_GOLD"), "VO_INNKEEPER_FIRST_100_GOLD.prefab:c6a50337099a454488acd96d2f37320f");
 				Options.Get().SetBool(Option.HAS_SEEN_100g_REMINDER, val: true);
@@ -462,6 +469,10 @@ public class Hub : PegasusScene
 		NotificationManager notificationManager = NotificationManager.Get();
 		if (notificationManager != null && !m_isTutorialPreviewOpen)
 		{
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+              yield return new WaitForSeconds(3f); // Allow menu to be read before jumping in
+            }
 			m_innkeeperPopup = notificationManager.CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_1ST_HUB_06"), "VO_INNKEEPER_1ST_HUB_06.prefab:9774392944a21424788286f80d401d8c", 3f);
 			if ((bool)UniversalInputManager.UsePhoneUI)
 			{
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
index 6b58bab..a5724d5 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
@@ -1,4 +1,5 @@
 using System;
+using Accessibility;
 using HutongGames.PlayMaker.AnimationEnums;
 using UnityEngine;
 
@@ -335,7 +336,8 @@ namespace HutongGames.PlayMaker
 		{
 			if (!(Camera.main == null))
 			{
-				Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out mousePickInfo, distance, layerMask);
+				Physics.Raycast(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), out mousePickInfo, distance, layerMask);
+				//Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out mousePickInfo, distance, layerMask);
 				mousePickLayerMaskUsed = layerMask;
 				mousePickDistanceUsed = distance;
 				mousePickRaycastTime = Time.frameCount;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
index 8f7015a..0db1a61 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
@@ -32,7 +32,8 @@ namespace HutongGames.PlayMaker.Actions
 		{
 			if (storeResult != null)
 			{
-				float num = Input.mousePosition.x;
+				float num = AccessibleUnityInput.Get().GetMousePosition().x;
+				//float num = Input.mousePosition.x;
 				if (normalize)
 				{
 					num /= (float)Screen.width;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
index 30f3fbf..327bca0 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
@@ -32,7 +32,8 @@ namespace HutongGames.PlayMaker.Actions
 		{
 			if (storeResult != null)
 			{
-				float num = Input.mousePosition.y;
+				float num = AccessibleUnityInput.Get().GetMousePosition().y;
+				//float num = Input.mousePosition.y;
 				if (normalize)
 				{
 					num /= (float)Screen.height;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
index 44a1bbd..bf99203 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
@@ -54,7 +54,8 @@ namespace HutongGames.PlayMaker.Actions
 
 		private void DoMousePick2d()
 		{
-			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			//RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
 			bool flag = rayIntersection.collider != null;
 			storeDidPickObject.Value = flag;
 			if (flag)
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
index dcd9828..4f70c4f 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
@@ -84,7 +84,8 @@ namespace HutongGames.PlayMaker.Actions
 		private bool DoRaycast()
 		{
 			GameObject gameObject = ((GameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : GameObject.GameObject.Value);
-			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			//RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
 			Fsm.RecordLastRaycastHit2DInfo(base.Fsm, rayIntersection);
 			if (rayIntersection.transform != null && rayIntersection.transform.gameObject == gameObject)
 			{
diff --git a/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs b/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs
index 4f6d108..4af0340 100644
--- a/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs
+++ b/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs
@@ -175,7 +175,7 @@ public class ICCPrologueFakeDeath : Spell
 			}
 			FullScreenFXMgr.Get().SetBlurDesaturation(0.5f);
 			FullScreenFXMgr.Get().Blur(1f, 0.5f, iTween.EaseType.easeInCirc);
-			defeatTwoScoop.Show(showXPBar: false);
+			defeatTwoScoop.Show(null, showXPBar: false);
 			yield return new WaitForSeconds(m_FakeDefeatScreenShowTime);
 			FullScreenFXMgr.Get().StopBlur(0.25f, iTween.EaseType.linear);
 			FullScreenFXMgr.Get().SetBlurDesaturation(0f);
diff --git a/Decompiled/Assembly-CSharp/ICollectible.cs b/Decompiled/Assembly-CSharp/ICollectible.cs
index 9279439..479df90 100644
--- a/Decompiled/Assembly-CSharp/ICollectible.cs
+++ b/Decompiled/Assembly-CSharp/ICollectible.cs
@@ -10,4 +10,8 @@ public interface ICollectible : IComparable
 	HashSet<string> GetSearchableTokens();
 
 	SearchableString GetSearchableString();
+
+	#region Accessibility
+	bool IsAccessible();
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs b/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
index bba775e..c558ce9 100644
--- a/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
+++ b/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
@@ -23,7 +23,7 @@ public class InactivePlayerKicker : IService, IHasUpdate
 
 	private GameMgr m_gameMgr;
 
-	public bool WasKickedForInactivity { get; private set; }
+	public bool WasKickedForInactivity { get; set; }
 
 	public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
 	{
diff --git a/Decompiled/Assembly-CSharp/InputCollection.cs b/Decompiled/Assembly-CSharp/InputCollection.cs
index 9fc8020..5568c6d 100644
--- a/Decompiled/Assembly-CSharp/InputCollection.cs
+++ b/Decompiled/Assembly-CSharp/InputCollection.cs
@@ -8,6 +8,7 @@ public static class InputCollection
 	static InputCollection()
 	{
 		m_Inputs = new List<IInput>();
+		m_Inputs.Add(AccessibleUnityInput.Get());
 		m_Inputs.Add(new UnityInput());
 	}
 
diff --git a/Decompiled/Assembly-CSharp/InputManager.cs b/Decompiled/Assembly-CSharp/InputManager.cs
index 371c141..cf98068 100644
--- a/Decompiled/Assembly-CSharp/InputManager.cs
+++ b/Decompiled/Assembly-CSharp/InputManager.cs
@@ -239,6 +239,10 @@ public class InputManager : MonoBehaviour
 
 	public Vector3 LastMouseDownPosition => m_lastMouseDownPosition;
 
+	#region Accessibility
+	internal Card m_mousedOverCardRegardlessOfInput; // Used in Battlegrounds only due to the tutorial messing things up
+	#endregion
+
 	private void Awake()
 	{
 		s_instance = this;
@@ -595,6 +599,8 @@ public class InputManager : MonoBehaviour
 
 	public void SetMousedOverCard(Card card)
 	{
+		m_mousedOverCardRegardlessOfInput = card;
+
 		if (!(m_mousedOverCard == card))
 		{
 			if (m_mousedOverCard != null && !(m_mousedOverCard.GetZone() is ZoneHand))
@@ -603,7 +609,7 @@ public class InputManager : MonoBehaviour
 			}
 			if (card.IsInputEnabled())
 			{
-				m_mousedOverCard = card;
+				SetMousedOverCardVariable(card);
 				card.NotifyMousedOver();
 			}
 		}
@@ -3303,7 +3309,7 @@ public class InputManager : MonoBehaviour
 	{
 		if (card.IsInputEnabled() && !m_gameState.GetGameEntity().ShouldSuppressCardMouseOver(card.GetEntity()))
 		{
-			m_mousedOverCard = card;
+			SetMousedOverCardVariable(card);
 			bool flag = m_gameState.IsFriendlySidePlayerTurn() && (bool)m_targetReticleManager && m_targetReticleManager.ShouldPreventMouseOverBigCard();
 			if (!PermitDecisionMakingInput())
 			{
@@ -3337,7 +3343,7 @@ public class InputManager : MonoBehaviour
 		{
 			PegCursor.Get().SetMode(PegCursor.Mode.UP);
 			Card mousedOverCard = m_mousedOverCard;
-			m_mousedOverCard = null;
+			SetMousedOverCardVariable(null);
 			mousedOverCard.HideTooltip();
 			mousedOverCard.NotifyMousedOut();
 			ShowBullseyeIfNeeded();
@@ -3881,4 +3887,12 @@ public class InputManager : MonoBehaviour
 	{
 		return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().EnablePlayingFromMiniHand;
 	}
+
+	#region Accessibility
+	private void SetMousedOverCardVariable(Card card)
+	{
+		m_mousedOverCard = card;
+		m_mousedOverCardRegardlessOfInput = card;
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/JoustSpellController.cs b/Decompiled/Assembly-CSharp/JoustSpellController.cs
index d995418..5b41fd6 100644
--- a/Decompiled/Assembly-CSharp/JoustSpellController.cs
+++ b/Decompiled/Assembly-CSharp/JoustSpellController.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Core;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class JoustSpellController : SpellController
@@ -267,6 +268,7 @@ public class JoustSpellController : SpellController
 		{
 			PlayNoJousterSpell(GameState.Get().GetOpposingSidePlayer());
 		}
+
 		while (IsJousterBusy(m_friendlyJouster) || IsJousterBusy(m_opponentJouster))
 		{
 			yield return null;
@@ -311,9 +313,26 @@ public class JoustSpellController : SpellController
 			DriftJouster(jouster);
 		};
 		iTween.Timer(card.gameObject, iTween.Hash("delay", delaySec, "time", showSec, "oncomplete", action));
+
+		var jousterName = card.GetEntity().GetName();
+		var jousterCost = card.GetEntity().GetDefCost();
+
+		if (card.GetEntity().IsControlledByFriendlySidePlayer())
+        {
+			OutputSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_JOUST_PLAYER_REVEALED_CARD, jousterCost, jousterName));
+        }
+		else
+        {
+			if (card.GetEntity().GetCardType() != TAG_CARDTYPE.INVALID)
+			{
+				// Some cards reuse the Joust mechanic even though they're not really Jousts
+				// e.g. Guess the weight when used by the opponent (only the opponent sees the card)
+				OutputSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD, jousterCost, jousterName));
+			}
+		}
 	}
 
-	private void PlayNoJousterSpell(Player player)
+    private void PlayNoJousterSpell(Player player)
 	{
 		ZoneDeck deckZone = player.GetDeckZone();
 		Spell spell2 = UnityEngine.Object.Instantiate(m_NoJousterSpellPrefab);
@@ -326,6 +345,15 @@ public class JoustSpellController : SpellController
 			}
 		});
 		spell2.Activate();
+
+		if (player.IsFriendlySide())
+        {
+			OutputSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS));
+        }
+		else
+        {
+			OutputSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS));
+        }
 	}
 
 	private void DriftJouster(Jouster jouster)
@@ -534,4 +562,14 @@ public class JoustSpellController : SpellController
 		}
 		return jouster.m_effectsPendingFinish > 0;
 	}
+
+    #region Accessibility
+
+    private void OutputSpeech(string speech)
+    {
+        AccessibilityMgr.Output(AccessibleGameplay.Get(), speech);
+        AccessibleHistoryMgr.Get().AddEntry(speech);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs b/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
index d34aaf9..d6e5e18 100644
--- a/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
+++ b/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.UI;
 
-public class LeaguePromoteSelfManuallyDialog : DialogBase
+public class LeaguePromoteSelfManuallyDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback();
 
diff --git a/Decompiled/Assembly-CSharp/LettuceCollectionDisplay.cs b/Decompiled/Assembly-CSharp/LettuceCollectionDisplay.cs
index d8602a9..461de0f 100644
--- a/Decompiled/Assembly-CSharp/LettuceCollectionDisplay.cs
+++ b/Decompiled/Assembly-CSharp/LettuceCollectionDisplay.cs
@@ -151,7 +151,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 		DoEnterCollectionManagerEvents();
 		if (CollectionManager.Get().ShouldShowWildToStandardTutorial())
 		{
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
 		CollectionManager.Get().RequestDeckContentsForDecksWithoutContentsLoaded();
 		StartCoroutine(WaitUntilReady());
@@ -170,7 +170,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 
 	protected override void OnDestroy()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
@@ -992,7 +992,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 		{
 			yield return null;
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_SHOW_MERC_DETAILS_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_SEEN_SHOW_MERC_DETAILS_TUTORIAL))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_SHOW_MERC_DETAILS_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_SEEN_SHOW_MERC_DETAILS_TUTORIAL))
 		{
 			m_helpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_showMercDetailsTutorialBone.position, m_showMercDetailsTutorialBone.localScale, GameStrings.Get("GLUE_LETTUCE_COLLECTION_TUTORIAL01"));
 			m_helpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
@@ -1014,7 +1014,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber("LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/LettuceMapDisplay.cs b/Decompiled/Assembly-CSharp/LettuceMapDisplay.cs
index 0e0595b..0eb7982 100644
--- a/Decompiled/Assembly-CSharp/LettuceMapDisplay.cs
+++ b/Decompiled/Assembly-CSharp/LettuceMapDisplay.cs
@@ -1329,7 +1329,7 @@ public class LettuceMapDisplay : AbsSceneDisplay
 			rewardWidget.RegisterDoneChangingStatesListener(delegate
 			{
 				RewardScroll componentInChildren = rewardWidget.GetComponentInChildren<RewardScroll>();
-				componentInChildren.Initialize(delegate
+				componentInChildren.Initialize(null, delegate
 				{
 					m_waitingForVisitorSelectionServerResponse = false;
 					FullScreenFXMgr.Get().EndStandardBlurVignette(0.25f);
@@ -1402,7 +1402,7 @@ public class LettuceMapDisplay : AbsSceneDisplay
 		rewardWidget.RegisterDoneChangingStatesListener(delegate
 		{
 			RewardScroll componentInChildren = rewardWidget.GetComponentInChildren<RewardScroll>();
-			componentInChildren.Initialize(delegate
+			componentInChildren.Initialize(null, delegate
 			{
 				m_waitingForVisitorSelectionServerResponse = false;
 				FullScreenFXMgr.Get().EndStandardBlurVignette(0.25f);
diff --git a/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs b/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
index 6f5714f..436d3f1 100644
--- a/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
@@ -2,8 +2,9 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class LoadingPopupDisplay : TransitionPopup
+public class LoadingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	[Serializable]
 	public class LoadingbarTexture
@@ -95,12 +96,23 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 	}
 
+	public override void Show()
+    {
+		base.Show();
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, m_title.Text, true);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+    }
+
 	public override void Hide()
 	{
 		if (m_shown)
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -415,4 +427,18 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 		m_progressBar.SetBarTexture(texture);
 	}
+
+	#region Accessibility
+
+	public void HandleAccessibleInput()
+    {
+		HandleCancelButtonInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return HandleCancelButtonHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Log.cs b/Decompiled/Assembly-CSharp/Log.cs
index 165da7d..30e013f 100644
--- a/Decompiled/Assembly-CSharp/Log.cs
+++ b/Decompiled/Assembly-CSharp/Log.cs
@@ -11,10 +11,10 @@ public class Log
 {
 	public enum LogLevel
 	{
-		[Description("None")]
-		None,
-		[Description("Debug")]
-		Debug,
+        [Description("None")]
+        None,
+        [Description("Debug")]
+        Debug,
 		[Description("Info")]
 		Info,
 		[Description("Warning")]
@@ -27,6 +27,8 @@ public class Log
 
 	public static Logger All = new Logger("All");
 
+	public static Logger Accessibility = new Logger("Accessibility");
+
 	public static Logger AchievementManager = new Logger("AchievementManager");
 
 	public static Logger Achievements = new Logger("Achievements");
@@ -213,7 +215,9 @@ public class Log
 
 	private const string CONFIG_FILE_NAME = "log.config";
 
-	private readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[5]
+	private const string ACCESSIBILITY_LOG_NAME = "Accessibility";
+
+	private static readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[]
 	{
 		new LogInfo
 		{
@@ -229,6 +233,14 @@ public class Log
 			m_minLevel = LogLevel.Info
 		},
 		new LogInfo
+		{
+			m_name = ACCESSIBILITY_LOG_NAME,
+			m_filePrinting = true,
+			m_consolePrinting = false,
+			m_minLevel = LogLevel.Info,
+			m_defaultLevel = LogLevel.Info
+		},
+		new LogInfo
 		{
 			m_name = "Login",
 			m_filePrinting = true,
@@ -421,6 +433,10 @@ public class Log
 				value2.m_verbose = GeneralUtils.ForceBool(value);
 			}
 		}
+
+		// Force Accessibility log for returning users (e.g. PCs shared with sighted people)
+		var accessibilityLog = Array.Find(DEFAULT_LOG_INFOS, x => x.m_name.Equals(ACCESSIBILITY_LOG_NAME));
+		map.Add(accessibilityLog.m_name, accessibilityLog);
 		return map;
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Login.cs b/Decompiled/Assembly-CSharp/Login.cs
index 872db0e..5d51952 100644
--- a/Decompiled/Assembly-CSharp/Login.cs
+++ b/Decompiled/Assembly-CSharp/Login.cs
@@ -1,4 +1,5 @@
 using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.Jobs;
 using Hearthstone;
 using Hearthstone.Core;
@@ -92,6 +93,7 @@ public class Login : PegasusScene
 
 	private void ChangeMode()
 	{
+		HSADevTools.Init();
 		MusicManager.Get().StartPlaylist(MusicPlaylistType.UI_MainTitle);
 		m_nextMissionId = GameUtils.GetNextTutorial();
 		if (m_nextMissionId > 3)
@@ -103,25 +105,27 @@ public class Login : PegasusScene
 			if (!CreateSkipHelper.ShouldShowCreateSkip() || !CreateSkipHelper.ShowCreateSkipDialog(ChangeToAppropriateHubMode))
 			{
 				ChangeToAppropriateHubMode();
-				ChangeMode_SetRotation();
+				ChangeMode_SetRotation(false);
 			}
+			return;
 		}
-		else
-		{
-			if (NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>() == null)
-			{
-				Debug.LogError(" Could not get NetCacheFeatures Object");
-			}
-			ChangeMode_Hub();
-		}
+
+		// Force old flow as the new one isn't accessible yet
+		if (m_nextMissionId == 3)
+        {
+			ChangeMode_TutorialWithStart();
+			return;
+        }
+		ChangeMode_Hub();
 	}
 
 	private void ChangeToAppropriateHubMode()
 	{
 		Log.Login.PrintInfo("Changing mode");
-		if (SetRotationManager.ShouldShowSetRotationIntro())
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && SetRotationManager.ShouldShowSetRotationIntro())
 		{
-			ChangeMode_SetRotation();
+            // None of this is implemented yet (nor needed until ranked etc)
+            ChangeMode_SetRotation(false);
 		}
 		else
 		{
@@ -230,6 +234,7 @@ public class Login : PegasusScene
 	{
 		Box.Get().AddButtonPressListener(OnStartButtonPressed);
 		Box.Get().ChangeState(Box.State.PRESS_START);
+		AccessibleLoginScreen.Get().OnGameLoaded(Box.Get().m_StartButton);
 	}
 
 	private void OnStartButtonPressed(Box.ButtonType buttonType, object userData)
@@ -267,6 +272,7 @@ public class Login : PegasusScene
 
 	private void StartTutorial()
 	{
+		AccessibleTutorialProgressScreen.Get().OnStartTutorial();
 		MusicManager.Get().StopPlaylist();
 		Box.Get().ChangeState(Box.State.CLOSED);
 		GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
@@ -280,9 +286,9 @@ public class Login : PegasusScene
 		return true;
 	}
 
-	private void ChangeMode_SetRotation()
+	private void ChangeMode_SetRotation(bool accessible)
 	{
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		Spell eventSpell = Box.Get().GetEventSpell(BoxEventType.STARTUP_SET_ROTATION);
 		Box.Get().m_StoreButton.gameObject.SetActive(value: false);
 		Box.Get().m_QuestLogButton.gameObject.SetActive(value: false);
diff --git a/Decompiled/Assembly-CSharp/LoginManager.cs b/Decompiled/Assembly-CSharp/LoginManager.cs
index 85da186..83fedc2 100644
--- a/Decompiled/Assembly-CSharp/LoginManager.cs
+++ b/Decompiled/Assembly-CSharp/LoginManager.cs
@@ -257,7 +257,7 @@ public class LoginManager : IService
 	private void OnProfileProgressResponse()
 	{
 		HearthstoneApplication.SendStartupTimeTelemetry("LoginManager.OnProfileProgressResponse");
-		if (!Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
+		if (!Accessibility.AccessibilityMgr.IsAccessibilityEnabled() && !Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
 		{
 			HearthstoneServices.Get<Cinematic>().Play(delegate
 			{
@@ -495,7 +495,7 @@ public class LoginManager : IService
 
 	private void ShowGoldCapAlert(Action callback)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber("Login.ShowGoldCapAlert"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, "Login.ShowGoldCapAlert"))
 		{
 			callback();
 			return;
diff --git a/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs b/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
index 7c9737d..2184d6a 100644
--- a/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
+++ b/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class LoginPopupSequencePopup : BasicPopup
 {
@@ -18,6 +19,8 @@ public class LoginPopupSequencePopup : BasicPopup
 		public AssetReference m_backgroundMaterialReference;
 
 		public HideCallback m_callbackOnHide;
+
+		public Info(bool markedForAccessibility) { } // If something new shows up we must ensure login popup sequence is still hidden
 	}
 
 	private struct CardActorLoadedData
@@ -129,14 +132,17 @@ public class LoginPopupSequencePopup : BasicPopup
 		if (m_headerText != null)
 		{
 			m_headerText.Text = info.m_headerText;
+			AccessibilityMgr.Output(this, info.m_headerText);
 		}
 		if (m_bodyText != null)
 		{
 			m_bodyText.Text = info.m_bodyText;
+			AccessibilityMgr.Output(this, info.m_bodyText);
 		}
 		if (m_cancelButton != null)
 		{
 			m_cancelButton.SetText(info.m_buttonText);
+			AccessibilityMgr.Output(this, info.m_buttonText);
 		}
 		if (m_backgroundMaterial != null)
 		{
@@ -146,7 +152,7 @@ public class LoginPopupSequencePopup : BasicPopup
 
 	public override void GoBack()
 	{
-		if (!base.gameObject.TryGetComponent<FactionChoicePopup>(out var component) || component.HasFactionChoiceConfirmationBeenReceived)
+		if (!IsFactionChoicePopup())
 		{
 			base.GoBack();
 		}
diff --git a/Decompiled/Assembly-CSharp/LoginPopups.cs b/Decompiled/Assembly-CSharp/LoginPopups.cs
index b1a3083..f60f47b 100644
--- a/Decompiled/Assembly-CSharp/LoginPopups.cs
+++ b/Decompiled/Assembly-CSharp/LoginPopups.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using Assets;
 using Hearthstone.Progression;
+using Accessibility;
 
 public class LoginPopups : IDisposable
 {
@@ -24,7 +25,14 @@ public class LoginPopups : IDisposable
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber("ShowLoginPopupSequence"))
+		/*if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Not implemented yet as there's a few tricky ones
+		// TODO: Check all of this as I had to disable it due to the choose faction poup
+			return false;
+		}
+		*/
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "ShowLoginPopupSequence"))
 		{
 			return false;
 		}
@@ -118,7 +126,7 @@ public class LoginPopups : IDisposable
 					}
 					continue;
 				}
-				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info
+				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info(false)
 				{
 					m_headerText = loginPopupSequencePopupDbfRecord2.HeaderText,
 					m_bodyText = loginPopupSequencePopupDbfRecord2.BodyText,
diff --git a/Decompiled/Assembly-CSharp/ManaFilterTab.cs b/Decompiled/Assembly-CSharp/ManaFilterTab.cs
index 0908af6..6e3ba75 100644
--- a/Decompiled/Assembly-CSharp/ManaFilterTab.cs
+++ b/Decompiled/Assembly-CSharp/ManaFilterTab.cs
@@ -29,6 +29,10 @@ public class ManaFilterTab : PegUIElement
 
 	private AudioSource m_mouseOverSound;
 
+	#region Accessibility
+	internal string m_manaCostText;
+	#endregion
+
 	protected override void Awake()
 	{
 		m_crystal.MarkAsNotInGame();
@@ -115,19 +119,25 @@ public class ManaFilterTab : PegUIElement
 		if (m_manaID == -1)
 		{
 			text2 = GameStrings.Get("GLUE_COLLECTION_ALL");
+			m_manaCostText = text2;
 		}
 		else
 		{
 			text = m_manaID.ToString();
+			m_manaCostText = text;
+
 			if (m_manaID == 7)
 			{
+				var plus = GameStrings.Get("GLUE_COLLECTION_PLUS");
 				if ((bool)UniversalInputManager.UsePhoneUI)
 				{
-					text += GameStrings.Get("GLUE_COLLECTION_PLUS");
+					text += plus;
+					m_manaCostText = text;
 				}
 				else
 				{
-					text2 = GameStrings.Get("GLUE_COLLECTION_PLUS");
+					text2 = plus;
+					m_manaCostText += plus; // This is the one we'll actually end up using
 				}
 			}
 		}
diff --git a/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs b/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
index 8d39aff..d4936bc 100644
--- a/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
+++ b/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
@@ -4,6 +4,8 @@ using UnityEngine;
 
 public class ManaFilterTabManager : MonoBehaviour
 {
+	internal static int NUM_MANA_FILTERS = 7;
+
 	public ManaFilterTab m_singleManaFilterPrefab;
 
 	public ManaFilterTab m_dynamicManaFilterPrefab;
@@ -12,7 +14,7 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	private bool m_tabsActive;
 
-	private List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
+	internal List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
 
 	private HashSet<int> m_currentFilterExactValues = new HashSet<int>();
 
@@ -169,11 +171,11 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	public void SetUpTabs()
 	{
-		for (int i = 0; i <= 6; i++)
+		for (int i = 0; i <= NUM_MANA_FILTERS - 1; i++)
 		{
 			CreateNewTab(m_singleManaFilterPrefab, i);
 		}
-		CreateNewTab(m_dynamicManaFilterPrefab, 7);
+		CreateNewTab(m_dynamicManaFilterPrefab, NUM_MANA_FILTERS);
 		m_manaCrystalContainer.UpdateSlices();
 	}
 
@@ -208,7 +210,7 @@ public class ManaFilterTabManager : MonoBehaviour
 		if (m_tabsActive)
 		{
 			ManaFilterTab manaFilterTab = (ManaFilterTab)e.GetElement();
-			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
+			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
 			{
 				Options.Get().SetBool(Option.HAS_CLICKED_MANA_TAB, val: true);
 				ShowManaTabHint(manaFilterTab);
@@ -298,6 +300,9 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	private void ShowManaTabHint(ManaFilterTab tabButton)
 	{
+		// Visual notif
+		return;
+
 		Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, tabButton.transform.position + new Vector3(0f, 0f, 7f), TutorialEntity.GetTextScale(), GameStrings.Get("GLUE_COLLECTION_MANAGER_MANA_TAB_FIRST_CLICK"));
 		if (!(notification == null))
 		{
diff --git a/Decompiled/Assembly-CSharp/MassDisenchant.cs b/Decompiled/Assembly-CSharp/MassDisenchant.cs
index be44576..dab69e2 100644
--- a/Decompiled/Assembly-CSharp/MassDisenchant.cs
+++ b/Decompiled/Assembly-CSharp/MassDisenchant.cs
@@ -2,8 +2,9 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class MassDisenchant : MonoBehaviour
+public class MassDisenchant : MonoBehaviour, AccessibleUI
 {
 	public GameObject m_root;
 
@@ -112,10 +113,12 @@ public class MassDisenchant : MonoBehaviour
 	public void Show()
 	{
 		m_root.SetActive(value: true);
+		ReadScreen();
 	}
 
 	public void Hide()
 	{
+		HideThis();
 		m_root.SetActive(value: false);
 		BlockCurrencyFrame(block: false);
 	}
@@ -127,6 +130,7 @@ public class MassDisenchant : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		HideThis();
 		foreach (GameObject cleanupObject in m_cleanupObjects)
 		{
 			if (cleanupObject != null)
@@ -339,6 +343,9 @@ public class MassDisenchant : MonoBehaviour
 
 	private IEnumerator DoDisenchantAnims(int maxGlowBalls, int disenchantTotal)
 	{
+		AccessibleCollectionManager.Get().OnMassDisenchantAnimStarted();
+		m_isPlayingAnim = true;
+
 		if (disenchantTotal == 0)
 		{
 			yield return null;
@@ -509,6 +516,9 @@ public class MassDisenchant : MonoBehaviour
 			material2.SetFloat("_XSpeed", origXSpeed);
 			item5.m_amountBar.GetComponent<Renderer>().GetMaterial().SetFloat("_Intensity", origInten);
 		}
+
+		m_isPlayingAnim = false;
+		AccessibleCollectionManager.Get().OnMassDisenchantAnimDone();
 	}
 
 	private void SetDustBalance(float bal)
@@ -704,4 +714,64 @@ public class MassDisenchant : MonoBehaviour
 		}
 		return raritySound;
 	}
+
+	#region Accessibility
+
+	private bool m_isPlayingAnim;
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadScreen()
+	{
+		if (AccessibilityMgr.IsCurrentlyFocused(this))
+		{
+			// Show triggers again after disenchanting for some reason
+			return;
+		}
+
+		m_isPlayingAnim = false;
+
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleMenu = new AccessibleMenu(this, m_headlineText.Text, CancelMassDisenchant);
+		m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_MASS_DISENCHANT_FOR_N_DUST, m_totalCardsToDisenchant, m_totalAmount), ConfirmMassDisenchant);
+		m_accessibleMenu.AddOption(GameStrings.Get("GLOBAL_CANCEL"), CancelMassDisenchant);
+
+		m_accessibleMenu.StartReading();
+	}
+
+	private void ConfirmMassDisenchant()
+	{
+		m_disenchantButton.TriggerRelease();
+	}
+
+	private void CancelMassDisenchant()
+	{
+		CraftingTray.Get().m_massDisenchantButton.TriggerRelease();
+	}
+
+	internal void HideThis()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (!m_isPlayingAnim)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_isPlayingAnim)
+		{
+			return "";
+		}
+
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs b/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
index 3a0c603..6b68b50 100644
--- a/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
@@ -3,8 +3,9 @@ using System.Collections.Generic;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class MatchingPopupDisplay : TransitionPopup
+public class MatchingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	public UberText m_tipOfTheDay;
 
@@ -37,6 +38,8 @@ public class MatchingPopupDisplay : TransitionPopup
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -46,6 +49,9 @@ public class MatchingPopupDisplay : TransitionPopup
 		UpdateTipOfTheDay();
 		GenerateRandomSpinnerTexts(IsMultiOpponentGame());
 		m_title.Text = GetTitleTextBasedOnScenario();
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, m_title.Text, true);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
 		base.Show();
 	}
 
@@ -278,4 +284,18 @@ public class MatchingPopupDisplay : TransitionPopup
 		}
 		return record.Players > 2;
 	}
+
+	#region
+
+	public void HandleAccessibleInput()
+    {
+		HandleCancelButtonInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return HandleCancelButtonHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs b/Decompiled/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs
index 2f2992b..5f08066 100644
--- a/Decompiled/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs
+++ b/Decompiled/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs
@@ -5,8 +5,9 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using UnityEngine;
+using Accessibility;
 
-public class MercenariesSeasonRewardsDialog : DialogBase
+public class MercenariesSeasonRewardsDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/MercenariesZoneUnlockDialog.cs b/Decompiled/Assembly-CSharp/MercenariesZoneUnlockDialog.cs
index d95c373..d1c1328 100644
--- a/Decompiled/Assembly-CSharp/MercenariesZoneUnlockDialog.cs
+++ b/Decompiled/Assembly-CSharp/MercenariesZoneUnlockDialog.cs
@@ -1,10 +1,11 @@
 using System;
 using System.Collections;
+using Accessibility;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
 
-public class MercenariesZoneUnlockDialog : DialogBase
+public class MercenariesZoneUnlockDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
@@ -90,4 +91,15 @@ public class MercenariesZoneUnlockDialog : DialogBase
 	{
 		Hide();
 	}
+
+	#region Accessibility
+	public override void HandleAccessibleInput()
+	{
+		// Not really sure what this dialog is yet but might help someone
+		if (AccessibleKey.CONFIRM.IsPressed())
+		{
+			m_clickCatcher.TriggerRelease();
+		}
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MercenaryDetailDisplay.cs b/Decompiled/Assembly-CSharp/MercenaryDetailDisplay.cs
index 2ab94a1..6e6d7f5 100644
--- a/Decompiled/Assembly-CSharp/MercenaryDetailDisplay.cs
+++ b/Decompiled/Assembly-CSharp/MercenaryDetailDisplay.cs
@@ -913,7 +913,7 @@ public class MercenaryDetailDisplay : MonoBehaviour
 	protected void ShowRequiredTutorialIfNeeded()
 	{
 		LettuceMercenary lettuceMercenary = null;
-		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && (long)GetCurrentlyDisplayedMercenary().ID == 18)
+		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && (long)GetCurrentlyDisplayedMercenary().ID == 18)
 		{
 			lettuceMercenary = CollectionManager.Get().GetMercenary(18L);
 			if (lettuceMercenary.HasUnlockedGoldenOrBetter())
@@ -933,13 +933,13 @@ public class MercenaryDetailDisplay : MonoBehaviour
 		{
 			LettuceTutorialUtils.FireEvent(LettuceTutorialVo.LettuceTutorialEvent.VILLAGE_TUTORIAL_UPGRADE_ABILITY_START, base.gameObject);
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_ABILITY_UPGRADE, defaultVal: false) && flag && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:" + Option.HAS_SEEN_ABILITY_UPGRADE))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_ABILITY_UPGRADE, defaultVal: false) && flag && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:" + Option.HAS_SEEN_ABILITY_UPGRADE))
 		{
 			HideHelpPopups();
 			m_helpPopupType = Option.HAS_SEEN_ABILITY_UPGRADE;
 			m_tutorialCoroutine = StartCoroutine(ShowUpgradeAbilityTutorialWhenReady(lettuceMercenary));
 		}
-		else if (!Options.Get().GetBool(Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:" + Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL))
+		else if (!Options.Get().GetBool(Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:" + Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL))
 		{
 			HideHelpPopups();
 			m_helpPopupType = Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL;
@@ -949,7 +949,7 @@ public class MercenaryDetailDisplay : MonoBehaviour
 
 	protected void ShowAppearancePart2TutorialIfNeeded()
 	{
-		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && (long)GetCurrentlyDisplayedMercenary().ID == 18 && CollectionManager.Get().GetMercenary(18L).HasUnlockedGoldenOrBetter())
+		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && (long)GetCurrentlyDisplayedMercenary().ID == 18 && CollectionManager.Get().GetMercenary(18L).HasUnlockedGoldenOrBetter())
 		{
 			HideHelpPopups();
 			m_helpPopupType = Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL;
diff --git a/Decompiled/Assembly-CSharp/MiniSetProductPage.cs b/Decompiled/Assembly-CSharp/MiniSetProductPage.cs
index d65d96c..9e7fb13 100644
--- a/Decompiled/Assembly-CSharp/MiniSetProductPage.cs
+++ b/Decompiled/Assembly-CSharp/MiniSetProductPage.cs
@@ -3,6 +3,8 @@ using System.Linq;
 using Blizzard.T5.AssetManager;
 using Hearthstone.DataModels;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 public class MiniSetProductPage : ProductPage
 {
@@ -12,12 +14,12 @@ public class MiniSetProductPage : ProductPage
 
 	private ShopCardList m_cardList;
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		SetMusicOverride(MusicPlaylistType.Invalid);
 		m_cardList = new ShopCardList(m_widget, m_scrollbar);
 		m_firstVariantSet = true;
-		base.Open();
+		base.Open(true);
 		base.OnOpened += InitInput;
 	}
 
@@ -65,4 +67,79 @@ public class MiniSetProductPage : ProductPage
 		TAG_PREMIUM premium = (product.Tags.Contains("golden") ? TAG_PREMIUM.GOLDEN : TAG_PREMIUM.NORMAL);
 		m_cardList.SetPremium(premium);
 	}
+
+	#region Accessibility
+
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleCards;
+
+	protected override void SetupVariantMenuOptions(ProductDataModel variant)
+	{
+		var buyText = AccessibleShopUtils.GetBuyForGoldText(variant);
+
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_READ_DESCRIPTION), () => ReadVariantDescription(variant));
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_CARDS), () => ReadCards());
+		m_readingVariantMenu.AddOption(buyText, () => BuyVariant(variant));
+	}
+
+	private void ReadCards()
+	{
+		var cardTiles = m_cardList.m_dataModel.CardTiles;
+
+		var accessibleCards = new List<AccessibleCollectibleCard>(cardTiles.Count);
+
+		foreach (var card in cardTiles)
+        {
+			var cardId = card.CardId;
+			var cardQty = card.Count;
+			var entityDef = DefLoader.Get().GetEntityDef(cardId);
+			var cardRecord = GameUtils.GetCardRecord(cardId);
+			var collectibleCard = new CollectibleCard(cardRecord, entityDef, TAG_PREMIUM.NORMAL);
+			collectibleCard.OwnedCount = cardQty;
+			var accessibleCollectibleCard = new AccessibleCollectibleCard(m_container, collectibleCard, true, true);
+
+			accessibleCards.Add(accessibleCollectibleCard);
+        }
+
+		m_accessibleCards = new AccessibleListOfItems<AccessibleCollectibleCard>(m_container, accessibleCards);
+		m_accessibleCards.StartReading();
+		m_curState = State.READING_CARDS;
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		if (m_curState == State.READING_CARDS)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadVariantMenu();
+			}
+			else
+			{
+				var curTile = m_scrollbar.m_scrollableItems[m_accessibleCards.GetItemBeingReadIndex()];
+				if (m_accessibleCards.HandleAccessibleInput())
+				{
+					AccessibilityUtils.CenterScrollbarAroundObject(m_scrollbar, curTile.gameObject);
+				}
+				AccessibleInputMgr.MoveMouseTo(curTile);
+			}
+		}
+		else
+		{
+			base.HandleAccessibleInput();
+		}
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		if (m_curState == State.READING_CARDS)
+		{
+			return LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_CARDS_HELP);
+		}
+		else
+		{
+			return base.GetAccessibleHelp();
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MissionEntity.cs b/Decompiled/Assembly-CSharp/MissionEntity.cs
index f7dde89..02c967e 100644
--- a/Decompiled/Assembly-CSharp/MissionEntity.cs
+++ b/Decompiled/Assembly-CSharp/MissionEntity.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class MissionEntity : GameEntity
 {
@@ -1295,4 +1296,109 @@ public class MissionEntity : GameEntity
 		}
 		return list;
 	}
+
+    #region Missions with Turn Counters
+
+	private Notification m_turnCounter;
+
+	private string m_turnCounterText = ""; // Used for reading # of remaining turns when focusing on opponent's Hero
+
+	private bool m_isTurnCounterBasedMission = false; // Used to avoid race conditions after the counter is destroyed
+
+	// the key used by a particular mission to specify what should read in the banner.
+	// Not all "turn counter"-based missions are turns. e.g. Valeera 08 is "silent shadows left to defeat" but all componentry is reused
+	private string m_turnCounterKey;
+
+	// Not all of these are the same between missions but it's easier to keep them like this to force conflicts if Blizzard refactors any of this
+	private bool m_fsmRunningManVal;
+	private bool m_fsmMineCartVal;
+	private bool m_fsmAirshipVal;
+	private bool m_fsmDestroyerVal;
+
+    protected virtual void InitTurnCounterVisuals(string turnCounterKey, bool fsmRunningManVal, bool fsmMineCartVal, bool fsmAirshipVal, bool fsmDestroyerVal)
+	{
+		m_turnCounterKey = turnCounterKey;
+		m_fsmRunningManVal = fsmRunningManVal;
+		m_fsmMineCartVal = fsmMineCartVal;
+		m_fsmAirshipVal = fsmAirshipVal;
+		m_fsmDestroyerVal = fsmDestroyerVal;
+
+		m_isTurnCounterBasedMission = true;
+		int cost = GetCost();
+		InitTurnCounter(cost);
+	}
+
+	private void InitTurnCounter(int cost)
+	{
+		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
+		m_turnCounter = gameObject.GetComponent<Notification>();
+		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
+		component.FsmVariables.GetFsmBool("RunningMan").Value = m_fsmRunningManVal;
+		component.FsmVariables.GetFsmBool("MineCart").Value = m_fsmMineCartVal;
+		component.FsmVariables.GetFsmBool("Airship").Value = m_fsmAirshipVal;
+		component.FsmVariables.GetFsmBool("Destroyer").Value = m_fsmDestroyerVal;
+		component.SendEvent("Birth");
+		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
+			.GetActor();
+		m_turnCounter.transform.parent = actor.gameObject.transform;
+		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
+		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
+		UpdateTurnCounterText(cost);
+	}
+
+	protected virtual void UpdateTurnCounterVisualsIfNeeded(TagDelta change)
+    {
+		GAME_TAG tag = (GAME_TAG)change.tag;
+		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
+		{
+			UpdateTurnCounterVisuals(change.newValue);
+		}
+    }
+
+	private void UpdateTurnCounterVisuals(int cost)
+	{
+		UpdateTurnCounter(cost);
+	}
+
+	private void UpdateTurnCounter(int cost)
+	{
+		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
+		if (cost <= 0)
+		{
+			UnityEngine.Object.Destroy(m_turnCounter.gameObject);
+		}
+		else
+		{
+			UpdateTurnCounterText(cost);
+		}
+	}
+
+	private void UpdateTurnCounterText(int cost)
+	{
+		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+		{
+			new GameStrings.PluralNumber
+			{
+				m_index = 0,
+				m_number = cost
+			}
+		};
+		string headlineString = GameStrings.FormatPlurals(m_turnCounterKey, pluralNumbers);
+		string costString = cost.ToString();
+		m_turnCounter.ChangeDialogText(headlineString, costString, "", "");
+		m_turnCounterText = $"{costString} {headlineString}";
+		AccessibilityMgr.Output(AccessibleGameplay.Get(), m_turnCounterText);
+	}
+
+	public string GetTurnCounterText()
+    {
+		return m_turnCounterText;
+    }
+
+    public override bool IsTurnCounterBasedMission()
+    {
+		return m_isTurnCounterBasedMission;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MountRewardData.cs b/Decompiled/Assembly-CSharp/MountRewardData.cs
index de87265..e26110e 100644
--- a/Decompiled/Assembly-CSharp/MountRewardData.cs
+++ b/Decompiled/Assembly-CSharp/MountRewardData.cs
@@ -5,7 +5,8 @@ public class MountRewardData : RewardData
 		UNKNOWN,
 		WOW_HEARTHSTEED,
 		HEROES_MAGIC_CARPET_CARD,
-		WOW_SARGE_TALE
+		WOW_SARGE_TALE,
+		EOE
 	}
 
 	public MountType Mount { get; set; }
diff --git a/Decompiled/Assembly-CSharp/MulliganManager.cs b/Decompiled/Assembly-CSharp/MulliganManager.cs
index 5caad6e..1d8d911 100644
--- a/Decompiled/Assembly-CSharp/MulliganManager.cs
+++ b/Decompiled/Assembly-CSharp/MulliganManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using UnityEngine;
 
@@ -92,7 +93,7 @@ public class MulliganManager : MonoBehaviour
 
 	private bool mulliganActive;
 
-	private MulliganTimer m_mulliganTimer;
+	internal MulliganTimer m_mulliganTimer;
 
 	private NormalButton mulliganButton;
 
@@ -1469,13 +1470,25 @@ public class MulliganManager : MonoBehaviour
 			mulliganButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton();
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
-		}
+
+                if (AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+                }
+                else
+                {
+                    innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+                }
+            }
+        }
 		GameState.Get().GetGameEntity().StartMulliganSoundtracks(soft: true);
 		m_waitingForUserInput = true;
 		while (innkeeperMulliganDialog != null)
@@ -1490,6 +1503,10 @@ public class MulliganManager : MonoBehaviour
 		{
 			BeginDealNewCards();
 		}
+		else
+		{
+			AccessibleGameplay.Get().OnEnterMultiplayerWaitingArea(m_startingCards, mulliganBannerText, mulliganBannerSubtitleText, mulliganButton);
+		}
 	}
 
 	private IEnumerator DealStartingCards()
@@ -1502,7 +1519,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterIntroBeforeMulligan());
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.DO_OPENING_TAUNTS) && !Cheats.Get().ShouldSkipMulligan())
 		{
-			m_PlayStartingTaunts = PlayStartingTaunts();
+            m_PlayStartingTaunts = PlayStartingTaunts();
 			StartCoroutine(m_PlayStartingTaunts);
 		}
 		Player friendlySidePlayer = GameState.Get().GetFriendlySidePlayer();
@@ -1510,11 +1527,11 @@ public class MulliganManager : MonoBehaviour
 		GetStartingLists();
 		if (m_startingCards.Count == 0)
 		{
-			SkipCardChoosing();
+            SkipCardChoosing();
 		}
 		foreach (Card startingCard in m_startingCards)
 		{
-			startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
 			startingCard.GetActor().TurnOffCollider();
 			startingCard.GetActor().GetMeshRenderer().gameObject.layer = 8;
 			startingCard.GetActor().m_nameTextMesh.UpdateNow();
@@ -1533,15 +1550,15 @@ public class MulliganManager : MonoBehaviour
 		int numCardsToDealExcludingBonusCard = m_startingCards.Count;
 		if (!friendlyPlayerGoesFirst)
 		{
-			numCardsToDealExcludingBonusCard = m_bonusCardIndex;
+            numCardsToDealExcludingBonusCard = m_bonusCardIndex;
 			spacingToUse = spaceForEachCard;
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
 			if (m_coinCardIndex >= 0)
 			{
-				m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
+                m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
 			}
 		}
 		opposingSideHandZone.SetDoNotUpdateLayout(enable: false);
@@ -1558,9 +1575,10 @@ public class MulliganManager : MonoBehaviour
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeDealingBaseMulliganCards());
 		float xOffset2 = spacingToUse / 2f;
+		AccessibleGameplay.Get().OnStartingHand(m_startingCards);
 		for (int i = 0; i < numCardsToDealExcludingBonusCard; i++)
 		{
-			GameObject topCard = m_startingCards[i].gameObject;
+            GameObject topCard = m_startingCards[i].gameObject;
 			iTween.Stop(topCard);
 			Vector3[] array = new Vector3[3]
 			{
@@ -1594,11 +1612,12 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeCoinFlip());
 		if (coinObject != null)
 		{
-			Transform transform = Board.Get().FindBone("MulliganCoinPosition");
+            Transform transform = Board.Get().FindBone("MulliganCoinPosition");
 			coinObject.transform.position = transform.position;
 			coinObject.transform.localEulerAngles = transform.localEulerAngles;
 			coinObject.SetActive(value: true);
 			coinObject.GetComponent<CoinEffect>().DoAnim(friendlyPlayerGoesFirst);
+			AccessibleGameplay.Get().OnCoinResult(friendlyPlayerGoesFirst);
 			SoundManager.Get().LoadAndPlay("FX_MulliganCoin03_CoinFlip.prefab:07015cb3f02713a45aa03fc3aa798778", coinObject);
 			coinLocation = transform.position;
 			AssetLoader.Get().InstantiatePrefab("MulliganResultText.prefab:0369b435afd2e344db21e58648f8636c", CoinTossTextCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
@@ -1607,7 +1626,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterCoinFlip());
 		if (!friendlyPlayerGoesFirst)
 		{
-			GameObject topCard = m_startingCards[m_bonusCardIndex].gameObject;
+            GameObject topCard = m_startingCards[m_bonusCardIndex].gameObject;
 			Vector3[] array2 = new Vector3[3]
 			{
 				topCard.transform.position,
@@ -1622,7 +1641,7 @@ public class MulliganManager : MonoBehaviour
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
 			opposingSideHandZone.UpdateLayout(null, forced: true, 4);
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterDealingBonusCard());
@@ -1634,7 +1653,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeSpreadingMulliganCards());
 		if (friendlyPlayerGoesFirst)
 		{
-			xOffset2 = 0f;
+            xOffset2 = 0f;
 			for (int num3 = m_startingCards.Count - 1; num3 >= 0; num3--)
 			{
 				GameObject target = m_startingCards[num3].gameObject;
@@ -1644,22 +1663,23 @@ public class MulliganManager : MonoBehaviour
 			}
 		}
 		GameState.Get().GetGameEntity().OnMulliganCardsDealt(m_startingCards);
+		AccessibleGameplay.Get().OnMulliganCardsDealt(m_startingCards);
 		yield return new WaitForSeconds(0.6f);
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterSpreadingMulliganCards());
 		if (skipCardChoosing)
 		{
-			if (GameState.Get().IsMulliganPhase())
+            if (GameState.Get().IsMulliganPhase())
 			{
-				if (GameState.Get().IsFriendlySidePlayerTurn())
+                if (GameState.Get().IsFriendlySidePlayerTurn())
 				{
-					TurnStartManager.Get().BeginListeningForTurnEvents();
+                    TurnStartManager.Get().BeginListeningForTurnEvents();
 				}
 				m_WaitForOpponentToFinishMulligan = WaitForOpponentToFinishMulligan();
 				StartCoroutine(m_WaitForOpponentToFinishMulligan);
 			}
 			else
 			{
-				yield return new WaitForSeconds(2f);
+                yield return new WaitForSeconds(2f);
 				EndMulligan();
 			}
 			yield break;
@@ -1693,12 +1713,26 @@ public class MulliganManager : MonoBehaviour
 			mulliganButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton();
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
+
+				if (AccessibilityMgr.IsAccessibilityEnabled())
+				{
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+				}
+				else
+                {
+                    innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+                }
+            }
+
+			AccessibleGameplay.Get().OnMulliganChoiceStart(m_startingCards, mulliganButton);
 		}
 		GameState.Get().GetGameEntity().StartMulliganSoundtracks(soft: true);
 		m_waitingForUserInput = true;
@@ -2377,6 +2411,7 @@ public class MulliganManager : MonoBehaviour
 
 	private IEnumerator WaitForOpponentToFinishMulligan()
 	{
+		AccessibleGameplay.Get().WaitingForOpponentToFinishMulligan();
 		DestroyChooseBanner();
 		DestroyDetailLabel();
 		DestroyTagConditionalVFXs();
@@ -2951,6 +2986,7 @@ public class MulliganManager : MonoBehaviour
 
 	public void EndMulligan()
 	{
+		AccessibleGameplay.Get().EndMulligan();
 		m_waitingForUserInput = false;
 		if (m_replaceLabels != null)
 		{
@@ -3090,7 +3126,7 @@ public class MulliganManager : MonoBehaviour
 				coinObject.GetComponentInChildren<PlayMakerFSM>().SendEvent("Birth");
 				yield return new WaitForSeconds(0.1f);
 			}
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_COIN_INTRO"), "VO_INNKEEPER_COIN_INTRO.prefab:6fb1b3b124d474c4c84e392646caada4");
 				Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, val: true);
@@ -3148,6 +3184,7 @@ public class MulliganManager : MonoBehaviour
 
 	private void CoinCardSummonFinishedCallback(Spell spell, object userData)
 	{
+		AccessibleGameplay.Get().OnCoinCard();
 		Card card = SceneUtils.FindComponentInParents<Card>(spell);
 		card.RefreshActor();
 		card.UpdateActorComponents();
diff --git a/Decompiled/Assembly-CSharp/MulliganTimer.cs b/Decompiled/Assembly-CSharp/MulliganTimer.cs
index e0c361b..e968c03 100644
--- a/Decompiled/Assembly-CSharp/MulliganTimer.cs
+++ b/Decompiled/Assembly-CSharp/MulliganTimer.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class MulliganTimer : MonoBehaviour
 {
@@ -33,6 +34,7 @@ public class MulliganTimer : MonoBehaviour
 		{
 			num2 = 0;
 		}
+		UpdateAccessibleTimer(num2);
 		m_timeText.Text = $":{num2:D2}";
 		if (!(num > 0f))
 		{
@@ -77,4 +79,21 @@ public class MulliganTimer : MonoBehaviour
 	{
 		Object.Destroy(base.gameObject);
 	}
+
+	#region Accessibility
+
+	private int m_prevSeconds;
+
+	private void UpdateAccessibleTimer(int curSeconds)
+	{
+		AccessibilityUtils.OutputTimerIfNecessary(curSeconds, m_prevSeconds);
+
+		m_prevSeconds = curSeconds;
+	}
+
+	internal void OutputSecondsRemaining()
+	{
+		AccessibilityUtils.OutputSecondsRemaining(m_prevSeconds);
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MultiPagePopup.cs b/Decompiled/Assembly-CSharp/MultiPagePopup.cs
index 114e077..8b7efd4 100644
--- a/Decompiled/Assembly-CSharp/MultiPagePopup.cs
+++ b/Decompiled/Assembly-CSharp/MultiPagePopup.cs
@@ -1,9 +1,10 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
 
 [CustomEditClass]
-public class MultiPagePopup : DialogBase
+public class MultiPagePopup : InaccessibleDialogBase
 {
 	public enum PageType
 	{
@@ -26,6 +27,8 @@ public class MultiPagePopup : DialogBase
 		public List<int> m_cards;
 
 		public int m_dustAmount;
+
+		public PageInfo(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	public class Info
@@ -35,6 +38,8 @@ public class MultiPagePopup : DialogBase
 		public bool m_blurWhenShown;
 
 		public List<PageInfo> m_pages = new List<PageInfo>();
+
+		public Info(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	private readonly Map<PageType, string> m_pagePrefabRefs = new Map<PageType, string>
@@ -55,7 +60,7 @@ public class MultiPagePopup : DialogBase
 	[CustomEditField(Sections = "Sounds", T = EditType.SOUND_PREFAB)]
 	public string m_hideAnimationSound = "Shrink_Down_Quicker.prefab:2fe963b171811ca4b8d544fa53e3330c";
 
-	private Info m_info = new Info();
+	private Info m_info = new Info(true);
 
 	private int m_currentPageIdx;
 
@@ -63,6 +68,11 @@ public class MultiPagePopup : DialogBase
 
 	private int m_numPagesLoaded;
 
+	private MultiPagePopup()
+    {
+		// Protect against constructors due to accessibility and the fact that this has a dangling m_info (Info subclass)
+    }
+
 	protected override void OnDestroy()
 	{
 		base.OnDestroy();
diff --git a/Decompiled/Assembly-CSharp/NameBanner.cs b/Decompiled/Assembly-CSharp/NameBanner.cs
index 3d46ace..410dd98 100644
--- a/Decompiled/Assembly-CSharp/NameBanner.cs
+++ b/Decompiled/Assembly-CSharp/NameBanner.cs
@@ -987,7 +987,7 @@ public class NameBanner : MonoBehaviour
 		return (HonorManager.FactionChoice)GetPlayerForSide(playerSide).GetTag(GAME_TAG.AVFACTION);
 	}
 
-	private static string GetRankNameForSide(Player.Side playerSide)
+	internal static string GetRankNameForSide(Player.Side playerSide)
 	{
 		Player playerForSide = GetPlayerForSide(playerSide);
 		int faction = playerForSide.GetTag(GAME_TAG.AVFACTION);
diff --git a/Decompiled/Assembly-CSharp/NarrativeManager.cs b/Decompiled/Assembly-CSharp/NarrativeManager.cs
index 2329db6..0d5cce1 100644
--- a/Decompiled/Assembly-CSharp/NarrativeManager.cs
+++ b/Decompiled/Assembly-CSharp/NarrativeManager.cs
@@ -872,7 +872,7 @@ public class NarrativeManager : MonoBehaviour
 		{
 			return false;
 		}
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/NetCache.cs b/Decompiled/Assembly-CSharp/NetCache.cs
index 907665d..c193a2e 100644
--- a/Decompiled/Assembly-CSharp/NetCache.cs
+++ b/Decompiled/Assembly-CSharp/NetCache.cs
@@ -18,6 +18,7 @@ using PegasusLettuce;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class NetCache : IService, IHasUpdate
 {
@@ -2624,24 +2625,50 @@ public class NetCache : IService, IHasUpdate
 		return GetNetObject<T>() != null;
 	}
 
+	#region Accessibility
+	private NetCacheBoosters m_testNetCacheBoosters;
+
+    internal void SetTestDataNetCacheBoosters(NetCacheBoosters netCacheBoosters)
+    {
+		m_testNetCacheBoosters = netCacheBoosters;
+    }
+	#endregion
+
 	private object GetTestData(Type type)
 	{
+		if (type == typeof(NetCacheBoosters) && m_testNetCacheBoosters != null)
+        {
+			return m_testNetCacheBoosters;
+        }
+
 		if (type == typeof(NetCacheBoosters) && GameUtils.IsFakePackOpeningEnabled())
 		{
 			NetCacheBoosters netCacheBoosters = new NetCacheBoosters();
 			int fakePackCount = GameUtils.GetFakePackCount();
-			BoosterStack item = new BoosterStack
-			{
-				Id = 1,
-				Count = fakePackCount
-			};
-			netCacheBoosters.BoosterStacks.Add(item);
+			AddTestPack(netCacheBoosters.BoosterStacks, 1, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 23, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 468, 7);
+			AddTestPack(netCacheBoosters.BoosterStacks, 470, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 545, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 553, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 616, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 633, 1);
 			return netCacheBoosters;
 		}
 		return null;
 	}
 
-	public void UnloadNetObject<T>()
+    private void AddTestPack(List<BoosterStack> boosterStacks, int packId, int packCount)
+    {
+		BoosterStack item = new BoosterStack
+		{
+			Id = packId,
+			Count = packCount
+		};
+		boosterStacks.Add(item);
+    }
+
+    public void UnloadNetObject<T>()
 	{
 		Type typeFromHandle = typeof(T);
 		m_netCache[typeFromHandle] = null;
@@ -2659,6 +2686,11 @@ public class NetCache : IService, IHasUpdate
 
 	public long GetArcaneDustBalance()
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return 327;
+		}
+
 		NetCacheArcaneDustBalance netObject = GetNetObject<NetCacheArcaneDustBalance>();
 		if (netObject == null)
 		{
diff --git a/Decompiled/Assembly-CSharp/Network.cs b/Decompiled/Assembly-CSharp/Network.cs
index 10b5a44..7e5a857 100644
--- a/Decompiled/Assembly-CSharp/Network.cs
+++ b/Decompiled/Assembly-CSharp/Network.cs
@@ -33,6 +33,7 @@ using Shared.Scripts.Game.Shop.Product;
 using Shared.Scripts.Util.ValueTypes;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 public class Network : IHasUpdate, IService
 {
@@ -3615,6 +3616,12 @@ public class Network : IHasUpdate, IService
 
 	public void BuyCard(int assetId, TAG_PREMIUM premium, int count, int unitBuyPrice, int currentCollectionCount)
 	{
+		if (AccessibleCraftingTestingUtils.IsTestingCrafting())
+		{
+			AccessibleCraftingTestingUtils.BuyCard(assetId, premium, count, unitBuyPrice, currentCollectionCount);
+			return;
+		}
+
 		PegasusShared.CardDef cardDef = new PegasusShared.CardDef
 		{
 			Asset = assetId
@@ -3628,6 +3635,12 @@ public class Network : IHasUpdate, IService
 
 	public void SellCard(int assetId, TAG_PREMIUM premium, int count, int unitSellPrice, int currentCollectionCount)
 	{
+		if (AccessibleCraftingTestingUtils.IsTestingCrafting())
+		{
+			AccessibleCraftingTestingUtils.SellCard(assetId, premium, count, unitSellPrice, currentCollectionCount);
+			return;
+		}
+
 		PegasusShared.CardDef cardDef = new PegasusShared.CardDef
 		{
 			Asset = assetId
@@ -6472,6 +6485,12 @@ public class Network : IHasUpdate, IService
 
 	public void MassDisenchant()
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			AccessibleCraftingTestingUtils.DoMassDisenchant();
+			return;
+		}
+
 		m_connectApi.MassDisenchant();
 	}
 
@@ -6769,6 +6788,11 @@ public class Network : IHasUpdate, IService
 
 	public void PurchaseViaGold(int quantity, ProductType productItemType, int data)
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return;
+		}
+
 		if (!IsLoggedIn())
 		{
 			Log.All.PrintError("Client attempted to make a gold purchase while offline!");
@@ -6781,6 +6805,11 @@ public class Network : IHasUpdate, IService
 
 	public void GetPurchaseMethod(long? pmtProductId, int quantity, Currency currency)
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return;
+		}
+
 		m_connectApi.RequestPurchaseMethod(pmtProductId, quantity, currency.toProto(), SystemInfo.deviceUniqueIdentifier, GetPlatformBuilder());
 	}
 
diff --git a/Decompiled/Assembly-CSharp/NotificationManager.cs b/Decompiled/Assembly-CSharp/NotificationManager.cs
index a2bd509..ddc9462 100644
--- a/Decompiled/Assembly-CSharp/NotificationManager.cs
+++ b/Decompiled/Assembly-CSharp/NotificationManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -249,7 +250,7 @@ public class NotificationManager : MonoBehaviour
 
 	private Notification popUpDialog;
 
-	private Notification m_quote;
+	internal Notification m_quote;
 
 	private List<string> m_quotesThisSession;
 
@@ -329,28 +330,28 @@ public class NotificationManager : MonoBehaviour
 		return s_instance;
 	}
 
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
-	{
-		return CreatePopupDialog(headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
-	}
-
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
-	{
-		if (popUpDialog != null)
-		{
-			UnityEngine.Object.Destroy(popUpDialog.gameObject);
-		}
-		GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
-		Vector3 position = Camera.main.transform.position;
-		gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
-		popUpDialog = gameObject.GetComponent<Notification>();
-		popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
-		popUpDialog.PlayBirth();
-		UniversalInputManager.Get().SetGameDialogActive(active: true);
-		return popUpDialog;
-	}
-
-	public Notification CreateSpeechBubble(string speechText, Actor actor)
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
+    {
+        return CreatePopupDialog(accessible, headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
+    }
+
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
+    {
+        if (popUpDialog != null)
+        {
+            UnityEngine.Object.Destroy(popUpDialog.gameObject);
+        }
+        GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
+        Vector3 position = Camera.main.transform.position;
+        gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
+        popUpDialog = gameObject.GetComponent<Notification>();
+        popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
+        popUpDialog.PlayBirth();
+        UniversalInputManager.Get().SetGameDialogActive(active: true);
+        return popUpDialog;
+    }
+
+    public Notification CreateSpeechBubble(string speechText, Actor actor)
 	{
 		return CreateSpeechBubble(speechText, Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: false);
 	}
@@ -467,12 +468,13 @@ public class NotificationManager : MonoBehaviour
 			DestroyNotification(component, options.emoteDuration);
 		}
 		component.notificationGroup = options.speechBubbleGroup;
+		AccessibleNotificationMgr.OnCreateNotificationWithSound(component);
 		return component;
 	}
 
 	public Notification CreateBouncingArrow(UserAttentionBlocker blocker, bool addToList)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManger.CreateBouncingArrow"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManger.CreateBouncingArrow"))
 		{
 			return null;
 		}
@@ -492,7 +494,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreateBouncingArrow(UserAttentionBlocker blocker, Vector3 position, Vector3 rotation, bool addToList, float scaleFactor = 1f)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManger.CreateBouncingArrow"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManger.CreateBouncingArrow"))
 		{
 			return null;
 		}
@@ -538,7 +540,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreatePopupText(UserAttentionBlocker blocker, Vector3 position, Vector3 scale, string text, bool convertLegacyPosition = true, PopupTextType popupTextType = PopupTextType.BASIC)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreatePopupText"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreatePopupText"))
 		{
 			return null;
 		}
@@ -558,6 +560,7 @@ public class NotificationManager : MonoBehaviour
 		component.PlayBirth();
 		component.OnDestroyCallback = (Action<Notification>)Delegate.Combine(component.OnDestroyCallback, new Action<Notification>(OnPopupTextDestroy));
 		popUpTexts.Add(component);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(component);
 		return component;
 	}
 
@@ -573,7 +576,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreateInnkeeperQuote(UserAttentionBlocker blocker, Vector3 position, string text, string soundPath, float durationSeconds = 0f, Action<int> finishCallback = null, bool clickToDismiss = false)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreateInnkeeperQuote"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreateInnkeeperQuote"))
 		{
 			finishCallback?.Invoke(0);
 			return null;
@@ -800,7 +803,8 @@ public class NotificationManager : MonoBehaviour
 			return;
 		}
 		m_quote.PlayBirthWithForcedScale(Vector3.one);
-		if (durationSeconds > 0f)
+        AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        if (durationSeconds > 0f)
 		{
 			if (persistCharacter)
 			{
@@ -830,8 +834,9 @@ public class NotificationManager : MonoBehaviour
 			quoteSoundCallbackData.m_quote = m_quote;
 			quoteSoundCallbackData.m_durationSeconds = durationSeconds;
 			SoundLoader.LoadSound(soundPath, OnQuoteSoundLoaded, quoteSoundCallbackData, SoundManager.Get().GetPlaceholderSound());
-		}
-		else
+            AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        }
+        else
 		{
 			PlayQuoteWithoutSound(durationSeconds, text);
 		}
@@ -840,6 +845,7 @@ public class NotificationManager : MonoBehaviour
 	private void PlayQuoteWithoutSound(float durationSeconds, string text = null)
 	{
 		m_quote.PlayBirthWithForcedScale(UniversalInputManager.UsePhoneUI ? NOTIFICATION_SCALE_PHONE : NOTIFICATION_SCALE);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(m_quote);
 		if (durationSeconds <= 0f && text != null)
 		{
 			durationSeconds = ClipLengthEstimator.StringToReadTime(text);
diff --git a/Decompiled/Assembly-CSharp/Option.cs b/Decompiled/Assembly-CSharp/Option.cs
index 8640e4d..03bd03c 100644
--- a/Decompiled/Assembly-CSharp/Option.cs
+++ b/Decompiled/Assembly-CSharp/Option.cs
@@ -608,5 +608,12 @@ public enum Option
 	[Description("hasEncounteredFriendlySpeedTie")]
 	HAS_ENCOUNTERED_FRIENDLY_SPEED_TIE,
 	[Description("hasSeenMercAppearnceTutorial")]
-	HAS_SEEN_MERC_APPEARANCE_TUTORIAL
+	HAS_SEEN_MERC_APPEARANCE_TUTORIAL,
+
+	#region Accessibility
+	[Description("accessibilityGameSpeed")]
+	ACCESSIBILITY_GAME_SPEED,
+	[Description("accessibilityBattlegroundsNarrateAttacks")]
+	ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/OptionDataTables.cs b/Decompiled/Assembly-CSharp/OptionDataTables.cs
index 3996205..052097d 100644
--- a/Decompiled/Assembly-CSharp/OptionDataTables.cs
+++ b/Decompiled/Assembly-CSharp/OptionDataTables.cs
@@ -680,6 +680,16 @@ public class OptionDataTables
 			Option.FORMAT_TYPE_LAST_PLAYED,
 			typeof(int)
 		},
+		#region Accessibility
+		{
+      Option.ACCESSIBILITY_GAME_SPEED,
+			typeof(int)
+    },
+		{
+      Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS,
+			typeof(bool)
+    },
+		#endregion
 		{
 			Option.AADC_LOCAL_SAVE_TIME_STAMP,
 			typeof(ulong)
@@ -738,7 +748,7 @@ public class OptionDataTables
 		},
 		{
 			Option.SOUND_VOLUME,
-			1f
+			0.5f // Start lower due to screen readers as it's easier for beginners
 		},
 		{
 			Option.MUSIC_VOLUME,
@@ -1184,6 +1194,16 @@ public class OptionDataTables
 			Option.HAS_SEEN_CLASSIC_MODE_VO,
 			false
 		},
+		#region Accessibility
+    {
+			Option.ACCESSIBILITY_GAME_SPEED,
+			3
+	},
+    {
+			Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS,
+			true
+	},
+		#endregion
 		{
 			Option.DEBUG_SHOW_BATTLEGROUND_SKIN_IDS,
 			false
diff --git a/Decompiled/Assembly-CSharp/OptionsMenu.cs b/Decompiled/Assembly-CSharp/OptionsMenu.cs
index 10b6899..9a2fe6d 100644
--- a/Decompiled/Assembly-CSharp/OptionsMenu.cs
+++ b/Decompiled/Assembly-CSharp/OptionsMenu.cs
@@ -4,9 +4,10 @@ using Blizzard.T5.Configuration;
 using Hearthstone;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class OptionsMenu : MonoBehaviour
+public class OptionsMenu : MonoBehaviour, AccessibleUI
 {
 	public delegate void hideHandler();
 
@@ -260,10 +261,13 @@ public class OptionsMenu : MonoBehaviour
 		UpdateOtherUI();
 		ShowOrHide(showOrHide: true);
 		AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
+
+		ReadMenu();
 	}
 
 	public void Hide(bool callHideHandler = true)
 	{
+		AccessibilityMgr.HideUI(this);
 		ShowOrHide(showOrHide: false);
 		if (m_hideHandler != null && callHideHandler)
 		{
@@ -354,7 +358,7 @@ public class OptionsMenu : MonoBehaviour
 
 	private bool CanShowOtherMenuOptions()
 	{
-		if (UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: false) != 0)
+		if (UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: false) != 0)
 		{
 			return false;
 		}
@@ -645,4 +649,132 @@ public class OptionsMenu : MonoBehaviour
 		m_privacyMenu.Show(playSound: false);
 		m_privacyMenuLoading = false;
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleScrollbarControl m_accessibleScrollbar;
+
+	private AccessibleCheckBox m_accessibleCheckBox;
+
+	private AccessibleDropdownControl m_accessibleDropdown;
+
+	private enum AccessibleMenuState { MAIN_MENU, ADJUSTING_MASTER_VOLUME, ADJUSTING_MUSIC_VOLUME, ADJUSTING_GRAPHICS_QUALITY, ADJUSTING_GRAPHICS_RESOLUTION };
+
+	private AccessibleMenuState m_curState;
+
+	private void ReadMenu()
+    {
+        AccessibilityMgr.ShowUI(this);
+
+		SetupMainMenu();
+    }
+
+	private void SetupMainMenu()
+    {
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_TITLE), () => Hide(), true);
+
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MASTER_VOLUME_OPTION), OnClickMasterVolume);
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MUSIC_VOLUME_OPTION), OnClickMusicVolume);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION)), OnToggleSoundInBackground);
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION), OnClickGraphicsResolutionDropdown);
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_GRAPHICS_QUALITY_OPTION), OnClickGraphicsQualityDropdown);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FULLSCREEN_OPTION)), OnToggleFullscreen);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ALLOW_SPECTATORS_OPTION)), OnToggleAllowSpectators);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION)), OnToggleScreenShake);
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void BackToMainMenu()
+    {
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu.ReadCurrentOption();
+    }
+
+    private void OnClickGraphicsQualityDropdown()
+    {
+		m_accessibleDropdown = new AccessibleDropdownControl(this, m_graphicsQuality, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_GRAPHICS_QUALITY;
+		m_accessibleDropdown.StartReading();
+    }
+
+    private void OnClickGraphicsResolutionDropdown()
+    {
+		m_accessibleDropdown = new AccessibleDropdownControl(this, m_graphicsRes, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_GRAPHICS_RESOLUTION;
+		m_accessibleDropdown.StartReading();
+    }
+
+    private void OnClickMasterVolume()
+    {
+		m_accessibleScrollbar = new AccessibleScrollbarControl(this, m_masterVolume, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_MASTER_VOLUME;
+		AccessibilityMgr.Output(this, LocalizedText.OPTIONS_MENU_ADJUST_VOLUME);
+    }
+
+    private void OnClickMusicVolume()
+    {
+		m_accessibleScrollbar = new AccessibleScrollbarControl(this, m_musicVolume, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_MUSIC_VOLUME;
+		AccessibilityMgr.Output(this, LocalizedText.OPTIONS_MENU_ADJUST_VOLUME);
+    }
+
+    private void OnToggleFullscreen()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_fullScreenCheckbox);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    private void OnToggleSoundInBackground()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_backgroundSound);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    private void OnToggleAllowSpectators()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_spectatorOpenJoinCheckbox);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    private void OnToggleScreenShake()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_screenShakeCheckbox);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+        {
+            m_accessibleMenu?.HandleAccessibleInput();
+        }
+		else if (m_curState == AccessibleMenuState.ADJUSTING_MASTER_VOLUME || m_curState == AccessibleMenuState.ADJUSTING_MUSIC_VOLUME)
+        {
+			m_accessibleScrollbar?.HandleInput();
+        }
+		else if (m_curState == AccessibleMenuState.ADJUSTING_GRAPHICS_QUALITY || m_curState == AccessibleMenuState.ADJUSTING_GRAPHICS_RESOLUTION)
+        {
+			m_accessibleDropdown?.HandleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+        {
+            return m_accessibleMenu?.GetHelp();
+        }
+		else if (m_curState == AccessibleMenuState.ADJUSTING_MASTER_VOLUME || m_curState == AccessibleMenuState.ADJUSTING_MUSIC_VOLUME)
+        {
+			return LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ADJUST_VOLUME);
+        }
+
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs b/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
index f5bc7a8..88c2b04 100644
--- a/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
+++ b/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using System;
 using System.Collections;
 using UnityEngine;
 
-public class OutstandingDraftTicketDialog : DialogBase
+public class OutstandingDraftTicketDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/PackOpening.cs b/Decompiled/Assembly-CSharp/PackOpening.cs
index b594fec..d702051 100644
--- a/Decompiled/Assembly-CSharp/PackOpening.cs
+++ b/Decompiled/Assembly-CSharp/PackOpening.cs
@@ -8,8 +8,9 @@ using PegasusLettuce;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
-public class PackOpening : MonoBehaviour
+public class PackOpening : MonoBehaviour, AccessibleScreen
 {
 	public PackOpeningBones m_Bones;
 
@@ -528,12 +529,12 @@ public class PackOpening : MonoBehaviour
 		BnetBar.Get().HideCurrencyTemporarily();
 		if (GameUtils.IsFakePackOpeningEnabled())
 		{
-			StartCoroutine(OnFakeBoosterOpened());
+			StartCoroutine(OnFakeBoosterOpened(pack.GetBoosterId()));
 		}
 		m_UnopenedPackScroller.Pause(pause: true);
 	}
 
-	private IEnumerator OnFakeBoosterOpened()
+	private IEnumerator OnFakeBoosterOpened(int boosterId)
 	{
 		float seconds = UnityEngine.Random.Range(0f, 1f);
 		yield return new WaitForSeconds(seconds);
@@ -558,6 +559,10 @@ public class PackOpening : MonoBehaviour
 		boosterCard.Def.Name = "EX1_350";
 		boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
 		list.Add(boosterCard);
+
+		//
+		m_director.Play(boosterId);
+		m_autoOpenPending = false;
 		m_director.OnBoosterOpened(list);
 	}
 
@@ -746,13 +751,19 @@ public class PackOpening : MonoBehaviour
 			m_InputBlocker.SetActive(value: false);
 			CreateDirector();
 			LayoutPacks(animate: true);
+			ReadChoosePack();
 		}
 		BnetBar.Get().RefreshCurrency();
 	}
 
 	private void ShowHintOnUnopenedPack()
 	{
-		if (!m_shown || Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) || !UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnUnopenedPack"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// This is a visual notification
+			return;
+		}
+		if (!m_shown || Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) || !UserAttentionManager.CanShowAttentionGrabber(true, "PackOpening.ShowHintOnUnopenedPack"))
 		{
 			return;
 		}
@@ -797,7 +808,7 @@ public class PackOpening : MonoBehaviour
 
 	private void ShowHintOnSlot()
 	{
-		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnSlot"))
+		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "PackOpening.ShowHintOnSlot"))
 		{
 			if (m_hintArrow == null)
 			{
@@ -870,9 +881,11 @@ public class PackOpening : MonoBehaviour
 				unopenedPack.Value.SetEnabled(enabled: true);
 			}
 		}
+
+		AccessibilityOnUpdateUIEvents();
 	}
 
-	private void UnregisterUIEvents()
+    private void UnregisterUIEvents()
 	{
 		m_enableBackButton = false;
 		m_BackButton.SetEnabled(enabled: false);
@@ -944,21 +957,26 @@ public class PackOpening : MonoBehaviour
 		ShowHintOnUnopenedPack();
 	}
 
-	private void AutomaticallyOpenPack()
+	private void AutomaticallyOpenPack(UnopenedPack pack)
 	{
 		HideUnopenedPackTooltip();
-		UnopenedPack value = null;
-		if (!m_unopenedPacks.TryGetValue(m_lastOpenedBoosterId, out value) || value.GetCount() == 0)
+		UnopenedPack value = pack;
+		if (value == null)
 		{
-			foreach (KeyValuePair<int, UnopenedPack> unopenedPack in m_unopenedPacks)
+			// Normal HS flow - This is not used by HSA since we specifically pass a pack in
+			if (!m_unopenedPacks.TryGetValue(m_lastOpenedBoosterId, out value) || value.GetCount() == 0)
 			{
-				if (!(unopenedPack.Value == null) && unopenedPack.Value.GetCount() > 0)
+				foreach (KeyValuePair<int, UnopenedPack> unopenedPack in m_unopenedPacks)
 				{
-					value = unopenedPack.Value;
-					break;
+					if (!(unopenedPack.Value == null) && unopenedPack.Value.GetCount() > 0)
+					{
+						value = unopenedPack.Value;
+						break;
+					}
 				}
 			}
 		}
+
 		if (!(value == null) && value.CanOpenPack())
 		{
 			if (m_draggedPack != null || m_InputBlocker.activeSelf)
@@ -1084,7 +1102,7 @@ public class PackOpening : MonoBehaviour
 			yield return null;
 		}
 		yield return new WaitForSeconds(waitTime);
-		AutomaticallyOpenPack();
+		AutomaticallyOpenPack(null);
 	}
 
 	private void OnPackOpeningCardFXLoaded(AssetReference assetRef, GameObject go, object callbackData)
@@ -1155,4 +1173,161 @@ public class PackOpening : MonoBehaviour
 		DialogManager.Get().ShowReconnectHelperDialog();
 		Navigation.Clear();
 	}
+
+    #region Accessibility
+	private enum AccessibleState { LOADING, CHOOSING_PACK };
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleListOfItems<AccessibleUnopenedPack> m_accessiblePacks;
+
+    private void AccessibilityOnUpdateUIEvents()
+    {
+		AccessibilityMgr.SetScreen(this);
+    }
+
+    private void ReadChoosePack()
+    {
+		m_curAccessibleState = AccessibleState.CHOOSING_PACK;
+
+		if (GetNumUnopenedPacks() == 0)
+        {
+			// Players can't enter the screen if they don't have card packs. The screen sends them back to Hub if they've opened all
+			return;
+        }
+
+		if (m_accessiblePacks != null && m_accessiblePacks.Count == GetNumUnopenedPacks())
+        {
+			m_accessiblePacks.StartReading();
+			return;
+        }
+
+		var unopenedPacks = GetSortedUnopenedPacks();
+		var accessiblePacks = new List<AccessibleUnopenedPack>();
+
+        foreach (var pack in unopenedPacks)
+        {
+			if (pack.GetCount() > 0)
+            {
+                accessiblePacks.Add(new AccessibleUnopenedPack(this, pack));
+            }
+        }
+
+		m_accessiblePacks = new AccessibleListOfItems<AccessibleUnopenedPack>(this, accessiblePacks);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS));
+		m_accessiblePacks.StartReading();
+        AccessibilityUtils.CenterScrollbarAroundObject(m_UnopenedPackScroller, m_accessiblePacks.GetItemBeingRead().GetUnopenedPack().gameObject);
+    }
+
+    private List<UnopenedPack> GetSortedUnopenedPacks()
+    {
+		// Index by game object to compare
+		var gameObjectIndex = new Dictionary<GameObject, int>();
+		var spacedObjects = m_UnopenedPackContainer.m_Objects;
+		for (var i = 0; i < spacedObjects.Count; i++) 
+        {
+			var spacedObject = spacedObjects[i];
+			if (spacedObject != null && spacedObject.m_Object != null)
+            {
+                gameObjectIndex.Add(spacedObject.m_Object, i);
+            }
+        }
+
+		// Use index to sort
+		var ret = new List<UnopenedPack>();
+		ret.AddRange(m_unopenedPacks.Values);
+		ret.RemoveAll(p => p.GetCount() == 0);
+		ret.Sort((a, b) => gameObjectIndex[a.gameObject] - gameObjectIndex[b.gameObject]);
+
+		return ret;
+    }
+
+    private int GetNumUnopenedPacks()
+    {
+		int ret = 0;
+
+		foreach (var entry in m_unopenedPacks)
+        {
+			if (entry.Value.GetCount() > 0)
+            {
+				ret++;
+            }
+        }
+
+		return ret;
+    }
+
+    private bool FinishedLoadingPacks()
+    {
+        foreach (var pack in m_unopenedPacksLoading)
+        {
+			if (pack.Value)
+            {
+				return false;
+            }
+        }
+
+		return true;
+    }
+
+    public void HandleInput()
+    {
+		if (m_curAccessibleState == AccessibleState.LOADING)
+        {
+			if (FinishedLoadingPacks())
+            {
+				ReadChoosePack();
+				return;
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_PACK)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				// TODO: Locked, open, etc
+				TryOpenPack();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				m_BackButton.TriggerRelease();
+            }
+			else if (m_accessiblePacks.HandleAccessibleInput())
+			{
+				AccessibilityUtils.CenterScrollbarAroundObject(m_UnopenedPackScroller, m_accessiblePacks.GetItemBeingRead().GetUnopenedPack().gameObject);
+			}
+        }
+    }
+
+    private void TryOpenPack()
+    {
+		var curPack = m_accessiblePacks.GetItemBeingRead();
+
+		if (curPack.IsLocked())
+        {
+			AccessibilityMgr.Output(this, curPack.GetLockedRibbonText());
+        }
+		else
+        {
+			AutomaticallyOpenPack(curPack.GetUnopenedPack());
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.LOADING)
+        {
+			return LocalizedText.GLOBAL_LOADING;
+        }
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_PACK)
+        {
+			return m_accessiblePacks?.GetHelp(true);
+        }
+
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PackOpeningButton.cs b/Decompiled/Assembly-CSharp/PackOpeningButton.cs
index 6fbb2eb..7afa78b 100644
--- a/Decompiled/Assembly-CSharp/PackOpeningButton.cs
+++ b/Decompiled/Assembly-CSharp/PackOpeningButton.cs
@@ -6,6 +6,9 @@ public class PackOpeningButton : BoxMenuButton
 
 	public GameObject m_countFrame;
 
+	// Accessibility
+	public int m_numPacks;
+
 	public string GetGetPackCount()
 	{
 		return m_count.Text;
@@ -13,6 +16,8 @@ public class PackOpeningButton : BoxMenuButton
 
 	public void SetPackCount(int packs)
 	{
+		m_numPacks = packs;
+
 		if (packs < 0)
 		{
 			m_count.Text = "";
diff --git a/Decompiled/Assembly-CSharp/PackOpeningCard.cs b/Decompiled/Assembly-CSharp/PackOpeningCard.cs
index 8ac25b5..9c9e664 100644
--- a/Decompiled/Assembly-CSharp/PackOpeningCard.cs
+++ b/Decompiled/Assembly-CSharp/PackOpeningCard.cs
@@ -38,13 +38,13 @@ public class PackOpeningCard : MonoBehaviour
 
 	private LettucePackComponent m_mercenaryPackComponent;
 
-	private TAG_PREMIUM m_premium;
+	internal TAG_PREMIUM m_premium;
 
 	private EntityDef m_entityDef;
 
 	private Actor m_actor;
 
-	private PackOpeningCardRarityInfo m_rarityInfo;
+	internal PackOpeningCardRarityInfo m_rarityInfo;
 
 	private Spell m_spell;
 
@@ -64,7 +64,7 @@ public class PackOpeningCard : MonoBehaviour
 
 	private bool m_revealed;
 
-	private bool m_isNew;
+	internal bool m_isNew;
 
 	private List<RevealedListener> m_revealedListeners = new List<RevealedListener>();
 
@@ -352,10 +352,10 @@ public class PackOpeningCard : MonoBehaviour
 	{
 		if (go == null)
 		{
-			Debug.LogError($"PackOpeningCard.OnActorLoaded() - FAILED to load actor \"{assetRef}\"");
+            Debug.LogError($"PackOpeningCard.OnActorLoaded() - FAILED to load actor \"{assetRef}\"");
 			return;
 		}
-		Actor component = go.GetComponent<Actor>();
+        Actor component = go.GetComponent<Actor>();
 		if (component == null)
 		{
 			Debug.LogError($"PackOpeningCard.OnActorLoaded() - ERROR actor \"{base.name}\" has no Actor component");
@@ -840,7 +840,7 @@ public class PackOpeningCard : MonoBehaviour
 		}
 	}
 
-	private string GetClassName()
+	internal string GetClassName()
 	{
 		TAG_CLASS @class = m_entityDef.GetClass();
 		if (m_entityDef.IsMultiClass())
diff --git a/Decompiled/Assembly-CSharp/PackOpeningDirector.cs b/Decompiled/Assembly-CSharp/PackOpeningDirector.cs
index 1d4f7bc..5d12f59 100644
--- a/Decompiled/Assembly-CSharp/PackOpeningDirector.cs
+++ b/Decompiled/Assembly-CSharp/PackOpeningDirector.cs
@@ -7,9 +7,10 @@ using Hearthstone.Progression;
 using PegasusLettuce;
 using Shared.UI.Scripts.Carousel;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class PackOpeningDirector : MonoBehaviour
+public class PackOpeningDirector : MonoBehaviour, AccessibleUI
 {
 	private readonly Vector3 PACK_OPENING_FX_POSITION = Vector3.zero;
 
@@ -79,7 +80,8 @@ public class PackOpeningDirector : MonoBehaviour
 		}
 	}
 
-	public void Play(int boosterId, float timeToRegisterPackOpening, int packOpeningId)
+	// -1,-1 is because of testing (to avoid telemetry)
+	public void Play(int boosterId, float timeToRegisterPackOpening=-1, int packOpeningId=-1)
 	{
 		if (!m_playing)
 		{
@@ -140,6 +142,7 @@ public class PackOpeningDirector : MonoBehaviour
 			this.OnDoneOpeningPack?.Invoke();
 			HideKeywordTooltips();
 		}
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public void ForceRevealRandomCard()
@@ -184,7 +187,12 @@ public class PackOpeningDirector : MonoBehaviour
 		}
 		m_activePackFxSpell.AddFinishedCallback(OnSpellFinished);
 		float timeTillAnimationStart = Time.realtimeSinceStartup - m_initializePackOpeningAnimationStartTime;
-		TelemetryManager.Client().SendPackOpening(timeToRegisterPackOpening, timeTillAnimationStart, packOpeningId);
+
+		if (packOpeningId != -1)
+		{
+			// We need to fake this during tests -> don't send telemetry though
+			TelemetryManager.Client().SendPackOpening(timeToRegisterPackOpening, timeTillAnimationStart, packOpeningId);
+		}
 		m_activePackFxSpell.ActivateState(SpellStateType.ACTION);
 		void Callback(AssetReference assetRef, GameObject go, object callbackData)
 		{
@@ -208,6 +216,7 @@ public class PackOpeningDirector : MonoBehaviour
 		m_hiddenCards.SetInputEnabled(enable: true);
 		m_hiddenCards.EnableReveal();
 		AttachCardsToCarousel();
+		ReadCards();
 	}
 
 	private void CameraBlurOn()
@@ -332,6 +341,8 @@ public class PackOpeningDirector : MonoBehaviour
 	private void OnDoneButtonShown(Spell spell, object userData)
 	{
 		m_doneButton.AddEventListener(UIEventType.RELEASE, OnDoneButtonPressed);
+
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 	}
 
 	private void HideDoneButton()
@@ -381,6 +392,11 @@ public class PackOpeningDirector : MonoBehaviour
 				BnetPresenceMgr.Get().SetGameField(4u, packOpeningCard.GetCardId() + ",0");
 			}
 		}
+
+		// a11y
+		AccessibilityOnRevealedCard(packOpeningCard);
+		// a11y
+
 		m_cardsPendingReveal--;
 		if (m_cardsPendingReveal <= 0)
 		{
@@ -419,4 +435,89 @@ public class PackOpeningDirector : MonoBehaviour
 			UnityEngine.Object.Destroy(base.gameObject);
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleListOfItems<AccessiblePackOpeningCard> m_accessiblePackOpeningCards;
+
+	private void ReadCards()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		var accessiblePackOpeningCards = new List<AccessiblePackOpeningCard>();
+		foreach(var card in m_hiddenCards.m_cards)
+        {
+			accessiblePackOpeningCards.Add(new AccessiblePackOpeningCard(this, card));
+        }
+
+		m_accessiblePackOpeningCards = new AccessibleListOfItems<AccessiblePackOpeningCard>(this, accessiblePackOpeningCards);
+		m_accessiblePackOpeningCards.StartReading();
+		AccessibleInputMgr.MoveMouseTo(m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed() || AccessibleKey.SPACE.IsPressed())
+        {
+			if (m_doneButtonShown)
+            {
+				m_doneButton.TriggerRelease();
+            }
+			else
+            {
+                TryRevealCard();
+            }
+        }
+		else if (AccessibleKey.READ_TOOLTIP.IsPressed())
+        {
+            AccessibilityUtils.ReadTooltip(this);
+        }
+		else
+        {
+			if (m_accessiblePackOpeningCards?.HandleAccessibleInput() ?? false)
+            {
+				AccessibleInputMgr.MoveMouseTo(m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard());
+            }
+        }
+    }
+
+    private void TryRevealCard()
+    {
+		var curCard = m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard();
+
+		if (!curCard.IsRevealed())
+		{
+			curCard.ForceReveal();
+		}
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_doneButtonShown)
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+		else
+        {
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_PACK_OPENING_OPEN_CARDS_HELP, AccessibleKey.CONFIRM);
+        }
+    }
+
+	public List<PackOpeningCard> GetRevealedCards()
+    {
+		return m_hiddenCards.m_cards;
+    }
+
+    private void AccessibilityOnRevealedCard(PackOpeningCard revealedCard)
+    {
+		foreach (var card in m_accessiblePackOpeningCards.Items)
+        {
+			if (card.GetPackOpeningCard() == revealedCard)
+            {
+				card.ReadLine();
+            }
+        }
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PegUIElement.cs b/Decompiled/Assembly-CSharp/PegUIElement.cs
index f7082fe..0be249b 100644
--- a/Decompiled/Assembly-CSharp/PegUIElement.cs
+++ b/Decompiled/Assembly-CSharp/PegUIElement.cs
@@ -110,6 +110,7 @@ public class PegUIElement : MonoBehaviour
 
 	public virtual void TriggerOver()
 	{
+		Accessibility.AccessibilityUtils.DebugGameObjectInHierarchy(gameObject);
 		if (m_enabled && !m_focused)
 		{
 			PrintLog("OVER", PegUILogLevel.ALL_EVENTS);
@@ -159,6 +160,7 @@ public class PegUIElement : MonoBehaviour
 
 	public virtual void TriggerRelease()
 	{
+		Accessibility.AccessibilityUtils.DebugGameObjectInHierarchy(gameObject);
 		if (m_enabled)
 		{
 			PrintLog("RELEASE", PegUILogLevel.ALL_EVENTS);
diff --git a/Decompiled/Assembly-CSharp/Player.cs b/Decompiled/Assembly-CSharp/Player.cs
index 479219d..f965405 100644
--- a/Decompiled/Assembly-CSharp/Player.cs
+++ b/Decompiled/Assembly-CSharp/Player.cs
@@ -1713,4 +1713,13 @@ public class Player : Entity
 			}
 		}
 	}
+
+	#region Accessibility
+
+	public ZoneBattlegroundHeroBuddy GetHeroBuddyZone()
+	{
+		return ZoneMgr.Get().FindZoneOfType<ZoneBattlegroundHeroBuddy>(GetSide());
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PlayerLeaderboardCard.cs b/Decompiled/Assembly-CSharp/PlayerLeaderboardCard.cs
index 8b952d4..e9a01b3 100644
--- a/Decompiled/Assembly-CSharp/PlayerLeaderboardCard.cs
+++ b/Decompiled/Assembly-CSharp/PlayerLeaderboardCard.cs
@@ -99,7 +99,7 @@ public class PlayerLeaderboardCard : HistoryItem
 
 	private VisualController m_recentCombatsPanelController;
 
-	private PlayerLeaderboardRecentCombatsPanel m_recentCombatsPanel;
+	internal PlayerLeaderboardRecentCombatsPanel m_recentCombatsPanel;
 
 	private PlayerLeaderboardRecentCombatsPanel m_recentCombatsPanelNormal;
 
@@ -787,10 +787,9 @@ public class PlayerLeaderboardCard : HistoryItem
 		{
 			m_triplesDirty = !UpdateTriples();
 		}
-		if (m_racesDirty)
-		{
-			m_racesDirty = !UpdateRaces();
-		}
+
+		// Accessibility -> AccessiblePlayerLeaderboardCard relies on this
+		GoUpdateRaces();
 	}
 
 	private string GetHistoryActorBoneName()
@@ -884,7 +883,7 @@ public class PlayerLeaderboardCard : HistoryItem
 		int key = m_playerHeroEntity.GetTag(GAME_TAG.PLAYER_ID);
 		if (GameState.Get().GetPlayerInfoMap().ContainsKey(key) && GameState.Get().GetPlayerInfoMap()[key].GetPlayerHero() != null)
 		{
-			num = GameState.Get().GetPlayerInfoMap()[key].GetPlayerHero().GetTag(GAME_TAG.PLAYER_TRIPLES);
+			num = GetPlayerTriples(GameState.Get().GetPlayerInfoMap()[key].GetPlayerHero());
 		}
 		if (m_recentCombatsPanel.GetTripleCount() == num)
 		{
@@ -991,4 +990,21 @@ public class PlayerLeaderboardCard : HistoryItem
 		}
 		return gameObject.transform.localPosition.x;
 	}
+
+	#region Accessibility
+
+	internal static int GetPlayerTriples(Entity playerHero)
+	{
+		return playerHero.GetTag(GAME_TAG.PLAYER_TRIPLES);
+	}
+
+	private void GoUpdateRaces()
+	{
+		if (m_racesDirty)
+		{
+			m_racesDirty = !UpdateRaces();
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PlayerLeaderboardManager.cs b/Decompiled/Assembly-CSharp/PlayerLeaderboardManager.cs
index 56d6564..f67271e 100644
--- a/Decompiled/Assembly-CSharp/PlayerLeaderboardManager.cs
+++ b/Decompiled/Assembly-CSharp/PlayerLeaderboardManager.cs
@@ -29,7 +29,7 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 
 	private bool m_disabled;
 
-	private List<PlayerLeaderboardCard> m_playerTiles = new List<PlayerLeaderboardCard>();
+	internal List<PlayerLeaderboardCard> m_playerTiles = new List<PlayerLeaderboardCard>();
 
 	private PlayerLeaderboardCard m_currentlyMousedOverTile;
 
@@ -392,7 +392,7 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 
 	private void OnTurnChanged(int oldTurn, int newTurn, object userdata)
 	{
-		int num = GameState.Get().GetFriendlySidePlayer().GetTag(GAME_TAG.NEXT_OPPONENT_PLAYER_ID);
+		int num = GetNextOpponentId();
 		if (GameState.Get().GetCurrentPlayer().IsFriendlySide())
 		{
 			SetNextOpponent(num);
@@ -819,4 +819,23 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 	{
 		return m_oddManOutOpponentHero;
 	}
+
+	#region Accessibility
+
+	private int GetNextOpponentId()
+	{
+		return GameState.Get().GetFriendlySidePlayer().GetTag(GAME_TAG.NEXT_OPPONENT_PLAYER_ID);
+	}
+
+	internal PlayerLeaderboardCard GetNextOpponentTile()
+	{
+		return GetTileForPlayerId(GetNextOpponentId());
+	}
+
+	internal PlayerLeaderboardCard GetMyTile()
+	{
+		return GetTileForPlayerId(GameState.Get().GetFriendlyPlayerId());
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs b/Decompiled/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs
index ecb4679..9e4c5b4 100644
--- a/Decompiled/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs
+++ b/Decompiled/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationPanel
 {
@@ -19,7 +20,7 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 		public bool isDefeated;
 	}
 
-	public uint m_maxDisplayItems = 2u;
+	public uint m_maxDisplayItems = MAX_VISIBLE_COMBATS_PER_PANEL;
 
 	public List<GameObject> m_recentActionPlaceholders;
 
@@ -61,6 +62,14 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 
 	public UberText m_singleTribeWithoutCountName;
 
+	#region Accessibility
+
+	internal static uint MAX_VISIBLE_COMBATS_PER_PANEL = 2u;
+
+	internal string m_accessibleRacesCounter;
+
+	#endregion
+
 	public void Awake()
 	{
 		for (int i = 0; i < m_recentActionPlaceholders.Count; i++)
@@ -233,6 +242,8 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 			{
 				m_singleTribeWithoutCountWrapper.SetActive(value: true);
 				m_singleTribeWithCountWrapper.SetActive(value: false);
+
+				m_accessibleRacesCounter = GameStrings.Get("GLOBAL_RACE_MIXED_BATTLEGROUNDS");
 			}
 		}
 		else
@@ -241,6 +252,8 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 			m_singleTribeWithCountWrapper.SetActive(value: true);
 			m_singleTribeWithCountNumber.Text = num2.ToString();
 			m_singleTribeWithCountName.Text = GameStrings.GetRaceNameBattlegrounds(tAG_RACE);
+
+			m_accessibleRacesCounter = AccessibleSpeechUtils.CombineWordsWithColon(m_singleTribeWithCountName.Text, m_singleTribeWithCountNumber.Text);
 		}
 		return m_racesInitialized;
 	}
diff --git a/Decompiled/Assembly-CSharp/PopupDisplayManager.cs b/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
index 92b97a1..1f04577 100644
--- a/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
+++ b/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
@@ -9,6 +9,7 @@ using Hearthstone.InGameMessage.UI;
 using Hearthstone.Progression;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class PopupDisplayManager : IHasUpdate, IService
 {
@@ -235,7 +236,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 			s_isShowing = true;
 			return;
 		}
-		if (DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(m_popClosedCallback))
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(m_popClosedCallback)) // To be reviewed if we implement arena
 		{
 			this.OnPopupShown();
 			s_isShowing = true;
@@ -414,7 +415,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private static bool ShowNextRankedIntro()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextRankedIntro"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextRankedIntro"))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/PowerProcessor.cs b/Decompiled/Assembly-CSharp/PowerProcessor.cs
index f2c7f6c..6cc077c 100644
--- a/Decompiled/Assembly-CSharp/PowerProcessor.cs
+++ b/Decompiled/Assembly-CSharp/PowerProcessor.cs
@@ -164,11 +164,11 @@ public class PowerProcessor
 				HistoryBlock.Type blockType = m_currentTaskList.GetBlockType();
 				if (sourceEntity != null && sourceEntity.HasTag(GAME_TAG.FAST_BATTLECRY) && blockType == HistoryBlock.Type.POWER)
 				{
-					HistoryManager.Get().CreateFastBigCardFromMetaData(entity);
+					HistoryManager.Get().CreateFastBigCardFromMetaData(m_currentTaskList, entity);
 					return;
 				}
 				int displayTimeMS = ((metaData.Info.Count > 1) ? metaData.Info[1] : 0);
-				HistoryManager.Get().CreatePlayedBigCard(entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
+				HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
 			}
 		}
 		else if (metaData.MetaType == HistoryMeta.Type.BEGIN_LISTENING_FOR_TURN_EVENTS)
@@ -1262,7 +1262,7 @@ public class PowerProcessor
 				{
 					bool countered = m_currentTaskList.WasThePlayedSpellCountered(sourceEntity);
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreatePlayedBigCard(sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
+					HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
 				}
 			}
 			m_currentTaskList.NotifyHistoryOfAdditionalTargets();
@@ -1295,7 +1295,7 @@ public class PowerProcessor
 				if (ShouldShowPlayedBigCard(sourceEntity3, blockStart))
 				{
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreatePlayedBigCard(sourceEntity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered: false, 0);
+					HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, sourceEntity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered: false, 0);
 				}
 			}
 			m_currentTaskList.NotifyHistoryOfAdditionalTargets();
@@ -1315,7 +1315,7 @@ public class PowerProcessor
 					HistoryManager.Get().CreateTriggerTile(sourceEntity2);
 					m_currentTaskList.SetWillCompleteHistoryEntry(set: true);
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreateTriggeredBigCard(sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
+					HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
 				}
 				m_currentTaskList.NotifyHistoryOfAdditionalTargets();
 				break;
@@ -1334,7 +1334,7 @@ public class PowerProcessor
 					if (sourceEntity2.GetController() != GameState.Get().GetFriendlySidePlayer() || !sourceEntity2.HasTag(GAME_TAG.HISTORY_PROXY_NO_BIG_CARD))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(entity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, entity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 				}
 				else
@@ -1342,7 +1342,7 @@ public class PowerProcessor
 					if (ShouldShowTriggeredBigCard(sourceEntity2))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 					HistoryManager.Get().CreateTriggerTile(sourceEntity2);
 				}
@@ -1393,7 +1393,7 @@ public class PowerProcessor
 		m_historyBlocking = false;
 	}
 
-	private bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
+	internal static bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
 	{
 		if (!GameState.Get().GetBooleanGameOption(GameEntityOption.USES_BIG_CARDS))
 		{
@@ -1418,7 +1418,7 @@ public class PowerProcessor
 		return false;
 	}
 
-	private bool ShouldShowTriggeredBigCard(Entity sourceEntity)
+	internal static bool ShouldShowTriggeredBigCard(Entity sourceEntity)
 	{
 		if (sourceEntity.GetZone() != TAG_ZONE.HAND)
 		{
@@ -1546,7 +1546,7 @@ public class PowerProcessor
 		m_currentTaskList.DoAllTasks(delegate
 		{
 			EndCurrentTaskList();
-		});
+        });
 	}
 
 	private void EndCurrentTaskList()
diff --git a/Decompiled/Assembly-CSharp/PowerSpellController.cs b/Decompiled/Assembly-CSharp/PowerSpellController.cs
index 42a05de..6e8469a 100644
--- a/Decompiled/Assembly-CSharp/PowerSpellController.cs
+++ b/Decompiled/Assembly-CSharp/PowerSpellController.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class PowerSpellController : SpellController
 {
diff --git a/Decompiled/Assembly-CSharp/PowerTask.cs b/Decompiled/Assembly-CSharp/PowerTask.cs
index 361d824..a2b648e 100644
--- a/Decompiled/Assembly-CSharp/PowerTask.cs
+++ b/Decompiled/Assembly-CSharp/PowerTask.cs
@@ -1,8 +1,11 @@
+using System;
 using System.Collections.Generic;
 using PegasusGame;
 
 public class PowerTask
 {
+	public delegate void TaskStartCallback(PowerTask task);
+
 	public delegate void TaskCompleteCallback();
 
 	private Network.PowerHistory m_power;
@@ -11,6 +14,8 @@ public class PowerTask
 
 	private TaskCompleteCallback m_onCompleted;
 
+	private TaskStartCallback m_onStarted;
+
 	public Network.PowerHistory GetPower()
 	{
 		return m_power;
@@ -40,6 +45,11 @@ public class PowerTask
 		m_onCompleted = onComplete;
 	}
 
+	public void SetTaskStartCallback(TaskStartCallback onStart)
+	{
+		m_onStarted = onStart;
+	}
+
 	private bool IsZoneTransition(TAG_ZONE fromZone, TAG_ZONE toZone)
 	{
 		if (IsCompleted())
@@ -95,7 +105,8 @@ public class PowerTask
 
 	public void DoRealTimeTask(List<Network.PowerHistory> powerList, int index)
 	{
-		GameState gameState = GameState.Get();
+        m_onStarted(this);
+        GameState gameState = GameState.Get();
 		switch (m_power.Type)
 		{
 		case Network.PowerType.CREATE_GAME:
@@ -150,10 +161,11 @@ public class PowerTask
 		}
 	}
 
-	public void DoTask()
+    public void DoTask()
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
@@ -234,6 +246,7 @@ public class PowerTask
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
@@ -357,4 +370,61 @@ public class PowerTask
 		}
 		return $"[id={netEntity.ID} cardId={netEntity.CardID} name={entityLogName}]";
 	}
+
+	#region Accessibility
+
+	public bool IsCardTrade(int entityId)
+    {
+		Network.PowerHistory power = GetPower();
+
+		if (power.Type == Network.PowerType.TAG_CHANGE)
+		{
+			Network.HistTagChange histTagChange = (Network.HistTagChange)power;
+			if (histTagChange.Tag == (int)GAME_TAG.IS_USING_TRADE_OPTION && histTagChange.Value == 1)
+			{
+				return true;
+			}
+		}
+		else if (power.Type == Network.PowerType.SHOW_ENTITY)
+        {
+			Network.HistShowEntity histShowEntity = (Network.HistShowEntity)power;
+			var entity = histShowEntity.Entity;
+
+			if (entity != null && entity.ID == entityId)
+            {
+				foreach (var tag in entity.Tags)
+                {
+					if (tag.Name == (int)GAME_TAG.IS_USING_TRADE_OPTION && tag.Value == 1)
+                    {
+						return true;
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public bool IsShowStartOfGameCard()
+    {
+		Network.PowerHistory power = GetPower();
+
+		if (power.Type == Network.PowerType.SHOW_ENTITY)
+        {
+			Network.HistShowEntity histShowEntity = (Network.HistShowEntity)power;
+			var entity = histShowEntity.Entity;
+
+            foreach (var tag in entity.Tags)
+            {
+                if (tag.Name == (int)GAME_TAG.START_OF_GAME && tag.Value == 1)
+                {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PowerTaskList.cs b/Decompiled/Assembly-CSharp/PowerTaskList.cs
index 8b41ed9..068e30b 100644
--- a/Decompiled/Assembly-CSharp/PowerTaskList.cs
+++ b/Decompiled/Assembly-CSharp/PowerTaskList.cs
@@ -3,12 +3,13 @@ using System.Threading;
 using Cysharp.Threading.Tasks;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class PowerTaskList
 {
 	public delegate void CompleteCallback(PowerTaskList taskList, int startIndex, int count, object userData);
 
-	public class DamageInfo
+    public class DamageInfo
 	{
 		public Entity m_entity;
 
@@ -506,6 +507,7 @@ public class PowerTaskList
 		PowerTask powerTask = new PowerTask();
 		powerTask.SetPower(netPower);
 		powerTask.SetTaskCompleteCallback(OnTaskCompleted);
+		powerTask.SetTaskStartCallback(OnTaskStarted);
 		m_tasks.Add(powerTask);
 		return powerTask;
 	}
@@ -1648,7 +1650,7 @@ public class PowerTaskList
 		callback?.Invoke(this, startIndex, count, userData);
 	}
 
-	private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
+    private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
 	{
 		for (int i = incompleteStartIndex; i <= endIndex; i++)
 		{
@@ -1919,4 +1921,38 @@ public class PowerTaskList
 			}
 		}
 	}
+
+    #region Accessibility
+
+	public delegate void GlobalCompleteCallback(PowerTaskList taskList);
+
+	private GlobalCompleteCallback m_globalCompleteCallback;
+
+    private bool m_startedTasks = false;
+
+    private void OnTaskStarted(PowerTask task)
+    {
+        if (!m_startedTasks)
+        {
+            m_startedTasks = true;
+            AccessiblePowerTaskListDescriber.Get().OnPowerTaskListStart(this);
+        }
+    }
+
+    internal void SetGlobalCompleteCallback(GlobalCompleteCallback callback)
+    {
+		m_globalCompleteCallback = callback;
+    }
+
+	public void FireCompleteEvent()
+    {
+        m_globalCompleteCallback?.Invoke(this);
+    }
+
+	public bool IsTradeBlock()
+	{
+		return IsBlockType(HistoryBlock.Type.TRADE);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
index 7dd5034..e6114ae 100644
--- a/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
@@ -3,6 +3,8 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
+using Assets;
 
 [CustomEditClass]
 public class PracticePickerTrayDisplay : MonoBehaviour
@@ -42,8 +44,6 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 
 	private List<PracticeAIButton> m_practiceAIButtons = new List<PracticeAIButton>();
 
-	private List<Achievement> m_lockedHeroes = new List<Achievement>();
-
 	private PracticeAIButton m_selectedPracticeAIButton;
 
 	private Map<string, DefLoader.DisposableFullDef> m_heroDefs = new Map<string, DefLoader.DisposableFullDef>();
@@ -156,7 +156,9 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 		Hashtable args = iTween.Hash("position", PracticeDisplay.Get().GetPracticePickerShowPosition(), "isLocal", true, "time", m_trayAnimationTime, "easetype", m_trayInEaseType, "delay", 0.001f);
 		iTween.MoveTo(base.gameObject, args);
 		SoundManager.Get().LoadAndPlay("choose_opponent_panel_slide_on.prefab:66491d3d01ed663429ab80daf6a5e880");
-		if (!Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_TRAY, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PracticePickerTrayDisplay.Show:" + Option.HAS_SEEN_PRACTICE_TRAY))
+
+		bool introducingPracticeTray = !Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_TRAY, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "PracticePickerTrayDisplay.Show:" + Option.HAS_SEEN_PRACTICE_TRAY);
+		if (introducingPracticeTray)
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_TRAY, val: true);
 			StartCoroutine(DoPickHeroLines());
@@ -166,7 +168,13 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			m_playButton.Enable();
 		}
 		Navigation.Push(OnNavigateBack);
-	}
+
+		if (!introducingPracticeTray)
+        {
+			// Only read out if we're not going to introduce the tray (see DoPickHeroLines() for that)
+            AccessibleAdventureScene.Get().OnPracticePickerTrayDisplayShown(m_practiceAIButtons);
+        }
+    }
 
 	private IEnumerator DoPickHeroLines()
 	{
@@ -176,11 +184,23 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			yield return null;
 		}
 		yield return new WaitForSeconds(firstPart.GetAudio().clip.length);
-		yield return new WaitForSeconds(6f);
-		if (!m_playButton.IsEnabled() && !GameMgr.Get().IsTransitionPopupShown())
+
+		if (!AccessibilityMgr.IsAccessibilityEnabled())
 		{
-			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_PRACTICE_INST2_08"), "VO_INNKEEPER_PRACTICE_INST2_08.prefab:7f8a9981df8853d44b3cc423d4f44f52", 2f);
+			// Ignore second part ("I'd personally choose Uther") if accessibility is enabled as it might confuse people
+			yield return new WaitForSeconds(6f);
+			if (!m_playButton.IsEnabled() && !GameMgr.Get().IsTransitionPopupShown())
+			{
+				Notification secondPart = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_PRACTICE_INST2_08"), "VO_INNKEEPER_PRACTICE_INST2_08.prefab:7f8a9981df8853d44b3cc423d4f44f52", 2f);
+				while (secondPart.GetAudio() == null)
+				{
+					yield return null;
+				}
+				yield return new WaitForSeconds(secondPart.GetAudio().clip.length);
+			}
 		}
+
+		AccessibleAdventureScene.Get().OnPracticePickerTrayDisplayShown(m_practiceAIButtons);
 	}
 
 	public void Hide()
@@ -358,14 +378,14 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			PracticeAIButton practiceAIButton = m_practiceAIButtons[i];
 			practiceAIButton.SetInfo(text, @class, disposableFullDef.DisposableCardDef, iD, flip: false);
 			bool shown = false;
-			foreach (Achievement lockedHero in m_lockedHeroes)
-			{
-				if (lockedHero.ClassReward.Value == @class)
-				{
-					shown = true;
-					break;
-				}
-			}
+
+            // "Undefeated" flags are broken on the official game so I had to tweak this
+            NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(@class);
+			if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
+            {
+				shown = true;
+            }
+
 			practiceAIButton.ShowQuestBang(shown);
 			if (practiceAIButton == m_selectedPracticeAIButton)
 			{
diff --git a/Decompiled/Assembly-CSharp/PresenceMgr.cs b/Decompiled/Assembly-CSharp/PresenceMgr.cs
index 8e422f8..b4b95fe 100644
--- a/Decompiled/Assembly-CSharp/PresenceMgr.cs
+++ b/Decompiled/Assembly-CSharp/PresenceMgr.cs
@@ -2669,6 +2669,12 @@ public class PresenceMgr
 
 	public string GetStatusText(BnetPlayer player)
 	{
+		if (player != null && player.IsCheatPlayer && "Nearby Player".Equals(player.GetBestName()))
+		{
+			// Default used to be "Hearthstone" but is now null since 21.4. Could just use the fake WoW player to test but this is fine
+			return "Doing something cool";
+		}
+
 		List<string> list = new List<string>();
 		string statusKey = null;
 		if (GetStatus_Internal(player, ref statusKey, list) == Global.PresenceStatus.UNKNOWN || !BnetPresenceMgr.Get().IsSubscribedToPlayer(player.GetHearthstoneGameAccountId()))
diff --git a/Decompiled/Assembly-CSharp/PrivacyFeatures.cs b/Decompiled/Assembly-CSharp/PrivacyFeatures.cs
index dbca850..25be7dc 100644
--- a/Decompiled/Assembly-CSharp/PrivacyFeatures.cs
+++ b/Decompiled/Assembly-CSharp/PrivacyFeatures.cs
@@ -6,5 +6,6 @@ public enum PrivacyFeatures
 	PERSONALIZED_STORE_ITEMS = 3,
 	PUSH_NOTIFICATIONS = 4,
 	ANALYTICS = 5,
-	NEARBY_FRIENDS = 6
+	NEARBY_FRIENDS = 6,
+	EOE = 7
 }
diff --git a/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs b/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs
index 1d7249c..581c813 100644
--- a/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs
+++ b/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class PrivacyFeaturesPopup : DialogBase
 {
@@ -260,6 +261,8 @@ public class PrivacyFeaturesPopup : DialogBase
 		m_buttonBlocked = true;
 		AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
 		FullScreenFXMgr.Get()?.StartStandardBlurVignette(0.1f);
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -267,4 +270,48 @@ public class PrivacyFeaturesPopup : DialogBase
 		FullScreenFXMgr.Get()?.EndStandardBlurVignette(0.1f);
 		base.Hide();
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    protected void ReadPopup()
+    {
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_choiceOneButton != null && m_choiceOneButton.isActiveAndEnabled)
+        {
+			m_accessibleMenu.AddOption(m_choiceOneButton.GetText(), () => m_choiceOneButton.TriggerRelease());
+        }
+
+		if (m_choiceTwoButton != null && m_choiceTwoButton.isActiveAndEnabled)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		if (m_continueButton != null && m_continueButton.isActiveAndEnabled)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, GameStrings.Get(m_titleText.Text));
+		AccessibilityMgr.Output(this, GameStrings.Get(m_searchText.Text));
+		AccessibilityMgr.Output(this, GameStrings.Get(m_successText.Text));
+
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PrivacyGate.cs b/Decompiled/Assembly-CSharp/PrivacyGate.cs
index ea672cb..e6fb6b7 100644
--- a/Decompiled/Assembly-CSharp/PrivacyGate.cs
+++ b/Decompiled/Assembly-CSharp/PrivacyGate.cs
@@ -43,6 +43,12 @@ public class PrivacyGate : IService
 
 	public bool FeatureEnabled(PrivacyFeatures privacyFeature)
 	{
+		// Accessibility
+		if (privacyFeature == PrivacyFeatures.CHAT)
+        {
+			return true;
+        }
+
 		if (featuresData.ContainsKey(privacyFeature))
 		{
 			return featuresData[privacyFeature];
diff --git a/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs b/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
index 9726a07..6feb577 100644
--- a/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
+++ b/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using Hearthstone;
 using Hearthstone.UI;
 using UnityEngine;
 
-public class PrivacyPolicyPopup : DialogBase
+public class PrivacyPolicyPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool confirmedPrivacyPolicy);
 
diff --git a/Decompiled/Assembly-CSharp/ProductPage.cs b/Decompiled/Assembly-CSharp/ProductPage.cs
index 4ad2999..42d5861 100644
--- a/Decompiled/Assembly-CSharp/ProductPage.cs
+++ b/Decompiled/Assembly-CSharp/ProductPage.cs
@@ -5,6 +5,7 @@ using System.Linq;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class ProductPage : MonoBehaviour
 {
@@ -26,6 +27,10 @@ public class ProductPage : MonoBehaviour
 
 	protected AlertPopup.PopupInfo m_preBuyPopupInfo;
 
+	#region Accessibility
+	private bool m_isAccessible;
+	#endregion
+
 	public Widget WidgetComponent => m_widget;
 
 	public ProductDataModel Product => m_productMutable ?? m_productImmutable;
@@ -258,8 +263,10 @@ public class ProductPage : MonoBehaviour
 		}
 	}
 
-	public virtual void Open()
+	public virtual void Open(bool isAccessible)
 	{
+		m_isAccessible = isAccessible;
+
 		if (IsOpen)
 		{
 			return;
@@ -529,4 +536,222 @@ public class ProductPage : MonoBehaviour
 			this.OnOpened(this, new EventArgs());
 		}
 	}
+
+	#region Accessibility
+
+	protected enum State
+	{
+		LOADING,
+		CHOOSING_VARIANT,
+		READING_VARIANT_MENU,
+		READING_VARIANT_DESCRIPTION,
+
+		// Mini-set
+		READING_CARDS,
+	}
+
+	protected State m_curState;
+
+	private AccessibleMenu m_accessibleMenu;
+
+	protected AccessibleMenu m_readingVariantMenu;
+
+	private AccessibleMultilineText m_variantDescription;
+
+	protected void BuyVariant(ProductDataModel variant)
+	{
+		if (!AccessibleShopUtils.HasEnoughGoldToBuyVariant(variant))
+		{
+			AccessibilityMgr.Output(m_container, GameStrings.Get("GAMEPLAY_PlayErrors_REQ_ENOUGH_COIN"));
+		}
+		else
+		{
+			var priceOption = AccessibleShopUtils.GetGoldPriceOptionForVariant(variant);
+			TryBuy(priceOption);
+		}
+	}
+
+	public virtual void ReadProductPage()
+	{
+		if (!m_isAccessible)
+		{
+			return;
+		}
+
+		m_curState = State.LOADING; // Make products with no gold variants stay "loading" forever so we don't read them
+
+		var product = m_container.Product;
+
+		if (product.Variants.Count > 1)
+		{
+			ReadProductPageWithVariants(product);
+			return;
+		}
+
+		if (AccessibleShopUtils.IsAvailable(product) && AccessibleShopUtils.CanVariantBeBoughtWithGold(product))
+		{
+			ChooseVariant(product, false);
+		}
+	}
+
+	private void ReadProductPageWithVariants(ProductDataModel product)
+	{
+		var availableVariants = AccessibleShopUtils.GetVariantsWhichCanBeBoughtWithGold(product);
+
+		if (availableVariants.Count == 0)
+		{
+			return;
+		}
+
+		var productName = product.Name;
+		m_accessibleMenu = new AccessibleMenu(m_container, productName, () => m_container.Close());
+
+		foreach (var variant in availableVariants)
+		{
+			m_accessibleMenu.AddOption(variant.VariantName, () => ChooseVariant(variant));
+		}
+
+		ReadChoosingVariantMenu();
+	}
+
+	private void ReadChoosingVariantMenu()
+	{
+		m_accessibleMenu.StartReading();
+		m_curState = State.CHOOSING_VARIANT;
+	}
+
+	private void ChooseVariant(ProductDataModel variant, bool hasOtherVariants=true)
+	{
+		SelectVariant(variant);
+
+		SetupVariantMenu(variant, hasOtherVariants);
+
+		ReadVariantMenu();
+	}
+
+	private void SetupVariantMenu(ProductDataModel variant, bool hasOtherVariants)
+	{
+		if (hasOtherVariants)
+		{
+			m_readingVariantMenu = new AccessibleMenu(m_container, "", ReadChoosingVariantMenu);
+		}
+		else
+		{
+			m_readingVariantMenu = new AccessibleMenu(m_container, variant.Name, () => m_container.Close());
+		}
+
+		SetupVariantMenuOptions(variant);
+	}
+
+	protected virtual void SetupVariantMenuOptions(ProductDataModel variant)
+	{
+		var buyText = AccessibleShopUtils.GetBuyForGoldText(variant);
+
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_READ_DESCRIPTION), () => ReadVariantDescription(variant));
+		m_readingVariantMenu.AddOption(buyText, () => BuyVariant(variant));
+	}
+
+	protected void ReadVariantMenu()
+	{
+		m_readingVariantMenu.StartReading();
+		m_curState = State.READING_VARIANT_MENU;
+	}
+
+	protected void ReadVariantDescription(ProductDataModel variant)
+	{
+		var descriptionLines = AccessibleShopUtils.CreateMultilineDescriptionForVariant(variant);
+
+		m_variantDescription = new AccessibleMultilineText(m_container, descriptionLines);
+		m_variantDescription.ReadAllLines();
+		m_curState = State.READING_VARIANT_DESCRIPTION;
+	}
+
+	internal virtual void OnStorePurchaseAuthClosed(bool purchaseSuccess)
+	{
+		if (!m_isAccessible)
+		{
+			return;
+		}
+
+		if (purchaseSuccess)
+		{
+			ReadRemainingGold();
+		}
+
+		if (m_curState == State.READING_VARIANT_MENU)
+		{
+			if (!CanBuyWithGold())
+			{
+				// Close container if we bought a product that we can only buy once
+				m_container.Close(true);
+			}
+			else
+			{
+				ReadVariantMenu();
+			}
+		}
+	}
+
+	protected bool CanBuyWithGold()
+	{
+		return AccessibleShopUtils.IsAvailable(m_container.Product);
+	}
+
+	public virtual void HandleAccessibleInput()
+	{
+		if (!m_isAccessible)
+		{
+			return;
+		}
+
+		if (m_curState == State.CHOOSING_VARIANT)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_VARIANT_MENU)
+		{
+			m_readingVariantMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_VARIANT_DESCRIPTION)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadVariantMenu();
+			}
+			else
+			{
+				m_variantDescription?.HandleAccessibleInput();
+			}
+		}
+	}
+
+	public virtual string GetAccessibleHelp()
+	{
+		if (!m_isAccessible)
+		{
+			return "";
+		}
+
+		if (m_curState == State.CHOOSING_VARIANT)
+		{
+			return m_accessibleMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_VARIANT_MENU)
+		{
+			return m_readingVariantMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_VARIANT_DESCRIPTION)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+
+		return "";
+	}
+
+	protected void ReadRemainingGold()
+	{
+		AccessibleShopUtils.ReadRemainingGold(m_container);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ProductPageContainer.cs b/Decompiled/Assembly-CSharp/ProductPageContainer.cs
index 5ec2035..b373544 100644
--- a/Decompiled/Assembly-CSharp/ProductPageContainer.cs
+++ b/Decompiled/Assembly-CSharp/ProductPageContainer.cs
@@ -6,8 +6,9 @@ using Hearthstone;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
-public class ProductPageContainer : MonoBehaviour
+public class ProductPageContainer : MonoBehaviour, AccessibleUI
 {
 	[SerializeField]
 	private GameObject m_pageRoot;
@@ -107,6 +108,8 @@ public class ProductPageContainer : MonoBehaviour
 		}
 		m_pages = null;
 		m_tempInstances = null;
+
+		HideThis();
 	}
 
 	public void Open()
@@ -132,12 +135,15 @@ public class ProductPageContainer : MonoBehaviour
 			m_pageRoot.SetActive(value: true);
 			IsOpen = true;
 			SetProduct(product, variant);
+			OnOpenProductPage();
 			StartCoroutine(OpenProductPageCoroutine());
 		}
 	}
 
-	public void Close()
+	public void Close(bool goBackToMainMenu=false)
 	{
+		HideThis(goBackToMainMenu);
+
 		if (!IsOpen)
 		{
 			return;
@@ -251,6 +257,7 @@ public class ProductPageContainer : MonoBehaviour
 			Log.Store.PrintError("Previous product page did not close properly: {0}", m_currentProductPage.gameObject.name);
 		}
 		m_currentProductPage = currentProductPage;
+		ReadProductPage();
 	}
 
 	protected void HandleProductPageClosed(object sender, EventArgs e)
@@ -308,6 +315,8 @@ public class ProductPageContainer : MonoBehaviour
 			i.Unload();
 		});
 		m_pages.Clear();
+
+		HideThis();
 	}
 
 	protected IEnumerator OpenProductPageCoroutine()
@@ -339,7 +348,7 @@ public class ProductPageContainer : MonoBehaviour
 			Close();
 			yield break;
 		}
-		activePage.Open();
+		activePage.Open(true);
 		while (activePage.WidgetComponent.IsChangingStates && IsOpen)
 		{
 			yield return null;
@@ -358,4 +367,44 @@ public class ProductPageContainer : MonoBehaviour
 			}
 		}
 	}
+
+	#region Accessibility
+
+	private void OnOpenProductPage()
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.ShowUI(this);
+	}
+
+	private void HideThis(bool goBackToMainMenu=false)
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.HideUI(this);
+		Shop.Get()?.Browser?.OnProductPageClosed(goBackToMainMenu);
+	}
+
+	private void ReadProductPage()
+	{
+		m_currentProductPage.ReadProductPage();
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_currentProductPage?.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_currentProductPage?.GetAccessibleHelp();
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/QuestLog.cs b/Decompiled/Assembly-CSharp/QuestLog.cs
index 7b45fc5..c77bc9a 100644
--- a/Decompiled/Assembly-CSharp/QuestLog.cs
+++ b/Decompiled/Assembly-CSharp/QuestLog.cs
@@ -406,7 +406,7 @@ public class QuestLog : UIBPopup
 			if (AchieveManager.Get().HasUnlockedFeature(Achieve.Unlocks.DAILY))
 			{
 				m_noQuestText.Text = GameStrings.Get("GLUE_QUEST_LOG_NO_QUESTS_DAILIES_UNLOCKED");
-				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
+				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
 				{
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, 0f, 34.5f), GameStrings.Get("VO_INNKEEPER_OUT_OF_QUESTS"), "VO_INNKEEPER_OUT_OF_QUESTS.prefab:b0073c56bf38c664dab532ad92f3baf9");
 					Options.Get().SetBool(Option.HAS_RUN_OUT_OF_QUESTS, val: true);
diff --git a/Decompiled/Assembly-CSharp/QuestPopups.cs b/Decompiled/Assembly-CSharp/QuestPopups.cs
index 4643fb2..3546223 100644
--- a/Decompiled/Assembly-CSharp/QuestPopups.cs
+++ b/Decompiled/Assembly-CSharp/QuestPopups.cs
@@ -122,7 +122,7 @@ public class QuestPopups : IDisposable
 
 	public void ShowQuestProgressToasts(List<Achievement> progressedAchieves)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber("ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
 		{
 			if (QuestManager.Get() != null && QuestToastManager.Get() != null)
 			{
diff --git a/Decompiled/Assembly-CSharp/QuestProgressToast.cs b/Decompiled/Assembly-CSharp/QuestProgressToast.cs
index dcc9ec6..f9b652d 100644
--- a/Decompiled/Assembly-CSharp/QuestProgressToast.cs
+++ b/Decompiled/Assembly-CSharp/QuestProgressToast.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class QuestProgressToast : GameToast
 {
@@ -31,5 +32,18 @@ public class QuestProgressToast : GameToast
 		}
 		m_questTitle.Text = title;
 		m_questDescription.Text = description;
-	}
+
+		// Accessibility
+		if (maxProgress > 1)
+        {
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+			AccessibilityMgr.OutputNotification(m_questTitle.Text);
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, progress, maxProgress));
+        }
+		else
+        {
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+			AccessibilityMgr.OutputNotification(m_questTitle.Text);
+        }
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/QuestTile.cs b/Decompiled/Assembly-CSharp/QuestTile.cs
index e2e800d..eff2b53 100644
--- a/Decompiled/Assembly-CSharp/QuestTile.cs
+++ b/Decompiled/Assembly-CSharp/QuestTile.cs
@@ -73,7 +73,7 @@ public class QuestTile : MonoBehaviour
 	[CustomEditField(Sections = "Special Event FX")]
 	public List<SpecialEventFxEntry> m_specialEventFx = new List<SpecialEventFxEntry>();
 
-	private Achievement m_quest;
+	internal Achievement m_quest;
 
 	private bool m_canShowCancelButton;
 
diff --git a/Decompiled/Assembly-CSharp/QuestToast.cs b/Decompiled/Assembly-CSharp/QuestToast.cs
index 535b8ba..7fc38b7 100644
--- a/Decompiled/Assembly-CSharp/QuestToast.cs
+++ b/Decompiled/Assembly-CSharp/QuestToast.cs
@@ -1,6 +1,7 @@
 using System.Linq;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class QuestToast : MonoBehaviour
 {
@@ -124,7 +125,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToast(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, bool updateCacheValues, Achievement quest, bool fullscreenEffects)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -167,7 +168,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToastPopup(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, RewardData rewardData, string name, string description, bool fullscreenEffects, bool updateCacheValues, Achievement quest)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : string.Concat(rewardData.Origin, ":", rewardData.OriginData, ":", rewardData.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : string.Concat(rewardData.Origin, ":", rewardData.OriginData, ":", rewardData.RewardType))))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -265,6 +266,10 @@ public class QuestToast : MonoBehaviour
 		m_clickCatcher.AddEventListener(UIEventType.RELEASE, CloseQuestToast);
 		m_questName.Text = m_toastName;
 		m_requirement.Text = m_toastDescription;
+		AccessibilityMgr.OutputNotification(LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_TOAST_TITLE));
+		AccessibilityMgr.OutputNotification(m_questName.Text);
+		AccessibilityMgr.OutputNotification(m_requirement.Text);
 		if (m_toastReward != null)
 		{
 			if (SpecialEventManager.Get().IsEventActive(SpecialEventType.SPECIAL_EVENT_GOLD_DOUBLED, activeIfDoesNotExist: false) && m_quest != null && m_quest.IsAffectedByDoubleGold && m_toastReward is GoldRewardData)
diff --git a/Decompiled/Assembly-CSharp/QuestlineController.cs b/Decompiled/Assembly-CSharp/QuestlineController.cs
index 95d52e5..3e2b95d 100644
--- a/Decompiled/Assembly-CSharp/QuestlineController.cs
+++ b/Decompiled/Assembly-CSharp/QuestlineController.cs
@@ -27,7 +27,7 @@ public class QuestlineController : MonoBehaviour
 
 	private Entity m_entity;
 
-	private QuestlineProgressUI m_QuestlineProgressUI;
+	internal QuestlineProgressUI m_QuestlineProgressUI;
 
 	private bool m_questCompleted;
 
diff --git a/Decompiled/Assembly-CSharp/QuickChatFrame.cs b/Decompiled/Assembly-CSharp/QuickChatFrame.cs
index eb94fd1..34c4a36 100644
--- a/Decompiled/Assembly-CSharp/QuickChatFrame.cs
+++ b/Decompiled/Assembly-CSharp/QuickChatFrame.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using bgs;
 using UnityEngine;
+using Accessibility;
 
 public class QuickChatFrame : MonoBehaviour
 {
@@ -406,6 +407,8 @@ public class QuickChatFrame : MonoBehaviour
 			m_text = pendingMessage
 		};
 		UniversalInputManager.Get().UseTextInput(parms);
+		AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_CHAT_TYPE_MESSAGE_PROMPT));
+		AccessibilityMgr.AllowTextInput();
 	}
 
 	private bool OnInputPreprocess(Event e)
@@ -440,6 +443,8 @@ public class QuickChatFrame : MonoBehaviour
 
 	private void OnInputComplete(string input)
 	{
+		AccessibilityMgr.DisallowTextInput();
+
 		if (!string.IsNullOrEmpty(input))
 		{
 			BnetPlayer myPlayer = BnetPresenceMgr.Get().GetMyPlayer();
diff --git a/Decompiled/Assembly-CSharp/RankChangeTwoScoop_NEW.cs b/Decompiled/Assembly-CSharp/RankChangeTwoScoop_NEW.cs
index 394aa7d..750ee95 100644
--- a/Decompiled/Assembly-CSharp/RankChangeTwoScoop_NEW.cs
+++ b/Decompiled/Assembly-CSharp/RankChangeTwoScoop_NEW.cs
@@ -6,6 +6,8 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 [CustomEditClass]
 public class RankChangeTwoScoop_NEW : MonoBehaviour
@@ -388,6 +390,7 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 
 	private void OnPlayMakerFinished()
 	{
+		ReadCurrentRank();
 		m_isPlayingAnimWithCancelPoint = false;
 		EnableClickToContinue();
 		if (m_medalInfoTranslator.GetChangeType(m_formatType) == RankChangeType.RANK_UP && Gameplay.Get() != null)
@@ -419,6 +422,8 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 
 	private void Hide()
 	{
+		AccessibleEndGameScreen.Get().ClearLines();
+
 		m_mainFSM.SendEvent("Death");
 		if (m_clickToContinueCoroutine != null)
 		{
@@ -435,6 +440,7 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 		if (m_isRankChangeCheat)
 		{
 			FullScreenFXMgr.Get().StopAllEffects();
+			AccessibleEndGameScreen.Get().OnDebugEndGameScreenHide();
 		}
 	}
 
@@ -449,6 +455,7 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 
 	private void PlayRankUp()
 	{
+		ReadRankUp();
 		PopuplateBasicFsmVars(m_rankUpFSM);
 		m_currMedalStars.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedMedalStars", 0, m_currMedalDataModel.Stars);
 		m_newlyEarnedStarsForRankUpRow1.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedStarsRow1");
@@ -467,12 +474,15 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 
 	private void PlayRankDown()
 	{
+		ReadRankDown();
 		m_isPlayingAnimWithCancelPoint = true;
 		m_rankDownFSM.SendEvent("StartAnim");
 	}
 
 	private void PlayStarChange(bool canLoseStars, bool canLoseLevel)
 	{
+		ReadStarChange(canLoseStars, canLoseLevel);
+
 		int num = m_currMedalDataModel.Stars - m_prevMedalDataModel.Stars;
 		if (num < 0)
 		{
@@ -500,6 +510,7 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 					m_cannotLoseLevelText.gameObject.SetActive(value: true);
 				}
 			}
+			ReadCurrentRank();
 			EnableClickToContinue();
 			break;
 		case 1:
@@ -574,6 +585,7 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 		FullScreenFXMgr.Get().SetBlurDesaturation(0.5f);
 		FullScreenFXMgr.Get().Blur(1f, 0.5f, iTween.EaseType.easeInCirc);
 		m_debugClickCatcher.gameObject.SetActive(value: true);
+		AccessibleEndGameScreen.Get().OnDebugEndGameScreen(m_debugClickCatcher);
 	}
 
 	[ContextMenu("Test StarLoss")]
@@ -710,4 +722,172 @@ public class RankChangeTwoScoop_NEW : MonoBehaviour
 		AssetLoader.Get().LoadTexture("Medal_Key_6.tif:1a7672de24da5bc4caea4d847cd690d0", callback);
 		return dataModel;
 	}
+
+	#region Accessibility
+
+	private static int WIN_STREAK_MULT = 2;
+
+	private List<string> m_outputLines = new List<string>();
+
+	private void Output(string text)
+	{
+		AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), text);
+		m_outputLines.Add(text);
+	}
+
+	private void ReadCannotLoseStars()
+	{
+		Output(GameStrings.Get("GLOBAL_RANK_SCRUB_RANK_DESC"));
+	}
+
+	private void ReadCannotLoseLevel()
+	{
+		Output(GameStrings.Get("GLOBAL_RANK_CANT_LOSE_LEVEL"));
+	}
+
+	private void ReadCurrentRank()
+	{
+		var prevRank = AccessibleRankedUtils.GetRankText(m_prevMedalInfo);
+		var curRank = AccessibleRankedUtils.GetRankText(m_currMedalInfo);
+
+		var rankChanged = !prevRank.Equals(curRank);
+
+		if (rankChanged)
+		{
+			Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_NEW_RANK, curRank));
+		}
+		else
+		{
+			Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_CURRENT_RANK, curRank));
+		}
+
+		if (!m_currMedalInfo.IsLegendRank())
+		{
+			var earnedStars = m_currMedalInfo.earnedStars;
+			var maxStars = m_currMedalInfo.RankConfig.Stars;
+
+			Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_CURRENT_STARS, earnedStars, maxStars));
+		}
+
+		// Setup accessible item so players can reread
+		AccessibleEndGameScreen.Get().SetupLines(m_outputLines);
+	}
+
+	private void ReadRankUp()
+	{
+		ReadEarnedOrLostStars();
+	}
+
+	private void ReadRankDown()
+	{
+		ReadEarnedOrLostStars();
+	}
+
+	private void ReadEarnedOrLostStars()
+	{
+		if (m_currMedalInfo.IsLegendRank())
+		{
+			if (!m_prevMedalInfo.IsLegendRank())
+			{
+				// We've just reached legend!
+				ReadEarnedStars();
+			}
+
+			return;
+		}
+
+		var curStarLevel = m_currMedalDataModel.StarLevel;
+		var prevStarLevel = m_prevMedalDataModel.StarLevel;
+		var curStars = m_currMedalDataModel.Stars;
+		var prevStars = m_prevMedalDataModel.Stars;
+
+		if (curStarLevel == prevStarLevel && curStars == prevStars)
+		{
+			// Nothing changed
+			return;
+		}
+
+		// Huge mess but there's a few bugs with star level on the previous medal which would mess everything up
+		if (prevStarLevel == curStarLevel)
+		{
+			if (prevStars < curStars)
+			{
+				ReadEarnedStars();
+			}
+			else if (prevStars > curStars)
+			{
+				ReadLostStars();
+			}
+		}
+		else if (prevStarLevel < curStarLevel)
+		{
+			ReadEarnedStars();
+		}
+		else if (prevStarLevel > curStarLevel)
+		{
+			ReadLostStars();
+		}
+	}
+
+	private void ReadLostStars()
+	{
+		Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_LOST_STARS, 1));
+	}
+
+	private void ReadEarnedStars()
+	{
+		var starBonus = m_prevMedalDataModel.StarMultiplier;
+		if (starBonus > 1)
+		{
+			Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_STAR_BONUS_MULT, starBonus));
+		}
+
+		if (m_isOnWinStreak)
+		{
+			Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_WIN_STREAK_MULT, WIN_STREAK_MULT));
+		}
+
+		var earnedStars = m_prevMedalInfo.starsPerWin;
+		if (m_isOnWinStreak)
+		{
+			earnedStars *= WIN_STREAK_MULT;
+		}
+		Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_EARNED_STARS, earnedStars));
+	}
+
+	private void ReadStarChange(bool canLoseStars, bool canLoseLevel)
+	{
+		if (m_currMedalDataModel.IsLegend)
+		{
+			return;
+		}
+		else
+		{
+			var curStarLevel = m_currMedalDataModel.StarLevel;
+			var prevStarLevel = m_prevMedalDataModel.StarLevel;
+			var curStars = m_currMedalDataModel.Stars;
+			var prevStars = m_prevMedalDataModel.Stars;
+
+			if (curStarLevel == prevStarLevel && curStars == prevStars)
+			{
+				if (!m_currMedalDataModel.IsNewPlayer)
+				{
+					if (!canLoseStars)
+					{
+						ReadCannotLoseStars();
+					}
+					else if (!canLoseLevel)
+					{
+						ReadCannotLoseLevel();
+					}
+				}
+			}
+			else
+			{
+				ReadEarnedOrLostStars();
+			}
+		}
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankMgr.cs b/Decompiled/Assembly-CSharp/RankMgr.cs
index 6b92727..e613a83 100644
--- a/Decompiled/Assembly-CSharp/RankMgr.cs
+++ b/Decompiled/Assembly-CSharp/RankMgr.cs
@@ -8,6 +8,7 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class RankMgr
 {
@@ -232,6 +233,11 @@ public class RankMgr
 
 	public bool IsNewPlayer()
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return CollectionManager.Cheat_IsNewPlayer();
+		}
+
 		if (!Network.ShouldBeConnectedToAurora())
 		{
 			return false;
diff --git a/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs b/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
index 54f93f0..bb1e4fe 100644
--- a/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
+++ b/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
@@ -4,6 +4,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedBonusStarsPopup : BasicPopup
@@ -11,6 +12,7 @@ public class RankedBonusStarsPopup : BasicPopup
 	public class BonusStarsPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+		public BonusStarsPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	public UberText m_descriptionText;
@@ -29,12 +31,18 @@ public class RankedBonusStarsPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+	#region Accessibility
+	private RankedPlayDataModel m_rankedPlayDataModel;
+
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -72,6 +80,8 @@ public class RankedBonusStarsPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -84,16 +94,18 @@ public class RankedBonusStarsPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
 		IncrementBonusStarsPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void OnWidgetReady()
 	{
 		IDataModel model = null;
 		m_widget.GetDataModel(123, out model);
-		RankedPlayDataModel rankedPlayDataModel = model as RankedPlayDataModel;
-		if (rankedPlayDataModel != null && m_descriptionText != null)
+		m_rankedPlayDataModel = model as RankedPlayDataModel;
+		if (m_rankedPlayDataModel != null && m_descriptionText != null)
 		{
-			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", rankedPlayDataModel.StarMultiplier);
+			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", m_rankedPlayDataModel.StarMultiplier);
 		}
 	}
 
@@ -112,4 +124,34 @@ public class RankedBonusStarsPopup : BasicPopup
 			GameSaveDataManager.Get().SaveSubkeys(list);
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_rankedPlayDataModel == null)
+        {
+			return;
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_RANKED_BONUS_STARS_POPUP, m_rankedPlayDataModel.StarMultiplier));
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankedCardBackProgressDisplay.cs b/Decompiled/Assembly-CSharp/RankedCardBackProgressDisplay.cs
index 892b4fc..930c623 100644
--- a/Decompiled/Assembly-CSharp/RankedCardBackProgressDisplay.cs
+++ b/Decompiled/Assembly-CSharp/RankedCardBackProgressDisplay.cs
@@ -4,6 +4,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class RankedCardBackProgressDisplay : MonoBehaviour
@@ -145,6 +146,8 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 			float delay = m_progressBarAnimTime / (float)m_winsNeeded;
 			StartCoroutine(WaitThenTriggerPlayMaker(delay));
 		}
+
+		ReadFooter();
 	}
 
 	private IEnumerator WaitThenTriggerPlayMaker(float delay)
@@ -178,6 +181,11 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 		{
 			AnimationUtil.ScaleFade(base.gameObject, new Vector3(0.01f, 0.01f, 0.01f), "OnClosed");
 		}
+
+		if (m_isDebugShow)
+		{
+			AccessibleEndGameScreen.Get().OnDebugEndGameScreenHide();
+		}
 	}
 
 	private void OnClosed()
@@ -204,6 +212,7 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 		m_debugClickCatcher.gameObject.SetActive(value: true);
 		m_debugClickCatcher.AddEventListener(UIEventType.RELEASE, OnClick);
 		m_isDebugShow = true;
+		AccessibleEndGameScreen.Get().OnDebugEndGameScreen(m_debugClickCatcher);
 	}
 
 	private void PositionForDebugShow()
@@ -217,4 +226,25 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 		FullScreenFXMgr.Get().StopAllEffects();
 		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
 	}
+
+	#region Accessibility
+	private void ReadFooter()
+	{
+		if (m_medalInfo.GetSeasonCardBackWinsRemaining() == 0)
+		{
+			// Not incredible but given that this is a card back it's not worth it to keep a translation
+			Output(GameStrings.Get("GLOBAL_REWARD_CARD_BACK_HEADLINE"));
+		}
+		else
+		{
+			Output(m_footerText.Text);
+		}
+	}
+
+	private void Output(string text)
+	{
+		AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), text);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankedIntroPopup.cs b/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
index cfeeade..7a99abb 100644
--- a/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
+++ b/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
@@ -2,6 +2,7 @@ using System;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedIntroPopup : BasicPopup
@@ -9,6 +10,8 @@ public class RankedIntroPopup : BasicPopup
 	public class RankedIntroPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public RankedIntroPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	private const string SHOW_EVENT_NAME = "CODE_DIALOGMANAGER_SHOW";
@@ -23,12 +26,16 @@ public class RankedIntroPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+    #region Accessibility
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -63,6 +70,8 @@ public class RankedIntroPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -75,6 +84,8 @@ public class RankedIntroPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
 		IncrementRankedIntroPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void IncrementRankedIntroPopupSeenCount()
@@ -89,4 +100,30 @@ public class RankedIntroPopup : BasicPopup
 			gameSaveDataManager.SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.RANKED_PLAY, GameSaveKeySubkeyId.RANKED_PLAY_INTRO_SEEN_COUNT, array));
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RANKED_INTRO_POPUP));
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankedMedal.cs b/Decompiled/Assembly-CSharp/RankedMedal.cs
index cca6a85..5b97283 100644
--- a/Decompiled/Assembly-CSharp/RankedMedal.cs
+++ b/Decompiled/Assembly-CSharp/RankedMedal.cs
@@ -53,7 +53,7 @@ public class RankedMedal : MonoBehaviour
 		}
 	}
 
-	private RankedPlayDataModel GetRankedPlayDataModel()
+	internal RankedPlayDataModel GetRankedPlayDataModel()
 	{
 		IDataModel model = null;
 		m_widget.GetDataModel(123, out model);
diff --git a/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs b/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
index 6409d63..ac076cd 100644
--- a/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
+++ b/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
@@ -5,6 +5,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class RankedRewardDisplay : MonoBehaviour
@@ -127,6 +128,8 @@ public class RankedRewardDisplay : MonoBehaviour
 		{
 			EndGameScreen.Get().m_hitbox.AddEventListener(UIEventType.RELEASE, OnClick);
 		}
+
+		ReadRewardDisplay();
 	}
 
 	private void BindNextRewardItemDataModel()
@@ -161,6 +164,12 @@ public class RankedRewardDisplay : MonoBehaviour
 
 	private void OnClick(UIEvent e)
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			SendPlayMakerDeath();
+			return;
+		}
+
 		if (m_numAnimationsRemaining > 0)
 		{
 			if (!m_isAnimating)
@@ -194,6 +203,11 @@ public class RankedRewardDisplay : MonoBehaviour
 		{
 			AnimationUtil.ScaleFade(base.gameObject, new Vector3(0.01f, 0.01f, 0.01f), "OnClosed");
 		}
+
+		if (m_doPositionForDebugShow)
+		{
+			AccessibleEndGameScreen.Get().OnDebugEndGameScreenHide();
+		}
 	}
 
 	private void OnClosed()
@@ -221,6 +235,7 @@ public class RankedRewardDisplay : MonoBehaviour
 		m_debugClickCatcher.gameObject.SetActive(value: true);
 		m_debugClickCatcher.AddEventListener(UIEventType.RELEASE, OnClick);
 		m_doPositionForDebugShow = true;
+		AccessibleEndGameScreen.Get().OnDebugEndGameScreen(m_debugClickCatcher);
 	}
 
 	private void PositionForDebugShow()
@@ -240,4 +255,20 @@ public class RankedRewardDisplay : MonoBehaviour
 		FullScreenFXMgr.Get().StopAllEffects();
 		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
 	}
+
+    #region Accessibility
+
+	private void ReadRewardDisplay()
+    {
+		// Note: this is a visual experience so just inform + skip
+		Output(GameStrings.Get("GLUE_RANKED_REWARD_IN_GAME_TITLE"));
+		Output(GameStrings.Get("GLUE_RANKED_REWARD_IN_GAME_FOOTER"));
+    }
+
+	private void Output(string text)
+	{
+		AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), text);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs b/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
index 0c6a7fe..d77f078 100644
--- a/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
+++ b/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Hearthstone;
 using UnityEngine;
 
@@ -23,7 +24,8 @@ public class ReconnectHelperDialog : DialogBase
 		BAD_VERSION_CAN_RESET,
 		BAD_VERSION_USE_LAUNCHER,
 		INACTIVE_TIMEOUT,
-		RESTART_REQUIRED
+		RESTART_REQUIRED,
+		EOE
 	}
 
 	private class Layout
@@ -47,9 +49,13 @@ public class ReconnectHelperDialog : DialogBase
 		public Action m_choiceButtonTwoAction;
 
 		public Action m_onInit;
-	}
 
-	public UIBButton m_continueButton;
+        #region Accessibility
+        public string m_accessibleMenuText = "Connection lost";
+        #endregion
+    }
+
+    public UIBButton m_continueButton;
 
 	public UIBButton m_choiceOneButton;
 
@@ -171,6 +177,7 @@ public class ReconnectHelperDialog : DialogBase
 	{
 		m_stateLayouts[DialogState.PROMPT] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_OFFLINE), LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED)),
 			m_activePanel = m_reconnectPromptPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -187,6 +194,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.FAILURE] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED),
 			m_activePanel = m_reconnectFailurePanel,
 			m_twoButtons = true,
 			m_successRingState = SpellStateType.DEATH,
@@ -197,6 +205,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.WIFI_DISABLED] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_NO_INTERNET),
 			m_activePanel = m_wifiDisabledPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -206,6 +215,10 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_CAN_RESET] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER),
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY)
+            ),
 			m_activePanel = m_badVersionCanResetPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_UPDATE"),
@@ -215,6 +228,10 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_USE_LAUNCHER] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER),
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY)
+            ),
 			m_activePanel = m_badVersionUseLauncherPanel,
 			m_twoButtons = false,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -223,6 +240,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.INACTIVE_TIMEOUT] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT),
 			m_activePanel = m_inactiveTimeoutPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -232,6 +250,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.RESTART_REQUIRED] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED),
 			m_activePanel = m_restartRequiredPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get(HearthstoneApplication.AllowResetFromFatalError ? "GLUE_RECONNECT_HELPER_RESTART_GAME" : "GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -272,9 +291,11 @@ public class ReconnectHelperDialog : DialogBase
 		{
 			layout.m_onInit();
 		}
+
+		ReadAccessibleDialog();
 	}
 
-	private void ChangeStateToPromptBasedOnReconnectMgr()
+    private void ChangeStateToPromptBasedOnReconnectMgr()
 	{
 		if (ReconnectMgr.Get().FullResetRequired)
 		{
@@ -355,6 +376,7 @@ public class ReconnectHelperDialog : DialogBase
 	private void OnReconnectSuccess()
 	{
 		ReconnectMgr.Get().SetNextReLoginCallback(m_reconnectSuccessCallback);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_RECONNECTED);
 		Hide();
 	}
 
@@ -403,4 +425,62 @@ public class ReconnectHelperDialog : DialogBase
 			ChangeState_FullResetRequired();
 		}
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    private void ReadAccessibleDialog()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING));
+			return;
+        }
+
+		Layout layout = m_stateLayouts[m_state];
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_continueButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_continueButton.GetText(), () => m_continueButton.TriggerRelease());
+        }
+
+		if (m_choiceOneButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceOneButton.GetText(), () => m_choiceOneButton.TriggerRelease());
+        }
+
+		if (m_choiceTwoButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_TITLE), true);
+		AccessibilityMgr.Output(this, layout?.m_accessibleMenuText);
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return;
+        }
+
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING), LocalizedText.GLOBAL_PLEASE_WAIT);
+        }
+
+		return m_accessibleMenu?.GetHelp();
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ReconnectMgr.cs b/Decompiled/Assembly-CSharp/ReconnectMgr.cs
index 52eb012..9bc9b7e 100644
--- a/Decompiled/Assembly-CSharp/ReconnectMgr.cs
+++ b/Decompiled/Assembly-CSharp/ReconnectMgr.cs
@@ -12,6 +12,7 @@ using Hearthstone.Core;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class ReconnectMgr : IService, IHasUpdate
 {
@@ -775,6 +776,8 @@ public class ReconnectMgr : IService, IHasUpdate
 
 	private void ChangeGameplayDialogToReconnected()
 	{
+		AccessibleGameplay.Get().OnReconnected();
+
 		if (!(m_gameplayReconnectDialog == null))
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
diff --git a/Decompiled/Assembly-CSharp/Reward.cs b/Decompiled/Assembly-CSharp/Reward.cs
index 29a1261..9faff3a 100644
--- a/Decompiled/Assembly-CSharp/Reward.cs
+++ b/Decompiled/Assembly-CSharp/Reward.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public abstract class Reward : MonoBehaviour
+public abstract class Reward : MonoBehaviour, AccessibleUI
 {
 	public enum Type
 	{
@@ -11,30 +12,31 @@ public abstract class Reward : MonoBehaviour
 		BOOSTER_PACK,
 		CARD,
 		CARD_BACK,
-		CRAFTABLE_CARD,
-		FORGE_TICKET,
+		CRAFTABLE_CARD, // Not implemented
+		FORGE_TICKET, // Not implemented
 		GOLD,
 		MOUNT,
-		CLASS_CHALLENGE,
-		EVENT,
-		RANDOM_CARD,
-		BONUS_CHALLENGE,
-		ADVENTURE_DECK,
-		ADVENTURE_HERO_POWER,
+		CLASS_CHALLENGE, // Not implemented
+		EVENT, // Not implemented
+		RANDOM_CARD, // Not implemented
+		BONUS_CHALLENGE, // Not implemented
+		ADVENTURE_DECK, // Not implemented
+		ADVENTURE_HERO_POWER, // Not implemented
 		ARCANE_ORBS,
 		DECK,
 		MINI_SET,
-		MERCENARY_COIN,
-		MERCENARY_EXP,
-		MERCENARY_ABILITY_UNLOCK,
-		MERCENARY_EQUIPMENT,
-		REWARD_ITEM,
-		MERCENARY_BOOSTER,
-		MERCENARY_MERCENARY,
-		MERCENARY_RANDOM_MERCENARY,
-		MERCENARY_KNOCKOUT,
-		BATTLEGROUNDS_GUIDE_SKIN,
-		BATTLEGROUNDS_HERO_SKIN
+		MERCENARY_COIN, // TODO
+		MERCENARY_EXP, // TODO
+		MERCENARY_ABILITY_UNLOCK, // TODO
+		MERCENARY_EQUIPMENT, // TODO
+		REWARD_ITEM, // TODO
+		MERCENARY_BOOSTER, // TODO
+		MERCENARY_MERCENARY, // TODO
+		MERCENARY_RANDOM_MERCENARY, // TODO
+		MERCENARY_KNOCKOUT, // TODO
+		BATTLEGROUNDS_GUIDE_SKIN, // TODO
+		BATTLEGROUNDS_HERO_SKIN, // TODO
+		EOE
 	}
 
 	public delegate void DelOnRewardLoaded(Reward reward, object callbackData);
@@ -124,9 +126,10 @@ public abstract class Reward : MonoBehaviour
 
 	protected virtual void OnDestroy()
 	{
-	}
+        AccessibilityMgr.HideUI(this);
+    }
 
-	public void Show(bool updateCacheValues)
+    public void Show(bool updateCacheValues)
 	{
 		Data.AcknowledgeNotices();
 		if (m_MeshRoot != null)
@@ -154,6 +157,8 @@ public abstract class Reward : MonoBehaviour
 		}
 		ShowReward(updateCacheValues);
 		m_shown = true;
+
+		ReadReward();
 	}
 
 	protected virtual void PlayShowSounds()
@@ -180,10 +185,14 @@ public abstract class Reward : MonoBehaviour
 			}
 		}
 		iTween.FadeTo(base.gameObject, 0f, RewardUtils.REWARD_HIDE_TIME);
+		AccessibilityMgr.HideUI(this);
+
 	}
 
 	public virtual void Hide(bool animate = false)
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (!animate)
 		{
 			OnHideAnimateComplete();
@@ -336,6 +345,8 @@ public abstract class Reward : MonoBehaviour
 
 	private void OnHide()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		OnHideListener[] array = m_hideListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
@@ -365,4 +376,40 @@ public abstract class Reward : MonoBehaviour
 			}
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleRewardData m_accessibleReward;
+
+	private void ReadReward()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleReward = new AccessibleRewardData(this, m_data);
+
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_REWARD_TITLE));
+		m_accessibleReward.ReadAllLines();
+    }
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			AccessibleInputMgr.ClickCenterOfScreen(); // TODO: Refactor tests to make this the endgame screen (even if a dummy one like in rank changes)
+        }
+        else
+        {
+			m_accessibleReward.HandleAccessibleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		var helpText = LocalizationUtils.Get(LocalizationKey.UI_REWARD_HELP);
+		var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+		return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs b/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
index 09fc72b..eb9e38f 100644
--- a/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
+++ b/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
@@ -3,9 +3,10 @@ using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class RewardBoxesDisplay : MonoBehaviour
+public class RewardBoxesDisplay : MonoBehaviour, AccessibleUI
 {
 	[Serializable]
 	public class RewardPackageData
@@ -119,6 +120,11 @@ public class RewardBoxesDisplay : MonoBehaviour
 
 	private List<RewardData> CurrentPageRewards => m_rewards.Skip(m_RewardSet.m_MaxPackagesPerPage * m_currentPageNum).Take(m_RewardSet.m_MaxPackagesPerPage).ToList();
 
+	#region Accessibility
+	private List<RewardBoxData> m_rewardsBoxData = new List<RewardBoxData>();
+	private int m_pendingAnimations;
+	#endregion
+
 	public bool IsClosing { get; private set; }
 
 	private void Awake()
@@ -244,6 +250,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 
 	public void AnimateRewards()
 	{
+		AccessibilityMgr.ShowUI(this);
+
 		List<RewardData> currentPageRewards = CurrentPageRewards;
 		int count = currentPageRewards.Count;
 		m_RewardPackages = GetPackageData(count);
@@ -308,6 +316,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			}
 		}
 		m_rewardPackageInstances.Clear();
+		m_rewardsBoxData.Clear(); // Accessibility
+		m_pendingAnimations = 0;
 		for (int i = 0; i < m_RewardPackages.Count; i++)
 		{
 			RewardPackageData rewardPackageData = m_RewardPackages[i];
@@ -343,6 +353,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			rewardBoxData.m_RewardPackage = component2;
 			rewardBoxData.m_FSM = component;
 			rewardBoxData.m_Index = i;
+			m_rewardsBoxData.Add(rewardBoxData);
+			m_pendingAnimations++;
 			iTween.MoveTo(gameObject, iTween.Hash("position", rewardPackageData.m_TargetBone.transform.position, "time", m_RewardSet.m_AnimationTime, "delay", rewardPackageData.m_StartDelay, "easetype", iTween.EaseType.linear, "onstarttarget", base.gameObject, "onstart", "RewardPackageOnStart", "onstartparams", rewardBoxData, "oncompletetarget", base.gameObject, "oncomplete", "RewardPackageOnComplete", "oncompleteparams", rewardBoxData));
 		}
 	}
@@ -362,9 +374,10 @@ public class RewardBoxesDisplay : MonoBehaviour
 		yield return new WaitForSeconds(0.5f);
 		SceneUtils.EnableColliders(boxData.m_GameObject, enable: true);
 		boxData.m_RewardPackage.AddEventListener(UIEventType.PRESS, RewardPackagePressed);
+		OnRewardPackageActivated();
 	}
 
-	private void RewardPackagePressed(UIEvent e)
+    private void RewardPackagePressed(UIEvent e)
 	{
 		Log.RewardBox.Print("box clicked!");
 	}
@@ -545,6 +558,7 @@ public class RewardBoxesDisplay : MonoBehaviour
 		{
 			FadeFullscreenEffectsOut();
 			Navigation.GoBack();
+			AccessibilityMgr.HideUI(this);
 			return;
 		}
 		m_currentPageNum++;
@@ -735,4 +749,109 @@ public class RewardBoxesDisplay : MonoBehaviour
 			Debug.Log($"  reward {i}={arg}");
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleRewardPackage> m_accessibleRewardPackages;
+
+    private void OnRewardPackageActivated()
+    {
+		m_pendingAnimations--;
+
+		if (m_pendingAnimations == 0)
+        {
+			List<AccessibleRewardPackage> rewardPackages = new List<AccessibleRewardPackage>(m_rewardsBoxData.Count);
+			m_rewardsBoxData.ForEach(r => rewardPackages.Add(new AccessibleRewardPackage(this, r, CurrentPageRewards[r.m_RewardPackage.m_RewardIndex])));
+			m_accessibleRewardPackages = new AccessibleListOfItems<AccessibleRewardPackage>(this, rewardPackages);
+
+			var numRewardPackages = m_rewardsBoxData.Count;
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_REWARD_BOXES_DISPLAY_TITLE, numRewardPackages));
+            m_accessibleRewardPackages.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (AllPackagesOpened())
+            {
+                m_DoneButton.TriggerRelease();
+            }
+			else
+            {
+                var focusedPackage = m_accessibleRewardPackages.GetItemBeingRead();
+
+                if (!focusedPackage.Open)
+                {
+                    focusedPackage.RewardBoxData.m_RewardPackage.TriggerPress();
+                    focusedPackage.Open = true;
+                    focusedPackage.ReadAllLines();
+
+                    OnRewardPackageOpened();
+                }
+            }
+        }
+		else
+        {
+			m_accessibleRewardPackages?.HandleAccessibleInput();
+        }
+    }
+
+    private void OnRewardPackageOpened()
+    {
+		if (AllPackagesOpened())
+        {
+            AccessibilityMgr.Output(this, GetAccessibleHelp());
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return LocalizedText.GLOBAL_PLEASE_WAIT;
+        }
+		else if (AllPackagesOpened())
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+        else
+        {
+			return LocalizationUtils.Format(LocalizationKey.UI_REWARD_BOXES_DISPLAY_HELP, AccessibleKey.CONFIRM);
+        }
+    }
+
+	private bool AllPackagesOpened()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return false;
+        }
+
+		return GetNumOpenPackages() == m_rewardsBoxData.Count;
+    }
+
+    private int GetNumOpenPackages()
+    {
+        if (m_accessibleRewardPackages == null)
+        {
+			return 0;
+        }
+		else
+        {
+			var ret = 0;
+			foreach (var package in m_accessibleRewardPackages.Items)
+            {
+				if (package.Open)
+                {
+					ret++;
+                }
+            }
+
+			return ret;
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardItemType.cs b/Decompiled/Assembly-CSharp/RewardItemType.cs
index 5dae747..6961523 100644
--- a/Decompiled/Assembly-CSharp/RewardItemType.cs
+++ b/Decompiled/Assembly-CSharp/RewardItemType.cs
@@ -21,17 +21,20 @@ public enum RewardItemType
 	MINI_SET,
 	CARD_SUBSET,
 	SELLABLE_DECK,
+  // TODO ALL FROM HERE vvv
 	MERCENARY_COIN,
 	MERCENARY,
 	MERCENARY_XP,
 	MERCENARY_EQUIPMENT,
 	MERCENARY_EQUIPMENT_ICON,
 	MERCENARY_BOOSTER,
+  // TODO ALL UNTIL HERE
 	BATTLEGROUNDS_HERO_SKIN,
 	BATTLEGROUNDS_GUIDE_SKIN,
-	MERCENARY_RANDOM_MERCENARY,
-	MERCENARY_KNOCKOUT_SPECIFIC,
-	MERCENARY_KNOCKOUT_RANDOM,
-	BATTLEGROUNDS_BOARD_SKIN,
-	BATTLEGROUNDS_FINISHER
+	MERCENARY_RANDOM_MERCENARY, // New as well
+	MERCENARY_KNOCKOUT_SPECIFIC, // New as well
+	MERCENARY_KNOCKOUT_RANDOM, // New as well
+	BATTLEGROUNDS_BOARD_SKIN, // New as well
+	BATTLEGROUNDS_FINISHER, // New as well
+  EOE
 }
diff --git a/Decompiled/Assembly-CSharp/RewardPopups.cs b/Decompiled/Assembly-CSharp/RewardPopups.cs
index b01034a..27cfed8 100644
--- a/Decompiled/Assembly-CSharp/RewardPopups.cs
+++ b/Decompiled/Assembly-CSharp/RewardPopups.cs
@@ -10,6 +10,7 @@ using Hearthstone.Progression;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class RewardPopups : IDisposable
 {
@@ -56,7 +57,7 @@ public class RewardPopups : IDisposable
 
 	private long m_freeDeckNoticeIdBeingProcessed;
 
-	private static string CHOOSE_A_DECK_PREFAB = "ChooseADeck.prefab:de9efdb77e14b144ea84f333a1e78926";
+	internal static string CHOOSE_A_DECK_PREFAB = "ChooseADeck.prefab:de9efdb77e14b144ea84f333a1e78926";
 
 	private PopupDisplayManager m_popupDisplayManager;
 
@@ -76,7 +77,7 @@ public class RewardPopups : IDisposable
 
 	private PopupDisplayManagerBones ChestBones { get; set; }
 
-	private PopupDisplayManagerBones QuestChestBones { get; set; }
+	internal PopupDisplayManagerBones QuestChestBones { get; set; }
 
 	private event Action<long> OnGenericRewardShown = delegate
 	{
@@ -422,7 +423,13 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextTavernBrawlReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.UpdateTavernBrawlRewards"))
+    if (AccessibilityMgr.IsAccessibilityEnabled())
+    {
+      // TB is not implemented yet
+      return false;
+    }
+
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.UpdateTavernBrawlRewards"))
 		{
 			return false;
 		}
@@ -471,7 +478,7 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextLeaguePromotionReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextLeaguePromotionReward"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextLeaguePromotionReward"))
 		{
 			return false;
 		}
@@ -520,7 +527,7 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextFreeDeckReward(bool rankedIntroShown)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextFreeDeckReward"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextFreeDeckReward"))
 		{
 			return false;
 		}
@@ -611,7 +618,7 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextSellableDeckReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
@@ -757,6 +764,12 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextProgressionAchievementReward()
 	{
+    if (AccessibilityMgr.IsAccessibilityEnabled())
+    {
+      // Not implemented yet
+      return false;
+    }
+
 		AchievementManager achievementManager = AchievementManager.Get();
 		if (achievementManager == null || !achievementManager.HasReward() || !achievementManager.ShowNextReward(OnPopupClosed))
 		{
@@ -897,7 +910,7 @@ public class RewardPopups : IDisposable
 		}
 		Reward reward = m_purchasedCardRewards[0];
 		UserAttentionBlocker userAttentionBlockerForReward = RewardUtils.GetUserAttentionBlockerForReward(reward.Data.Origin, reward.Data.OriginData);
-		if (!UserAttentionManager.CanShowAttentionGrabber(userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
 		{
 			return false;
 		}
@@ -994,7 +1007,7 @@ public class RewardPopups : IDisposable
 		}
 	}
 
-	private Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
+	internal Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
 	{
 		PopupDisplayManagerBones popupDisplayManagerBones = ((boneSet != null) ? boneSet : ChestBones);
 		switch (SceneMgr.Get().GetMode())
diff --git a/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs b/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
index 3679527..ff7a678 100644
--- a/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
+++ b/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
@@ -1,9 +1,10 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
-public class RewardTrackForgotRewardsPopup : MonoBehaviour
+public class RewardTrackForgotRewardsPopup : MonoBehaviour, AccessibleUI
 {
 	public UberText m_headerText;
 
@@ -46,9 +47,51 @@ public class RewardTrackForgotRewardsPopup : MonoBehaviour
 		m_widget.Show();
 	}
 
-	public void Hide()
+    public void Hide()
 	{
 		m_widget.GetComponentInParent<RewardTrackSeasonRoll>();
 		m_widget.Hide();
+
+		AccessibilityMgr.HideUI(this);
+	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	public void ReadPopup()
+	{
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_POPUP), true);
+
+		if (m_headerText.gameObject.activeInHierarchy)
+        {
+            AccessibilityMgr.Output(this, m_headerText.Text);
+        }
+
+		if (m_bodyText.gameObject.activeInHierarchy)
+        {
+            AccessibilityMgr.Output(this, m_bodyText.Text);
+        }
+
+		var okButton = AccessibleWidgetUtils.GetPegUIElement(m_widget, "Root/Button_Framed/Button_Framed/ButtonFramed");
+		var okButtonText = AccessibleWidgetUtils.GetUberText(okButton, "Button/ButtonText");
+
+		m_accessibleMenu = new AccessibleMenu(this, "", null);
+		m_accessibleMenu.AddOption(GameStrings.Get(okButtonText.Text), () => AccessibleWidgetUtils.ClickButton(okButton));
+
+		m_accessibleMenu.StartReading();
 	}
+
+    public void HandleAccessibleInput()
+    {
+		m_accessibleMenu.HandleAccessibleInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return m_accessibleMenu.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardTrackSeasonRoll.cs b/Decompiled/Assembly-CSharp/RewardTrackSeasonRoll.cs
index 2d2cbbd..e9a246e 100644
--- a/Decompiled/Assembly-CSharp/RewardTrackSeasonRoll.cs
+++ b/Decompiled/Assembly-CSharp/RewardTrackSeasonRoll.cs
@@ -6,6 +6,7 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RewardTrackSeasonRoll : MonoBehaviour
@@ -80,10 +81,12 @@ public class RewardTrackSeasonRoll : MonoBehaviour
 		m_forgotRewardsPopupWidget.RegisterDoneChangingStatesListener(delegate
 		{
 			m_widget.GetComponentInChildren<RewardTrackForgotRewardsPopup>().Show();
-		}, null, callImmediatelyIfSet: true, doOnce: true);
+
+            ReadForgotRewardsPopup();
+        }, null, callImmediatelyIfSet: true, doOnce: true);
 	}
 
-	public void ShowChooseOneRewardPickerPopup()
+    public void ShowChooseOneRewardPickerPopup()
 	{
 		if (m_unclaimedRewardTrackNodeDataModels.Count == 0)
 		{
@@ -97,16 +100,20 @@ public class RewardTrackSeasonRoll : MonoBehaviour
 		m_chooseOneItemPopupWidget.RegisterDoneChangingStatesListener(delegate
 		{
 			m_widget.GetComponentInChildren<RewardTrackForgotRewardsPopup>().Show();
+
+            ReadChooseOneRewardPopup();
 		}, null, callImmediatelyIfSet: true, doOnce: true);
 	}
 
 	public void Hide()
 	{
+		HidePopups();
+
 		m_widget.Hide();
 		UnityEngine.Object.Destroy(m_owner);
 	}
 
-	private void OnDestroy()
+    private void OnDestroy()
 	{
 		UIContext.GetRoot()?.UnregisterPopup(m_owner);
 		m_callback?.Invoke();
@@ -165,4 +172,27 @@ public class RewardTrackSeasonRoll : MonoBehaviour
 			componentInChildren.Show();
 		});
 	}
+
+	#region Accessibility
+    private void ReadForgotRewardsPopup()
+    {
+		var rewardTrackForgotRewardsPopup = m_widget.GetComponentInChildren<RewardTrackForgotRewardsPopup>();
+		rewardTrackForgotRewardsPopup.ReadPopup();
+    }
+
+    private void ReadChooseOneRewardPopup()
+    {
+		var chooseOneRewardsPopup = m_widget.GetComponentInChildren<RewardTrackChooseOneItemPopup>();
+		chooseOneRewardsPopup.ReadPopup();
+    }
+
+    private void HidePopups()
+    {
+		var rewardTrackForgotRewardsPopup = m_widget.GetComponentInChildren<RewardTrackForgotRewardsPopup>();
+		AccessibilityMgr.HideUI(rewardTrackForgotRewardsPopup);
+
+		var chooseOneRewardsPopup = m_widget.GetComponentInChildren<RewardTrackChooseOneItemPopup>();
+		AccessibilityMgr.HideUI(chooseOneRewardsPopup);
+    }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardUtils.cs b/Decompiled/Assembly-CSharp/RewardUtils.cs
index e51663d..dd7e7c3 100644
--- a/Decompiled/Assembly-CSharp/RewardUtils.cs
+++ b/Decompiled/Assembly-CSharp/RewardUtils.cs
@@ -1336,7 +1336,7 @@ public class RewardUtils
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : string.Concat(reward.Data.Origin, ":", reward.Data.OriginData, ":", reward.Data.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : string.Concat(reward.Data.Origin, ":", reward.Data.OriginData, ":", reward.Data.RewardType))))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/ScenarioDbId.cs b/Decompiled/Assembly-CSharp/ScenarioDbId.cs
index 94c3edf..8762390 100644
--- a/Decompiled/Assembly-CSharp/ScenarioDbId.cs
+++ b/Decompiled/Assembly-CSharp/ScenarioDbId.cs
@@ -613,5 +613,6 @@ public enum ScenarioDbId
 	LETTUCE_MAP = 3790,
 	LETTUCE_TAVERN = 3862,
 	LETTUCE_MAP_COOP = 3899,
-	LETTUCE_PVP_VS_AI = 4123
+	LETTUCE_PVP_VS_AI = 4123,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/SceneMgr.cs b/Decompiled/Assembly-CSharp/SceneMgr.cs
index 21be696..674f9e1 100644
--- a/Decompiled/Assembly-CSharp/SceneMgr.cs
+++ b/Decompiled/Assembly-CSharp/SceneMgr.cs
@@ -978,7 +978,7 @@ public class SceneMgr : IService, IHasUpdate
 
 	private void OnFatalError(FatalErrorMessage message, object userData)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			Log.Offline.Print("SceneMgr.OnFatalError: Error blocked by set rotation.");
 			SetNextMode(Mode.FATAL_ERROR);
@@ -1064,7 +1064,7 @@ public class SceneMgr : IService, IHasUpdate
 		SetNextMode(Mode.HUB);
 	}
 
-	private void GoToFatalErrorScreen(FatalErrorMessage message)
+	internal void GoToFatalErrorScreen(FatalErrorMessage message)
 	{
 		if (HearthstoneApplication.Get().ResetOnErrorIfNecessary())
 		{
diff --git a/Decompiled/Assembly-CSharp/ScrollbarControl.cs b/Decompiled/Assembly-CSharp/ScrollbarControl.cs
index 3770e48..38102ce 100644
--- a/Decompiled/Assembly-CSharp/ScrollbarControl.cs
+++ b/Decompiled/Assembly-CSharp/ScrollbarControl.cs
@@ -158,7 +158,7 @@ public class ScrollbarControl : MonoBehaviour
 		FireFinishEvent();
 	}
 
-	private void FireUpdateEvent()
+	internal void FireUpdateEvent()
 	{
 		if (m_updateHandler != null)
 		{
@@ -166,7 +166,7 @@ public class ScrollbarControl : MonoBehaviour
 		}
 	}
 
-	private void FireFinishEvent()
+	internal void FireFinishEvent()
 	{
 		if (m_finishHandler != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/SeasonEndDialog.cs b/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
index 43776bb..1d191b3 100644
--- a/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
+++ b/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
@@ -6,6 +6,7 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class SeasonEndDialog : DialogBase
 {
@@ -38,7 +39,8 @@ public class SeasonEndDialog : DialogBase
 		REDUCED_WELCOME,
 		REMINDER_CHEST,
 		STAR_MULTIPLIER,
-		REMINDER_CARDBACK
+		REMINDER_CARDBACK,
+		EOE
 	}
 
 	public GameObject m_root;
@@ -177,6 +179,8 @@ public class SeasonEndDialog : DialogBase
 
 	private const string REWARD_CHEST_EARNED_STRING_FORMAT = "GLOBAL_REWARD_CHEST_TIER{0}_EARNED";
 
+	private const string REWARD_CHEST_WIDGET_OPEN_EVENT_NAME = "CLICKED";
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -342,8 +346,9 @@ public class SeasonEndDialog : DialogBase
 			m_currentMode = MODE.CHEST_EARNED;
 			m_medalPlayMaker.SendEvent("RevealRewardChest");
 			iTween.FadeTo(m_rankAchieved.gameObject, 0f, 0.5f);
-		}
-		else
+			HandleAccessibility();
+        }
+        else
 		{
 			GotoBonusStarsOrWelcome();
 		}
@@ -391,11 +396,13 @@ public class SeasonEndDialog : DialogBase
 
 	public void GoToStarMultiplier()
 	{
-		m_currentMode = MODE.STAR_MULTIPLIER;
+        m_currentMode = MODE.STAR_MULTIPLIER;
 		m_welcomeItems.SetActive(value: false);
+        HandleAccessibility();
+
 		if (m_skipRankedIntroPopup)
 		{
-			StartCoroutine(DoPageTear());
+            StartCoroutine(DoPageTear());
 			return;
 		}
 		HideRewardChestPage();
@@ -405,9 +412,9 @@ public class SeasonEndDialog : DialogBase
 		StartCoroutine(FadeWidgetIn(m_starMultiplierWidget, 0f));
 		iTween.FadeTo(m_bonusStarItems, 1f, 0f);
 		EnableOkayButton();
-	}
+    }
 
-	public void GotoReducedMedal()
+    public void GotoReducedMedal()
 	{
 		m_currentMode = MODE.REDUCED_WELCOME;
 		StartCoroutine(DoPageTear());
@@ -418,9 +425,10 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarLabel.Text = m_currentMedalInfo.GetRankName();
 		m_bonusStarTitle.Text = GameStrings.Get("GLOBAL_SEASON_END_BONUS_STAR_TITLE");
 		UpdateBonusStarFinePrint();
-	}
+        HandleAccessibility();
+    }
 
-	public void GotoChestReminder()
+    public void GotoChestReminder()
 	{
 		m_currentMode = MODE.REMINDER_CHEST;
 		HideRewardChestPage();
@@ -428,19 +436,21 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
 		int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
-		m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
-	}
+        m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
+        HandleAccessibility();
+    }
 
-	public void GoToCardBackReminder()
+    public void GoToCardBackReminder()
 	{
 		m_currentMode = MODE.REMINDER_CARDBACK;
 		HideRewardChestPage();
 		m_welcomeItems.SetActive(value: false);
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
-	}
+        HandleAccessibility();
+    }
 
-	public void GoToRankedIntroPopUp()
+    public void GoToRankedIntroPopUp()
 	{
 		iTween.ScaleTo(m_root, new Vector3(0f, 0f, 0f), 0.5f);
 		m_rankedIntroPopUpWidget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
@@ -459,9 +469,10 @@ public class SeasonEndDialog : DialogBase
 		HideRewardChestPage();
 		m_bonusStarItems.SetActive(value: false);
 		m_welcomeDetails.Text = GameStrings.Format("GLOBAL_SEASON_END_NEW_SEASON", newSeasonName);
-	}
+		HandleAccessibility();
+    }
 
-	public IEnumerator DoPageTear()
+    public IEnumerator DoPageTear()
 	{
 		m_medalPlayMaker.SendEvent("PageTear");
 		yield return new WaitForSeconds(0.69f);
@@ -538,6 +549,7 @@ public class SeasonEndDialog : DialogBase
 		DoShowAnimation();
 		UniversalInputManager.Get().SetGameDialogActive(active: true);
 		PlayShowSound();
+		HandleAccessibility();
 	}
 
 	public override void Hide()
@@ -786,7 +798,7 @@ public class SeasonEndDialog : DialogBase
 
 	private void RankedChestEventListener(string eventName)
 	{
-		if (eventName.Equals("CLICKED") && !m_chestOpened)
+		if (eventName.Equals(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME) && !m_chestOpened)
 		{
 			m_chestOpened = true;
 			PlayMakerFSM componentInChildren = m_rankedRewardChestWidget.GetComponentInChildren<PlayMakerFSM>();
@@ -899,4 +911,111 @@ public class SeasonEndDialog : DialogBase
 		m_showAnimState = ShowAnimState.IN_PROGRESS;
 		AnimationUtil.ShowWithPunch(base.gameObject, START_SCALE, Vector3.Scale(PUNCH_SCALE, m_originalScale), m_originalScale, "OnShowAnimFinished", noFade: true);
 	}
+
+	private void HandleAccessibility()
+    {
+        switch (m_currentMode)
+        {
+            case MODE.RANK_EARNED:
+				AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				var seasonName = GameUtils.GetRankedSeasonName(m_seasonEndInfo.m_seasonID);
+				var rankName = m_seasonBestMedalInfo.GetRankName();
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_RANK_EARNED, seasonName, rankName));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.CHEST_EARNED:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED));
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED_HELP, AccessibleKey.CONFIRM));
+                break;
+            case MODE.SEASON_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				var seasonName2 = GameUtils.GetRankedSeasonName(m_rewardProgress.Season);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_SEASON_WELCOME, seasonName2));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REDUCED_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SEASON_END_DIALOG_REDUCED_WELCOME));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CHEST:
+                int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_REMINDER_CHEST, seasonRollRewardMinWins));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.STAR_MULTIPLIER:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_RANKED_BONUS_STARS_POPUP, m_currentMedalInfo.starsPerWin));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CARDBACK:
+                int seasonCardBackMinWins = RankMgr.Get().GetLocalPlayerMedalInfo().GetSeasonCardBackMinWins();
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_REMINDER_CARDBACK, seasonCardBackMinWins));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            default:
+                break;
+        }
+    }
+
+	private PegUIElement GetNextChest()
+    {
+		if (m_rewardChestLegacy != null)
+		{
+			return m_rewardChestLegacy;
+		}
+
+		foreach (var chest in m_rewardChests)
+		{
+			if (chest.gameObject.activeInHierarchy)
+            {
+				return chest;
+            }
+		}
+
+		return m_okayButton;
+    }
+
+	public override void HandleAccessibleInput()
+    {
+		if (m_currentMode == MODE.CHEST_EARNED && AccessibleKey.CONFIRM.IsPressed())
+		{
+			if (m_rewardChestLegacy != null)
+            {
+				m_rewardChestLegacy.TriggerRelease();
+				return;
+            }
+
+			if (!m_chestOpened)
+            {
+                m_rankedRewardChestWidget.TriggerEvent(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME);
+            }
+        }
+        else if (AccessibleKey.CONFIRM.IsPressed())
+		{
+            m_okayButton.TriggerRelease();
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+        if (m_currentMode == MODE.CHEST_EARNED)
+        {
+			return LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED_HELP, AccessibleKey.CONFIRM);
+        }
+		else
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/SellableDeckProductPage.cs b/Decompiled/Assembly-CSharp/SellableDeckProductPage.cs
index cdec680..69d4dcf 100644
--- a/Decompiled/Assembly-CSharp/SellableDeckProductPage.cs
+++ b/Decompiled/Assembly-CSharp/SellableDeckProductPage.cs
@@ -18,10 +18,10 @@ public class SellableDeckProductPage : ProductPage
 		base.OnProductVariantSet += HandleProductVariantSet;
 	}
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		m_cardList = new ShopCardList(m_widget, m_scrollbar);
-		base.Open();
+		base.Open(false);
 		SelectVariant(ProductFactory.CreateEmptyProductDataModel());
 		base.OnOpened += InitInput;
 		m_preBuyPopupInfo = new AlertPopup.PopupInfo
diff --git a/Decompiled/Assembly-CSharp/SetFilterTray.cs b/Decompiled/Assembly-CSharp/SetFilterTray.cs
index bfa7482..2eb44a2 100644
--- a/Decompiled/Assembly-CSharp/SetFilterTray.cs
+++ b/Decompiled/Assembly-CSharp/SetFilterTray.cs
@@ -4,8 +4,9 @@ using System.Linq;
 using Blizzard.T5.AssetManager;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class SetFilterTray : MonoBehaviour
+public class SetFilterTray : MonoBehaviour, AccessibleUI
 {
 	public UIBScrollable m_scroller;
 
@@ -47,7 +48,7 @@ public class SetFilterTray : MonoBehaviour
 
 	private HashSet<TAG_CARD_SET> m_setsWithOwnedCards = new HashSet<TAG_CARD_SET>();
 
-	private SetFilterItem m_selected;
+	internal SetFilterItem m_selected;
 
 	private SetFilterItem m_lastSelected;
 
@@ -298,6 +299,8 @@ public class SetFilterTray : MonoBehaviour
 		{
 			collectionManagerDisplay.HideSetFilterTutorial();
 		}
+
+		ReadFilterTray();
 	}
 
 	public bool IsShown()
@@ -429,4 +432,188 @@ public class SetFilterTray : MonoBehaviour
 		}
 		m_items.Clear();
 	}
+
+	#region Accessibility
+
+	private enum State
+	{
+		LOADING,
+		MAIN_MENU,
+		READING_GROUP_ITEMS
+	}
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleMenu m_groupedItemsMenu;
+
+	private State m_curState;
+
+	private void ReadFilterTray()
+	{
+		if (!m_shown)
+		{
+			AccessibilityMgr.HideUI(this);
+			return;
+		}
+
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleMenu = new AccessibleMenu(this, "", m_hideArea.TriggerPress);
+
+		var rootItems = GetRootItems();
+		var groupedItems = GetGroupedItems();
+
+		// Root items (standard, wild, classic) first
+		foreach (var item in rootItems)
+		{
+			AddItemToMenu(m_accessibleMenu, item);
+		}
+
+		// Grouped items second
+		foreach (var group in groupedItems)
+		{
+			var groupName = group.Key;
+			var groupItems = group.Value;
+
+			m_accessibleMenu.AddOption(groupName, () => ReadGroupItems(groupItems));
+		}
+
+		ReadMainMenu();
+	}
+
+	private void AddItemToMenu(AccessibleMenu menu, SetFilterItem item)
+	{
+		menu.AddOption(item.Text, () => SelectItem(item), () => ReadItem(item));
+	}
+
+	private void ReadItem(SetFilterItem item)
+	{
+		AccessibilityUtils.CenterScrollbarAroundObject(m_scroller, item.gameObject);
+	}
+
+	private void SelectItem(SetFilterItem item)
+	{
+		item.TriggerRelease();
+		AccessibleCollectionManager.Get().OnSelectFilterItem();
+		m_hideArea.TriggerPress();
+	}
+
+	private void ReadMainMenu()
+	{
+		m_accessibleMenu.StartReading();
+		m_curState = State.MAIN_MENU;
+	}
+
+	private void ReadGroupItems(List<SetFilterItem> groupItems)
+	{
+		m_groupedItemsMenu = new AccessibleMenu(this, "", ReadMainMenu);
+
+		foreach (var item in groupItems)
+		{
+			AddItemToMenu(m_groupedItemsMenu, item);
+		}
+
+		m_groupedItemsMenu.StartReading();
+		m_curState = State.READING_GROUP_ITEMS;
+	}
+
+	private List<SetFilterItem> GetRootItems()
+	{
+		var ret = new List<SetFilterItem>();
+
+		foreach (var item in m_items)
+		{
+			if (item.IsHeader)
+			{
+				return ret;
+			}
+			else if (!IsActiveSetFilterItem(item))
+			{
+				continue;
+			}
+
+			ret.Add(item);
+		}
+
+		return ret;
+	}
+
+	private Dictionary<string, List<SetFilterItem>> GetGroupedItems()
+	{
+		var ret = new Dictionary<string, List<SetFilterItem>>();
+
+		string curGroupName = null;
+		var curGroupItems = new List<SetFilterItem>();
+
+		foreach (var item in m_items)
+		{
+			if (!IsActiveSetFilterItem(item))
+			{
+				continue;
+			}
+
+			if (item.IsHeader)
+			{
+				// Skip root items
+				if (curGroupItems.Count > 0 && curGroupName != null)
+				{
+					ret.Add(curGroupName, curGroupItems);
+				}
+
+				curGroupItems = new List<SetFilterItem>();
+				curGroupName = item.Text;
+			}
+			else
+			{
+				curGroupItems.Add(item);
+			}
+		}
+
+		if (curGroupItems.Count > 0 && curGroupName != null)
+		{
+			ret.Add(curGroupName, curGroupItems);
+		}
+
+		return ret;
+	}
+
+	private bool IsActiveSetFilterItem(SetFilterItem item)
+	{
+		UIBScrollableItem component = item.GetComponent<UIBScrollableItem>();
+		if (component == null || component.m_active == UIBScrollableItem.ActiveState.Inactive ||
+			(component.m_active == UIBScrollableItem.ActiveState.UseHierarchy && !item.gameObject.activeInHierarchy))
+		{
+			return false;
+		}
+
+		return true;
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_GROUP_ITEMS)
+		{
+			m_groupedItemsMenu?.HandleAccessibleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			return m_accessibleMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_GROUP_ITEMS)
+		{
+			return m_groupedItemsMenu?.GetHelp();
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/SetRotationManager.cs b/Decompiled/Assembly-CSharp/SetRotationManager.cs
index 6d315e0..354b1d6 100644
--- a/Decompiled/Assembly-CSharp/SetRotationManager.cs
+++ b/Decompiled/Assembly-CSharp/SetRotationManager.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class SetRotationManager : IService
 {
@@ -71,12 +72,23 @@ public class SetRotationManager : IService
 
 	public static bool HasSeenStandardModeTutorial()
 	{
+		// This is an entirely visual tutorial and players using OCR were having trouble
+		return true;
 		return Options.Get().GetBool(Option.HAS_SEEN_STANDARD_MODE_TUTORIAL, defaultVal: false);
 	}
 
 	public static bool ShouldShowSetRotationIntro()
 	{
-		if (ReturningPlayerMgr.Get().IsInReturningPlayerMode)
+		// This is an entirely visual tutorial and players using OCR were having trouble
+		return false;
+
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Not implemented yet - making the clock accessible would be quite tricky
+            return false;
+        }
+
+        if (ReturningPlayerMgr.Get().IsInReturningPlayerMode)
 		{
 			return false;
 		}
@@ -205,12 +217,13 @@ public class SetRotationManager : IService
 		{
 			return false;
 		}
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var popupText = GameStrings.Get("GLUE_NEW_PLAYER_SET_ROTATION_POPUP_BODY_NEW");
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add("SetRotationNewPlayerPopup.prefab:cb6eb3b3df79ec34f826043f13e9a609");
 		popupInfo.m_blurWhenShown = true;
 		if (!RankMgr.Get().UseLegacyRankedPlay())
 		{
-			popupInfo.m_bodyText = GameStrings.Get("GLUE_NEW_PLAYER_SET_ROTATION_POPUP_BODY_NEW");
+			popupInfo.m_bodyText = popupText;
 		}
 		popupInfo.m_responseCallback = delegate
 		{
diff --git a/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs b/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
index e3788b7..fd0eeb1 100644
--- a/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
+++ b/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class SetRotationRotatedBoostersPopup : BasicPopup
@@ -11,6 +12,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 	public class SetRotationRotatedBoostersPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public SetRotationRotatedBoostersPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	private Widget m_widget;
@@ -25,12 +28,18 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 
 	private SetRotationRotatedBoostersPopupInfo m_info;
 
+    #region Accessibility
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+
+	private PackListDataModel m_packListDataModel;
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -55,6 +64,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 			}
 			Hashtable args = iTween.Hash("scale", localScale, "time", 0.3f, "easetype", iTween.EaseType.easeOutBack);
 			iTween.ScaleTo(base.gameObject, args);
+
+			ReadPopup();
 		}
 	}
 
@@ -66,11 +77,13 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 			setRotationRotatedBoostersPopupInfo.m_onHiddenCallback();
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void BindRankedPackListDataModel()
 	{
-		PackListDataModel packListDataModel = new PackListDataModel();
+		m_packListDataModel = new PackListDataModel();
 		SpecialEventManager events = SpecialEventManager.Get();
 		List<BoosterDbfRecord> records = GameDbf.Booster.GetRecords((BoosterDbfRecord r) => events.IsEventActive(r.BuyWithGoldEvent, activeIfDoesNotExist: false));
 		records.Sort((BoosterDbfRecord a, BoosterDbfRecord b) => b.LatestExpansionOrder.CompareTo(a.LatestExpansionOrder));
@@ -81,13 +94,53 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 				PackDataModel packDataModel = new PackDataModel();
 				packDataModel.Type = (BoosterDbId)item.ID;
 				packDataModel.BoosterName = item.Name;
-				packListDataModel.Packs.Insert(0, packDataModel);
-				if (packListDataModel.Packs.Count >= 3)
+				m_packListDataModel.Packs.Insert(0, packDataModel);
+				if (m_packListDataModel.Packs.Count >= 3)
 				{
 					break;
 				}
 			}
 		}
-		m_widget.BindDataModel(packListDataModel);
+		m_widget.BindDataModel(m_packListDataModel);
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_widget == null || m_packListDataModel == null)
+        {
+			return;
+        }
+
+		var packNames = new List<string>();
+
+		foreach (var pack in m_packListDataModel.Packs)
+		{
+			packNames.Add(pack.BoosterName);
+		}
+
+		var packNamesList = AccessibleSpeechUtils.HumanizeList(packNames);
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE));
+		AccessibilityMgr.Output(this, packNamesList);
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Shop.cs b/Decompiled/Assembly-CSharp/Shop.cs
index 9af08e0..7ccd70b 100644
--- a/Decompiled/Assembly-CSharp/Shop.cs
+++ b/Decompiled/Assembly-CSharp/Shop.cs
@@ -13,6 +13,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class Shop : MonoBehaviour, IStore
 {
@@ -28,7 +29,7 @@ public class Shop : MonoBehaviour, IStore
 	private delegate void ReopenCallback();
 
 	[SerializeField]
-	protected UIBScrollable m_browserScroller;
+	internal UIBScrollable m_browserScroller;
 
 	[SerializeField]
 	protected VisualController m_shopStateController;
@@ -313,6 +314,8 @@ public class Shop : MonoBehaviour, IStore
 			{
 				this.OnOpened();
 			}
+
+			m_browser.OnShopOpened();
 		}
 	}
 
@@ -809,7 +812,7 @@ public class Shop : MonoBehaviour, IStore
 			currentProductPage.Close();
 			if (reopenLater)
 			{
-				m_reopenPageCall = currentProductPage.Open;
+				m_reopenPageCall = () => currentProductPage.Open(true);
 			}
 		}
 		else if (currentProductPage == m_productPageContainer.GetCurrentProductPage())
diff --git a/Decompiled/Assembly-CSharp/ShopBrowser.cs b/Decompiled/Assembly-CSharp/ShopBrowser.cs
index 7cc1799..97d9612 100644
--- a/Decompiled/Assembly-CSharp/ShopBrowser.cs
+++ b/Decompiled/Assembly-CSharp/ShopBrowser.cs
@@ -5,8 +5,9 @@ using System.Linq;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
-public class ShopBrowser : MonoBehaviour
+public class ShopBrowser : MonoBehaviour, AccessibleUI
 {
 	[SerializeField]
 	protected ShopProductData[] m_testData;
@@ -320,6 +321,8 @@ public class ShopBrowser : MonoBehaviour
 			}
 		}
 		ResizeTierCount(0);
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void RecordStartLoading()
@@ -336,6 +339,8 @@ public class ShopBrowser : MonoBehaviour
 		m_isLoading = false;
 		m_timeSpentLoading = DateTime.UtcNow - m_timeStartedLoading;
 		Log.Store.PrintDebug("Shop load done at {0} seconds {1} frames", m_timeSpentLoading.TotalSeconds, m_framesSpentLoading);
+
+		ReadShop();
 	}
 
 	private void UpdateLoadingStats()
@@ -499,4 +504,422 @@ public class ShopBrowser : MonoBehaviour
 		Log.Store.PrintDebug("Finished loading section {0} contents at frame = {1}, time = {2}", sectionIndex, m_framesSpentLoading, m_timeSpentLoading.TotalSeconds);
 		onComplete(obj: true);
 	}
+
+	#region Accessibility
+	private enum State
+	{
+		LOADING,
+		MAIN_MENU,
+		BUY_PACKS_SELECT_FORMAT_MENU,
+		BUY_PACKS_STANDARD_MENU,
+		BUY_PACKS_WILD_MENU,
+		BUY_PRODUCTS_MENU,
+	}
+
+	private State m_curState;
+
+	private AccessibleMenu m_accessibleShopMenu;
+
+	private AccessibleMenu m_buyPacksSelectFormatMenu;
+
+	private AccessibleMenu m_buyPacksMenu;
+
+	private List<ShopSlot> m_availablePacks;
+
+	private AccessibleMenu m_buyProductsMenu;
+
+	private bool m_hasProductPageOpened;
+
+	internal void OnShopOpened()
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_LOADING);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+		m_curState = State.LOADING;
+	}
+
+	private void ReadShop()
+	{
+		var slots = GetAllSlots();
+		var slotsWhichCanBeBoughtWithGold = AccessibleShopUtils.FilterSlotsWhichCanBeBoughtWithGold(slots);
+
+		// Create categories for the main items
+		m_availablePacks = GetCardPackSlots(slotsWhichCanBeBoughtWithGold);
+		var availableMiniSets = GetMiniSetSlots(slotsWhichCanBeBoughtWithGold);
+		var availableHeroSkins = GetHeroSkinSlots(slotsWhichCanBeBoughtWithGold);
+		var availableBundles = GetBundleSlots(slotsWhichCanBeBoughtWithGold);
+
+		// Group everything else together in an "other" category
+		var availableOthers = slotsWhichCanBeBoughtWithGold;
+		availableOthers.RemoveAll(m_availablePacks.Contains);
+		availableOthers.RemoveAll(availableMiniSets.Contains);
+		availableOthers.RemoveAll(availableHeroSkins.Contains);
+		availableOthers.RemoveAll(availableBundles.Contains);
+
+		m_accessibleShopMenu = new AccessibleMenu(this, "", () => Shop.Get().Close(true));
+		m_accessibleShopMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_GOLD), ReadGold);
+
+		if (m_availablePacks.Count > 0)
+		{
+			m_accessibleShopMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_BUY_PACKS), BuyPacksSelectFormat);
+		}
+
+		AddBuyProductsOptionIfNecessary(m_accessibleShopMenu, LocalizationKey.UI_SHOP_BUY_MINI_SETS, availableMiniSets);
+		AddBuyProductsOptionIfNecessary(m_accessibleShopMenu, LocalizationKey.UI_SHOP_BUY_HERO_SKINS, availableHeroSkins);
+		AddBuyProductsOptionIfNecessary(m_accessibleShopMenu, LocalizationKey.UI_SHOP_BUY_BUNDLES, availableBundles);
+		AddBuyProductsOptionIfNecessary(m_accessibleShopMenu, LocalizationKey.UI_SHOP_BUY_OTHERS, availableOthers);
+
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_STORE_HEADLINE"));
+		ReadShopMainMenu();
+	}
+
+	private void AddBuyProductsOptionIfNecessary(AccessibleMenu shopMenu, LocalizationKey optionKey, List<ShopSlot> slots)
+	{
+		if (slots.Count > 0)
+		{
+			shopMenu.AddOption(LocalizationUtils.Get(optionKey), () => BuyProducts(slots));
+		}
+	}
+
+	private void ReadShopMainMenu()
+	{
+		m_accessibleShopMenu.StartReading();
+		m_curState = State.MAIN_MENU;
+	}
+
+	private void BuyPacksSelectFormat()
+	{
+		m_buyPacksSelectFormatMenu = new AccessibleMenu(this, "", ReadShopMainMenu);
+
+		if (CanBuyStandardPacks())
+		{
+			m_buyPacksSelectFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_STANDARD), BuyPacksStandard);
+		}
+		if (CanBuyWildPacks())
+		{
+			m_buyPacksSelectFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_WILD), BuyPacksWild);
+		}
+
+		ReadBuyPacksSelectFormatMenu();
+	}
+
+	private void ReadBuyPacksSelectFormatMenu()
+	{
+		m_buyPacksSelectFormatMenu?.StartReading();
+		m_curState = State.BUY_PACKS_SELECT_FORMAT_MENU;
+	}
+
+	private void BuyPacksStandard()
+	{
+		var standardPacks = GetAvailableStandardPacks();
+		m_buyPacksMenu = new AccessibleMenu(this, "", ReadBuyPacksSelectFormatMenu);
+
+		foreach (var pack in standardPacks)
+		{
+			m_buyPacksMenu.AddOption(GetPackName(pack), () => OpenShopSlot(pack), () => ScrollToShopSlot(pack));
+		}
+
+		m_buyPacksMenu.StartReading();
+		m_curState = State.BUY_PACKS_STANDARD_MENU;
+	}
+
+	private void BuyPacksWild()
+	{
+		var wildPacks = GetAvailableWildPacks();
+		m_buyPacksMenu = new AccessibleMenu(this, "", ReadBuyPacksSelectFormatMenu);
+
+		foreach (var pack in wildPacks)
+		{
+			m_buyPacksMenu.AddOption(GetPackName(pack), () => OpenShopSlot(pack), () => ScrollToShopSlot(pack));
+		}
+
+		m_buyPacksMenu.StartReading();
+		m_curState = State.BUY_PACKS_WILD_MENU;
+	}
+
+	private string GetPackName(ShopSlot pack)
+	{
+		var packDataModel = GetPackDataModel(pack);
+		return AccessibleCardUtils.GetCardPackName((int)packDataModel.Type);
+	}
+
+	private List<ShopSlot> GetAvailableStandardPacks()
+	{
+		var ret = new List<ShopSlot>();
+
+		foreach (var pack in m_availablePacks)
+		{
+			if (IsStandardPack(pack))
+			{
+				ret.Add(pack);
+			}
+		}
+
+		return ret;
+	}
+
+	private List<ShopSlot> GetAvailableWildPacks()
+	{
+		var ret = new List<ShopSlot>();
+
+		foreach (var pack in m_availablePacks)
+		{
+			if (IsWildPack(pack))
+			{
+				ret.Add(pack);
+			}
+		}
+
+		return ret;
+	}
+
+	private bool CanBuyStandardPacks()
+	{
+		foreach (var pack in m_availablePacks)
+		{
+			if (IsStandardPack(pack))
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	private bool CanBuyWildPacks()
+	{
+		foreach (var pack in m_availablePacks)
+		{
+			if (IsWildPack(pack))
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	private bool IsStandardPack(ShopSlot pack)
+	{
+		return !IsWildPack(pack);
+	}
+
+	private bool IsWildPack(ShopSlot pack)
+	{
+		return GameUtils.IsBoosterRotated(GetPackDataModel(pack).Type, DateTime.UtcNow);
+	}
+
+	private void BuyProducts(List<ShopSlot> products)
+	{
+		m_buyProductsMenu = new AccessibleMenu(this, "", ReadShopMainMenu);
+
+		foreach (var product in products)
+		{
+			m_buyProductsMenu.AddOption(GetProductName(product), () => OpenShopSlot(product), () => ScrollToShopSlot(product));
+		}
+
+		ReadBuyProductsMenu();
+	}
+
+	private void ReadBuyProductsMenu()
+	{
+		m_buyProductsMenu.StartReading();
+		m_curState = State.BUY_PRODUCTS_MENU;
+	}
+
+	private string GetProductName(ShopSlot slot)
+	{
+		return slot.m_productDataModel.Name;
+	}
+
+	private void ReadGold()
+	{
+		AccessibleShopUtils.ReadGold(this);
+	}
+
+	private PackDataModel GetPackDataModel(ShopSlot pack)
+	{
+		var productDataModel = pack.m_productDataModel;
+		var rewardItemDataModel = productDataModel.Items[0];
+		return rewardItemDataModel.Booster;
+	}
+
+	private List<ShopSlot> GetAllSlots()
+	{
+		var ret = new List<ShopSlot>();
+
+		foreach (var section in m_shopSections)
+		{
+			if (section.isActiveAndEnabled)
+			{
+				var slots = section.GetSortedEnabledSlots();
+
+				foreach (var slot in slots)
+				{
+					ret.Add(slot);
+				}
+			}
+		}
+
+		return ret;
+	}
+
+	private List<ShopSlot> GetCardPackSlots(List<ShopSlot> slots)
+	{
+		var ret = new List<ShopSlot>();
+
+		foreach (var slot in slots)
+		{
+			if (AccessibleShopUtils.IsAvailable(slot) && AccessibleShopUtils.IsCardPackSlot(slot))
+			{
+				ret.Add(slot);
+			}
+		}
+
+		return ret;
+	}
+
+	private List<ShopSlot> GetMiniSetSlots(List<ShopSlot> slots)
+	{
+		var ret = new List<ShopSlot>();
+
+		foreach (var slot in slots)
+		{
+			if (AccessibleShopUtils.IsAvailable(slot) && AccessibleShopUtils.IsMiniSetSlot(slot))
+			{
+				ret.Add(slot);
+			}
+		}
+
+		return ret;
+	}
+
+	private List<ShopSlot> GetHeroSkinSlots(List<ShopSlot> slots)
+	{
+		var ret = new List<ShopSlot>();
+
+		foreach (var slot in slots)
+		{
+			if (AccessibleShopUtils.IsAvailable(slot) && AccessibleShopUtils.IsHeroSkinSlot(slot))
+			{
+				ret.Add(slot);
+			}
+		}
+
+		return ret;
+	}
+
+	private List<ShopSlot> GetBundleSlots(List<ShopSlot> slots)
+	{
+		var ret = new List<ShopSlot>();
+
+		foreach (var slot in slots)
+		{
+			if (AccessibleShopUtils.IsAvailable(slot) && AccessibleShopUtils.IsBundle(slot))
+			{
+				ret.Add(slot);
+			}
+		}
+
+		return ret;
+	}
+
+	private void OpenShopSlot(ShopSlot slot)
+	{
+		m_hasProductPageOpened = true;
+		slot.ClickOpen();
+	}
+
+	private void ScrollToShopSlot(ShopSlot slot)
+	{
+		AccessibilityUtils.CenterScrollbarAroundObject(Shop.Get().m_browserScroller, slot.gameObject);
+	}
+
+	internal void OnProductPageClosed(bool goBackToMainMenu)
+	{
+		if (!m_hasProductPageOpened)
+		{
+			return;
+		}
+
+		m_hasProductPageOpened = false;
+
+		if (goBackToMainMenu)
+		{
+			ReadShop();
+			return;
+		}
+
+		if (m_curState == State.BUY_PACKS_STANDARD_MENU || m_curState == State.BUY_PACKS_WILD_MENU)
+		{
+			m_buyPacksMenu?.StartReading();
+		}
+		else if (m_curState == State.BUY_PRODUCTS_MENU)
+		{
+			m_buyProductsMenu?.StartReading();
+		}
+	}
+
+	internal void OnStorePurchaseAuthClosed(bool purchaseSuccess)
+	{
+		Shop.Get()?.CurrentProductPage?.OnStorePurchaseAuthClosed(purchaseSuccess);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (m_curState == State.LOADING || m_hasProductPageOpened)
+		{
+			return;
+		}
+
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_accessibleShopMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.BUY_PACKS_SELECT_FORMAT_MENU)
+		{
+			m_buyPacksSelectFormatMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.BUY_PACKS_STANDARD_MENU || m_curState == State.BUY_PACKS_WILD_MENU)
+		{
+			m_buyPacksMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.BUY_PRODUCTS_MENU)
+		{
+			m_buyProductsMenu?.HandleAccessibleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == State.LOADING)
+		{
+			return LocalizedText.GLOBAL_LOADING;
+		}
+		else if (m_curState == State.MAIN_MENU)
+		{
+			return m_accessibleShopMenu?.GetHelp();
+		}
+		else if (m_curState == State.BUY_PACKS_SELECT_FORMAT_MENU)
+		{
+			return m_buyPacksSelectFormatMenu?.GetHelp();
+		}
+		else if (m_curState == State.BUY_PACKS_STANDARD_MENU || m_curState == State.BUY_PACKS_WILD_MENU)
+		{
+			return m_buyPacksMenu?.GetHelp();
+		}
+		else if (m_curState == State.BUY_PRODUCTS_MENU)
+		{
+			return m_buyProductsMenu?.GetHelp();
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ShopCardList.cs b/Decompiled/Assembly-CSharp/ShopCardList.cs
index a7c975f..98bb45e 100644
--- a/Decompiled/Assembly-CSharp/ShopCardList.cs
+++ b/Decompiled/Assembly-CSharp/ShopCardList.cs
@@ -7,7 +7,7 @@ public class ShopCardList
 {
 	private UIBScrollable m_scrollbar;
 
-	private MiniSetDetailsDataModel m_dataModel;
+	internal MiniSetDetailsDataModel m_dataModel;
 
 	private CardTileDataModel m_clickedTile;
 
diff --git a/Decompiled/Assembly-CSharp/ShopSlot.cs b/Decompiled/Assembly-CSharp/ShopSlot.cs
index a6749fe..48755e4 100644
--- a/Decompiled/Assembly-CSharp/ShopSlot.cs
+++ b/Decompiled/Assembly-CSharp/ShopSlot.cs
@@ -71,6 +71,10 @@ public class ShopSlot : ShopBrowserElement
 		}
 	}
 
+	#region Accessibility
+	internal ProductDataModel m_productDataModel;
+	#endregion
+
 	private void Start()
 	{
 		m_widget = GetComponent<Widget>();
@@ -160,12 +164,12 @@ public class ShopSlot : ShopBrowserElement
 	public void SetBrowserButton(ShopBrowserButtonDataModel buttonDataModel)
 	{
 		DataModel = buttonDataModel;
-		ProductDataModel productDataModel = buttonDataModel.DisplayProduct ?? ProductFactory.CreateEmptyProductDataModel();
-		m_isFilled = productDataModel != ProductFactory.CreateEmptyProductDataModel();
+		m_productDataModel = buttonDataModel.DisplayProduct ?? ProductFactory.CreateEmptyProductDataModel();
+		m_isFilled = m_productDataModel != ProductFactory.CreateEmptyProductDataModel();
 		RefreshEnableInput();
 		if (m_widget != null)
 		{
-			m_widget.BindDataModel(productDataModel);
+			m_widget.BindDataModel(m_productDataModel);
 		}
 		StartCoroutine(DisableChildCollidersCoroutine());
 		UpdateSize();
@@ -304,4 +308,12 @@ public class ShopSlot : ShopBrowserElement
 			}
 		}
 	}
+
+	#region Accessibility
+	internal void ClickOpen()
+	{
+		Clickable component = GetComponent<Clickable>();
+		component.GetPegUIElement()?.TriggerRelease();
+	}
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ShopUtils.cs b/Decompiled/Assembly-CSharp/ShopUtils.cs
index b3ec151..32e0db2 100644
--- a/Decompiled/Assembly-CSharp/ShopUtils.cs
+++ b/Decompiled/Assembly-CSharp/ShopUtils.cs
@@ -8,6 +8,7 @@ using Hearthstone.UI;
 using PegasusShared;
 using Shared.Scripts.Util;
 using UnityEngine;
+using Accessibility;
 
 public static class ShopUtils
 {
@@ -97,6 +98,11 @@ public static class ShopUtils
 
 	public static long GetCachedBalance(CurrencyType currencyType)
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return 327;
+		}
+
 		switch (currencyType)
 		{
 		case CurrencyType.DUST:
diff --git a/Decompiled/Assembly-CSharp/SocialToastMgr.cs b/Decompiled/Assembly-CSharp/SocialToastMgr.cs
index e8bdd81..f28ad15 100644
--- a/Decompiled/Assembly-CSharp/SocialToastMgr.cs
+++ b/Decompiled/Assembly-CSharp/SocialToastMgr.cs
@@ -10,6 +10,7 @@ using Hearthstone.Progression;
 using PegasusClient;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class SocialToastMgr : MonoBehaviour
 {
@@ -168,7 +169,7 @@ public class SocialToastMgr : MonoBehaviour
 
 	public void AddToast(UserAttentionBlocker blocker, string textArg, TOAST_TYPE toastType, float displayTime, bool playSound)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "SocialToastMgr.AddToast:" + toastType))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "SocialToastMgr.AddToast:" + toastType))
 		{
 			SocialToastDesign design = SocialToastDesign.Default;
 			string message;
@@ -303,13 +304,14 @@ public class SocialToastMgr : MonoBehaviour
 		RenderUtils.SetAlpha(m_currentToast.gameObject, 1f);
 		if (toastArgs.m_playSound)
 		{
-			PlayToastSound();
+			PlayToastSound(toastArgs.m_message);
 		}
 	}
 
-	public void PlayToastSound()
+	public void PlayToastSound(string message)
 	{
 		SoundManager.Get().LoadAndPlay("UI_BnetToast.prefab:b869739323d1fc241984f9f480fff8ef");
+		AccessibilityMgr.OutputNotification(message);
 	}
 
 	private void FadeOutToast(float displayTime)
diff --git a/Decompiled/Assembly-CSharp/SoundManager.cs b/Decompiled/Assembly-CSharp/SoundManager.cs
index 8881f05..e6c31c7 100644
--- a/Decompiled/Assembly-CSharp/SoundManager.cs
+++ b/Decompiled/Assembly-CSharp/SoundManager.cs
@@ -11,6 +11,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 {
@@ -716,8 +717,8 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			SoundLoadContext soundLoadContext = new SoundLoadContext();
 			soundLoadContext.Init(parent, volume, callback, callbackData);
 			SoundLoader.LoadSound(assetRef, OnLoadAndPlaySoundLoaded, soundLoadContext, GetPlaceholderSound());
-		}
-	}
+        }
+    }
 
 	public void PlayPreloaded(AudioSource source)
 	{
@@ -749,7 +750,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 		InitSourceTransform(source, parentObject);
 		m_generatedSources.Add(source);
 		Play(source);
-	}
+    }
 
 	public AudioSource PlayClip(SoundPlayClipArgs args, bool createNewSource = true, SoundOptions options = null)
 	{
@@ -854,7 +855,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			return;
 		}
 		RegisterSourceBundle(assetRef, component);
-		component.volume = 0f;
+        component.volume = 0f;
 		component.Play();
 		component.Stop();
 		UnregisterSourceBundle(assetRef.ToString(), component);
@@ -2141,7 +2142,14 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			}
 			HearthstoneApplication.Get().StartCoroutine(EnableInstanceLimitedSound(source.gameObject.name, num2));
 		}
-		source.Play();
+
+		if (HearthstoneAccessConstants.DEBUG_SOUND)
+        {
+            AccessibilityUtils.LogDebug($"Playing sound: {source.name}");
+			AccessibilityUtils.LogDebug(Environment.StackTrace);
+        }
+
+        source.Play();
 		return source;
 	}
 
diff --git a/Decompiled/Assembly-CSharp/SpectatorManager.cs b/Decompiled/Assembly-CSharp/SpectatorManager.cs
index 322b083..9ee0fc5 100644
--- a/Decompiled/Assembly-CSharp/SpectatorManager.cs
+++ b/Decompiled/Assembly-CSharp/SpectatorManager.cs
@@ -2317,7 +2317,7 @@ public class SpectatorManager
 					Processor.CancelScheduledCallback(SpectatePlayer_RequestInvite_OpposingSide_Timeout);
 				}
 			}
-			else if (!UserAttentionManager.CanShowAttentionGrabber("SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
+			else if (!UserAttentionManager.CanShowAttentionGrabber(false, "SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
 			{
 				flag3 = true;
 				text = "user_attention_blocked";
diff --git a/Decompiled/Assembly-CSharp/StoreManager.cs b/Decompiled/Assembly-CSharp/StoreManager.cs
index 679b424..d3961b8 100644
--- a/Decompiled/Assembly-CSharp/StoreManager.cs
+++ b/Decompiled/Assembly-CSharp/StoreManager.cs
@@ -566,7 +566,7 @@ public class StoreManager
 		return false;
 	}
 
-	private void SetCanTapOutConfirmationUI(bool closeConfirmationUI)
+	internal void SetCanTapOutConfirmationUI(bool closeConfirmationUI)
 	{
 		m_canCloseConfirmation = closeConfirmationUI;
 	}
@@ -3084,7 +3084,7 @@ public class StoreManager
 		GetCurrentStore()?.BlockInterface(blocked: true);
 	}
 
-	private void UnblockStoreInterface()
+	internal void UnblockStoreInterface()
 	{
 		GetCurrentStore()?.BlockInterface(blocked: false);
 	}
diff --git a/Decompiled/Assembly-CSharp/StorePurchaseAuth.cs b/Decompiled/Assembly-CSharp/StorePurchaseAuth.cs
index 440e7a9..db23a38 100644
--- a/Decompiled/Assembly-CSharp/StorePurchaseAuth.cs
+++ b/Decompiled/Assembly-CSharp/StorePurchaseAuth.cs
@@ -3,9 +3,11 @@ using System.Linq;
 using Hearthstone.Commerce;
 using PegasusShared;
 using PegasusUtil;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class StorePurchaseAuth : UIBPopup
+public class StorePurchaseAuth : UIBPopup, AccessibleUI
 {
 	public delegate void AckPurchaseResultListener(bool success, MoneyOrGTAPPTransaction moneyOrGTAPPTransaction);
 
@@ -76,6 +78,7 @@ public class StorePurchaseAuth : UIBPopup
 			}
 			Navigation.PushBlockBackingOut();
 			DoShowAnimation();
+			ReadPopup();
 		}
 	}
 
@@ -151,6 +154,8 @@ public class StorePurchaseAuth : UIBPopup
 
 	public override void Hide()
 	{
+		HideThis();
+
 		if (m_shown)
 		{
 			m_shown = false;
@@ -313,6 +318,8 @@ public class StorePurchaseAuth : UIBPopup
 		m_failHeadlineText.gameObject.SetActive(value: false);
 		m_failDetailsText.gameObject.SetActive(value: false);
 		m_spell.ActivateState(SpellStateType.ACTION);
+
+		ReadPurchaseSuccess();
 	}
 
 	private void ShowPurchaseFailure(MoneyOrGTAPPTransaction moneyOrGTAPPTransaction, string failDetails, bool showMiniSummary, Network.PurchaseErrorInfo.ErrorType error)
@@ -336,6 +343,8 @@ public class StorePurchaseAuth : UIBPopup
 		m_failHeadlineText.gameObject.SetActive(value: true);
 		m_failDetailsText.gameObject.SetActive(value: true);
 		m_spell.ActivateState(SpellStateType.DEATH);
+
+		ReadPurchaseFailure();
 	}
 
 	private void ShowMiniSummary()
@@ -348,4 +357,102 @@ public class StorePurchaseAuth : UIBPopup
 			m_root.UpdateSlices();
 		}
 	}
+
+	#region Accessibility
+
+	private enum State
+	{
+		LOADING,
+		TEXT_ONLY,
+		TEXT_AND_OK_BUTTON
+	};
+
+	private State m_curState;
+
+	private AccessibleMultilineText m_accessibleText;
+
+	private void ReadPopup()
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleText = new AccessibleMultilineText(this, m_waitingForAuthText.Text);
+		m_accessibleText.ReadAllLines();
+
+		m_curState = State.TEXT_ONLY;
+	}
+
+	private void ReadPurchaseSuccess()
+	{
+		m_accessibleText = new AccessibleMultilineText(this, m_successHeadlineText.Text, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+		m_accessibleText.ReadAllLines();
+
+		m_curState = State.TEXT_AND_OK_BUTTON;
+	}
+
+	private void ReadPurchaseFailure()
+	{
+		m_accessibleText = new AccessibleMultilineText(this, m_failHeadlineText.Text, m_failDetailsText.Text, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+		m_accessibleText.ReadAllLines();
+
+		m_curState = State.TEXT_AND_OK_BUTTON;
+	}
+
+	private void HideThis()
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.HideUI(this);
+		Shop.Get()?.Browser?.OnStorePurchaseAuthClosed(m_showingSuccess);
+
+		// Unblock interface since we're shortcutting a lot of stuff
+		StoreManager.Get()?.SetCanTapOutConfirmationUI(closeConfirmationUI: true);
+		StoreManager.Get()?.UnblockStoreInterface();
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			if (AccessibleKey.DEV_1.IsPressed())
+			{
+				ShowPurchaseSuccess(null, false);
+			}
+			else if (AccessibleKey.DEV_2.IsPressed())
+			{
+				ShowPurchaseFailure(null, "Failed for some reason", false, Network.PurchaseErrorInfo.ErrorType.UNKNOWN);
+			}
+		}
+
+		if (m_curState == State.TEXT_ONLY || m_curState == State.TEXT_AND_OK_BUTTON)
+		{
+			m_accessibleText?.HandleAccessibleInput();
+		}
+
+		if (m_curState == State.TEXT_AND_OK_BUTTON)
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				m_okButton.TriggerRelease();
+			}
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == State.TEXT_AND_OK_BUTTON)
+		{
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/SubSpellController.cs b/Decompiled/Assembly-CSharp/SubSpellController.cs
index b9ecadc..19c0a97 100644
--- a/Decompiled/Assembly-CSharp/SubSpellController.cs
+++ b/Decompiled/Assembly-CSharp/SubSpellController.cs
@@ -68,7 +68,7 @@ public class SubSpellController : SpellController
 		{
 			CheckForSubSpellEnd(taskList);
 		}
-		return num;
+        return num;
 	}
 
 	private SubSpellInstance GetSubSpellInstanceForTasklist(PowerTaskList taskList)
diff --git a/Decompiled/Assembly-CSharp/TAG_CARDTYPE.cs b/Decompiled/Assembly-CSharp/TAG_CARDTYPE.cs
index 4a38aa0..5df7070 100644
--- a/Decompiled/Assembly-CSharp/TAG_CARDTYPE.cs
+++ b/Decompiled/Assembly-CSharp/TAG_CARDTYPE.cs
@@ -15,5 +15,6 @@ public enum TAG_CARDTYPE
 	GAME_MODE_BUTTON = 12,
 	MOVE_MINION_HOVER_TARGET = 22,
 	LETTUCE_ABILITY = 23,
-	BATTLEGROUND_HERO_BUDDY = 24
+	BATTLEGROUND_HERO_BUDDY = 24,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_CLASS.cs b/Decompiled/Assembly-CSharp/TAG_CLASS.cs
index 25a920d..093b6c4 100644
--- a/Decompiled/Assembly-CSharp/TAG_CLASS.cs
+++ b/Decompiled/Assembly-CSharp/TAG_CLASS.cs
@@ -14,5 +14,6 @@ public enum TAG_CLASS
 	DREAM,
 	NEUTRAL,
 	WHIZBANG,
-	DEMONHUNTER
+	DEMONHUNTER,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_FACTION.cs b/Decompiled/Assembly-CSharp/TAG_FACTION.cs
index 95167c3..4d0a453 100644
--- a/Decompiled/Assembly-CSharp/TAG_FACTION.cs
+++ b/Decompiled/Assembly-CSharp/TAG_FACTION.cs
@@ -3,5 +3,6 @@ public enum TAG_FACTION
 	INVALID,
 	HORDE,
 	ALLIANCE,
-	NEUTRAL
+	NEUTRAL,
+	EOE // There are comparisons throughout the code which assume HORDE == 1 and ALLIANCE == 2 (see HonorManager.IsValdidQuestForAction / AccessibleCard.AddAvLinesForPlayer)
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs b/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs
index 11f69f0..86c4fe0 100644
--- a/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs
+++ b/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs
@@ -2,5 +2,6 @@ public enum TAG_PREMIUM
 {
 	NORMAL,
 	GOLDEN,
-	DIAMOND
+	DIAMOND,
+	EOE // AccessibleCollectibleCard depends on this for reading premium
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_RARITY.cs b/Decompiled/Assembly-CSharp/TAG_RARITY.cs
index ab28cdd..ab9360c 100644
--- a/Decompiled/Assembly-CSharp/TAG_RARITY.cs
+++ b/Decompiled/Assembly-CSharp/TAG_RARITY.cs
@@ -5,5 +5,6 @@ public enum TAG_RARITY
 	FREE,
 	RARE,
 	EPIC,
-	LEGENDARY
+	LEGENDARY,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_STEP.cs b/Decompiled/Assembly-CSharp/TAG_STEP.cs
index f8fe27a..465dfb8 100644
--- a/Decompiled/Assembly-CSharp/TAG_STEP.cs
+++ b/Decompiled/Assembly-CSharp/TAG_STEP.cs
@@ -20,5 +20,6 @@ public enum TAG_STEP
 	MAIN_START_TRIGGERS,
 	MAIN_SET_ACTION_STEP_TYPE,
 	MAIN_PRE_ACTION,
-	MAIN_POST_ACTION
+	MAIN_POST_ACTION,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_ZONE.cs b/Decompiled/Assembly-CSharp/TAG_ZONE.cs
index 412e709..6f1d091 100644
--- a/Decompiled/Assembly-CSharp/TAG_ZONE.cs
+++ b/Decompiled/Assembly-CSharp/TAG_ZONE.cs
@@ -8,5 +8,6 @@ public enum TAG_ZONE
 	REMOVEDFROMGAME,
 	SETASIDE,
 	SECRET,
-	LETTUCE_ABILITY
+	LETTUCE_ABILITY,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TB_BaconShop.cs b/Decompiled/Assembly-CSharp/TB_BaconShop.cs
index 022494b..94c4aa6 100644
--- a/Decompiled/Assembly-CSharp/TB_BaconShop.cs
+++ b/Decompiled/Assembly-CSharp/TB_BaconShop.cs
@@ -5,6 +5,7 @@ using System.Linq;
 using Hearthstone.Progression;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class TB_BaconShop : MissionEntity
 {
@@ -272,6 +273,14 @@ public class TB_BaconShop : MissionEntity
 		};
 	}
 
+	#region Accessibility
+
+	internal static int GAME_PHASE_SHOP = 1;
+
+	internal static int GAME_PHASE_COMBAT = 2;
+
+	#endregion
+
 	public TB_BaconShop()
 	{
 		m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
@@ -434,17 +443,7 @@ public class TB_BaconShop : MissionEntity
 
 	public override string GetMulliganDetailText()
 	{
-		List<TAG_RACE> list = GameState.Get().GetAvailableRacesInBattlegroundsExcludingAmalgam().ToList();
-		if (list.Contains(TAG_RACE.INVALID))
-		{
-			return null;
-		}
-		list.Sort((TAG_RACE a, TAG_RACE b) => string.Compare(GameStrings.GetRaceNameBattlegrounds(a), GameStrings.GetRaceNameBattlegrounds(b), StringComparison.Ordinal));
-		if (list.Count == 5)
-		{
-			return GameStrings.Format("GAMEPLAY_BACON_MULLIGAN_AVAILABLE_RACES", GameStrings.GetRaceNameBattlegrounds(list[0]), GameStrings.GetRaceNameBattlegrounds(list[1]), GameStrings.GetRaceNameBattlegrounds(list[2]), GameStrings.GetRaceNameBattlegrounds(list[3]), GameStrings.GetRaceNameBattlegrounds(list[4]));
-		}
-		return null;
+		return GetAvailableRacesText();
 	}
 
 	public override Vector3 NameBannerPosition(Player.Side side)
@@ -516,7 +515,7 @@ public class TB_BaconShop : MissionEntity
 		return true;
 	}
 
-	private int CountPlayersFinishedMulligan()
+	internal int CountPlayersFinishedMulligan()
 	{
 		int num = 0;
 		foreach (SharedPlayerInfo value in GameState.Get().GetPlayerInfoMap().Values)
@@ -529,7 +528,7 @@ public class TB_BaconShop : MissionEntity
 		return num;
 	}
 
-	private int CountPlayersInGame()
+	internal int CountPlayersInGame()
 	{
 		return GameState.Get().GetPlayerInfoMap().Values.Count;
 	}
@@ -736,21 +735,23 @@ public class TB_BaconShop : MissionEntity
 	{
 		if (missionEvent == 1)
 		{
-			m_gamePhase = 1;
+			m_gamePhase = GAME_PHASE_SHOP;
 			yield return OnShopPhase(waitForBaconBoard: true);
 		}
 		if (missionEvent == 5)
 		{
-			m_gamePhase = 1;
+			m_gamePhase = GAME_PHASE_SHOP;
 			yield return OnShopPhase(waitForBaconBoard: false);
 		}
 		if (missionEvent == 2)
 		{
-			m_gamePhase = 2;
+			m_gamePhase = GAME_PHASE_COMBAT;
 			yield return OnCombatPhase();
 		}
 		if (missionEvent == 3)
 		{
+			AccessibleGameplay.Get().OnFreezeOrUnfreezeEvent();
+
 			int tag = GetFreezeButtonCard().GetEntity().GetTag(GAME_TAG.TAG_SCRIPT_DATA_NUM_1);
 			int tag2 = GetFreezeButtonCard().GetEntity().GetTag(GAME_TAG.TAG_SCRIPT_DATA_NUM_2);
 			tag2--;
@@ -947,7 +948,7 @@ public class TB_BaconShop : MissionEntity
 	protected virtual IEnumerator OnShopPhase(bool waitForBaconBoard)
 	{
 		AchievementManager.Get().UnpauseToastNotifications();
-		yield return ShowPopup("Shop", waitForBaconBoard);
+		yield return ShowShopPopup(waitForBaconBoard);
 		PlayerLeaderboardManager.Get().UpdateLayout();
 		GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 		UpdateNameBanner();
@@ -961,7 +962,7 @@ public class TB_BaconShop : MissionEntity
 	protected virtual IEnumerator OnCombatPhase()
 	{
 		HideShopTutorials();
-		yield return ShowPopup("Combat", waitForBaconBoard: true);
+		yield return ShowCombatPopup(true);
 		GameEntity.Coroutines.StartCoroutine(WaitAndHideActiveSpeechBubble());
 		ShowTechLevelDisplay(shown: false);
 		GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
@@ -1003,13 +1004,13 @@ public class TB_BaconShop : MissionEntity
 
 	public override string GetVictoryScreenBannerText()
 	{
-		int realTimePlayerLeaderboardPlace = GameState.Get().GetFriendlySidePlayer().GetHero()
-			.GetRealTimePlayerLeaderboardPlace();
+		int realTimePlayerLeaderboardPlace = GetPlace();
 		if (realTimePlayerLeaderboardPlace == 0)
 		{
 			return string.Empty;
 		}
-		return GameStrings.Get("GAMEPLAY_END_OF_GAME_PLACE_" + realTimePlayerLeaderboardPlace);
+
+		return GetPlaceString(realTimePlayerLeaderboardPlace);
 	}
 
 	public override string GetBestNameForPlayer(int playerId)
@@ -1585,8 +1586,9 @@ public class TB_BaconShop : MissionEntity
 		Vector3 position = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
 			.transform.position;
 		position += new Vector3(0f, 0f, 2.25f);
-		string key = "GAMEPLAY_BACON_ENEMY_MINION_TUTORIAL";
-		m_enemyMinionTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+		//string key = "GAMEPLAY_BACON_ENEMY_MINION_TUTORIAL";
+		var msg = FormatBuyMinionsMessage();
+		m_enemyMinionTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), msg);
 		m_enemyMinionTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.BottomThree);
 		m_enemyMinionTutorialNotification.PulseReminderEveryXSeconds(2f);
 	}
@@ -1824,17 +1826,17 @@ public class TB_BaconShop : MissionEntity
 		return zone.GetFirstCard();
 	}
 
-	protected Card GetFreezeButtonCard()
+	internal Card GetFreezeButtonCard()
 	{
 		return GetGameModeButtonBySlot(1);
 	}
 
-	protected Card GetRefreshButtonCard()
+	internal Card GetRefreshButtonCard()
 	{
 		return GetGameModeButtonBySlot(2);
 	}
 
-	protected Card GetTavernUpgradeButtonCard()
+	internal Card GetTavernUpgradeButtonCard()
 	{
 		return GetGameModeButtonBySlot(3);
 	}
@@ -1896,4 +1898,76 @@ public class TB_BaconShop : MissionEntity
 			}
 		}
 	}
+
+	#region Accessibility
+
+	protected IEnumerator ShowShopPopup(bool waitForBaconBoard)
+	{
+		var ret = ShowPopup("Shop", waitForBaconBoard: waitForBaconBoard);
+
+		if (ret != null)
+		{
+			AccessibleGameplay.Get().OnBattlegroundsShopPhasePopupShown();
+		}
+
+		return ret;
+	}
+
+	protected IEnumerator ShowCombatPopup(bool waitForBaconBoard)
+	{
+		var ret = ShowPopup("Combat", waitForBaconBoard: waitForBaconBoard);
+
+		if (ret != null)
+		{
+			AccessibleGameplay.Get().OnBattlegroundsCombatPhasePopupShown();
+		}
+
+		return ret;
+	}
+
+	internal int GetCurPhase()
+	{
+		return m_gamePhase;
+	}
+
+	private int GetPlace()
+	{
+		return GameState.Get().GetFriendlySidePlayer().GetHero().GetRealTimePlayerLeaderboardPlace();
+	}
+
+	internal static string GetPlaceString(int place)
+	{
+		if (place == 0)
+		{
+			return "";
+		}
+
+		return GameStrings.Get("GAMEPLAY_END_OF_GAME_PLACE_" + place);
+	}
+
+	internal static string GetAvailableRacesText()
+	{
+		List<TAG_RACE> list = GameState.Get().GetAvailableRacesInBattlegroundsExcludingAmalgam().ToList();
+		if (list.Contains(TAG_RACE.INVALID))
+		{
+			return null;
+		}
+		list.Sort((TAG_RACE a, TAG_RACE b) => string.Compare(GameStrings.GetRaceNameBattlegrounds(a), GameStrings.GetRaceNameBattlegrounds(b), StringComparison.Ordinal));
+		if (list.Count == 5)
+		{
+			return GameStrings.Format("GAMEPLAY_BACON_MULLIGAN_AVAILABLE_RACES", GameStrings.GetRaceNameBattlegrounds(list[0]), GameStrings.GetRaceNameBattlegrounds(list[1]), GameStrings.GetRaceNameBattlegrounds(list[2]), GameStrings.GetRaceNameBattlegrounds(list[3]), GameStrings.GetRaceNameBattlegrounds(list[4]));
+		}
+		return null;
+	}
+
+	#endregion
+
+	#region HSA Tutorial
+
+	protected string FormatBuyMinionsMessage()
+	{
+		return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TB_BaconShop_Tutorial.cs b/Decompiled/Assembly-CSharp/TB_BaconShop_Tutorial.cs
index fb0f64b..4f9ee8d 100644
--- a/Decompiled/Assembly-CSharp/TB_BaconShop_Tutorial.cs
+++ b/Decompiled/Assembly-CSharp/TB_BaconShop_Tutorial.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
@@ -234,7 +235,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 
 	protected override IEnumerator OnShopPhase(bool waitForBaconBoard)
 	{
-		yield return ShowPopup("Shop", waitForBaconBoard: false);
+		yield return ShowShopPopup(waitForBaconBoard: false);
 		PlayerLeaderboardManager.Get().UpdateLayout();
 		GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 		UpdateNameBanner();
@@ -248,7 +249,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 	{
 		HideShopTutorials();
 		BaconBoard.Get().OnBoardSkinChosen(1);
-		yield return ShowPopup("Combat", waitForBaconBoard: false);
+		yield return ShowCombatPopup(waitForBaconBoard: false);
 		ShowTechLevelDisplay(shown: false);
 		GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 		UpdateNameBanner();
@@ -315,6 +316,8 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		switch (missionEvent)
 		{
 		case 3:
+			AccessibleGameplay.Get().OnFreezeOrUnfreezeEvent();
+
 			if (GameState.Get().GetGameEntity().GetTag(GAME_TAG.TURN) != 9)
 			{
 				SetInputEnableForFrozenButton(isEnabled: false);
@@ -337,7 +340,8 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			break;
 		case 11:
 			GameState.Get().SetBusy(busy: true);
-			CreateTutorialDialog(DRAGBUY_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGBUY_TITLE_TUTORIAL", "GAMEPLAY_BACON_DRAGBUY_BODY_TUTORIAL", "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragBuyTutorial, new Vector2(0.5f, 0.5f));
+				var dragBuyBodyTutorialOverride = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGBUY_BODY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM);
+			CreateTutorialDialog(DRAGBUY_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGBUY_TITLE_TUTORIAL", dragBuyBodyTutorialOverride, "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragBuyTutorial, new Vector2(0.5f, 0.5f));
 			break;
 		case 12:
 			yield return new WaitForSeconds(1f);
@@ -353,8 +357,9 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			Card cardInOpposingPlay = GetCardInOpposingPlay("CS2_065");
 			if (cardInOpposingPlay != null)
 			{
-				ShowDragBuyTutorial(cardInOpposingPlay, "GAMEPLAY_BACON_DRAGBUY_TUTORIAL");
-				GameEntity.Coroutines.StartCoroutine(ShowOrHideDragBuyTutorial("GAMEPLAY_BACON_DRAGBUY_TUTORIAL"));
+						var dragbuyTutorialOverride = FormatBuyMinionsMessage();
+				ShowDragBuyTutorial(cardInOpposingPlay, dragbuyTutorialOverride);
+				GameEntity.Coroutines.StartCoroutine(ShowOrHideDragBuyTutorial(dragbuyTutorialOverride));
 			}
 			break;
 		}
@@ -537,7 +542,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			yield return PlayBobLine(VO_DALA_BOSS_99h_Male_Human_AfterShopUpgrade_04);
 			yield return new WaitForSeconds(0.5f);
 			GameState.Get().SetBusy(busy: false);
-			ShowRefreshButtonTutorial("GAMEPLAY_BACON_REFRESH_UPGRADE_TUTORIAL");
+			ShowRefreshButtonTutorial();
 			SetInputEnableForRefreshButton(isEnabled: true);
 			break;
 		case 53:
@@ -579,7 +584,8 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			SetInputEnableForAllButtons(isEnabled: false);
 			SetInputEnableForFriendlyHandCards(isEnabled: false);
 			GameState.Get().SetBusy(busy: true);
-			CreateTutorialDialog(DRAGSELL_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGSELL_TITLE_TUTORIAL", "GAMEPLAY_BACON_DRAGSELL_BODY_TUTORIAL", "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragSellTutorial, new Vector2(0f, 0.5f));
+				var dragsellBodyTutorialOverride = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGSELL_BODY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM);
+			CreateTutorialDialog(DRAGSELL_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGSELL_TITLE_TUTORIAL", dragsellBodyTutorialOverride, "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragSellTutorial, new Vector2(0f, 0.5f));
 			break;
 		case 63:
 			GameState.Get().SetBusy(busy: false);
@@ -623,6 +629,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			break;
 		case 70:
 			HideHandBounceArrow();
+				OutputReadTimeHelpNotification();
 			yield return PlayBobLine(VO_DALA_BOSS_99h_Male_Human_CombatWin_03);
 			break;
 		case 79:
@@ -808,6 +815,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		notification.artOverlay.GetMaterial().mainTextureOffset = materialOffset;
 		notification.m_ButtonStart.AddEventListener(UIEventType.RELEASE, delegate(UIEvent e)
 		{
+			notification.Hide();
 			if (buttonHandler != null)
 			{
 				buttonHandler(e);
@@ -817,6 +825,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		});
 		m_popupTutorialNotification.PlayBirth();
 		UniversalInputManager.Get().SetGameDialogActive(active: true);
+		notification.Show();
 		return notification;
 	}
 
@@ -833,6 +842,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 				NotificationManager.Get().DestroyNotification(notification, 0f);
 			}
 		}
+
+		// Accessibility F1
+		if (notification == m_curDisplayedNotification)
+		{
+			m_curDisplayedNotification = null;
+		}
 	}
 
 	protected void ShowDragBuyTutorial(Card card, string textID = "GAMEPLAY_BACON_PLAY_MINION_TUTORIAL", bool hideImmediately = false)
@@ -855,6 +870,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			m_dragBuyTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
 			m_dragBuyTutorialNotification.ShowPopUpArrow(direction);
 			m_dragBuyTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_dragBuyTutorialNotification;
 		}
 	}
 
@@ -901,6 +917,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			m_dragBuyTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
 			m_dragBuyTutorialNotification.ShowPopUpArrow(direction);
 			m_dragBuyTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_dragBuyTutorialNotification;
 		}
 	}
 
@@ -934,14 +951,16 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			Vector3 position = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
 				.transform.position;
 			position += new Vector3(0f, 0f, 2.25f);
-			string key = "GAMEPLAY_BACON_RECRUIT_REMINDER_TUTORIAL";
-			m_recruitReminderTutorialNofification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+			// string key = "GAMEPLAY_BACON_RECRUIT_REMINDER_TUTORIAL";
+			var msg = FormatBuyMinionsMessage();
+			m_recruitReminderTutorialNofification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), msg);
 			m_recruitReminderTutorialNofification.ShowPopUpArrow(Notification.PopUpArrowDirection.BottomThree);
 			m_recruitReminderTutorialNofification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_recruitReminderTutorialNofification;
 		}
 	}
 
-	protected void ShowRefreshButtonTutorial(string textID = "GAMEPLAY_BACON_REFRESH_TUTORIAL", bool hideImmediately = false)
+	protected void ShowRefreshButtonTutorial(bool hideImmediately = false)
 	{
 		List<Zone> list = ZoneMgr.Get().FindZonesForSide(Player.Side.FRIENDLY);
 		Zone zone = null;
@@ -952,11 +971,14 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 				zone = item;
 			}
 		}
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE, AccessibleKey.REFRESH_TAVERN, AccessibleKey.CONFIRM);
+
 		Vector3 position = zone.transform.position;
 		Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z - 2.25f) : new Vector3(position.x, position.y, position.z - 2.5f));
-		m_refreshButtonTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
+		m_refreshButtonTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 		m_refreshButtonTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
 		m_refreshButtonTutorialNotification.PulseReminderEveryXSeconds(2f);
+		m_curDisplayedNotification = m_refreshButtonTutorialNotification;
 	}
 
 	protected void ShowTavernUpgradeButtonTutorial(bool hideImmediately = false)
@@ -972,10 +994,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		Vector3 position = zone.transform.position;
 		Vector3 position2 = new Vector3(position.x, position.y, position.z - 2.25f);
-		string key = "GAMEPLAY_BACON_MINION_UPGRADE_TAVERN_TUTORIAL";
-		m_upgradeTavernTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+		// string key = "GAMEPLAY_BACON_MINION_UPGRADE_TAVERN_TUTORIAL";
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE, AccessibleKey.UPGRADE_TAVERN, AccessibleKey.CONFIRM);
+		m_upgradeTavernTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 		m_upgradeTavernTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
 		m_upgradeTavernTutorialNotification.PulseReminderEveryXSeconds(2f);
+		m_curDisplayedNotification = m_upgradeTavernTutorialNotification;
 	}
 
 	protected void ShowMinionMoveTutorial()
@@ -985,10 +1009,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		{
 			Vector3 position = leftMostMinionInFriendlyPlay.transform.position;
 			Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z + 2.5f) : new Vector3(position.x + 0.05f, position.y, position.z + 2.6f));
-			string key = "GAMEPLAY_BACON_MINION_MOVE_TUTORIAL";
-			m_minionMoveTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+			//string key = "GAMEPLAY_BACON_MINION_MOVE_TUTORIAL";
+			var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.SPACE);
+			m_minionMoveTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 			m_minionMoveTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Down);
 			m_minionMoveTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_minionMoveTutorialNotification;
 		}
 	}
 
@@ -1019,10 +1045,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			card.GetActor().SetActorState(ActorStateType.CARD_SELECTABLE);
 			Vector3 position = card.transform.position;
 			Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x - 3.2f, position.y, position.z) : new Vector3(position.x - 3.3f, position.y, position.z - 0f));
-			string key = "GAMEPLAY_BACON_DRAGSELL_TUTORIAL";
-			m_dragSellTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+			// string key = "GAMEPLAY_BACON_DRAGSELL_TUTORIAL";
+			var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM);
+			m_dragSellTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 			m_dragSellTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
 			m_dragSellTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_dragSellTutorialNotification;
 		}
 	}
 
@@ -1039,10 +1067,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		Vector3 position = zone.transform.position;
 		Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z - 2.1f) : new Vector3(position.x, position.y, position.z - 2.5f));
-		string key = "GAMEPLAY_BACON_FREEZE_TUTORIAL";
-		m_freezeTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+		// string key = "GAMEPLAY_BACON_FREEZE_TUTORIAL";
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_FREEZE_TUTORIAL_OVERRIDE, AccessibleKey.FREEZE_TAVERN, AccessibleKey.CONFIRM);
+		m_freezeTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 		m_freezeTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
 		m_freezeTutorialNotification.PulseReminderEveryXSeconds(2f);
+		m_curDisplayedNotification = m_freezeTutorialNotification;
 	}
 
 	protected IEnumerator ShowManaArrowWithText(string textID)
@@ -1062,7 +1092,9 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		m_manaNotifier = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
 		m_manaNotifier.ShowPopUpArrow(direction);
+		m_curDisplayedNotification = m_manaNotifier;
 		yield return new WaitForSeconds(2.5f);
+		m_curDisplayedNotification = null;
 		if (m_manaNotifier != null)
 		{
 			iTween.PunchScale(m_manaNotifier.gameObject, iTween.Hash("amount", new Vector3(1f, 1f, 1f), "time", 1f));
@@ -1182,4 +1214,30 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		return null;
 	}
+
+	#region Accessibility
+
+	private Notification m_curDisplayedNotification;
+
+	private void OutputReadTimeHelpNotification()
+	{
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING, AccessibleKey.END_TURN);
+		AccessibilityMgr.OutputNotification(msg);
+	}
+
+	internal string GetHelp()
+	{
+		if (m_curDisplayedNotification != null)
+		{
+			return m_curDisplayedNotification.speechUberText.Text;
+		}
+		else if (m_shouldShowHandBounceArrow)
+		{
+			return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_SUMMON_MINION_HELP, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM);
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs b/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
index 62bc36c..b41d0e4 100644
--- a/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
+++ b/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.Configuration;
 using Hearthstone.DungeonCrawl;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class TavernBrawlDisplay : MonoBehaviour
@@ -311,7 +312,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 			return;
 		}
 		UpdateRecordUI();
-		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
+		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
 		{
 			m_firstTimeIntroductionPopupShowing = true;
 			StartCoroutine(DoFirstTimeHeroicIntro());
@@ -917,7 +918,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 		{
 			return;
 		}
-		bool flag = UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.Show");
+		bool flag = UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.Show");
 		int latestSeenTavernBrawlChalkboard = TavernBrawlManager.Get().LatestSeenTavernBrawlChalkboard;
 		if (latestSeenTavernBrawlChalkboard == 0)
 		{
@@ -1692,6 +1693,10 @@ public class TavernBrawlDisplay : MonoBehaviour
 				collectionManagerDisplay.OnDoneEditingDeck();
 			}
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void OnDeckCreated(long deckID)
diff --git a/Decompiled/Assembly-CSharp/TooltipPanelManager.cs b/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
index e4e666e..46645db 100644
--- a/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
+++ b/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
@@ -1153,4 +1153,13 @@ public class TooltipPanelManager : MonoBehaviour
 		}
 		return result;
 	}
+
+	#region Accessibility
+
+	internal List<TooltipPanel> GetTooltipPanels()
+    {
+		return m_tooltipPanels;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TournamentDisplay.cs b/Decompiled/Assembly-CSharp/TournamentDisplay.cs
index 5502edf..6595454 100644
--- a/Decompiled/Assembly-CSharp/TournamentDisplay.cs
+++ b/Decompiled/Assembly-CSharp/TournamentDisplay.cs
@@ -47,7 +47,7 @@ public class TournamentDisplay : MonoBehaviour
 	private void OnDestroy()
 	{
 		s_instance = null;
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		UnregisterListeners();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/TransitionPopup.cs b/Decompiled/Assembly-CSharp/TransitionPopup.cs
index 6eb0bfd..f935afc 100644
--- a/Decompiled/Assembly-CSharp/TransitionPopup.cs
+++ b/Decompiled/Assembly-CSharp/TransitionPopup.cs
@@ -3,6 +3,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public abstract class TransitionPopup : MonoBehaviour
 {
@@ -398,4 +399,29 @@ public abstract class TransitionPopup : MonoBehaviour
 	}
 
 	protected abstract void OnGameplaySceneLoaded();
+
+	protected void HandleCancelButtonInput()
+	{
+		if (AccessibleKey.BACK.IsPressed() && m_cancelButton != null && m_cancelButton.isActiveAndEnabled)
+		{
+			m_cancelButton.TriggerRelease();
+		}
+	}
+
+	protected string HandleCancelButtonHelp()
+	{
+		var lines = new List<string>();
+		lines.Add(m_title.Text);
+
+		if (m_cancelButton != null && m_cancelButton.isActiveAndEnabled)
+		{
+			lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_CANCEL_HELP, AccessibleKey.BACK));
+		}
+		else
+		{
+			lines.Add(LocalizedText.GLOBAL_PLEASE_WAIT);
+		}
+
+		return AccessibleSpeechUtils.CombineLines(lines);
+	}
 }
diff --git a/Decompiled/Assembly-CSharp/TurnStartManager.cs b/Decompiled/Assembly-CSharp/TurnStartManager.cs
index 8f84554..0c01f66 100644
--- a/Decompiled/Assembly-CSharp/TurnStartManager.cs
+++ b/Decompiled/Assembly-CSharp/TurnStartManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -319,6 +320,7 @@ public class TurnStartManager : MonoBehaviour
 				m_turnStartInstance.SetReminderText(GameState.Get().GetGameEntity().GetTurnStartReminderText());
 				m_turnStartInstance.Show();
 				SoundManager.Get().LoadAndPlay("ALERT_YourTurn_0v2.prefab:201bcb34d33384e48ab226f7e797771f");
+				AccessibleGameplay.Get().OnTurnStart();
 			}
 		}
 	}
diff --git a/Decompiled/Assembly-CSharp/TurnTimer.cs b/Decompiled/Assembly-CSharp/TurnTimer.cs
index ad7ef8f..4eaa364 100644
--- a/Decompiled/Assembly-CSharp/TurnTimer.cs
+++ b/Decompiled/Assembly-CSharp/TurnTimer.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class TurnTimer : MonoBehaviour
 {
@@ -93,6 +94,7 @@ public class TurnTimer : MonoBehaviour
 	private void Update()
 	{
 		UpdateCountdownText();
+		UpdateAccessibleTimer();
 	}
 
 	public static TurnTimer Get()
@@ -496,4 +498,25 @@ public class TurnTimer : MonoBehaviour
 			}
 		}
 	}
+
+	#region Accessibility
+	private int m_prevSeconds;
+
+	private void UpdateAccessibleTimer()
+	{
+		var curSeconds = GetSecondsRemaining();
+
+		AccessibilityUtils.OutputTimerIfNecessary(curSeconds, m_prevSeconds);
+
+		m_prevSeconds = curSeconds;
+	}
+
+	internal int GetSecondsRemaining()
+	{
+		float curSecondsF = ComputeCountdownRemainingSec();
+
+		return Mathf.RoundToInt(curSecondsF);
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialEntity.cs b/Decompiled/Assembly-CSharp/TutorialEntity.cs
index a83ab46..3d1f872 100644
--- a/Decompiled/Assembly-CSharp/TutorialEntity.cs
+++ b/Decompiled/Assembly-CSharp/TutorialEntity.cs
@@ -1,7 +1,8 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
-public class TutorialEntity : MissionEntity
+public abstract class TutorialEntity : MissionEntity
 {
 	private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
 
@@ -74,14 +75,24 @@ public class TutorialEntity : MissionEntity
 				Notification notification = NotificationManager.Get().CreateSpeechBubble(GameStrings.Get("TUTORIAL02_JAINA_05"), Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: true);
 				SoundManager.Get().LoadAndPlay("VO_TUTORIAL_02_JAINA_05_20.prefab:700f7c6b778de5d41bf6d45a2e01b13d");
 				NotificationManager.Get().DestroyNotification(notification, 3.5f);
-				Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_01")));
+
+                if (!AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    // This is a visual-only reminder
+                    Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_01")));
+                }
 			}
 			else
 			{
 				Notification notification2 = NotificationManager.Get().CreateSpeechBubble(GameStrings.Get("TUTORIAL02_JAINA_04"), Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: true);
 				SoundManager.Get().LoadAndPlay("VO_TUTORIAL_02_JAINA_04_19.prefab:af04fcf53166d04469dc1b22b4181bf9");
 				NotificationManager.Get().DestroyNotification(notification2, 3.5f);
-				Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_03")));
+
+                if (!AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    // This is a visual-only reminder
+                    Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_03")));
+                }
 			}
 			return true;
 		}
@@ -230,9 +241,18 @@ public class TutorialEntity : MissionEntity
 			NotificationManager.Get().DestroyNotificationNowWithNoAnim(thatsABadPlayPopup);
 		}
 		Vector3 position = new Vector3(origin.x - 3f, origin.y, origin.z);
-		thatsABadPlayPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, GetTextScale(), GameStrings.Get("TUTORIAL01_HELP_07"));
-		NotificationManager.Get().DestroyNotification(thatsABadPlayPopup, 2.5f);
-	}
+
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_07);
+        }
+		else
+        {
+			// Visual-only popups
+            thatsABadPlayPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, GetTextScale(), GameStrings.Get("TUTORIAL01_HELP_07"));
+            NotificationManager.Get().DestroyNotification(thatsABadPlayPopup, 2.5f);
+        }
+    }
 
 	protected void HandleGameStartEvent()
 	{
@@ -312,4 +332,6 @@ public class TutorialEntity : MissionEntity
 	{
 		Options.Get().SetInt(Option.TUTORIAL_LOST_PROGRESS, 0);
 	}
+
+	protected abstract void MarkForAccessibility();
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs b/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
index 512c063..da825d4 100644
--- a/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
+++ b/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
@@ -190,4 +190,13 @@ public class TutorialKeywordManager : MonoBehaviour
 		}
 		return m_keywordPanels[0].transform.position;
 	}
+
+	#region Accessibility
+
+	internal List<TutorialKeywordTooltip> GetPanels()
+    {
+		return m_keywordPanels;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialNotification.cs b/Decompiled/Assembly-CSharp/TutorialNotification.cs
index c935105..05b8b72 100644
--- a/Decompiled/Assembly-CSharp/TutorialNotification.cs
+++ b/Decompiled/Assembly-CSharp/TutorialNotification.cs
@@ -1,4 +1,7 @@
-public class TutorialNotification : Notification
+using Accessibility;
+using System;
+
+public class TutorialNotification : Notification, AccessibleUI
 {
 	public UIBButton m_ButtonStart;
 
@@ -12,4 +15,44 @@ public class TutorialNotification : Notification
 			m_WantedText.gameObject.SetActive(value: true);
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMultilineText m_accessibleNotification;
+
+	public string GetAccessibleHelp()
+	{
+		return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (AccessibleKey.CONFIRM.IsPressed())
+		{
+			m_ButtonStart.TriggerRelease();
+		}
+		else
+		{
+			m_accessibleNotification.HandleAccessibleInput();
+		}
+	}
+
+	internal void Hide()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	internal void Show()
+	{
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP);
+
+		var headline = headlineUberText.Text;
+		var body = speechUberText.Text;
+
+		m_accessibleNotification = new AccessibleMultilineText(this, headline, body, GetAccessibleHelp());
+		m_accessibleNotification.ReadAllLines();
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs b/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
index 767c3d4..a3740f4 100644
--- a/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
+++ b/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -401,17 +402,20 @@ public class TutorialProgressScreen : MonoBehaviour
 		coin.m_inputEnabled = false;
 		yield return new WaitForSeconds(1f);
 		coin.SetProgress(HeroCoin.CoinStatus.ACTIVE_TO_DEFEATED);
-	}
+		yield return new WaitForSeconds(2f);
+        AccessibleTutorialProgressScreen.Get().OnDefeatedOpponent(coin);
+    }
 
-	private IEnumerator SetUnrevealedToActive(HeroCoin coin)
+    private IEnumerator SetUnrevealedToActive(HeroCoin coin)
 	{
 		coin.SetProgress(HeroCoin.CoinStatus.UNREVEALED);
 		coin.m_inputEnabled = false;
-		yield return new WaitForSeconds(2f);
+		yield return new WaitForSeconds(4f);
 		coin.SetProgress(HeroCoin.CoinStatus.UNREVEALED_TO_ACTIVE);
-	}
+        AccessibleTutorialProgressScreen.Get().OnNextOpponent(coin);
+    }
 
-	private void ExitButtonPress(UIEvent e)
+    private void ExitButtonPress(UIEvent e)
 	{
 		SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
 		FullScreenFXMgr.Get().Vignette(0f, 0.5f, iTween.EaseType.easeInOutQuad);
diff --git a/Decompiled/Assembly-CSharp/Tutorial_01.cs b/Decompiled/Assembly-CSharp/Tutorial_01.cs
index ad6f790..55e78ad 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_01.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_01.cs
@@ -1,38 +1,39 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class Tutorial_01 : TutorialEntity
 {
-	private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
 
-	private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
 
-	private Notification endTurnNotifier;
+    private Notification endTurnNotifier;
 
-	private Notification handBounceArrow;
+    private Notification handBounceArrow;
 
-	private Notification handFadeArrow;
+    private Notification handFadeArrow;
 
-	private Notification noFireballPopup;
+    private Notification noFireballPopup;
 
-	private Notification attackWithYourMinion;
+    private Notification attackWithYourMinion;
 
-	private Notification crushThisGnoll;
+    private Notification crushThisGnoll;
 
-	private Notification freeCardsPopup;
+    private Notification freeCardsPopup;
 
-	private TooltipPanel attackHelpPanel;
+    private TooltipPanel attackHelpPanel;
 
-	private TooltipPanel healthHelpPanel;
+    private TooltipPanel healthHelpPanel;
 
-	private Card mousedOverCard;
+    private Card mousedOverCard;
 
-	private GameObject costLabel;
+    private GameObject costLabel;
 
-	private GameObject attackLabel;
+    private GameObject attackLabel;
 
-	private GameObject healthLabel;
+    private GameObject healthLabel;
 
 	private Card firstMurlocCard;
 
@@ -1171,4 +1172,8 @@ public class Tutorial_01 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_02.cs b/Decompiled/Assembly-CSharp/Tutorial_02.cs
index 883a882..23b4ec3 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_02.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_02.cs
@@ -528,4 +528,9 @@ public class Tutorial_02 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_02
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_03.cs b/Decompiled/Assembly-CSharp/Tutorial_03.cs
index 34e83b6..65b31e9 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_03.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_03.cs
@@ -400,4 +400,9 @@ public class Tutorial_03 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_03
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_04.cs b/Decompiled/Assembly-CSharp/Tutorial_04.cs
index e73d949..478ae18 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_04.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_04.cs
@@ -642,4 +642,9 @@ public class Tutorial_04 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_04
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_05.cs b/Decompiled/Assembly-CSharp/Tutorial_05.cs
index 1e509d0..b95df21 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_05.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_05.cs
@@ -285,4 +285,9 @@ public class Tutorial_05 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_05
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_06.cs b/Decompiled/Assembly-CSharp/Tutorial_06.cs
index c2e385c..592cc33 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_06.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_06.cs
@@ -319,4 +319,9 @@ public class Tutorial_06 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_06
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/UIBScrollable.cs b/Decompiled/Assembly-CSharp/UIBScrollable.cs
index 03de1ca..cc85f70 100644
--- a/Decompiled/Assembly-CSharp/UIBScrollable.cs
+++ b/Decompiled/Assembly-CSharp/UIBScrollable.cs
@@ -200,7 +200,7 @@ public class UIBScrollable : PegUICustomBehavior
 
 	private bool m_ForceShowVisibleAffectedObjects;
 
-	private List<UIBScrollableItem> m_scrollableItems = new List<UIBScrollableItem>();
+	internal List<UIBScrollableItem> m_scrollableItems = new List<UIBScrollableItem>();
 
 	private int m_currentHierarchyCount;
 
diff --git a/Decompiled/Assembly-CSharp/UIBScrollableItem.cs b/Decompiled/Assembly-CSharp/UIBScrollableItem.cs
index ae84690..7e5c733 100644
--- a/Decompiled/Assembly-CSharp/UIBScrollableItem.cs
+++ b/Decompiled/Assembly-CSharp/UIBScrollableItem.cs
@@ -9,7 +9,8 @@ public class UIBScrollableItem : MonoBehaviour
 	{
 		Active,
 		Inactive,
-		UseHierarchy
+		UseHierarchy,
+		EOE
 	}
 
 	public enum BoundsMode
diff --git a/Decompiled/Assembly-CSharp/UIStatus.cs b/Decompiled/Assembly-CSharp/UIStatus.cs
index 7134874..2890d88 100644
--- a/Decompiled/Assembly-CSharp/UIStatus.cs
+++ b/Decompiled/Assembly-CSharp/UIStatus.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class UIStatus : MonoBehaviour
 {
@@ -134,6 +135,8 @@ public class UIStatus : MonoBehaviour
 		}
 		Hashtable args = iTween.Hash("amount", 0f, "delay", delay, "time", m_FadeSec, "easeType", m_FadeEaseType, "oncomplete", "OnFadeComplete", "oncompletetarget", base.gameObject);
 		iTween.FadeTo(m_Text.gameObject, args);
+
+		AccessibilityMgr.Output(null, message);
 	}
 
 	private void OnFadeComplete()
diff --git a/Decompiled/Assembly-CSharp/UniversalInputManager.cs b/Decompiled/Assembly-CSharp/UniversalInputManager.cs
index 04490bd..f9884a4 100644
--- a/Decompiled/Assembly-CSharp/UniversalInputManager.cs
+++ b/Decompiled/Assembly-CSharp/UniversalInputManager.cs
@@ -7,6 +7,7 @@ using Hearthstone;
 using Hearthstone.Commerce;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class UniversalInputManager : IHasUpdate, IService
 {
@@ -285,6 +286,10 @@ public class UniversalInputManager : IHasUpdate, IService
 
 	private void OnGUI()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled() && !AccessibilityMgr.IsTextInputAllowed())
+        {
+			return;
+        }
 		IgnoreGUIInput();
 		HandleGUIInputInactive();
 		HandleGUIInputActive();
@@ -1005,6 +1010,12 @@ public class UniversalInputManager : IHasUpdate, IService
 
 	private void UpdateInput()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			AccessibilityMgr.HandleKeyboardInput();
+			return;
+        }
+
 		if (UpdateTextInput())
 		{
 			return;
diff --git a/Decompiled/Assembly-CSharp/UserAttentionManager.cs b/Decompiled/Assembly-CSharp/UserAttentionManager.cs
index 76e8d49..a732ca5 100644
--- a/Decompiled/Assembly-CSharp/UserAttentionManager.cs
+++ b/Decompiled/Assembly-CSharp/UserAttentionManager.cs
@@ -14,7 +14,7 @@ public static class UserAttentionManager
 		get
 		{
 			IEnumerable<string> source = (from UserAttentionBlocker r in Enum.GetValues(typeof(UserAttentionBlocker))
-				where IsBlockedBy(r)
+				where IsBlockedBy(true, r)
 				select r).Select(delegate(UserAttentionBlocker r)
 			{
 				UserAttentionBlocker userAttentionBlocker = r;
@@ -28,7 +28,12 @@ public static class UserAttentionManager
 
 	public static event Action OnBlockingEnd;
 
-	public static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
+	public static bool IsBlockedBy(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		return IsBlockedBy(attentionCategory);
+    }
+
+	private static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
 	{
 		if (attentionCategory != 0)
 		{
@@ -37,12 +42,22 @@ public static class UserAttentionManager
 		return false;
 	}
 
-	public static bool CanShowAttentionGrabber(string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, string callerName)
+    {
+		return CanShowAttentionGrabber(callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(string callerName)
 	{
-		return CanShowAttentionGrabber(UserAttentionBlocker.NONE, callerName);
+		return CanShowAttentionGrabber(true, UserAttentionBlocker.NONE, callerName);
 	}
 
-	public static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, UserAttentionBlocker attentionCategory, string callerName)
+    {
+		return CanShowAttentionGrabber(attentionCategory, callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
 	{
 		if ((s_blockedReasons & ~attentionCategory) != 0)
 		{
@@ -51,9 +66,14 @@ public static class UserAttentionManager
 		return true;
 	}
 
-	public static void StartBlocking(UserAttentionBlocker attentionCategory)
+	public static void StartBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StartBlocking(attentionCategory);
+    }
+
+	private static void StartBlocking(UserAttentionBlocker attentionCategory)
 	{
-		if (!IsBlockedBy(attentionCategory))
+		if (!IsBlockedBy(true, attentionCategory))
 		{
 			bool isBlocked = IsBlocked;
 			if (isBlocked)
@@ -70,7 +90,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static void StopBlocking(UserAttentionBlocker attentionCategory)
+	public static void StopBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StopBlocking(attentionCategory);
+    }
+
+	private static void StopBlocking(UserAttentionBlocker attentionCategory)
 	{
 		bool isBlocked = IsBlocked;
 		s_blockedReasons &= ~attentionCategory;
@@ -92,7 +117,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
+	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool markedForAccessibility, bool isFriendlyChallenge)
+    {
+		return GetAvailabilityBlockerReason(isFriendlyChallenge);
+    }
+
+	private static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
 	{
 		if (SpectatorManager.Get().IsInSpectatorMode())
 		{
diff --git a/Decompiled/Assembly-CSharp/VirtualCurrencyPurchasePage.cs b/Decompiled/Assembly-CSharp/VirtualCurrencyPurchasePage.cs
index 3821f13..d0f3c74 100644
--- a/Decompiled/Assembly-CSharp/VirtualCurrencyPurchasePage.cs
+++ b/Decompiled/Assembly-CSharp/VirtualCurrencyPurchasePage.cs
@@ -18,7 +18,7 @@ public class VirtualCurrencyPurchasePage : ProductPage
 
 	public void OpenToSKU(float desiredAmount, bool closeOnPurchase = false)
 	{
-		base.Open();
+		base.Open(false);
 		ProductDataModel virtualCurrencyProductItem = StoreManager.Get().Catalog.VirtualCurrencyProductItem;
 		ProductDataModel variant = ShopUtils.FindCurrencyProduct(CurrencyType.RUNESTONES, desiredAmount);
 		m_closeOnPurchase = closeOnPurchase;
diff --git a/Decompiled/Assembly-CSharp/WelcomeQuests.cs b/Decompiled/Assembly-CSharp/WelcomeQuests.cs
index 131c909..fa1f20c 100644
--- a/Decompiled/Assembly-CSharp/WelcomeQuests.cs
+++ b/Decompiled/Assembly-CSharp/WelcomeQuests.cs
@@ -1,8 +1,9 @@
 using System.Collections.Generic;
 using Assets;
 using UnityEngine;
+using Accessibility;
 
-public class WelcomeQuests : MonoBehaviour
+public class WelcomeQuests : MonoBehaviour, AccessibleUI
 {
 	public delegate void DelOnWelcomeQuestsClosed();
 
@@ -70,7 +71,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static bool Show(UserAttentionBlocker blocker, bool fromLogin, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.Show:" + fromLogin))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.Show:" + fromLogin))
 		{
 			onCloseCallback?.Invoke();
 			return false;
@@ -95,7 +96,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static void ShowSpecialQuest(UserAttentionBlocker blocker, Achievement achievement, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
 		{
 			onCloseCallback?.Invoke();
 			return;
@@ -173,6 +174,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		FadeEffectsOut();
 		if (s_instance != null)
 		{
@@ -271,6 +274,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void ReinitAndShow(ShowRequestData showRequestData)
 	{
+		AccessibilityMgr.HideUI(this); // Seems like an error condition but not really sure - best effort
+
 		FadeEffectsOut();
 		UnlockBnetButtons();
 		InitAndShow(showRequestData);
@@ -406,6 +411,8 @@ public class WelcomeQuests : MonoBehaviour
 			m_loginQuestShownTime = Time.realtimeSinceStartup;
 			m_clickCatcher.AddEventListener(UIEventType.RELEASE, SendTelemetry);
 		}
+
+		ReadQuests();
 	}
 
 	private void CheckShowInnkeepersSpecial()
@@ -485,6 +492,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void Close()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		CleanUpEventListeners();
 		UnlockBnetButtons();
 		s_instance = null;
@@ -583,4 +592,89 @@ public class WelcomeQuests : MonoBehaviour
 			m_bnetButtonsLocked = false;
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleQuestTile> m_accessibleQuests;
+
+	private AccessibleQuestTile m_accessibleQuestTile;
+
+	private void ReadQuests()
+    {
+		m_accessibleQuestTile = null;
+		m_accessibleQuests = null;
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, m_headlineBanner.m_headline.Text);
+
+		if (m_currentQuests.Count == 1)
+        {
+			m_accessibleQuestTile = new AccessibleQuestTile(this, m_currentQuests[0]);
+			m_accessibleQuestTile.ReadAllLines();
+        }
+		else
+        {
+            var accessibleQuests = new List<AccessibleQuestTile>();
+            foreach (var quest in m_currentQuests)
+            {
+                accessibleQuests.Add(new AccessibleQuestTile(this, quest));
+            }
+
+            m_accessibleQuests = new AccessibleListOfItems<AccessibleQuestTile>(this, accessibleQuests);
+            m_accessibleQuests.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_clickCatcher.TriggerRelease();
+        }
+        else
+        {
+			m_accessibleQuestTile?.HandleAccessibleInput();
+            m_accessibleQuests?.HandleAccessibleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_accessibleQuests != null)
+        {
+            GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+            {
+                new GameStrings.PluralNumber
+                {
+                    m_index = 0,
+                    m_number = 2 // Doesn't really matter as long as it's not 1
+                }
+            };
+
+			var text = LocalizationUtils.FormatPlurals(LocalizationKey.UI_WELCOME_QUESTS_HELP, pluralNumbers);
+			var confirmText = AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE;
+
+			return AccessibleSpeechUtils.CombineSentences(text, confirmText);
+        }
+		else if (m_accessibleQuestTile != null)
+        {
+            GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+            {
+                new GameStrings.PluralNumber
+                {
+                    m_index = 0,
+                    m_number = 1
+                }
+            };
+
+			var text = LocalizationUtils.FormatPlurals(LocalizationKey.UI_WELCOME_QUESTS_HELP, pluralNumbers);
+			var confirmText = AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE;
+
+			return AccessibleSpeechUtils.CombineSentences(text, confirmText);
+        }
+
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
