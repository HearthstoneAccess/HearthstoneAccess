diff --git a/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
index 0f54b25..e80031b 100644
--- a/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
@@ -5,8 +5,9 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
+public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour, AccessibleScreen
 {
 	public delegate void DeckTrayLoaded();
 
@@ -127,7 +128,7 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	protected SlidingTray m_slidingTray;
 
-	protected PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
 	private AudioSource m_lastPickLine;
 
@@ -151,8 +152,15 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	public Transform empty;
 
+	#region Accessibility
+	protected bool m_creatingDeck;
+	#endregion
+
 	public virtual void Awake()
 	{
+		// Accessibility
+		m_creatingDeck = false;
+
 		m_randomDeckPickerTray.transform.localPosition = m_randomDecksShownBone.transform.localPosition;
 		DeckPickerTray.Get().SetDeckPickerTrayDisplayReference(this);
 		DeckPickerTray.Get().RegisterHandlers();
@@ -396,9 +404,11 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 				SceneMgr.Get().SetNextMode(SceneMgr.Get().GetPrevMode());
 			}
 		}
+
+		ReadHeroSelectionScreen();
 	}
 
-	protected virtual void InitForMode(SceneMgr.Mode mode)
+    protected virtual void InitForMode(SceneMgr.Mode mode)
 	{
 		switch (mode)
 		{
@@ -592,10 +602,12 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 				SoundManager.Get().LoadAndPlay(button.HeroPickerSelectedPrefab, button.gameObject, 1f, OnLastPickLineLoaded);
 			}
 			SetPlayButtonEnabled(flag);
-		}
-	}
 
-	protected virtual void UpdateHeroInfo(HeroPickerButton button)
+            OnChosenHero();
+        }
+    }
+
+    protected virtual void UpdateHeroInfo(HeroPickerButton button)
 	{
 	}
 
@@ -1670,4 +1682,194 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 	{
 		StartCoroutine(LoadHeroButtons(buttonsToDisplay));
 	}
+
+	#region Accessibility
+
+	private enum AccessibleState { LOADING, ADVENTURE_CHOOSING_HERO, ADVENTURE_HERO_CHOSEN, CREATE_DECK_CHOOSING_CLASS, CREATE_DECK_CLASS_CHOSEN };
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleHorizontalMenu<AccessibleHeroPickerButton> m_accessibleHeroPickerButtons;
+
+    private void ReadHeroSelectionScreen()
+    {
+		m_accessibleHeroPickerButtons = null;
+		m_curAccessibleState = AccessibleState.LOADING;
+
+		if (CreatingDeck())
+        {
+			ReadCreateDeckScreen();
+			return;
+        }
+
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+		AccessibilityMgr.SetScreen(this);
+
+		var menuTitle = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE);
+		var accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, menuTitle, PressBackButton);
+
+		var numSupportedBoHHeroes = 4; // Jaina, Rexxar, Garrosh, Uther
+
+		//foreach (var hb in m_heroButtons)
+		for (var i = 0; i < numSupportedBoHHeroes; i++)
+        {
+			var hb = m_heroButtons[i];
+
+			accessibleHeroPickerButtons.AddOption(new AccessibleHeroPickerButton(this, hb), () => ChooseHero(hb));
+        }
+
+		m_accessibleHeroPickerButtons = accessibleHeroPickerButtons;
+		m_accessibleHeroPickerButtons.StartReading();
+
+		m_curAccessibleState = AccessibleState.ADVENTURE_CHOOSING_HERO;
+    }
+
+    private void ReadCreateDeckScreen()
+    {
+		AccessibilityMgr.SetScreen(this);
+
+        SetupCreateDeckMenu();
+    }
+
+    private void SetupCreateDeckMenu()
+    {
+		var menuTitle = m_modeName.Text;
+		var accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, menuTitle, AccessibilityUtils.GoBackToHub);
+
+		foreach (var hb in m_heroButtons)
+        {
+			if (!hb.IsLocked())
+            {
+                accessibleHeroPickerButtons.AddOption(new AccessibleHeroPickerButton(this, hb, true), () => hb.TriggerRelease());
+            }
+        }
+
+		m_accessibleHeroPickerButtons = accessibleHeroPickerButtons;
+		m_accessibleHeroPickerButtons.StartReading();
+
+		m_curAccessibleState = AccessibleState.CREATE_DECK_CHOOSING_CLASS;
+    }
+
+    private bool CreatingDeck()
+    {
+		return m_creatingDeck;
+    }
+
+    private void OnChosenHero()
+    {
+		if (CreatingDeck())
+        {
+			m_curAccessibleState = AccessibleState.CREATE_DECK_CLASS_CHOSEN;
+			AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+			return;
+        }
+
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+        m_curAccessibleState = AccessibleState.ADVENTURE_HERO_CHOSEN;
+        AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+    }
+
+    private bool SupportedAdventure()
+    {
+		var selectedAdventure = AdventureConfig.Get().SelectedAdventure;
+
+		return selectedAdventure == AdventureDbId.BOH;
+    }
+
+    private void ChooseHero(HeroPickerButton hb)
+    {
+		hb.TriggerRelease();
+    }
+
+    public void HandleInput()
+    {
+		if (m_curAccessibleState == AccessibleState.ADVENTURE_CHOOSING_HERO)
+        {
+            m_accessibleHeroPickerButtons?.HandleAccessibleInput();
+        }
+        else if (m_curAccessibleState == AccessibleState.ADVENTURE_HERO_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_playButton.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				PressBackButton();
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+        {
+			m_accessibleHeroPickerButtons?.HandleAccessibleInput();
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CLASS_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_playButton.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				AccessibilityUtils.GoBackToHub();
+            }
+        }
+    }
+
+    private void PressBackButton()
+    {
+		m_backButton.TriggerRelease();
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.ADVENTURE_CHOOSING_HERO)
+        {
+			return m_accessibleHeroPickerButtons?.GetHelp();
+        }
+        else if (m_curAccessibleState == AccessibleState.ADVENTURE_HERO_CHOSEN)
+        {
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+        {
+			return m_accessibleHeroPickerButtons?.GetHelp();
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CLASS_CHOSEN)
+        {
+			// Click to start seems fine and easier on translators
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        }
+		else
+        {
+			return ""; // Could say loading I guess. Need to test other adventures
+        }
+    }
+
+    public void OnGainedFocus()
+    {
+		if (!CreatingDeck())
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE));
+        }
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+        {
+			if (AccessibleCollectionManager.Get().IsCreatingDeckFromClipboard())
+            {
+				AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+            }
+			else
+            {
+                m_accessibleHeroPickerButtons?.StartReading();
+            }
+        }
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
new file mode 100644
index 0000000..fbe9535
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
@@ -0,0 +1,7 @@
+﻿namespace Accessibility
+{
+    class AccessibilityConfig
+    {
+        internal static bool CAN_HEAR = true; // Could look into doing something like this for deaf-blind support
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
new file mode 100644
index 0000000..66d4939
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
@@ -0,0 +1,582 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    static class AccessibilityMgr
+    {
+        private static AccessibleKey s_forcedKey; // Override everything else e.g. sometimes we need to press enter before anything is possible but we don't necessarily want a screen or UI
+        private static Action s_forcedAction;
+
+        private static List<AccessibleUI> s_curUIs = new List<AccessibleUI>();
+
+        private static AccessibleScreen s_curScreen;
+
+        private static PegUIElement s_curNotificationDismissButton;
+
+        private static HSASpeech s_helpSpeech;
+
+        // Our sound game object
+        private static GameObject s_soundGameObject;
+
+        private static bool s_enabled;
+
+        private static bool s_textInputAllowed;
+
+        internal static void Initialize(GameObject rootGameObject)
+        {
+            try
+            {
+                Log.Accessibility.Print("Accessibility initialized");
+
+                // TODO: Think about whether we only want to enable if we detect a screen reader or if falling back to SAPI is fine
+                ScreenReader.Load();
+                rootGameObject.AddComponent<AccessibleInputMgr>();
+
+                s_enabled = true;
+
+                // Init sound stuff for narration
+                s_soundGameObject = InitSoundGameObject();
+                s_soundGameObject.transform.parent = rootGameObject.transform;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void Shutdown()
+        {
+            Log.Accessibility.Print("Accessibility shutdown");
+            ScreenReader.Unload();
+        }
+
+        internal static void SetScreen(AccessibleScreen screen)
+        {
+            Log.Accessibility.Print($"Setting screen {screen}");
+            var prevScreen = s_curScreen;
+            s_curScreen = screen;
+
+            if (s_curScreen != prevScreen && s_curUIs.Count == 0 && DialogManager.Get().GetNumQueuedDialogs() == 0)
+            {
+                NotifyScreenFocused();
+            }
+        }
+
+        private static void NotifyScreenFocused()
+        {
+            try
+            {
+                s_curScreen.OnGainedFocus();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void TransitioningScreens()
+        {
+            Log.Accessibility.Print($"Transitioning screens");
+            s_curScreen = null;
+        }
+
+        internal static void SetNotification(PegUIElement dismissButton)
+        {
+            if (s_curNotificationDismissButton != null)
+            {
+                // Remove any pending listeners
+                s_curNotificationDismissButton.RemoveEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+            }
+
+            s_curNotificationDismissButton = dismissButton;
+
+            s_curNotificationDismissButton.AddEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+        }
+
+        private static void OnNotificationDismissButtonReleased(UIEvent uiEvent)
+        {
+            s_curNotificationDismissButton = null;
+        }
+
+        public static void ShowUI(AccessibleUI ui)
+        {
+            try
+            {
+                Log.Accessibility.Print($"ShowUI({ui})");
+
+                if (GetFocusedUI() != ui)
+                {
+                    s_curUIs.Add(ui);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void HideUI(AccessibleUI ui)
+        {
+            try
+            {
+                var numRemovedUIs = s_curUIs.RemoveAll(obj => obj == ui);
+
+                if (numRemovedUIs > 0)
+                {
+                    OnUIPopped(ui);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void OnUIPopped(AccessibleUI ui)
+        {
+            var curUI = GetFocusedUI();
+
+            if (curUI == null)
+            {
+                if (s_curScreen != null)
+                {
+                    if (DialogManager.Get().GetCurrentDialog() == ui && DialogManager.Get().GetNumQueuedDialogs() > 0)
+                    {
+                        return;
+                    }
+
+                    NotifyScreenFocused();
+                }
+            }
+        }
+
+        private static AccessibleUI GetFocusedUI()
+        {
+            if (s_curUIs.Count == 0)
+            {
+                return null;
+            }
+
+            return s_curUIs[s_curUIs.Count - 1];
+        }
+
+        internal static void OutputAndWait(string text, Action onStart, Action onEnd)
+        {
+            GetSpeechMgr().OutputTextAndWait(text, onStart, onEnd);
+        }
+
+        public static void OutputNotification(string text, bool interrupt=false)
+        {
+            Output(text, interrupt);
+        }
+
+        public static void Output(AccessibleComponent speaker, string text, bool interrupt=false)
+        {
+            try
+            {
+                var curUI = GetFocusedUI();
+
+                if (speaker == null)
+                {
+                    // Something we haven't made accessible yet so read anyways in case it helps
+                    // Note: this is also useful for tests in some places where a UI doesn't necessarily exist
+                    Output(text, interrupt);
+                }
+                else if (curUI != null && speaker == curUI)
+                {
+                    Output(text, interrupt);
+                }
+                else if (curUI == null)
+                {
+                    if (s_curScreen != null && s_curScreen == speaker)
+                    {
+                        Output(text, interrupt);
+                    }
+                }
+                // Ignore text from non-focused screens
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void Output(string text, bool interrupt=false)
+        {
+            try
+            {
+                if (interrupt)
+                {
+                    GetSpeechMgr().OutputTextImmediately(text);
+                }
+                else
+                {
+                    Output(text);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void Output(string text)
+        {
+            GetSpeechMgr().OutputText(text);
+        }
+
+        public static void HandleKeyboardInput()
+        {
+            try
+            {
+                if (Input.anyKeyDown)
+                {
+                    InterruptHelpSpeeches();
+
+                    if (ScreenReader.IsUsingSAPI())
+                    {
+                        InterruptTexts();
+
+                        ScreenReader.Interrupt();
+                    }
+                }
+
+                HandleGlobalInput();
+
+                var curUI = GetFocusedUI();
+
+                if (AccessibleKey.HELP.IsPressed())
+                {
+                    if (s_helpSpeech != null)
+                    {
+                        NarrateHelp(s_helpSpeech);
+                    }
+                    else if (s_forcedKey != null)
+                    {
+                        Output(LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, s_forcedKey));
+                    }
+                    else if (s_curNotificationDismissButton != null)
+                    {
+                        Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                    }
+                    else if (curUI != null)
+                    {
+                        Output(curUI.GetAccessibleHelp());
+                    }
+                    else if (s_curScreen != null)
+                    {
+                        Output(s_curScreen.GetHelp());
+                    }
+                    else
+                    {
+                        Output(LocalizedText.GLOBAL_LOADING);
+                        Output(LocalizedText.GLOBAL_PLEASE_WAIT);
+                    }
+
+                    return;
+                }
+
+                if (s_forcedKey != null)
+                {
+                    if (s_forcedKey.IsPressed())
+                    {
+                        s_forcedKey = null;
+                        s_forcedAction();
+                    }
+                }
+                else if (s_curNotificationDismissButton != null)
+                {
+                    if (AccessibleKey.CONFIRM.IsPressed())
+                    {
+                        s_curNotificationDismissButton.TriggerRelease();
+                    }
+                }
+                else if (curUI != null)
+                {
+                    curUI.HandleAccessibleInput();
+                }
+                else if (s_curScreen != null)
+                {
+                    s_curScreen.HandleInput();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void AllowTextInput()
+        {
+            s_textInputAllowed = true;
+        }
+
+        internal static void DisallowTextInput()
+        {
+            s_textInputAllowed = false;
+        }
+
+        internal static bool IsTextInputAllowed()
+        {
+            return s_textInputAllowed;
+        }
+
+        private static void InterruptHelpSpeeches()
+        {
+            GetSpeechMgr().InterruptNarrations();
+        }
+
+        private static void InterruptTextSpeeches()
+        {
+            GetSpeechMgr().InterruptNarrations();
+        }
+
+        private static void HandleGlobalInput()
+        {
+            BnetBar bnetBar = BnetBar.Get();
+
+            if (bnetBar != null && AccessibleKey.OPEN_GAME_MENU.IsPressed())
+            {
+                bnetBar.ToggleGameMenu();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F5))
+            {
+                CheatMgr.Get().ShowConsole();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F6))
+            {
+                InGameSystemTests.BuildTestCardEffectInterpreter();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F7))
+            {
+                InGameSystemTests.Run();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.Backslash))
+            {
+                HSADevTools.RunTests();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F4))
+            {
+                // Smoke test speeches
+                GetSpeechMgr().Narrate(false, null, AccessibleSpeech.WELCOME_TO_HEARTHSTONE);
+            }
+            else if (AccessibleKey.INCREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().IncreaseSpeechRate();
+            }
+            else if (AccessibleKey.DECREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().DecreaseSpeechRate();
+            }
+        }
+
+        public static void WaitForForcedKey(AccessibleKey key, Action action)
+        {
+            s_forcedKey = key;
+            s_forcedAction = action;
+        }
+
+        public static void BlockAllInput(bool blockGlobalInput=false, bool blockHelpSpeech=false)
+        {
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            foreach (var key in AccessibleKey.GetAllKeys(blockGlobalInput))
+            {
+                key.Disable();
+            }
+
+            if (!blockGlobalInput && blockHelpSpeech)
+            {
+                AccessibleKey.HELP.Disable();
+            }
+        }
+
+        public static void UnblockAllInput()
+        {
+            m_isInWhitelistMode = false;
+
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            s_helpSpeech = null;
+        }
+
+        public static void OverrideHelpSpeech(HSASpeech helpSpeech)
+        {
+            s_helpSpeech = helpSpeech;
+            AccessibleKey.HELP.Enable();
+        }
+
+        public static void BlockHelpSpeech()
+        {
+            AccessibleKey.HELP.Disable();
+        }
+
+        public static void ResetHelpSpeech()
+        {
+            s_helpSpeech = null;
+            AccessibleKey.HELP.Enable();
+        }
+
+        private static bool m_isInWhitelistMode;
+
+        public static void WhitelistKeys(HSASpeech helpSpeech, params AccessibleKey[] keys)
+        {
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Enable();
+            }
+
+            OverrideHelpSpeech(helpSpeech);
+            m_isInWhitelistMode = true;
+        }
+
+        public static void BlacklistKeys(params AccessibleKey[] keys)
+        {
+            if (!m_isInWhitelistMode)
+            {
+                // e.g. it's useful to be able to disable end turn on Tutorial01, but we don't always want to block input after that
+                return;
+            }
+
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Disable();
+            }
+
+            s_helpSpeech = null;
+            AccessibleKey.HELP.Disable();
+        }
+
+        private static GameObject InitSoundGameObject()
+        {
+            var ret = new GameObject();
+
+            ret.AddComponent<AudioSource>();
+            ret.AddComponent<AccessibleSpeechMgr>();
+
+            return ret;
+        }
+
+        public static IEnumerator Narrate(HSASpeech speech)
+        {
+            return GetSpeechMgr().Narrate(speech);
+        }
+
+        public static void NarrateHelp(params HSASpeech[] speeches)
+        {
+            try
+            {
+                NarrateSpeeches(true, null, speeches);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void NarrateAndWait(HSASpeech speech, Action onFinish=null)
+        {
+            try
+            {
+                NarrateSpeeches(false, onFinish, speech);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void NarrateSpeeches(bool interruptable, Action onFinish=null, params HSASpeech[] speeches)
+        {
+            try
+            {
+                if (speeches == null || speeches.Length == 0)
+                {
+                    return;
+                }
+
+                GetSpeechMgr().Narrate(interruptable, onFinish, speeches);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static AccessibleSpeechMgr GetSpeechMgr()
+        {
+            return s_soundGameObject.GetComponent<AccessibleSpeechMgr>();
+        }
+
+        internal static int GetCPS()
+        {
+            return GetSpeechMgr().GetCPS();
+        }
+
+        public static void InterruptTexts()
+        {
+            try
+            {
+                GetSpeechMgr().InterruptTexts();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static bool IsAccessibilityEnabled()
+        {
+            return s_enabled;
+        }
+
+        internal static void ToggleEnabled()
+        {
+            s_enabled = !s_enabled;
+
+            if (s_enabled)
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.GLOBAL_ACCESSIBILITY_ON));
+            }
+            else
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.GLOBAL_ACCESSIBILITY_OFF));
+            }
+        }
+
+        internal static bool IsCurrentlyFocused(AccessibleComponent component)
+        {
+            var curUI = GetFocusedUI();
+
+            if (curUI != null && curUI == component)
+            {
+                return true;
+            }
+            else if (curUI == null)
+            {
+                return s_curScreen == component;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
new file mode 100644
index 0000000..4ef6757
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
@@ -0,0 +1,353 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibilityUtils
+    {
+        private static bool s_logEnabled = HearthstoneAccessConstants.DEV_MODE;
+
+        public static void DisableLogs()
+        {
+            s_logEnabled = false;
+        }
+
+        public static void LogDebug(string text)
+        {
+            try
+            {
+                if (!s_logEnabled)
+                {
+                    return;
+                }
+
+                Log.Accessibility.Print(text);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static string CurateText(string text)
+        {
+            try
+            {
+                LogDebug($"CT Before: {text}");
+                text = text.Trim();
+                text = AccessibilityUtils.FixWeirdText(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.HandleNewLines(text);
+                text = AccessibilityUtils.HandleSequentialBolds(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveHTMLTags(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveLooseFormattingTags(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveReadOnlyCharacters(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveAttackHealthParenthesisText(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.FixForwardSlashes(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.CapitalizeSentences(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveUnderscores(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.CollapsePeriods(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.NormalizeSpaces(text);
+                LogDebug($"CT: {text}");
+                text = text.Trim();
+                LogDebug($"CT: {text}");
+                //text = AccessibilityUtils.ExpandPlusSigns(text); // Not sure due to localization
+                LogDebug($"CT: {text}");
+                //text = AccessibilityUtils.ConvertNumbersToWrittenNumbers(text); // Bad idea as it breaks localization
+                LogDebug($"CT: {text}");
+
+                if (text.Length == 0)
+                {
+                    return text;
+                }
+
+                text = AccessibilityUtils.AddPeriodIfNeeded(text);
+
+                LogDebug($"CT After: {text}");
+
+                return text;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                return "";
+            }
+        }
+
+        private static string CapitalizeSentences(string text)
+        {
+            var sb = new StringBuilder(text.Length);
+
+            bool newSentence = true;
+
+            for (int i = 0; i < text.Length; i++)
+            {
+                if (newSentence && char.IsLetterOrDigit(text[i]))
+                {
+                    sb.Append(char.ToUpper(text[i]));
+                    newSentence = false;
+                }
+                else
+                {
+                    sb.Append(text[i]);
+                }
+
+                if (IsSentenceEndingCharacter(text[i]))
+                {
+                    newSentence = true;
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static bool IsSentenceEndingCharacter(char c)
+        {
+            return LocalizationUtils.GetSentenceEndingCharacters().Contains(c);
+        }
+
+        private static string CollapsePeriods(string text)
+        {
+            var period = LocalizationUtils.GetPeriod();
+            var threePeriods = $"{period}{period}{period}";
+            var twoPeriods = $"{period}{period}"; // Whatever
+
+            return text.Replace(threePeriods, period).Replace(twoPeriods, period); // . reads better than ... (.. reads dot/dot so needs to be removed)
+        }
+
+        private static string RemoveUnderscores(string text)
+        {
+            return text.Replace("_", " ");
+        }
+
+        private static string NormalizeSpaces(string text)
+        {
+            var sb = new StringBuilder();
+            bool ws = false;
+
+            foreach(var c in text)
+            {
+                if (c == ' ')
+                {
+                    if (!ws)
+                    {
+                        sb.Append(c);
+                    }
+
+                    ws = true;
+                }
+                else
+                {
+                    ws = false;
+                    sb.Append(c);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string AddPeriodIfNeeded(string text)
+        {
+            if (text.Length == 0)
+            {
+                return text;
+            }
+
+            var sentenceEndingCharacters = LocalizationUtils.GetSentenceEndingCharacters();
+            var lastChar = text[text.Length - 1];
+
+            AccessibilityUtils.LogDebug($"AddPeriodIfNeeded({text}) ; lastChar={lastChar}");
+
+            if (sentenceEndingCharacters.Contains(lastChar) || text.EndsWith(".\"")) // Edge case in a lot of languages
+            {
+                return text;
+            }
+
+            return text + LocalizationUtils.GetPeriod();
+        }
+
+        private static Regex s_attackAndHealthParenthesisRegex = new Regex(@"(.*)(\(\+\d Attack\/\+\d Health\))(.*)"); // TODO: Think if we want to bother with this
+
+        private static string RemoveAttackHealthParenthesisText(string text)
+        {
+            var match = s_attackAndHealthParenthesisRegex.Match(text);
+
+            if (match.Success)
+            {
+                return text.Replace(match.Groups[2].Value, "");
+            }
+            else
+            {
+                return text;
+            }
+        }
+
+        private static string FixForwardSlashes(string text)
+        {
+            return text.Replace("/", " ");
+        }
+
+        private static string FixWeirdText(string text)
+        {
+            return text.Replace("HIMSELF", "himself") // Injured Blademaster
+                .Replace("ALL", "all") // Various cards
+                .Replace("LOT", "lot"); // Deck recipe - you're missing a LOT of cards
+        }
+
+        private static Regex s_boldLinesRegex = new Regex("^<b>.*</b>$");
+
+        private static string HandleNewLines(string text)
+        {
+            // e.g. Battlecry on a single line and then something else below / Passive on a single line, etc.
+            var lines = text.Split('\n');
+            var sb = new StringBuilder();
+
+            for (var i = 0; i < lines.Length - 1; i++) // Last line doesn't matter
+            {
+                var line = lines[i];
+
+                if (s_boldLinesRegex.Match(line).Success)
+                {
+                    sb.Append($"{line}{LocalizationUtils.GetPeriod()} ");
+                }
+                else
+                {
+                    sb.Append($"{line} ");
+                }
+            }
+
+            sb.Append(lines[lines.Length - 1]);
+
+            return sb.ToString();
+        }
+
+        private static Regex s_htmlTagsRegex = new Regex("<[^>]*>");
+
+        private static string RemoveHTMLTags(string text)
+        {
+            return s_htmlTagsRegex.Replace(text, "");
+        }
+
+        private static string HandleSequentialBolds(string text)
+        {
+            return text.Replace("</b> <b>", $"</b>{LocalizationUtils.GetPeriod()} <b>");
+        }
+
+        private static string RemoveLooseFormattingTags(string text)
+        {
+            return text.Replace("[X]", "")
+                .Replace("[x]", "");
+        }
+
+        private static string RemoveReadOnlyCharacters(string text)
+        {
+            return text.Replace("*", "");
+        }
+
+        internal static void ReadTooltip(AccessibleComponent reader)
+        {
+            foreach (var tooltip in TooltipPanelManager.Get()?.GetTooltipPanels())
+            {
+                AccessibilityMgr.Output(reader, tooltip.m_name.Text);
+                AccessibilityMgr.Output(reader, tooltip.m_body.Text);
+            }
+
+            if (TutorialKeywordManager.Get()?.GetPanels() != null)
+            {
+                foreach (var tooltip in TutorialKeywordManager.Get().GetPanels())
+                {
+                    AccessibilityMgr.Output(reader, tooltip.m_name.Text);
+                    AccessibilityMgr.Output(reader, tooltip.m_body.Text);
+                }
+            }
+        }
+
+        /*private static string ExpandPlusSigns(string text)
+        {
+            var sb = new StringBuilder();
+
+            for (int i = 0; i < text.Length; i++)
+            {
+                var c = text[i];
+
+                if (c == '+' || c == '-')
+                {
+                    var replacedChar = true;
+
+                    if (c == '+')
+                    {
+                        sb.Append("plus");
+                    }
+                    else if (c == '-')
+                    {
+                        if (i > 0 && i < text.Length - 1 && text[i-1] == ' ' && text[i+1] != ' ') // Choose one - something
+                        {
+                            sb.Append("minus");
+                        }
+                        else
+                        {
+                            replacedChar = false; // e.g. Shadow-pan monk
+                        }
+                    }
+
+                    if (replacedChar)
+                    {
+                        int nextChar = i + 1;
+
+                        if (nextChar <= text.Length - 1 && text[nextChar] != ' ')
+                        {
+                            sb.Append(' ');
+                        }
+                    }
+                    else
+                    {
+                        sb.Append(c);
+                    }
+                }
+                else
+                {
+                    sb.Append(c);
+                }
+            }
+
+            return sb.ToString();
+        }*/
+
+        internal static void LogFatalError(Exception e)
+        {
+            Log.Accessibility.PrintError("FATAL ERROR - UNCAUGHT EXCEPTION");
+            Log.Accessibility.PrintError(e.ToString());
+        }
+
+        internal static void GoBackToHub()
+        {
+			Navigation.Clear();
+            SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
+        }
+
+        internal static void CenterScrollbarAroundObject(UIBScrollable scrollbar, GameObject gameObject)
+        {
+            scrollbar.CenterObjectInView(gameObject, 0f, null, iTween.EaseType.linear, 0f);
+        }
+
+        internal static void ProcessQueue(Queue<Action> queuedActions)
+        {
+            while (queuedActions.Count > 0)
+            {
+                queuedActions.Dequeue()();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
new file mode 100644
index 0000000..b22db7e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
@@ -0,0 +1,323 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleAdventureScene : AccessibleScreen
+    {
+        private enum State { LOADING, CHOOSING_ADVENTURE, CHOOSING_ADVENTURE_MODE, CHOOSING_DECK, CHOOSING_OPPONENT }; // Finding game is a loading state as well
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_curMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_chooseDeckMenu;
+
+        private AccessibleHorizontalMenu<AccessiblePracticeAIButton> m_chooseOpponentMenu;
+
+        private AdventureChooserTray m_adventureChooserTray;
+
+        private List<CustomDeckPage> m_customDeckPages;
+
+        private List<PracticeAIButton> m_practiceAIButtons;
+
+        private bool chosenDeck;
+
+        private static AccessibleAdventureScene s_instance = new AccessibleAdventureScene();
+
+        internal static AccessibleAdventureScene Get()
+        {
+            return s_instance;
+        }
+        
+        public void OnAdventureSceneShown()
+        {
+            try
+            {
+                m_practiceAIButtons = null; // Cleanup in case of unlocked heroes
+                m_curState = State.LOADING;
+
+                GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubSceneLoaded(AdventureData.Adventuresubscene subscene)
+        {
+            AccessibilityUtils.LogDebug($"OnSubSceneLoaded({subscene})");
+            m_curState = State.LOADING;
+
+            try
+            {
+                if (subscene == AdventureData.Adventuresubscene.CHOOSER)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                    SetupAndReadChooseAdventureMenu();
+                }
+                else if (subscene == AdventureData.Adventuresubscene.PRACTICE)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION));
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupAndReadChooseAdventureMenu()
+        {
+            m_curState = State.CHOOSING_ADVENTURE;
+            m_curMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE), OnGoBackToHub);
+
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION), OnChoosePracticeAdventure);
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION), OnChooseBookOfHeroesAdventure);
+            m_curMenu.AddOption(LocalizedText.SCREEN_GO_BACK, OnGoBackToHub);
+
+            m_curMenu.StartReading();
+        }
+
+        private void OnChoosePracticeAdventure()
+        {
+            m_curState = State.CHOOSING_ADVENTURE_MODE;
+            m_curMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE), SetupAndReadChooseAdventureMenu);
+
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION), OnChooseNormalAdventure);
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION), OnChooseExpertAdventure);
+
+            m_curMenu.StartReading();
+        }
+
+        private void OnChooseExpertAdventure()
+        {
+            if (!AdventureConfig.CanPlayMode(AdventureDbId.PRACTICE, AdventureModeDbId.EXPERT))
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED));
+            }
+            else
+            {
+                ChooseAdventure(AdventureDbId.PRACTICE, AdventureModeDbId.EXPERT);
+            }
+        }
+
+        private void OnChooseBookOfHeroesAdventure()
+        {
+            ChooseAdventure(AdventureDbId.BOH, AdventureModeDbId.DUNGEON_CRAWL);
+        }
+
+        public void OnAdventureChooserTrayAwake(AdventureChooserTray adventureChooserTray)
+        {
+            AccessibilityUtils.LogDebug($"OnAdventureChooserTrayAwake({adventureChooserTray})");
+            m_adventureChooserTray = adventureChooserTray;
+        }
+
+        private void OnChooseNormalAdventure()
+        {
+            ChooseAdventure(AdventureDbId.PRACTICE, AdventureModeDbId.LINEAR);
+        }
+
+        private void ChooseAdventure(AdventureDbId adventure, AdventureModeDbId mode)
+        {
+            AdventureConfig.Get().SetSelectedAdventureMode(adventure, mode);
+            m_adventureChooserTray.m_ChooseButton.TriggerRelease();
+        }
+
+        private void OnGoBackToHub()
+        {
+            m_adventureChooserTray.m_BackButton.TriggerRelease();
+        }
+
+        public void OnPracticePickerTrayDisplayShown(List<PracticeAIButton> practiceAIButtons)
+        {
+            try
+            {
+                m_practiceAIButtons = practiceAIButtons;
+                SetupChooseOpponentMenu();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupChooseOpponentMenu()
+        {
+            m_curState = State.CHOOSING_OPPONENT;
+            var chooseOpponentMenu = new AccessibleHorizontalMenu<AccessiblePracticeAIButton>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_TITLE), OnGoBackToChooseDeckMenuFromChooseOpponentMenu);
+
+            foreach (var btn in m_practiceAIButtons)
+            {
+                chooseOpponentMenu.AddOption(new AccessiblePracticeAIButton(this, btn), () => SelectOpponent(btn));
+            }
+
+            m_chooseOpponentMenu = chooseOpponentMenu;
+            m_chooseOpponentMenu.StartReading();
+        }
+
+        private void SetupChooseDeckMenu()
+        {
+            chosenDeck = false;
+            m_curState = State.CHOOSING_DECK;
+            m_chooseDeckMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), OnGoBackToChooseAdventureFromChooseDeckMenu);
+
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+            var selectedDeckId = deckPickerTrayDisplay.GetLastChosenDeckId();
+            var selectedDeckIdx = 0;
+
+            for (int i = 0, curIdx = 0; i < m_customDeckPages.Count; i++)
+            {
+                var page = m_customDeckPages[i];
+                var pageDecks = page.m_customDecks;
+
+                for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+                {
+                    var deck = pageDecks[j];
+                    var deckId = deck.GetDeckID();
+
+                    if (deckId == -1L)
+                    {
+                        break;
+                    }
+                    else if (deckId == selectedDeckId)
+                    {
+                        selectedDeckIdx = curIdx;
+                    }
+
+                    var deckPageIdx = i;
+
+                    var accessibleDeck = new AccessibleCollectionDeckBoxVisual(this, deck);
+
+                    m_chooseDeckMenu.AddOption(accessibleDeck, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+                }
+            }
+
+            m_chooseDeckMenu.SetIndex(selectedDeckIdx);
+            m_chooseDeckMenu.StartReading();
+        }
+
+        private void OnGoBackToChooseDeckMenuFromChooseOpponentMenu()
+        {
+            PracticePickerTrayDisplay.Get().m_backButton.TriggerRelease();
+            SetupChooseDeckMenu();
+        }
+
+        private void OnGoBackToChooseAdventureFromChooseDeckMenu()
+        {
+            DeckPickerTrayDisplay.Get().m_backButton.TriggerRelease();
+        }
+
+        private void SelectOpponent(PracticeAIButton btn)
+        {
+            btn.TriggerRelease();
+            PracticePickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                m_chooseDeckMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                m_chooseOpponentMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState != State.LOADING)
+            {
+                m_curMenu?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                return m_chooseDeckMenu?.GetHelp();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                return m_chooseOpponentMenu?.GetHelp();
+            }
+            else if (m_curState != State.LOADING)
+            {
+                return m_curMenu?.GetHelp();
+            }
+
+            return "";
+        }
+
+        public void OnDeckPickerTrayDisplayReady(List<CustomDeckPage> pages)
+        {
+            try
+            {
+                m_customDeckPages = pages;
+                m_practiceAIButtons = null; // Cleanup in case we go out of adventure and in again
+                SetupChooseDeckMenu();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SelectDeck(CollectionDeckBoxVisual deck)
+        {
+            chosenDeck = true;
+            deck.TriggerRelease();
+            //DeckPickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        public void OnSelectedDeck(CollectionDeckBoxVisual deck)
+        {
+            if (AccessibilityMgr.IsAccessibilityEnabled() && chosenDeck)
+            {
+                DeckPickerTrayDisplay.Get().m_playButton.TriggerRelease();
+            }
+        }
+
+        private void ShowDeckPage(int pageIndex)
+        {
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+
+            if (deckPickerTrayDisplay.GetCurrentPageIndex() != pageIndex)
+            {
+                deckPickerTrayDisplay.ShowPage(pageIndex);
+            }
+        }
+
+        private bool OnFindGameEvent(FindGameEventData eventData, object userData)
+        {
+            m_curState = State.LOADING;
+
+            return false;
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.LOADING)
+            {
+                return;
+            }
+
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                m_chooseDeckMenu?.StartReading();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                m_chooseOpponentMenu?.StartReading();
+            }
+            else
+            {
+                m_curMenu?.StartReading();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
new file mode 100644
index 0000000..cdc2bbd
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
@@ -0,0 +1,26 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class AccessibleAttackSpellController
+    {
+        private PowerTaskList m_taskList;
+
+        public AccessibleAttackSpellController(PowerTaskList taskList)
+        {
+            m_taskList = taskList;
+        }
+
+        public void OnLaunchAttack()
+        {
+            try
+            {
+                AccessiblePlayDescriber.Get().OnAttack(m_taskList);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs
new file mode 100644
index 0000000..2ebe2a9
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs
@@ -0,0 +1,571 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleCard : AccessibleItem
+    {
+        private readonly Card m_card;
+
+        internal AccessibleCard(AccessibleComponent parent, Card card) : base(parent)
+        {
+            m_card = card;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_card.GetEntity().IsHero())
+            {
+                return GetLinesForHero();
+            }
+            else if (m_card.GetEntity().IsHeroPower())
+            {
+                return GetLinesForHeroPower();
+            }
+            else if (m_card.GetEntity().IsWeapon())
+            {
+                return GetLinesForWeapon();
+            }
+            else if (m_card.GetEntity().IsQuest())
+            {
+                return GetLinesForQuest();
+            }
+            else if (m_card.GetEntity().IsSideQuest())
+            {
+                return GetLinesForSideQuest();
+            }
+            else if (m_card.GetEntity().IsQuestline())
+            {
+                return GetLinesForQuestline();
+            }
+            else if (m_card.GetEntity().IsSecret() && !m_card.GetEntity().IsControlledByFriendlySidePlayer())
+            {
+                return GetLinesForOpponentSecret();
+            }
+            else
+            {
+                return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            var zone = m_card.GetEntity().GetZone();
+
+            if (zone == TAG_ZONE.PLAY)
+            {
+                if (IsTurnBasedHero())
+                {
+                    // e.g. Some BoH missions which use x turns to hold out instead of attack/health
+                    return GetLinesForTurnBasedHeroInPlayZone();
+                }
+                else
+                {
+                    return GetLinesForHeroInPlayZone();
+                }
+            }
+            else
+            {
+                return GetLinesForHeroCard();
+            }
+        }
+
+        private bool IsTurnBasedHero()
+        {
+            if (!GameState.Get().GetGameEntity().IsTurnCounterBasedMission())
+            {
+                return false;
+            }
+
+            return m_card.GetEntity().IsControlledByOpposingSidePlayer();
+        }
+
+        private List<string> GetLinesForTurnBasedHeroInPlayZone()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            var missionEntity = GameState.Get().GetGameEntity() as MissionEntity;
+            lines.Add(missionEntity.GetTurnCounterText());
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroInPlayZone()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroCard()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+            lines.Add(GetType());
+
+            var armor = m_card.GetEntity().GetArmor();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            try
+            {
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(m_card.GetEntity().GetCardId()));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (!IsCostHidden())
+            {
+                lines.Add(GetCost());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+
+        private bool IsCostHidden()
+        {
+            return AreStatsHidden() || m_card.GetEntity().HasTag(GAME_TAG.HIDE_COST);
+        }
+
+        private bool IsAttackHidden()
+        {
+            return AreStatsHidden() || m_card.GetEntity().HasTag(GAME_TAG.HIDE_ATTACK);
+        }
+
+        private bool IsHealthHidden()
+        {
+            return AreStatsHidden() || m_card.GetEntity().HasTag(GAME_TAG.HIDE_HEALTH);
+        }
+
+        private bool IsArmorHidden()
+        {
+            return AreStatsHidden();
+        }
+
+        private bool AreStatsHidden()
+        {
+            return m_card.GetEntity().HasTag(GAME_TAG.HIDE_STATS);
+        }
+
+        private List<string> GetLinesForWeapon()
+        {
+            var isWielded = m_card.GetZone()?.GetType() == typeof(ZoneWeapon);
+
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (!isWielded)
+            {
+                lines.Add(GetCost());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetResources(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            if (!isWielded)
+            {
+                lines.Add(GetType());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            var zone = m_card.GetEntity().GetZone();
+            var isInPlayZone = zone == TAG_ZONE.PLAY;
+            var isInSecretZone = zone == TAG_ZONE.SECRET;
+            var shouldReadCost = !isInPlayZone && !isInSecretZone;
+
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (shouldReadCost)
+            {
+                lines.Add(GetCost());
+            }
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                if (isInPlayZone)
+                {
+                    var effects = GetEffects();
+                    if (effects.Length > 0)
+                    {
+                        resources = $"{resources} {effects}";
+                    }
+                }
+
+                lines.Add(resources);
+            }
+            else if (isInPlayZone)
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetRace(), lines); // Handles spell school as well
+
+            if (!isInPlayZone)
+            {
+                lines.Add(GetType());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForQuest()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+            lines.AddRange(GetQuestReward());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForSideQuest()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForQuestline()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestlinePart(), lines);
+            lines.AddRange(GetQuestlineProgress());
+            lines.AddRange(GetQuestReward());
+            AccessibleCardUtils.AddLineIfExists(GetNextQuestlinePart(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForOpponentSecret()
+        {
+            var ret = new List<string>();
+            ret.Add(GetName());
+            return ret;
+        }
+
+        private string GetQuestProgress()
+        {
+            return AccessibleCardUtils.GetQuestProgressLine(m_card.GetEntity());
+        }
+
+        private string GetQuestlinePart()
+        {
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return "";
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return "";
+            }
+
+            if (questlineProgressUI.m_QuestDetailTextLeft.gameObject.activeSelf)
+            {
+                return questlineProgressUI.m_QuestDetailTextLeft.Text;
+            }
+
+            return "";
+        }
+
+        private string GetNextQuestlinePart()
+        {
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return "";
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return "";
+            }
+
+            if (questlineProgressUI.m_QuestDetailTextRight.gameObject.activeSelf)
+            {
+                return questlineProgressUI.m_QuestDetailTextRight.Text;
+            }
+
+            return "";
+        }
+
+        private List<string> GetQuestlineProgress()
+        {
+            var ret = new List<string>();
+
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return ret;
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return ret;
+            }
+
+            var req1Text = questlineProgressUI.m_QuestRequirementText1.Text;
+            var req2Text = questlineProgressUI.m_QuestRequirementText2.Text;
+            var req3Text = questlineProgressUI.m_QuestRequirementText3.Text;
+
+            if (questlineProgressUI.m_QuestRequirementText1.gameObject.activeSelf && req1Text != null && req1Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req1Text, questlineProgressUI.m_RequirementCheckmark1));
+            }
+
+            if (questlineProgressUI.m_QuestRequirementText2.gameObject.activeSelf && req2Text != null && req2Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req2Text, questlineProgressUI.m_RequirementCheckmark2));
+            }
+
+            if (questlineProgressUI.m_QuestRequirementText3.gameObject.activeSelf && req3Text != null && req3Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req3Text, questlineProgressUI.m_RequirementCheckmark3));
+            }
+
+            return ret;
+        }
+
+        private string FormatQuestlineRequirementText(string reqText, GameObject reqCheckmark)
+        {
+            if (reqCheckmark.activeInHierarchy)
+            {
+                return $"{reqText} {LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED)}";
+            }
+            else
+            {
+                return $"{reqText} {LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED)}";
+            }
+        }
+
+        private List<string> GetQuestReward()
+        {
+            var rewardCardId = AccessibleCardUtils.GetRewardCardIDFromQuestCardID(m_card.GetEntity());
+
+            if (rewardCardId == null)
+            {
+                return new List<string>();
+            }
+
+            return AccessibleCardUtils.GetQuestRewardCardLines(rewardCardId);
+        }
+
+        private string GetDescription()
+        {
+            Entity entity = m_card.GetEntity();
+            return entity.GetCardTextBuilder().BuildCardTextInHand(entity);
+        }
+
+        private string GetType()
+        {
+            return AccessibleCardUtils.GetType(m_card.GetEntity().GetCardType());
+        }
+
+        private string GetCost()
+        {
+            int cost = m_card.GetEntity().GetCost();
+
+            if (IsCostHidden())
+            {
+                cost = 0;
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+        }
+
+        private string GetResources()
+        {
+            if (m_card.GetEntity().IsDormant() || m_card.GetEntity().HasTag(GAME_TAG.DORMANT_VISUAL))
+            {
+                return "";
+            }
+            else if (m_card.GetEntity().GetTag(GAME_TAG.HIDE_STATS) == 1)
+            {
+                // e.g. Divine Bell in BoH Garrosh 7
+                return "";
+            }
+            else if (m_card.GetEntity().IsMinion()) {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp);
+            } 
+            else if (m_card.GetEntity().IsWeapon()) {
+                var atk = m_card.GetEntity().GetATK();
+                var durability = m_card.GetEntity().GetCurrentDurability();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, atk, durability);
+            } 
+            else if (m_card.GetEntity().IsHero())
+            {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                var armor = m_card.GetEntity().GetArmor();
+
+                var atkHidden = IsAttackHidden();
+                var hpHidden = IsHealthHidden();
+                var armorHidden = IsArmorHidden();
+
+                var showAtk = !atkHidden && atk > 0;
+                var showHp = !hpHidden;
+                var showArmor = !armorHidden && armor > 0;
+
+                var stats = new List<string>();
+
+                if (showAtk)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ATK, atk));
+                }
+                if (showArmor)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+                }
+                if (showHp)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, hp));
+                }
+
+                return AccessibleSpeechUtils.HumanizeList(stats);
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        private string GetRace()
+        {
+            // Note: This handles spell school as well
+            return m_card.GetEntity().GetEntityDef().GetRaceText();
+        }
+
+        private string GetRarity()
+        {
+            return AccessibleCardUtils.GetRarity(m_card.GetEntity().GetEntityDef());
+        }
+
+        internal string GetName()
+        {
+            if (m_card.GetEntity().IsHero() && m_card.GetEntity().GetZone() == TAG_ZONE.PLAY)
+            {
+                if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+                {
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO);
+                }
+                else
+                {
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HERO);
+                }
+            }
+            else if (m_card.GetEntity().IsSecret() && m_card.GetControllerSide() != Player.Side.FRIENDLY)
+            {
+                var secretClass = GameStrings.GetClassName(m_card.GetEntity().GetClass());
+                return LocalizationUtils.Format(LocalizationKey.GLOBAL_SECRET, secretClass);
+            }
+            else
+            {
+                return m_card.GetEntity().GetEntityDef().GetName();
+            }
+        }
+
+        private string GetEffects()
+        {
+            List<string> effects = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            if (entity.HasDivineShield()) effects.Add(LocalizedText.GLOBAL_DIVINE_SHIELD);
+            if (entity.IsFrozen()) effects.Add(LocalizedText.GLOBAL_FROZEN);
+            if (entity.HasLifesteal()) effects.Add(LocalizedText.GLOBAL_LIFESTEAL);
+            if (entity.HasDeathrattle()) effects.Add(LocalizedText.GLOBAL_DEATHRATTLE);
+            if (entity.IsPoisonous()) effects.Add(LocalizedText.GLOBAL_POISONOUS);
+            if (entity.IsStealthed()) effects.Add(LocalizedText.GLOBAL_STEALTH);
+            if (entity.HasTaunt()) effects.Add(LocalizedText.GLOBAL_TAUNT);
+            if (entity.IsImmune()) effects.Add(LocalizedText.GLOBAL_IMMUNE);
+            if (entity.IsDormant()) effects.Add(LocalizedText.GLOBAL_DORMANT);
+
+            if (effects.Count == 0)
+            {
+                return "";
+            }
+
+            return AccessibleSpeechUtils.HumanizeList(effects);
+        }
+
+        internal Card GetCard()
+        {
+            return m_card;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs
new file mode 100644
index 0000000..538ef29
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs
@@ -0,0 +1,225 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCardUtils
+    {
+        internal static string GetType(TAG_CARDTYPE type)
+        {
+            return GameStrings.GetCardTypeName(type);
+        }
+
+        internal static string GetRarity(EntityDef entityDef)
+        {
+            if (entityDef.IsElite())
+            {
+                // All elite cards are legendary at the moment. Legendary cards like Cairne Bloodhoof are elite but have their rarity set to invalid for some reason
+                return GameStrings.GetRarityText(TAG_RARITY.LEGENDARY);
+            }
+
+            var rarity = entityDef.GetRarity();
+
+            if (rarity == TAG_RARITY.INVALID || rarity == TAG_RARITY.FREE)
+            {
+                return "";
+            }
+
+            return GameStrings.GetRarityText(rarity);
+        }
+
+        internal static List<string> GetLinesForNormalEntityDef(EntityDef entityDef, TAG_PREMIUM premiumType, string className=null)
+        {
+            var ret = new List<string>();
+
+            ret.Add(GetNameWithPremium(entityDef.GetName(), premiumType)); // Golden/Diamond edition
+
+            if (className != null)
+            {
+                ret.Add(className); // We don't always want to show the class name but it's useful sometimes e.g. pack opening
+            }
+
+            ret.Add(GetCardCost(entityDef.GetCost())); // x mana
+
+            AddLineIfExists(GetResourcesForEntityDef(entityDef), ret); // Resources
+            AddLineIfExists(entityDef.GetCardTextInHand(), ret); // Description
+            AddLineIfExists(entityDef.GetRaceText(), ret); // Race or spell school
+
+            ret.Add(GetType(entityDef.GetCardType())); // Weapon, spell, etc.
+
+            AddLineIfExists(GetRarity(entityDef), ret); // Legendary, elite, etc.
+
+            return ret;
+        }
+
+        internal static void AddLineIfExists(string line, List<string> lines)
+        {
+            if (line == null || line.Length == 0)
+            {
+                return;
+            }
+
+            lines.Add(line);
+        }
+
+        internal static string GetResourcesForEntityDef(EntityDef entityDef)
+        {
+            if (entityDef.GetCardType() == TAG_CARDTYPE.MINION)
+            {
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, entityDef.GetATK(), entityDef.GetHealth());
+            } 
+            else if (entityDef.GetCardType() == TAG_CARDTYPE.WEAPON)
+            {
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, entityDef.GetATK(), entityDef.GetDurability());
+            } 
+            else if (entityDef.GetCardType() == TAG_CARDTYPE.HERO)
+            {
+                var atk = entityDef.GetATK();
+                var hp = entityDef.GetHealth();
+                var armor = entityDef.GetArmor();
+
+                var stats = new List<string>();
+
+                if (atk > 0)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ATK, atk));
+                }
+                if (armor > 0)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+                }
+
+                stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, hp));
+
+                return AccessibleSpeechUtils.HumanizeList(stats);
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        public static List<string> GetHeroPowerCardLinesForHeroCard(string heroCardId)
+        {
+            var ret = new List<string>();
+
+            var heroPowerCardId = GameUtils.GetHeroPowerCardIdFromHero(heroCardId);
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(heroPowerCardId);
+            var heroPowerName = entityDef.GetName();
+
+            ret.Add(AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO_POWER), heroPowerName));
+
+            if (!entityDef.HasTag(GAME_TAG.HIDE_STATS) && !entityDef.HasTag(GAME_TAG.HIDE_COST))
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, entityDef.GetCost()));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(entityDef.GetCardTextInHand(), ret);
+
+            return ret;
+        }
+
+        public static List<string> GetQuestRewardCardLines(string cardId)
+        {
+            var ret = new List<string>();
+
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+            var cardName = entityDef.GetName();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, cardName));
+
+            if (!entityDef.HasTag(GAME_TAG.HIDE_STATS) && !entityDef.HasTag(GAME_TAG.HIDE_COST))
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, entityDef.GetCost()));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetResources(entityDef), ret);
+            AccessibleCardUtils.AddLineIfExists(entityDef.GetCardTextInHand(), ret);
+            AccessibleCardUtils.AddLineIfExists(entityDef.GetRaceText(), ret);
+
+            ret.Add(GetType(entityDef.GetCardType()));
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(entityDef), ret);
+
+            return ret;
+        }
+
+        private static string GetResources(EntityDef entityDef)
+        {
+            if (entityDef.IsMinion())
+            {
+                var atk = entityDef.GetATK();
+                var hp = entityDef.GetHealth();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp);
+            } 
+            else if (entityDef.IsWeapon())
+            {
+                var atk = entityDef.GetATK();
+                var durability = entityDef.GetDurability();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, atk, durability);
+            } 
+            // TODO: Hero cards
+            else
+            {
+                return "";
+            }
+        }
+
+        internal static string GetQuestProgressLine(Entity entity)
+        {
+            var curProgress = entity.GetTag(GAME_TAG.QUEST_PROGRESS);
+            var questProgressTotal = entity.GetTag(GAME_TAG.QUEST_PROGRESS_TOTAL);
+
+            return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, curProgress, questProgressTotal);
+        }
+
+        internal static string GetRewardCardIDFromQuestCardID(Entity entity)
+        {
+            return QuestController.GetRewardCardIDFromQuestCardID(entity);
+        }
+
+        internal static string GetNameWithPremium(string name, TAG_PREMIUM premiumType)
+        {
+            switch (premiumType)
+            {
+                case TAG_PREMIUM.GOLDEN:
+                    return LocalizationUtils.Format(LocalizationKey.READ_COLLECTION_CARD_NAME_GOLDEN, name);
+                case TAG_PREMIUM.DIAMOND:
+                    return LocalizationUtils.Format(LocalizationKey.READ_COLLECTION_CARD_NAME_DIAMOND, name);
+                default:
+                    return name;
+            }
+        }
+
+        internal static string GetCardCost(int cost)
+        {
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+        }
+
+        internal static string GetCardPackName(int packId)
+        {
+            BoosterDbfRecord record = GameDbf.Booster.GetRecord(packId);
+
+            if (record == null)
+            {
+                return null;
+            }
+
+            var name = record.Name?.GetString();
+
+            if (name == null || name.Length == 0)
+            {
+                if (record.NoteDesc != null && record.NoteDesc.Length > 0)
+                {
+                    // e.g. standard warrior pack from BoH Garrosh
+                    return record.NoteDesc;
+                }
+
+                return null;
+            }
+
+            return name;
+        }
+
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs
new file mode 100644
index 0000000..926fe77
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs
@@ -0,0 +1,34 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleCheckBox : AccessibleElement
+    {
+        private readonly CheckBox m_checkBox;
+
+        internal AccessibleCheckBox(AccessibleComponent parent, CheckBox checkBox) : base(parent)
+        {
+            m_checkBox = checkBox;
+        }
+
+        public void Toggle()
+        {
+            m_checkBox.TriggerRelease();
+            ReadState();
+        }
+
+        private void ReadState()
+        {
+            if (m_checkBox.IsChecked())
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED));
+            }
+            else
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED));
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
new file mode 100644
index 0000000..0483f46
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
@@ -0,0 +1,183 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectibleCard : AccessibleItem
+    {
+        private readonly CollectibleCard m_card;
+
+        private bool m_readCount;
+
+        private bool m_countOverride;
+        private int m_count;
+
+        internal AccessibleCollectibleCard(AccessibleComponent parent, CollectibleCard card, bool readCount=true) : base(parent)
+        {
+            m_card = card;
+            m_readCount = readCount;
+        }
+
+        // Used for listing cards in e.g. deck building where the card count is not necessarily the owned count
+        internal AccessibleCollectibleCard(AccessibleComponent parent,CollectibleCard card, int count) : base(parent)
+        {
+            m_card = card;
+            m_countOverride = true;
+            m_count = count;
+            m_readCount = true;
+        }
+
+        internal override List<string> GetLines()
+        {
+            switch (m_card.CardType)
+            {
+                case TAG_CARDTYPE.HERO:
+                    return GetLinesForHero();
+                case TAG_CARDTYPE.HERO_POWER:
+                    return GetLinesForHeroPower();
+                case TAG_CARDTYPE.WEAPON:
+                case TAG_CARDTYPE.ENCHANTMENT:
+                case TAG_CARDTYPE.MINION:
+                case TAG_CARDTYPE.SPELL:
+                    return GetLinesForNormalCard();
+                default:
+                    Log.Accessibility.PrintError($"AccessibleCollectibleCard: Found unhandled CardType {m_card.CardType}");
+                    return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            if (m_card.IsHeroSkin)
+            {
+                return GetLinesForHeroSkin();
+            }
+            else if (m_card.GetEntityDef().GetArmor() > 0) // TODO: Figure out how we can differentiate this as this is a wild guess
+            {
+                return GetLinesForHeroCard();
+            }
+            else
+            {
+                // Generic default just in case we're missing something
+                var lines = new List<string>();
+                lines.Add(GetName());
+
+                AccessibleCardUtils.AddLineIfExists(GetResources(), lines);
+
+                return lines;
+            }
+        }
+
+        private List<string> GetLinesForHeroCard()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+            lines.Add(GetType());
+
+            var armor = m_card.GetEntityDef().GetArmor();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            try
+            {
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(m_card.GetEntityDef().GetCardId()));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroSkin()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            var lines = AccessibleCardUtils.GetLinesForNormalEntityDef(m_card.GetEntityDef(), m_card.PremiumType);
+
+            AccessibleCardUtils.AddLineIfExists(GetCardCount(), lines);
+
+            return lines;
+        }
+
+        private string GetDescription()
+        {
+            return m_card.CardInHandText;
+        }
+
+        private string GetType()
+        {
+            return AccessibleCardUtils.GetType(m_card.CardType);
+        }
+
+        private string GetRarity()
+        {
+            return AccessibleCardUtils.GetRarity(m_card.GetEntityDef());
+        }
+
+        private string GetCost()
+        {
+            return AccessibleCardUtils.GetCardCost(m_card.ManaCost);
+        }
+
+        private string GetCardCount()
+        {
+            if (!m_readCount)
+            {
+                return "";
+            }
+
+            int numCopies;
+
+            if (m_countOverride)
+            {
+                // Used by e.g. deck builder
+                numCopies = m_count;
+            }
+            else
+            {
+                numCopies = m_card.OwnedCount;
+            }
+
+            if (numCopies <= 1)
+            {
+                return "";
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_N_COPIES, numCopies);
+        }
+
+        private string GetResources()
+        {
+            return AccessibleCardUtils.GetResourcesForEntityDef(m_card.GetEntityDef());
+        }
+
+        internal string GetName()
+        {
+            return AccessibleCardUtils.GetNameWithPremium(m_card.Name, m_card.PremiumType);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleComponent.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleComponent.cs
new file mode 100644
index 0000000..3523cc1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleComponent.cs
@@ -0,0 +1,6 @@
+﻿namespace Accessibility
+{
+    public interface AccessibleComponent
+    {
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs
new file mode 100644
index 0000000..af45324
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs
@@ -0,0 +1,119 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleDropdownControl : AccessibleElement
+    {
+        private readonly DropdownControl m_dropdown;
+
+        private Action m_onDone;
+
+        private AccessibleMenu m_menu;
+
+        internal AccessibleDropdownControl(AccessibleComponent parent, DropdownControl dropdown, Action onDone) : base(parent)
+        {
+            m_dropdown = dropdown;
+            m_onDone = onDone;
+
+            SetupMenu();
+        }
+
+        private void SetupMenu()
+        {
+            m_menu = new AccessibleMenu(m_parent, "", OnBackPressed, true);
+            
+            foreach(var item in m_dropdown.m_items)
+            {
+                m_menu.AddOption(item.m_text.Text, () => SelectItem(item));
+            }
+        }
+
+        private void OnBackPressed()
+        {
+            m_dropdown.m_cancelCatcher.TriggerRelease();
+            m_onDone();
+        }
+
+        private void SelectItem(DropdownMenuItem item)
+        {
+            item.TriggerRelease();
+            m_onDone();
+        }
+
+        public void HandleInput()
+        {
+            m_menu?.HandleAccessibleInput();
+            /*if (GlobalAccessibleMenuUtils.ReadNextIsPressed())
+            {
+                ReadNextItem(1);
+            }
+            else if (GlobalAccessibleMenuUtils.ReadPrevIsPressed())
+            {
+                ReadNextItem(-1);
+            }
+            else if (GlobalAccessibleMenuUtils.BackIsPressed() || GlobalAccessibleMenuUtils.ConfirmIsPressed())
+            {
+                m_onDone();
+            }*/
+        }
+
+        private void ReadNextItem(int inc)
+        {
+            var selectedItem = GetSelectedItem();
+            var curIndex = FindItemIndex(selectedItem);
+            var targetIndex = curIndex + inc;
+            var numItems = m_dropdown.m_items.Count;
+
+            if (targetIndex >= numItems)
+            {
+                targetIndex = curIndex;
+            }
+            else if (targetIndex < 0)
+            {
+                targetIndex = 0;
+            }
+
+            var newItem = m_dropdown.m_items[targetIndex];
+            newItem.TriggerRelease();
+
+            StartReading();
+        }
+
+        public void StartReading()
+        {
+            /*var selectedItem = GetSelectedItem();
+
+            var curItemName = selectedItem?.m_text?.Text;
+            var curItemNumber = FindItemIndex(selectedItem) + 1;
+            var numItems = m_dropdown.m_items.Count;
+
+            AccessibilityMgr.Output(AccessibleSpeech.MENU_OPTION(curItemName, curItemNumber, numItems));*/
+
+            var selectedItem = GetSelectedItem();
+            var curItemIndex = FindItemIndex(selectedItem);
+            m_menu.SetIndex(curItemIndex);
+            m_menu.StartReading();
+            m_dropdown.m_button.TriggerRelease();
+        }
+
+        private DropdownMenuItem GetSelectedItem()
+        {
+            return m_dropdown.m_selectedItem;
+        }
+
+        private int FindItemIndex(DropdownMenuItem item)
+        {
+            for (int i = 0; i < m_dropdown.m_items.Count; i++)
+            {
+                if (m_dropdown.m_items[i].GetValue().Equals(item.GetValue()))
+                {
+                    return i;
+                }
+            }
+
+            return 0;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleElement.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleElement.cs
new file mode 100644
index 0000000..cc94417
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleElement.cs
@@ -0,0 +1,17 @@
+﻿namespace Accessibility
+{
+    public class AccessibleElement
+    {
+        protected AccessibleComponent m_parent;
+
+        public AccessibleElement(AccessibleComponent parent)
+        {
+            m_parent = parent;
+        }
+
+        protected void Output(string text)
+        {
+            AccessibilityMgr.Output(m_parent, text);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
new file mode 100644
index 0000000..642384f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
@@ -0,0 +1,45 @@
+﻿using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleEndGameScreen : AccessibleScreen
+    {
+        private static AccessibleEndGameScreen s_instance = new AccessibleEndGameScreen();
+
+        private PegUIElement m_continue;
+
+        internal static AccessibleEndGameScreen Get()
+        {
+            return s_instance;
+        }
+
+        internal void OnShow()
+        {
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        internal void OnShown(PegUIElement hitbox)
+        {
+            m_continue = hitbox;
+
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_continue.TriggerRelease();
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs
new file mode 100644
index 0000000..9259009
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs
@@ -0,0 +1,110 @@
+﻿using Hearthstone.DataModels;
+using Hearthstone.UI;
+using System;
+
+namespace Accessibility
+{
+    class AccessibleGameModeScene : AccessibleScreen
+    {
+        private enum State { LOADING, MAIN_MENU };
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_mainMenu;
+
+        private GameModeSceneDataModel m_gameModeSceneDataModel;
+
+        private static AccessibleGameModeScene s_instance = new AccessibleGameModeScene();
+
+        internal static AccessibleGameModeScene Get()
+        {
+            return s_instance;
+        }
+
+        public void OnDisplayReady(GameModeSceneDataModel gameModeSceneDataModel)
+        {
+            try
+            {
+                m_gameModeSceneDataModel = gameModeSceneDataModel;
+
+                SetupMainMenu();
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE), OnClickBackButton);
+
+            m_mainMenu.AddOption(LocalizedText.MODES_SOLO_ADVENTURES_OPTION, OnClickSoloAdventures);
+            m_mainMenu.AddOption(LocalizedText.SCREEN_GO_BACK, OnClickBackButton);
+
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void OnClickBackButton()
+        {
+            GameModeDisplay.Get().m_backButton.TriggerRelease();
+        }
+
+        private void OnClickSoloAdventures()
+        {
+            var soloAdventuresButton = GetSoloAdventuresButton();
+
+            if (soloAdventuresButton == null)
+            {
+                AccessibilityUtils.LogFatalError(new Exception("Could not find solo adventures button"));
+            }
+
+            GameModeDisplay.Get().SelectMode(soloAdventuresButton);
+            GameModeDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        private GameModeButtonDataModel GetSoloAdventuresButton()
+        {
+            foreach (var button in m_gameModeSceneDataModel.GameModeButtons)
+            {
+                if (button.GameModeRecordId == 6)
+                {
+                    return button;
+                }
+            }
+
+            return null;
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                default:
+                    break;
+            }
+
+            return "";
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu.StartReading();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
new file mode 100644
index 0000000..622cc91
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
@@ -0,0 +1,2257 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleGameplay : AccessibleScreen
+    {
+        private enum AccessibleGamePhase
+        {
+            WAITING_FOR_GAME_TO_START,
+            MULLIGAN,
+            WAITING_FOR_OPPONENT_MULLIGAN,
+            PLAYING,
+            GAME_OVER
+        }
+
+        private enum AccessibleGameState
+        {
+            UNKNOWN,
+            WAITING,
+            OPPONENT_TURN,
+            MAIN_OPTION_MODE,
+            SUB_OPTION_MODE,
+            TARGET_MODE,
+            CHOICE_MODE,
+            SUMMONING_MINION,
+            PLAYING_CARD,
+            TRADING_CARD,
+            CONFIRMING_END_TURN,
+            BROWSING_HISTORY,
+            ALL_MINIONS_TO_FACE
+        }
+
+        private static AccessibleGameplay s_instance = new AccessibleGameplay();
+
+        internal static AccessibleGameplay Get()
+        {
+            return s_instance;
+        }
+
+        private AccessibleGamePhase m_curPhase;
+
+        private AccessibleGameState m_curState;
+
+        private AccessibleGameState m_prevState;
+
+        private GameState.ResponseMode m_curResponseMode;
+        private GameState.ResponseMode m_prevResponseMode;
+
+        private Zone m_curZone;
+
+        private AccessibleCard m_cardBeingRead;
+
+        private Card m_heldCard;
+
+        private bool m_playerTurn;
+
+        private bool m_confirmingEndTurn;
+
+        private bool m_sendingAllMinionsToFace;
+        private Card m_curFaceAttacker;
+
+        private float m_nextAction = 0; // Needed to circumvent a lot of frame-related issues that would arise otherwise
+
+        // Choice mode
+        private AccessibleListOfItems<AccessibleCard> m_accessibleChoiceCards;
+
+        // Mulligan
+        private AccessibleListOfItems<AccessibleCard> m_accessibleMulliganCards;
+        private Dictionary<AccessibleCard, bool> m_mulliganMarkedForReplacement;
+        private NormalButton m_mulliganConfirmButton;
+        private bool m_waitingForMulliganReplacementCards;
+
+        private static bool m_justReconnected;
+
+        private bool m_tradingCard;
+        private bool m_tradingCardWaitingForHold; // Used to prevent "Summon?" or "Play?" when a card is traded straight from hand but we still need to wait for it to be held
+
+        public void OnTurnStart()
+        {
+            try
+            {
+                AccessiblePowerTaskListDescriber.OnTurnStart();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnCoinResult(bool friendlyPlayerGoesFirst)
+        {
+            if (friendlyPlayerGoesFirst)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOU_GO_FIRST));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_GOES_FIRST));
+            }
+        }
+
+        public void OnStartingHand(List<Card> cards)
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_YOU_START_WITH_N_CARDS, cards.Count));
+        }
+
+        public void EndMulligan()
+        {
+            try
+            {
+                if (m_accessibleMulliganCards != null)
+                {
+                    var originalCards = new HashSet<Card>(m_accessibleMulliganCards.Count);
+                    m_accessibleMulliganCards.Items.ForEach(c => originalCards.Add(c.GetCard()));
+                    var cardsAfterMulligan = GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCards();
+                    var newCards = new List<Card>();
+                    var droppedCards = new List<Card>();
+
+                    foreach (var card in originalCards)
+                    {
+                        if (!cardsAfterMulligan.Contains(card))
+                        {
+                            droppedCards.Add(card);
+                        }
+                    }
+
+                    foreach (var card in cardsAfterMulligan)
+                    {
+                        if (!originalCards.Contains(card) && !IsCoinCard(card.GetEntity()))
+                        {
+                            newCards.Add(card);
+                        }
+                    }
+
+                    if (droppedCards.Count > 0)
+                    {
+                        var droppedNames = AccessibleSpeechUtils.GetNames(droppedCards);
+                        var newNames = AccessibleSpeechUtils.GetNames(newCards);
+
+                        AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARDS, newNames));
+                    }
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            m_accessibleMulliganCards = null;
+            m_waitingForMulliganReplacementCards = false;
+
+            OnGameStart();
+        }
+
+        private bool IsCoinCard(Entity entity)
+        {
+            return entity.GetCardId() == CoinManager.Get()?.GetFavoriteCoinCardId();
+        }
+
+        public void OnMulliganCardsDealt(List<Card> cards)
+        {
+        }
+
+        public void OnGameplayScreenStart()
+        {
+            Reset();
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        private void Reset()
+        {
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            m_curState = AccessibleGameState.UNKNOWN;
+            m_prevState = AccessibleGameState.UNKNOWN;
+            m_curResponseMode = GameState.ResponseMode.NONE;
+            m_prevResponseMode = GameState.ResponseMode.NONE;
+            m_curZone = null;
+            m_cardBeingRead = null;
+            m_heldCard = null;
+            m_playerTurn = false;
+            m_confirmingEndTurn = false;
+            m_sendingAllMinionsToFace = false;
+            m_curFaceAttacker = null;
+            m_nextAction = 0;
+            m_accessibleChoiceCards = null;
+            m_zoneSelectedListeners.Clear();
+            m_cardSelectedListeners.Clear();
+            m_summoningMinionListeners.Clear();
+            m_stopHidingMouse = false;
+            m_waitingForMulliganReplacementCards = false;
+            m_tradingCard = false;
+            m_tradingCardWaitingForHold = false;
+            AccessibleHistoryMgr.Get().Reset();
+        }
+
+        public void OnCoinCard()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOU_GET_THE_COIN));
+        }
+
+        public void WaitingForOpponentToFinishMulligan()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_WAITING_FOR_OPPONENT));
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN;
+        }
+
+        public void OnDrawCard(Card card)
+        {
+        }
+
+        private void SetCardBeingRead(Card card, bool forceZoneRead)
+        {
+            m_cardBeingRead = new AccessibleCard(this, card);
+            var prevZone = m_curZone;
+            m_curZone = card.GetZone();
+            ReadZoneChangeIfNecessary(card, prevZone, m_curZone, forceZoneRead);
+        }
+
+        private void ReadZoneChangeIfNecessary(Card card, Zone fromZone, Zone toZone, bool forceZoneRead)
+        {
+            if (fromZone == toZone && !forceZoneRead)
+            {
+                return;
+            }
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            if (card.GetEntity() == player.GetHeroPower())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO_POWER));
+            }
+            else if (card.GetEntity() == opponent.GetHeroPower())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HERO_POWER));
+            }
+            else if (card == player.GetWeaponCard())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_WEAPON));
+            }
+            else if (card == opponent.GetWeaponCard())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_WEAPON));
+            }
+            else if (toZone == player.GetHandZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HAND));
+            }
+            else if (toZone == opponent.GetHandZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HAND)); // Not needed atm
+            }
+            else if (toZone == player.GetBattlefieldZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_MINIONS));
+            }
+            else if (toZone == opponent.GetBattlefieldZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_MINIONS));
+            }
+            else if (toZone == player.GetSecretZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_SECRETS));
+            }
+            else if (toZone == opponent.GetSecretZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_SECRETS)); // Not needed atm
+            }
+        }
+
+        public void HandleInput()
+        {
+            if (GameState.Get() == null || InputManager.Get() == null)
+            {
+                // Game hasn't even started yet
+                return;
+            }
+
+            if (GameState.Get().IsMulliganPhase())
+            {
+                m_curPhase = AccessibleGamePhase.MULLIGAN;
+            }
+            else if (GameState.Get().IsGameOver())
+            {
+                m_curPhase = AccessibleGamePhase.GAME_OVER;
+            }
+            else if (GameState.Get().IsGameCreated())
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+            }
+            else
+            {
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                HandleTooltipReading();
+            }
+
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.PLAYING:
+                    HandleInGameInput();
+                    break;
+                case AccessibleGamePhase.MULLIGAN:
+                    HandleMulliganInput();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private void HandleMulliganInput()
+        {
+            if (m_accessibleMulliganCards == null)
+            {
+                return; // yield
+            }
+
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+            }
+
+            if (AccessibleKey.MULLIGAN_MARK_CARD.IsPressed())
+            {
+                var focusedCard = m_accessibleMulliganCards.GetItemBeingRead();
+                AccessibleInputMgr.MoveMouseTo(focusedCard.GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+                m_mulliganMarkedForReplacement[focusedCard] = !m_mulliganMarkedForReplacement[focusedCard];
+
+                if (m_mulliganMarkedForReplacement[focusedCard])
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_WILL_BE_REPLACED));
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED));
+                }
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_mulliganConfirmButton.TriggerRelease();
+
+                // Prevent flicker while the game starts and new cards are drawn
+                m_waitingForMulliganReplacementCards = true;
+                HideMouse();
+            }
+            else if (!m_waitingForMulliganReplacementCards)
+            {
+                m_accessibleMulliganCards.HandleAccessibleInput();
+                MoveMouseToCard(m_accessibleMulliganCards.GetItemBeingRead().GetCard());
+            }
+        }
+
+        private void HandleInGameInput()
+        {
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GAMEPLAY_YOUR_TURN);
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GAMEPLAY_OPPONENT_TURN);
+                }
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+                AccessiblePowerTaskListDescriber.OnReconnected();
+            }
+
+            UpdateState();
+
+            if (m_curState == AccessibleGameState.ALL_MINIONS_TO_FACE)
+            {
+                HandleAllMinionsToFace();
+                return;
+            }
+            else if (m_curState == AccessibleGameState.TRADING_CARD)
+            {
+                HandleTradingCard();
+                return;
+            }
+
+            try
+            {
+                UpdateMousePosition();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            if (m_curState == AccessibleGameState.CONFIRMING_END_TURN)
+            {
+                if (AccessibleKey.CONFIRM.IsPressedDown() || AccessibleKey.END_TURN.IsPressedDown())
+                {
+                    EndTurn();
+                    return;
+                }
+                else if (Input.anyKeyDown)
+                {
+                    m_confirmingEndTurn = false;
+                }
+            }
+
+            switch(m_curState)
+            {
+                case AccessibleGameState.WAITING:
+                case AccessibleGameState.UNKNOWN:
+                case AccessibleGameState.OPPONENT_TURN:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleZoneInput();
+                    HandleValidOptionsSelectionInput();
+                    HandleZoneSelection();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleMainOptionMode();
+                    HandleEndTurnInput();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    HandleSubOptionMode();
+                    return;
+                case AccessibleGameState.CHOICE_MODE:
+                    HandleChoiceMode();
+                    return;
+                case AccessibleGameState.TARGET_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleTargetMode();
+                    return;
+                case AccessibleGameState.SUMMONING_MINION:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleSummoningMinion();
+                    HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.PLAYING_CARD:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandlePlayingCard();
+                    HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.BROWSING_HISTORY:
+                    HandleHistoryInput();
+                    return;
+                default:
+                    return;
+            }
+        }
+
+        private void HandleTooltipReading()
+        {
+            AccessibilityUtils.ReadTooltip(this);
+        }
+
+        private void HandleAllMinionsToFace()
+        {
+            if (Time.time < m_nextAction)
+            {
+                return;
+            }
+
+            if (m_curFaceAttacker != null)
+            {
+                ClickCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+                m_curFaceAttacker = null;
+                SetNextAction();
+            }
+            else
+            {
+                List<Card> remainingAttackers = GetValidFaceAttackers();
+
+                if (remainingAttackers.Count > 0)
+                {
+                    m_curFaceAttacker = remainingAttackers[0];
+                    ClickCard(m_curFaceAttacker);
+                    SetNextAction();
+                }
+                else
+                {
+                    m_sendingAllMinionsToFace = false;
+                }
+            }
+        }
+
+        private void SetNextAction()
+        {
+            m_nextAction = Time.time + 1.0f;
+        }
+
+        private void ClickCard(Card card)
+        {
+            MoveMouseToCard(card);
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        private void UpdateMousePosition()
+        {
+            if (m_heldCard != null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead != null)
+            {
+                MoveMouseToCard(m_cardBeingRead.GetCard());
+            }
+            else
+            {
+                HideMouse();
+            }
+        }
+
+        private void HideMouse()
+        {
+            if (!m_stopHidingMouse)
+            {
+                AccessibleInputMgr.HideMouse();
+            }
+        }
+
+        private void HandleTradeCardWhenHoldingCardInput()
+        {
+            if (AccessibleKey.TRADE_CARD.IsPressed() && CanTradeCard(m_heldCard))
+            {
+                QueryTradeCard();
+            }
+        }
+
+        private void QueryTradeCard()
+        {
+            m_tradingCard = true;
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_TRADE_CARD));
+        }
+
+        private bool CanTradeCard(Card card)
+        {
+            if (card == null || card.GetZone() != GameState.Get().GetFriendlySidePlayer().GetHandZone())
+            {
+                return false;
+            }
+
+            return card.GetEntity().IsTradeable();
+        }
+
+        private int m_summonPos;
+
+        private void HandleSummoningMinion()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION));
+                    OnSummoningMinion(m_heldCard);
+                }
+
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    m_summonPos = playerMinions.GetLastPos();
+                    QuerySummonPosition(0);
+                }
+
+                HandleSummoningPositionInput();
+
+                if (m_summonPos == playerMinions.GetLastPos())
+                {
+                    MoveMouseToRightOfZone(playerMinions);
+                }
+                else if (m_summonPos == 1)
+                {
+                    MoveMouseToLeftOfZone(playerMinions);
+                }
+                else
+                {
+                    var prevMinion = playerMinions.GetCardAtPos(m_summonPos - 1);
+                    var nextMinion = playerMinions.GetCardAtPos(m_summonPos);
+                    var pos = prevMinion.transform.position + (nextMinion.transform.position - prevMinion.transform.position) / 2;
+                    AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+                }
+            }
+
+            HandleConfirmOrCancel();
+        }
+
+        private void HandleSummoningPositionInput()
+        {
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                QuerySummonPosition(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                QuerySummonPosition(1);
+            }
+        }
+
+        private void QuerySummonPosition(int inc)
+        {
+            var prevSummonPos = m_summonPos;
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var lastPos = playerMinions.GetLastPos();
+
+            m_summonPos += inc;
+
+            if (m_summonPos > lastPos)
+            {
+                m_summonPos = lastPos;
+            }
+            else if (m_summonPos < 1)
+            {
+                m_summonPos = 1;
+            }
+
+            if (inc != 0 && prevSummonPos == m_summonPos)
+            {
+                return;
+            }
+
+            if (m_summonPos == lastPos)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT));
+                OnSummoningMinion(m_heldCard);
+            }
+            else if (m_summonPos == 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT));
+                OnSummoningMinion(m_heldCard);
+            }
+            else
+            {
+                var prevMinion = playerMinions.GetCardAtPos(m_summonPos - 1);
+                var nextMinion = playerMinions.GetCardAtPos(m_summonPos);
+                var prevMinionName = prevMinion.GetEntity().GetName();
+                var nextMinionName = nextMinion.GetEntity().GetName();
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN, prevMinionName, nextMinionName));
+                OnSummoningMinion(m_heldCard);
+            }
+        }
+
+        private void HandlePlayingCard()
+        { 
+            if (AccessibleUnityInput.Get().GetMousePosition().y < AccessibleInputMgr.GetMousePosition(GameState.Get().GetFriendlySidePlayer().GetHeroCard()).y)
+            {
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                HandleTargetMode();
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.PLAYING_CARD && !RequiresTarget(m_heldCard)) // If a target is required, "choose a target" will already indicate we're using it
+                {
+                    QueryPlayCard();
+                }
+
+                HandleConfirmOrCancel();
+            }
+        }
+
+        private void HandleTradingCard()
+        {
+            Collider collider = Board.Get().GetTradeArea();
+            if (collider != null)
+            {
+                var cardBounds = m_heldCard.GetActor().GetMeshRenderer().bounds;
+                Vector3 tradeAreaCenter = collider.bounds.ClosestPoint(m_heldCard.gameObject.transform.position);
+                Vector3 target = tradeAreaCenter;
+                target.x += cardBounds.size.x / 2;
+                AccessibleInputMgr.MoveMouseToWorldPosition(target);
+            }
+
+            HandleConfirmOrCancel();
+        }
+
+        private bool RequiresTarget(Card heldCard)
+        {
+            return GameState.Get().EntityHasTargets(heldCard.GetEntity());
+        }
+
+        private void QueryPlayCard()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_PLAY_CARD));
+        }
+
+        private void HandleConfirmOrCancel(bool targetRequired=false)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (!targetRequired || m_cardBeingRead != null)
+                {
+                    AccessibleInputMgr.ClickLeftMouseButton();
+                }
+            }
+            else if (AccessibleKey.BACK.IsPressed())
+            {
+                CancelOption();
+            }
+        }
+
+        private void HandleEndTurnInput()
+        {
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                return;
+            }
+
+            if (AccessibleKey.FORCE_END_TURN.IsPressedDown())
+            {
+                EndTurn();
+            }
+
+            if (AccessibleKey.END_TURN.IsPressedDown())
+            {
+                if (EndTurnButton.Get().HasNoMorePlays())
+                {
+                    EndTurn();
+                }
+                else
+                {
+                    if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK));
+                    }
+                    else if (PlayerCanStillUseHeroPower())
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER));
+                    }
+                    else
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS));
+                    }
+
+                    StopReadingCard();
+                    m_confirmingEndTurn = true;
+                }
+            }
+        }
+
+        private bool PlayerCanStillUseHeroPower()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var heroPower = player.GetHeroPower();
+
+            if (heroPower == null)
+            {
+                return false;
+            }
+
+            return GameState.Get().HasResponse(heroPower);
+        }
+
+        private void HandleMainOptionMode()
+        {
+            if (AccessibleKey.SEND_ALL_MINIONS_TO_FACE.IsPressed())
+            {
+                SendAllMinionsToFace();
+                return;
+            }
+
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                ClickCard();
+            }
+            else if (AccessibleKey.TRADE_CARD.IsPressed() && m_cardBeingRead != null && CanTradeCard(m_cardBeingRead.GetCard()))
+            {
+                QueryTradeCard();
+                ClickCard(true);
+            }
+        }
+
+        private void SendAllMinionsToFace()
+        {
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_NO_MINIONS));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeAttacked())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeTargetedByOpponents())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED));
+                return;
+            }
+
+            List<Card> validAttackers = GetValidFaceAttackers();
+
+            if (validAttackers.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS));
+            }
+            else
+            {
+                m_sendingAllMinionsToFace = true;
+            }
+        }
+
+        public void OnReconnected()
+        {
+            AccessibilityMgr.InterruptTexts();
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_RECONNECTED);
+
+            m_justReconnected = true;
+        }
+
+        private List<Card> GetValidFaceAttackers()
+        {
+            List<Card> ret = new List<Card>();
+            List<Entity> faceTargetters = GetOptionsWithTarget(GameState.Get().GetOpposingSidePlayer().GetHero());
+
+            foreach (var entity in faceTargetters)
+            {
+                if (entity.GetCard()?.GetZone() == GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone())
+                {
+                    ret.Add(entity.GetCard());
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Entity> GetOptionsWithTarget(Entity target)
+        {
+            List<Entity> ret = new List<Entity>();
+            Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+
+            if (optionsPacket == null) {
+                return ret;
+            }
+
+            for (int i = 0; i < optionsPacket.List.Count; i++)
+            {
+                Network.Options.Option option = optionsPacket.List[i];
+                if (option.Type == Network.Options.Option.OptionType.POWER)
+                {
+                    if (option.Main.IsValidTarget(target.GetEntityId()))
+                    {
+                        ret.Add(GameState.Get().GetEntity(option.Main.ID));
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private void EndTurn()
+        {
+            InputManager.Get().DoEndTurnButton();
+            StopReadingCard();
+        }
+
+        private void HandleSubOptionMode()
+        {
+            HandleChoiceMode();
+        }
+
+        private void HandleChoiceMode()
+        {
+            if (m_accessibleChoiceCards == null || !m_accessibleChoiceCards.IsReading())
+            {
+                return; // yield
+            }
+
+            try
+            {
+                m_cardBeingRead = m_accessibleChoiceCards.GetItemBeingRead();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                AccessibleInputMgr.MoveMouseTo(m_cardBeingRead.GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+            }
+            else
+            {
+                m_accessibleChoiceCards.HandleAccessibleInput();
+            }
+        }
+
+        private void HandleTargetMode()
+        {
+            //if (m_prevState != AccessibleGameState.TARGET_MODE) // Was broken due to play
+            if (m_prevResponseMode != m_curResponseMode)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_TARGET));
+
+                if (m_cardBeingRead != null && m_cardBeingRead.GetCard().GetZone() == GameState.Get().GetFriendlySidePlayer().GetHandZone())
+                {
+                    StopReadingCard(false);
+                }
+            }
+
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection(true);
+
+            HandleConfirmOrCancel(true);
+        }
+
+        private void UpdateState()
+        {
+            try
+            {
+                UpdateCardBeingReadState();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            m_heldCard = InputManager.Get().GetHeldCard();
+            m_playerTurn = GameState.Get().IsFriendlySidePlayerTurn();
+
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                m_confirmingEndTurn = false;
+            }
+
+            if (m_prevState != m_curState && (m_prevState == AccessibleGameState.CHOICE_MODE || m_prevState == AccessibleGameState.SUB_OPTION_MODE))
+            {
+                // Potential race condition when multiple choices happen in a game
+                m_accessibleChoiceCards = null;
+            }
+
+            if (m_heldCard == null)
+            {
+                m_tradingCard = false;
+            }
+            else if (m_tradingCardWaitingForHold && CanTradeCard(m_heldCard))
+            {
+                // Additional check via CanTradeCard to prevent potential race conditions around turns ending in-between trades/selections
+                m_tradingCardWaitingForHold = false;
+                m_tradingCard = true;
+            }
+
+            m_prevState = m_curState;
+            m_prevResponseMode = m_curResponseMode;
+            m_curResponseMode = GameState.Get().GetResponseMode();
+
+            // Proper states
+            if (!m_playerTurn)
+            {
+                m_curState = AccessibleGameState.OPPONENT_TURN;
+            } 
+            else if (m_sendingAllMinionsToFace)
+            {
+                m_curState = AccessibleGameState.ALL_MINIONS_TO_FACE;
+            }
+            else if (m_tradingCard)
+            {
+                m_curState = AccessibleGameState.TRADING_CARD;
+            }
+            else if (m_confirmingEndTurn)
+            {
+                m_curState = AccessibleGameState.CONFIRMING_END_TURN;
+            }
+            else if (AccessibleHistoryMgr.Get().IsReadingHistory())
+            {
+                m_curState = AccessibleGameState.BROWSING_HISTORY;
+            }
+            else if (m_heldCard != null)
+            {
+                if (m_heldCard.GetEntity().IsMinion())
+                {
+                    m_curState = AccessibleGameState.SUMMONING_MINION;
+                }
+                else if (GameState.Get().IsInMainOptionMode())
+                {
+                    m_curState = AccessibleGameState.PLAYING_CARD;
+                }
+            }
+            else if (GameState.Get().IsInMainOptionMode())
+            {
+                m_curState = AccessibleGameState.MAIN_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                m_curState = AccessibleGameState.SUB_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                m_curState = AccessibleGameState.CHOICE_MODE;
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                m_curState = AccessibleGameState.TARGET_MODE;
+            } 
+            else
+            {
+                // Normally happens in between turns (i.e. after button press but before response) due to network time
+                m_curState = AccessibleGameState.UNKNOWN;
+            }
+
+            if (m_curState != AccessibleGameState.BROWSING_HISTORY)
+            {
+                // Reset history in case turn ends while we're reading history or something
+                AccessibleHistoryMgr.Get().StopReadingHistory();
+            }
+        }
+
+        private void UpdateCardBeingReadState()
+        {
+            if (m_cardBeingRead == null || m_curZone == null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead.GetCard().GetZone() != m_curZone)
+            {
+                StopReadingCard();
+            }
+        }
+
+        private void StopReadingCard(bool hideMouse=true)
+        {
+            m_cardBeingRead = null;
+            m_curZone = null;
+
+            if (hideMouse)
+            {
+                HideMouse();
+            }
+        }
+
+        private void HandleZoneSelection(bool minionsAndHeroesOnly = false)
+        {
+            if (AccessibleKey.SEE_PLAYER_HAND.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerHand();
+            }
+            else if (AccessibleKey.SEE_PLAYER_SECRETS.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerSecrets();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_SECRETS.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeeOpponentSecrets();
+            }
+            else if (AccessibleKey.SEE_PLAYER_MINIONS.IsPressed())
+            {
+                SeePlayerMinions();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MINIONS.IsPressed())
+            {
+                SeeOpponentMinions();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HERO.IsPressed())
+            {
+                SeeOpponentHero();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HERO.IsPressed())
+            {
+                SeePlayerHero();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HERO_POWER.IsPressed())
+            {
+                SeePlayerHeroPower();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HERO_POWER.IsPressed())
+            {
+                SeeOpponentHeroPower();
+            }
+            else if (AccessibleKey.SEE_PLAYER_WEAPON.IsPressed())
+            {
+                SeePlayerWeapon();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_WEAPON.IsPressed())
+            {
+                SeeOpponentWeapon();
+            }
+        }
+
+        private void HandleHistoryInput()
+        {
+            AccessibleHistoryMgr.Get().HandleAccessibleInput();
+        }
+
+        private void HandleCheckStatusKeys()
+        {
+            if (AccessibleKey.SEE_PLAYER_MANA.IsPressed())
+            {
+                ReadPlayerMana();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MANA.IsPressed())
+            {
+                ReadOpponentMana();
+            }
+            else if (AccessibleKey.SEE_PLAYER_DECK.IsPressed())
+            {
+                ReadPlayerDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_DECK.IsPressed())
+            {
+                ReadOpponentDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HAND.IsPressed())
+            {
+                ReadOpponentHand();
+            }
+        }
+
+        private void HandleCardReadingInput()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            if (AccessibleKey.READ_ORIGINAL_CARD_STATS.IsPressed() && m_cardBeingRead.GetCard().GetEntity().IsMinion())
+            {
+                var atk = m_cardBeingRead.GetCard().GetEntity().GetEntityDef().GetATK();
+                var hp = m_cardBeingRead.GetCard().GetEntity().GetEntityDef().GetHealth();
+
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp));
+
+                ReadBigCard();
+            }
+            else
+            {
+                m_cardBeingRead.HandleAccessibleInput();
+            }
+        }
+
+        private void ReadBigCard()
+        {
+            var bigCard = BigCard.Get();
+            if (bigCard != null && bigCard.GetCard() != null && bigCard.isActiveAndEnabled)
+            {
+                var enchantments = bigCard.m_enchantmentPool.GetActiveList();
+                foreach (var enchantment in enchantments)
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GLOBAL_ENCHANTMENT);
+                    AccessibilityMgr.Output(this, enchantment.m_HeaderText.Text);
+                    AccessibilityMgr.Output(this, enchantment.m_BodyText.Text);
+                }
+            }
+        }
+
+        private void SeeOpponentMinions()
+        {
+            var opponentMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+
+            if (opponentMinions.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY));
+            }
+            else
+            {
+                SeeZone(opponentMinions);
+            }
+        }
+
+        private void SeePlayerMinions()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerMinions);
+            }
+        }
+
+        private void SeePlayerSecrets()
+        {
+            var playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+
+            if (playerSecrets.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerSecrets);
+            }
+        }
+
+        private void SeeOpponentSecrets()
+        {
+            var opponentSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone();
+
+            if (opponentSecrets.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY));
+            }
+            else
+            {
+                SeeZone(opponentSecrets);
+            }
+        }
+
+
+        private void SeeOpponentHero()
+        {
+            FocusOnCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), false);
+        }
+
+        private void SeePlayerHero()
+        {
+            FocusOnCard(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), false);
+        }
+
+        private void SeePlayerHeroPower()
+        {
+            var heroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY));
+            }
+        }
+
+        private void SeeOpponentHeroPower()
+        {
+            var heroPower = GameState.Get().GetOpposingSidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY));
+            }
+        }
+
+        private void SeePlayerWeapon()
+        {
+            var weapon = GameState.Get().GetFriendlySidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY));
+            }
+        }
+
+        private void SeeOpponentWeapon()
+        {
+            var weapon = GameState.Get().GetOpposingSidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY));
+            }
+        }
+
+        private void ClickCard(bool tradingCard=false)
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            if (tradingCard)
+            {
+                m_tradingCardWaitingForHold = true;
+            }
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        private void ReadPlayerMana()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int availableMana = player.GetNumAvailableResources();
+            int totalMana = player.GetTag(GAME_TAG.RESOURCES);
+
+            if (availableMana != totalMana)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL, availableMana, totalMana));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA, availableMana));
+            }
+        }
+
+        private void ReadOpponentMana()
+        {
+            int totalMana = GameState.Get().GetOpposingSidePlayer().GetTag(GAME_TAG.RESOURCES);
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_MANA, totalMana));
+        }
+
+        private void HandleZoneInput()
+        {
+            if (m_curZone == null)
+            {
+                return;
+            }
+
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                ReadCardInZone(numKeyPressed.Value);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos + 1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos - 1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+            {
+                ReadCardInZone(1);
+            }
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+            {
+                ReadCardInZone(m_curZone.GetCardCount());
+            }
+        }
+
+        private void HandleValidOptionsSelectionInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard();
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard(true);
+            }
+        }
+
+        private void FindNextValidCard(bool reverseDirection = false)
+        {
+            List<Card> candidates = GetCandidateOptions();
+            List<Card> validOptions = GetValidOptions(candidates);
+
+            if (validOptions.Count == 0)
+            {
+                OnNoValidPlays();
+                return;
+            }
+            else if (validOptions.Count == 1 && m_cardBeingRead != null && validOptions[0] == m_cardBeingRead.GetCard())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_NO_MORE_VALID_OPTIONS));
+                return;
+            }
+
+            if (GameState.Get().IsInTargetMode() && m_cardBeingRead?.GetCard() == GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard())
+            {
+                m_cardBeingRead = null;
+            }
+
+            if (m_cardBeingRead == null)
+            {
+                if (reverseDirection)
+                {
+                    FocusOnCard(validOptions[validOptions.Count - 1], false);
+                    return;
+                }
+                else
+                {
+                    FocusOnCard(validOptions[0], false);
+                    return;
+                }
+            }
+
+            int curCardIndex = 0;
+            for (int i = 0; i < candidates.Count; i++)
+            {
+                if (candidates[i] == m_cardBeingRead.GetCard())
+                {
+                    curCardIndex = i;
+                }
+            }
+
+            int inc = reverseDirection ? -1 : 1;
+
+            for (int toRead = candidates.Count - 1, i = curCardIndex + inc; toRead > 0; toRead--, i += inc)
+            {
+                if (i < 0)
+                {
+                    i = candidates.Count - 1;
+                }
+                else if (i >= candidates.Count)
+                {
+                    i = 0;
+                }
+
+                var card = candidates[i];
+
+                if (IsValidOption(card))
+                {
+                    FocusOnCard(card, false);
+                    return;
+                }
+            }
+        }
+
+        private List<Card> GetValidOptions(List<Card> candidates)
+        {
+            var ret = new List<Card>();
+
+            foreach (var card in candidates)
+            {
+                if (IsValidOption(card))
+                {
+                    ret.Add(card);
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Card> GetCandidateOptions()
+        {
+            var cycleFriendlyEntitiesFirst = true;
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                var source = GameState.Get().GetSelectedNetworkOption();
+                var sourceEntity = GameState.Get().GetEntity(source.Main.ID);
+
+                if (CardEffectInterpreter.GetEffect(sourceEntity.GetCardId()) == CardEffectInterpreter.CardEffect.UNFRIENDLY)
+                {
+                    cycleFriendlyEntitiesFirst = false;
+                }
+            }
+
+            var ret = new List<Card>();
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerWeapon = player.GetWeaponCard();
+            var playerHero = player.GetHeroCard();
+            var playerHeroPower = player.GetHeroPowerCard();
+            var opponentWeapon = opponent.GetWeaponCard();
+            var opponentHero = opponent.GetHeroCard();
+            var opponentHeroPower = opponent.GetHeroPowerCard();
+
+            var playerEntities = new List<Card>();
+            var opponentEntities = new List<Card>();
+
+            playerEntities.AddRange(player.GetHandZone().GetCards());
+            if (playerWeapon != null) playerEntities.Add(playerWeapon);
+            if (playerHero != null) playerEntities.Add(playerHero);
+            if (playerHeroPower != null) playerEntities.Add(playerHeroPower);
+            playerEntities.AddRange(player.GetBattlefieldZone().GetCards());
+
+            opponentEntities.AddRange(opponent.GetBattlefieldZone().GetCards());
+            if (opponentHero != null) opponentEntities.Add(opponentHero);
+            if (opponentWeapon != null) opponentEntities.Add(opponentWeapon);
+            if (opponentHeroPower != null) opponentEntities.Add(opponentHeroPower);
+
+            if (cycleFriendlyEntitiesFirst)
+            {
+                ret.AddRange(playerEntities);
+                ret.AddRange(opponentEntities);
+            }
+            else
+            {
+                ret.AddRange(opponentEntities);
+                ret.AddRange(playerEntities);
+            }
+
+
+            return ret;
+        }
+
+        private bool IsValidOption(Card card)
+        {
+            if (card == null)
+            {
+                return false;
+            }
+
+            Entity entity = card.GetEntity();
+
+            if (GameState.Get().IsInMainOptionMode())
+            {
+                return GameState.Get().IsValidOption(entity);
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                return GameState.Get().IsValidSubOption(entity);
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                return GameState.Get().IsChoice(entity);
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                return GameState.Get().IsValidOptionTarget(entity, true);
+            }
+
+            return false;
+        }
+
+        private int GetCardBeingReadPosition()
+        {
+            for (int i = 1; i <= m_curZone.GetCardCount(); i++)
+            {
+                if (m_curZone.GetCardAtPos(i) == m_cardBeingRead.GetCard())
+                {
+                    return i;
+                }
+            }
+
+            return 0;
+        }
+
+        private void ReadCardInZone(int pos)
+        {
+            Card card = m_curZone.GetCardAtPos(pos);
+
+            if (card != null)
+            {
+                FocusOnCard(card, false);
+            }
+        }
+
+        private void FocusOnCard(Card card, bool forceZoneRead)
+        {
+            SetCardBeingRead(card, forceZoneRead);
+
+            var speech = m_cardBeingRead.GetLine(0);
+
+            var zonePos = card.GetZone().FindCardPos(card); // card.GetZonePosition() isn't trustworthy. Wasn't working for secrets
+
+            if (ShouldReadCardAsList(card))
+            {
+                AccessibilityMgr.Output(this, AccessibleSpeech.MENU_OPTION(speech, zonePos, card.GetZone().GetCardCount()));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, speech);
+            }
+            MoveMouseToCard(card);
+            OnCardSelected(card, m_cardBeingRead);
+        }
+
+        private bool ShouldReadCardAsList(Card card)
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var cardZone = card.GetZone();
+
+            return cardZone == player.GetHandZone() ||
+                cardZone == opponent.GetHandZone() ||
+                cardZone == player.GetBattlefieldZone() ||
+                cardZone == opponent.GetBattlefieldZone() ||
+                cardZone == player.GetSecretZone() ||
+                cardZone == opponent.GetSecretZone();
+        }
+
+        private void MoveMouseToCard(Card card)
+        {
+            if (card.GetZone()?.GetType() == typeof(ZoneHand))
+            {
+                if (!card.IsMousedOver())
+                {
+                    AccessibleInputMgr.MoveMouseTo(card.GetActor().m_manaObject.transform);
+                }
+            }
+            else
+            {
+                AccessibleInputMgr.MoveMouseTo(card);
+            }
+        }
+
+        private void MoveMouseToZone(Zone zone)
+        {
+            Vector3 zoneCenter = zone.GetComponent<Collider>().bounds.center;
+            AccessibleInputMgr.MoveMouseToWorldPosition(zoneCenter);
+        }
+
+        private void MoveMouseToRightOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x += bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        private void MoveMouseToLeftOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x -= bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        private void CancelOption()
+        {
+            AccessibleInputMgr.ClickRightMouseButton();
+            HideMouse();
+        }
+
+        private void ReadOpponentHand()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetHandZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_HAND, numCards));
+        }
+
+        private void ReadPlayerDeck()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int numCards = player.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_DECK, numCards));
+        }
+
+        private void ReadOpponentDeck()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_DECK, numCards));
+        }
+
+        internal Card GetSelectedCard()
+        {
+            return m_cardBeingRead?.GetCard();
+        }
+
+        private void SeePlayerHand()
+        {
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            if (playerHand.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerHand);
+            }
+        }
+
+        private void SeeZone(Zone zone)
+        {
+            if (zone == null)
+            {
+                return;
+            }
+
+            Card card = zone.GetCardAtPos(1);
+
+            if (card != null) // Race conditions
+            {
+                FocusOnCard(card, true);
+            }
+        }
+
+        private void OnGameStart()
+        {
+            try
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+                m_curState = AccessibleGameState.WAITING;
+                AccessibleHistoryMgr.Get().Reset();
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void OnGameOver(TAG_PLAYSTATE playState, object userData)
+        {
+            m_curPhase = AccessibleGamePhase.GAME_OVER;
+
+            AccessibilityMgr.Output(this, GetGameOverMessage(playState));
+        }
+
+        private string GetGameOverMessage(TAG_PLAYSTATE playState)
+        {
+            switch (playState)
+            {
+                case TAG_PLAYSTATE.WON:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_WON);
+                case TAG_PLAYSTATE.LOST:
+                case TAG_PLAYSTATE.CONCEDED:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_LOST);
+                case TAG_PLAYSTATE.TIED:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_TIED);
+                default:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_GENERIC);
+            }
+        }
+
+        public void OnRevealDrawnOpponentCard(Card card)
+        {
+        }
+
+        public void OnDrawUnknownOpponentCard(Card card)
+        {
+        }
+
+        public void OnCardToDeck(Card card)
+        {
+        }
+
+        public void OnShowBigCard(HistoryCard card)
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug($"Card played: {card.GetEntity().GetName()} / type = {card.m_historyInfoType}");
+
+                if (card.m_historyInfoType == HistoryInfoType.CARD_PLAYED)
+                {
+                    OnCardPlayed(card.OriginTaskList, card.GetEntity());
+                }
+                else if (card.m_historyInfoType == HistoryInfoType.TRIGGER)
+                {
+                    OnCardTriggered(card.OriginTaskList, card.GetEntity());
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void OnCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardTriggered(taskList, card);
+        }
+
+        private void OnCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardPlayed(taskList, card);
+        }
+
+        public void OnChoice(List<Card> cards, Banner choiceBanner, NormalButton confirmChoiceButton)
+        {
+            // Clear up any previous choices
+            m_accessibleChoiceCards = null;
+            StopReadingCard();
+
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(new AccessibleCard(this, c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+
+                AccessibilityMgr.Output(this, choiceBanner.m_headline.Text);
+                m_accessibleChoiceCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubOption(List<Card> cards)
+        {
+            // Clear up any previous choices
+            m_accessibleChoiceCards = null;
+            StopReadingCard();
+
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(new AccessibleCard(this, c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_ONE));
+                m_accessibleChoiceCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnMulliganChoiceStart(List<Card> startingCards, NormalButton mulliganConfirmButton)
+        {
+            try
+            {
+                m_mulliganConfirmButton = mulliganConfirmButton;
+
+                var accessibleCards = new List<AccessibleCard>(startingCards.Count);
+                startingCards.ForEach(c => accessibleCards.Add(new AccessibleCard(this, c)));
+
+                m_accessibleMulliganCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+                m_mulliganMarkedForReplacement = new Dictionary<AccessibleCard, bool>();
+                accessibleCards.ForEach(c => m_mulliganMarkedForReplacement.Add(c, false));
+
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN));
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS));
+                m_accessibleMulliganCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Help
+        public string GetHelp()
+        {
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.WAITING_FOR_GAME_TO_START:
+                    return GetWaitingForGameToStartHelp();
+                case AccessibleGamePhase.MULLIGAN:
+                    return GetMulliganHelp();
+                case AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN:
+                    return GetWaitingForOpponentHelp();
+                case AccessibleGamePhase.PLAYING:
+                    return GetPlayingHelp();
+                case AccessibleGamePhase.GAME_OVER:
+                    return GetGameOverHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetGameOverHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_GENERIC);
+        }
+
+        private string GetPlayingHelp()
+        {
+            switch (m_curState)
+            {
+                case AccessibleGameState.OPPONENT_TURN:
+                    return GetOpponentTurnHelp();
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    return GetMainOptionModeHelp();
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    return GetSubOptionModeHelp();
+                case AccessibleGameState.TARGET_MODE:
+                    return GetTargetModeHelp();
+                case AccessibleGameState.CHOICE_MODE:
+                    return GetChoiceModeHelp();
+                case AccessibleGameState.SUMMONING_MINION:
+                    return GetSummoningMinionHelp();
+                case AccessibleGameState.PLAYING_CARD:
+                    return GetPlayingCardHelp();
+                case AccessibleGameState.CONFIRMING_END_TURN:
+                    return GetConfirmingEndTurnHelp();
+                case AccessibleGameState.BROWSING_HISTORY:
+                    return GetBrowsingHistoryHelp();
+                case AccessibleGameState.TRADING_CARD:
+                    return GetTradingCardHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetWaitingForOpponentHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_WAITING_FOR_OPPONENT);
+        }
+
+        private string GetMulliganHelp()
+        {
+            return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_MULLIGAN_HELP, AccessibleKey.MULLIGAN_MARK_CARD, AccessibleKey.CONFIRM);
+        }
+
+        private string GetWaitingForGameToStartHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START);
+        }
+
+        private string GetBrowsingHistoryHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_READ_HISTORY_HELP);
+        }
+
+        private string GetConfirmingEndTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CONFIRM_END_TURN_HELP);
+        }
+
+        private string GetPlayingCardHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+        }
+
+        private string GetTradingCardHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_2_5);
+        }
+
+        private string GetSummoningMinionHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_SUMMON_MINION_HELP);
+        }
+
+        private string GetChoiceModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        private string GetTargetModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOOSE_TARGET_HELP);
+        }
+
+        private string GetSubOptionModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        private string GetMainOptionModeHelp()
+        {
+            if (m_cardBeingRead != null)
+            {
+                return NarrateMainOptionWhenCardBeingRead();
+            }
+            else
+            {
+                return NarrateMainOption();
+            }
+        }
+
+        private string NarrateMainOption()
+        {
+            var speeches = GetMainOptionSpeeches(false);
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        private List<HSASpeech> GetMainOptionSpeeches(bool hasReadEndTurn, bool readManaFirst=false)
+        {
+            var playerHasValidOptions = PlayerHasValidOptions();
+
+            var speeches = new List<HSASpeech>();
+
+            if (!hasReadEndTurn && !playerHasValidOptions)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+            }
+
+            if (readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_VALID_OPTIONS);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HAND_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetSecretZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_SECRETS_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP);
+            }
+
+            if (GameState.Get().GetOpposingSidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_HERO_HELP);
+
+            if (GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP);
+            }
+
+            // Counts
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_PLAYER_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_HAND_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP);
+            }
+
+            if (!readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_MANA_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_OPEN_HISTORY_LOG_HELP);
+            }
+
+            return speeches;
+        }
+
+        private bool IsPlayingTutorial()
+        {
+            var gameEntity = GameState.Get().GetGameEntity();
+
+            return gameEntity.GetType().IsSubclassOf(typeof(TutorialEntity));
+        }
+
+        private bool PlayerHasValidOptions()
+        {
+            var candidates = GetCandidateOptions();
+            return GetValidOptions(candidates).Count > 0;
+        }
+
+        private string NarrateMainOptionWhenCardBeingRead()
+        {
+            var card = m_cardBeingRead.GetCard();
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            var playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var playerHero = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+            var playerHeroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+
+            var speeches = new List<HSASpeech>();
+
+            var hasReadEndTurn = false;
+
+            if (!PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                hasReadEndTurn = true;
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_HELP);
+
+            if (TooltipPanelManager.Get()?.GetTooltipPanels()?.Count > 0 || TutorialKeywordManager.Get()?.GetPanels()?.Count > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_TOOLTIP_HELP);
+            }
+
+            var readManaFirst = false;
+
+            if (IsValidOption(card))
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+
+                    if (card.GetEntity().IsTradeable())
+                    {
+                        speeches.Add(AccessibleSpeech.GAMEPLAY_TRADE_CARD_HELP);
+                    }
+                }
+                else if (card.GetZone() == playerBattlefield)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_MINION_HELP);
+                }
+                else if (card == playerHero)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_HERO_HELP);
+                }
+                else if (card == playerHeroPower)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_USE_HERO_POWER_HELP);
+                }
+            }
+            else
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    readManaFirst = true;
+                }
+            }
+
+            speeches.AddRange(GetMainOptionSpeeches(hasReadEndTurn, readManaFirst));
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        private string GetOpponentTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_OPPONENT_TURN_VOICE);
+        }
+
+        private string GetOrNarrateHelpSpeech(HSASpeech speech)
+        {
+            if (IsPlayingTutorial())
+            {
+                AccessibilityMgr.NarrateHelp(speech);
+                return "";
+            }
+            else
+            {
+                return speech.GetLocalizedText();
+            }
+        }
+
+        private string GetOrNarrateHelpSpeeches(List<HSASpeech> speeches)
+        {
+            if (IsPlayingTutorial())
+            {
+                AccessibilityMgr.NarrateHelp(speeches.ToArray());
+                return "";
+            }
+            else
+            {
+                var lines = new List<string>(speeches.Count);
+                speeches.ForEach(s => lines.Add(s.GetLocalizedText()));
+
+                return AccessibleSpeechUtils.CombineLines(lines);
+            }
+        }
+
+        #endregion Help
+
+        public void OnGainedFocus()
+        {
+            // TODO: Think about this but we probably don't want to say anything given that no one will forget they're playing a game
+        }
+
+        #region Tutorial stuff
+        private Dictionary<Zone, Action> m_zoneSelectedListeners = new Dictionary<Zone, Action>();
+        private Dictionary<Card, Action<AccessibleCard>> m_cardSelectedListeners = new Dictionary<Card, Action<AccessibleCard>>();
+        private Dictionary<Card, Action> m_summoningMinionListeners = new Dictionary<Card, Action>();
+
+        private void OnZoneSelected(Zone zone)
+        {
+            if (m_zoneSelectedListeners.ContainsKey(zone))
+            {
+                m_zoneSelectedListeners[zone]();
+                m_zoneSelectedListeners.Remove(zone);
+            }
+        }
+
+        private void OnCardSelected(Card card, AccessibleCard accessibleCard)
+        {
+            OnZoneSelected(card.GetZone());
+
+            if (m_cardSelectedListeners.ContainsKey(card))
+            {
+                m_cardSelectedListeners[card](accessibleCard);
+                m_cardSelectedListeners.Remove(card);
+            }
+        }
+
+        private void OnSummoningMinion(Card card)
+        {
+            if (m_summoningMinionListeners.ContainsKey(card))
+            {
+                m_summoningMinionListeners[card]();
+                m_summoningMinionListeners.Remove(card);
+            }
+        }
+
+        internal void RegisterZoneSelectedListener(Zone zone, Action action)
+        {
+            m_zoneSelectedListeners[zone] = action;
+        }
+
+        internal void RegisterCardSelectedListener(Card card, Action<AccessibleCard> action)
+        {
+            m_cardSelectedListeners[card] = action;
+        }
+
+        internal void RegisterSummoningCardListener(Card card, Action action)
+        {
+            m_summoningMinionListeners[card] = action;
+        }
+
+        private Action m_noValidPlaysListener;
+
+        internal void RegisterNoValidPlaysListener(Action action)
+        {
+            m_noValidPlaysListener = action;
+        }
+
+        private void OnNoValidPlays()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_NO_VALID_PLAYS));
+            StopReadingCard();
+
+            if (m_noValidPlaysListener != null)
+            {
+                m_noValidPlaysListener();
+                m_noValidPlaysListener = null;
+            }
+        }
+
+
+        private bool m_stopHidingMouse;
+
+        // Useful for e.g. pack opening in the tutorial
+        internal void StopHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+
+        internal void StartHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
new file mode 100644
index 0000000..3291f55
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
@@ -0,0 +1,62 @@
+﻿using System;
+using System.Net;
+
+namespace Accessibility
+{
+    static class AccessibleHearthstoneApplication
+    {
+        internal static void OnLoading()
+        {
+            AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_LOADING_GAME));
+
+            Log.Accessibility.Print($"Hearthstone version: {HearthstoneAccessConstants.HEARTHSTONE_VERSION}");
+            Log.Accessibility.Print($"Hearthstone Access version: {HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION}");
+
+            if (HearthstoneAccessUpdateRequired())
+            {
+                AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE));
+            }
+        }
+
+        internal static void OnClosing()
+        {
+            AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_CLOSING_GAME));
+        }
+
+        private static bool HearthstoneAccessUpdateRequired()
+        {
+            try
+            {
+                var fileName = "hsa-version";
+                var hsaRepoUrl = HearthstoneAccessConstants.GetHearthstoneAccessRepoUrl();
+                var url = $"{hsaRepoUrl}/{HearthstoneAccessConstants.HEARTHSTONE_VERSION}/{fileName}";
+
+                ServicePointManager.Expect100Continue = true;
+                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;
+
+                using (WebClient wc = new WebClient())
+                {
+                    var githubToken = HearthstoneAccessConstants.GetGithubToken();
+                    if (githubToken != null)
+                    {
+                        // Dev only
+                        wc.Headers.Add("Authorization", $"token {githubToken}");
+                    }
+
+                    wc.Headers.Add(HttpRequestHeader.UserAgent, "HSA");
+
+                    var hsaVersion = wc.DownloadString(url);
+
+                    return !hsaVersion.Equals(HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION);
+                }
+            }
+            catch (Exception e)
+            {
+                // Not really fatal since we'll just keep going but let's log it as such in case someone runs into issues
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs
new file mode 100644
index 0000000..2709a4d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs
@@ -0,0 +1,67 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleHeroPickerButton : AccessibleItem
+    {
+        private readonly HeroPickerButton m_button;
+
+        private bool m_inCreateDeckMode;
+
+        internal AccessibleHeroPickerButton(AccessibleComponent parent, HeroPickerButton button, bool inCreateDeckMode=false) : base(parent)
+        {
+            m_button = button;
+            m_inCreateDeckMode = inCreateDeckMode;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_inCreateDeckMode)
+            {
+                return GetLinesForCreateDeckMode();
+            }
+            else
+            {
+                return GetLinesForAdventureMode();
+            }
+        }
+
+        private List<string> GetLinesForCreateDeckMode()
+        {
+            var ret = new List<string>();
+
+            var heroClass = GameStrings.GetClassName(m_button.GetEntityDef().GetClass());
+
+            if (heroClass != null && heroClass.Length > 0)
+            {
+                ret.Add(heroClass);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForAdventureMode()
+        {
+            var ret = new List<string>();
+
+            var heroName = m_button.GetEntityDef()?.GetName();
+
+            if (heroName != null && heroName.Length > 0)
+            {
+                ret.Add(heroName);
+            }
+
+            if (m_button.m_crown.activeInHierarchy)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE));
+            }
+
+            return ret;
+        }
+
+        internal HeroPickerButton GetHeroPickerButton()
+        {
+            return m_button;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
new file mode 100644
index 0000000..ed5a085
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
@@ -0,0 +1,126 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleHistoryMgr
+    {
+        private List<string> m_entries = new List<string>();
+
+        private int m_entryBeingReadIndex;
+
+        private bool m_readingHistory;
+
+        private static AccessibleHistoryMgr s_instance;
+
+        internal static AccessibleHistoryMgr Get()
+        {
+            if (s_instance == null)
+            {
+                s_instance = new AccessibleHistoryMgr();
+            }
+
+            return s_instance;
+        }
+
+        internal void AddEntry(string entry)
+        {
+            if (entry == null || entry.Length == 0)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"HIST add entry: {entry}");
+            m_entries.Add(entry);
+        }
+
+        internal void Reset()
+        {
+            AccessibilityUtils.LogDebug("HIST Reset");
+            m_entries.Clear();
+            m_entryBeingReadIndex = -1;
+            m_readingHistory = false;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.SEE_HISTORY.IsPressed() && !m_readingHistory)
+            {
+                StartReadingHistory();
+                return true;
+            }
+            else if (AccessibleKey.BACK.IsPressed() && m_readingHistory)
+            {
+                StopReadingHistory();
+                return true;
+            }
+            else if (m_readingHistory && AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex + 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex - 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadToEnd();
+            }
+
+            return false;
+        }
+
+        private void ReadToEnd()
+        {
+            for (int i = m_entryBeingReadIndex; i < m_entries.Count; i++)
+            {
+                ReadEntry(i);
+            }
+        }
+
+        private void StartReadingHistory()
+        {
+            if (m_entries.Count == 0)
+            {
+                AccessibilityMgr.Output(AccessibleGameplay.Get(),LocalizationUtils.Get(LocalizationKey.GAMEPLAY_HISTORY_LOG_EMPTY));
+            }
+            else
+            {
+                m_readingHistory = true;
+                ReadEntry(m_entries.Count - 1);
+            }
+        }
+
+        private void ReadEntry(int index)
+        {
+            if (index < 0 || index >= m_entries.Count)
+            {
+                return;
+            }
+
+            m_entryBeingReadIndex = index;
+
+            var curEntry = m_entries[m_entryBeingReadIndex];
+            AccessibilityMgr.Output(AccessibleGameplay.Get(), LocalizationUtils.Format(LocalizationKey.GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT, m_entryBeingReadIndex + 1, m_entries.Count, curEntry));
+        }
+
+        internal bool IsReadingHistory()
+        {
+            return m_readingHistory;
+        }
+
+        internal void StopReadingHistory()
+        {
+            if (m_readingHistory)
+            {
+                AccessibilityMgr.Output(AccessibleGameplay.Get(),LocalizationUtils.Get(LocalizationKey.GAMEPLAY_HISTORY_LOG_CLOSE));
+                m_entryBeingReadIndex = -1;
+                m_readingHistory = false;
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs
new file mode 100644
index 0000000..5f92ec0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs
@@ -0,0 +1,181 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class AccessibleHorizontalMenu<T> : AccessibleElement where T : AccessibleItem
+    {
+        private class MenuOption
+        {
+            internal T m_option;
+            internal Action m_onClickAction;
+            internal Action m_onReadAction;
+
+            internal MenuOption(T option, Action onClickAction)
+            {
+                m_option = option;
+                m_onClickAction = onClickAction;
+            }
+
+            internal MenuOption(T option, Action onClickAction, Action onReadAction)
+            {
+                m_option = option;
+                m_onClickAction = onClickAction;
+                m_onReadAction = onReadAction;
+            }
+        }
+
+        private string m_menuName;
+
+        private List<MenuOption> m_options;
+
+        private int m_curOptionIdx;
+
+        private Action m_goBackAction;
+
+        private bool m_isReading;
+
+        public AccessibleHorizontalMenu(AccessibleComponent parent, string menuName, Action goBackAction) : base(parent)
+        {
+            m_menuName = menuName;
+            m_options = new List<MenuOption>();
+            m_goBackAction = goBackAction;
+        }
+
+        public void AddOption(T option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(T option, Action onClickAction, Action onReadAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction, onReadAction));
+        }
+
+        public bool HandleAccessibleInput()
+        {
+            try
+            {
+                if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+                {
+                    return ReadNextOption(1);
+                }
+                else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+                {
+                    return ReadNextOption(-1);
+                }
+                else if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    return SelectOption();
+                }
+                else if (AccessibleKey.BACK.IsPressed())
+                {
+                    return GoBack();
+                }
+                else if (m_isReading)
+                {
+                    m_options[m_curOptionIdx].m_option.HandleAccessibleInput();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+
+        private bool ReadNextOption(int inc)
+        {
+            int nextOptionIdx = m_curOptionIdx + inc;
+
+            if (nextOptionIdx < 0 || nextOptionIdx >= m_options.Count)
+            {
+                return false;
+            }
+
+            m_curOptionIdx = nextOptionIdx;
+            var curOption = m_options[m_curOptionIdx];
+            curOption.m_option.Reset();
+
+            var firstLine = curOption.m_option.GetLine(0);
+            var speech = AccessibleSpeech.MENU_OPTION(firstLine, m_curOptionIdx + 1, m_options.Count);
+            Output(speech);
+
+            if (curOption.m_onReadAction != null)
+            {
+                curOption.m_onReadAction();
+            }
+
+            return true;
+        }
+
+        private bool SelectOption()
+        {
+            if (!m_isReading || m_options.Count == 0)
+            {
+                return false;
+            }
+
+            m_options[m_curOptionIdx].m_onClickAction();
+
+            return true;
+        }
+
+        private bool GoBack()
+        {
+            if (m_goBackAction == null) {
+                return false;
+            }
+
+            m_goBackAction();
+
+            return true;
+        }
+
+        public void StartReading()
+        {
+            Output(m_menuName);
+
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public void SetIndex(int index)
+        {
+            m_curOptionIdx = index;
+        }
+
+        public string GetHelp()
+        {
+            if (m_options.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HORIZONTAL_HELP(m_goBackAction != null);
+            }
+        }
+
+        public void ReadCurrentOption()
+        {
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs
new file mode 100644
index 0000000..71140ba
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs
@@ -0,0 +1,109 @@
+﻿using System;
+
+namespace Accessibility
+{
+    class AccessibleHub : AccessibleScreen
+    {
+        private enum State { LOADING, MAIN_MENU };
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_mainMenu;
+
+        private static AccessibleHub s_instance = new AccessibleHub();
+
+        internal static AccessibleHub Get()
+        {
+            return s_instance;
+        }
+
+        public void OnHubOpened()
+        {
+            try
+            {
+                SetupMainMenu();
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizedText.HUB_MAIN_MENU_TITLE, null);
+
+            m_mainMenu.AddOption(LocalizedText.HUB_GAME_MODES_OPTION, OnClickModes);
+            m_mainMenu.AddOption(LocalizedText.HUB_MY_COLLECTION_OPTION, OnClickMyCollection);
+            m_mainMenu.AddOption($"{LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS)} {Box.Get().m_OpenPacksButton.m_count.Text}", OnClickOpenPacks);
+            m_mainMenu.AddOption(LocalizedText.HUB_HELP_OPTION, OnClickHelp);
+            m_mainMenu.AddOption(LocalizedText.GAME_MENU_TITLE, OnClickGameMenu);
+
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void OnClickGameMenu()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_GAME_MENU, AccessibleKey.OPEN_GAME_MENU));
+        }
+
+        private void OnClickHelp()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_HELP, AccessibleKey.HELP, AccessibleKey.TOGGLE_ACCESSIBILITY));
+        }
+
+        private void OnClickModes()
+        {
+            Box.Get().m_GameModesButton.TriggerRelease();
+        }
+
+        private void OnClickMyCollection()
+        {
+            Box.Get().m_CollectionButton.TriggerRelease();
+        }
+
+        private void OnClickOpenPacks()
+        {
+            var openPacksButton = Box.Get().m_OpenPacksButton;
+            if (openPacksButton.m_numPacks < 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_PACK_OPENING_NO_CARD_PACKS));
+            }
+            else
+            {
+                Box.Get().m_OpenPacksButton.TriggerRelease();
+            }
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                default:
+                    break;
+            }
+
+            return "";
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu.StartReading();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
new file mode 100644
index 0000000..d48b81a
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
@@ -0,0 +1,2051 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessibleInGameState
+    {
+        private class EntitySpeech : IEquatable<EntitySpeech>
+        {
+            public string SingularSpeech { get; private set; }
+            public string PluralSpeech { get; private set; }
+
+            public EntitySpeech(string speech)
+            {
+                SingularSpeech = PluralSpeech = speech;
+            }
+
+            public EntitySpeech(string singularSpeech, string pluralSpeech)
+            {
+                SingularSpeech = singularSpeech;
+                PluralSpeech = pluralSpeech;
+            }
+
+            public bool Equals(EntitySpeech other)
+            {
+                return SingularSpeech.Equals(other.SingularSpeech) && PluralSpeech.Equals(other.PluralSpeech);
+            }
+
+            public override bool Equals(object obj)
+            {
+                return Equals(obj as EntitySpeech);
+            }
+
+            public override int GetHashCode()
+            {
+                return SingularSpeech.GetHashCode() ^ PluralSpeech.GetHashCode();
+            }
+
+            public override string ToString()
+            {
+                return $"Singular={SingularSpeech} ; Plural={PluralSpeech}";
+            }
+        }
+
+        private class EntityDiff
+        {
+            private Entity m_before, m_after;
+
+            private bool m_died;
+            private bool m_transformed;
+            private bool m_revealed;
+            private int m_healedAmt;
+            private int m_healthDiff;
+            private int m_armorDiff;
+            private int m_atkDiff;
+            private bool m_becameInvulnerable;
+            private bool m_becameImmune;
+
+            private string m_descSingular;
+            private string m_descPlural;
+
+            internal EntityDiff(Entity before, Entity after, AccessibleInGameState gameStateBefore, AccessibleInGameState gameStateAfter)
+            {
+                m_before = before;
+                m_after = after;
+
+                m_died = HasDied(before, after);
+                m_transformed = HasTransformed(before, after);
+                m_revealed = HasRevealed(before, after);
+                m_healedAmt = Math.Abs(Math.Min(after.GetDamage() - before.GetDamage(), 0));
+                m_healthDiff = after.GetHealth() - before.GetHealth();
+                m_armorDiff = after.GetArmor() - before.GetArmor();
+                m_atkDiff = after.GetATK() - before.GetATK();
+                m_becameInvulnerable = before.CanBeAttacked() && !after.CanBeAttacked();
+                m_becameImmune = !before.IsImmune() && after.IsImmune();
+
+                InitDiffDescriptions();
+            }
+
+            private int GetDamageTaken()
+            {
+                if (m_after.IsCharacter())
+                {
+                    var afterDmg = m_after.GetDamage();
+                    var beforeDmg = m_before.GetDamage();
+
+                    var dmgTaken = 0;
+
+                    if (afterDmg > beforeDmg)
+                    {
+                        dmgTaken += afterDmg - beforeDmg;
+                    }
+
+                    return dmgTaken;
+                }
+                else if (m_after.IsWeapon())
+                {
+                    var afterDurability = m_after.GetCurrentDurability();
+                    var beforeDurability = m_before.GetCurrentDurability();
+
+                    if (afterDurability < beforeDurability)
+                    {
+                        return beforeDurability - afterDurability;
+                    }
+                }
+
+                return 0;
+            }
+
+            internal List<string> GetRawDiff()
+            {
+                var ret = new List<string>();
+
+                var beforeTags = m_before.GetTags().GetMap();
+                var afterTags = m_after.GetTags().GetMap();
+
+                foreach (var beforeEntry in beforeTags)
+                {
+                    int tag = beforeEntry.Key;
+                    int beforeVal = beforeEntry.Value;
+
+                    if (!afterTags.ContainsKey(tag))
+                    {
+                        ret.Add($"--- {GetTagName(tag)} ({beforeVal})");
+                    }
+                    else
+                    {
+                        int afterVal = afterTags[tag];
+
+                        if (beforeVal != afterVal)
+                        {
+                            ret.Add($"CCC {GetTagName(tag)}: {beforeVal} -> {afterVal}");
+                        }
+                    }
+                }
+
+                foreach (var afterEntry in afterTags)
+                {
+                    int tag = afterEntry.Key;
+                    int afterVal = afterEntry.Value;
+                    if (!beforeTags.ContainsKey(tag))
+                    {
+                        ret.Add($"+++ {GetTagName(tag)}={afterVal}");
+                    }
+                }
+
+                return ret;
+            }
+
+            private string GetTagName(int tag)
+            {
+                var ret = Enum.GetName(typeof(GAME_TAG), tag);
+
+                if (ret == null)
+                {
+                    ret = tag.ToString();
+                }
+
+                return ret;
+            }
+
+            internal int GetEntityId()
+            {
+                return m_before.GetEntityId();
+            }
+
+            internal bool HasDied()
+            {
+                return m_died;
+            }
+
+            private static bool IsInvalid(Entity entity)
+            {
+                return entity.GetCardType() == TAG_CARDTYPE.INVALID;
+            }
+
+            private static bool IsDead(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsDeadZone(entity.GetZone());
+            }
+
+            private static bool IsAlive(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsAliveZone(entity.GetZone());
+            }
+
+            private static bool IsDeadZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.GRAVEYARD || zone == TAG_ZONE.REMOVEDFROMGAME || zone == TAG_ZONE.SETASIDE;
+            }
+
+            private static bool IsAliveZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.PLAY; // Only PLAY should count as alive as e.g. in-hand cards are not "alive"
+            }
+
+            private static bool IsAbleToLive(Entity entity)
+            {
+                return entity.IsCharacter() || entity.IsWeapon();
+            }
+
+            internal EntitySpeech GetDeathSpeech()
+            {
+                if (m_before.IsWeapon())
+                {
+                    if (m_after.GetController().GetWeaponCard() == null)
+                    {
+                        return new EntitySpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_WEAPON_BROKE));
+                    }
+                    else
+                    {
+                        return new EntitySpeech("");
+                    }
+                }
+                else
+                {
+                    return new EntitySpeech(
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_DIED),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED)
+                    );
+                }
+            }
+
+            private static bool HasDied(Entity before, Entity after)
+            {
+                var died = IsAlive(before) && IsDead(after);
+
+                if (!died)
+                {
+                    return false;
+                }
+
+                if (!before.IsWeapon())
+                {
+                    return true;
+                }
+
+                if (after.GetController().GetWeaponCard() == null)
+                {
+                    s_heroWeaponBroke.Add(after.GetController().GetHero());
+                }
+
+                return true;
+            }
+
+            internal bool HasChanges()
+            {
+                return !m_died && !m_transformed && GetDiffDescription().SingularSpeech.Length > 0;
+            }
+
+            internal Entity GetBeforeEntity()
+            {
+                return m_before;
+            }
+
+            internal Entity GetAfterEntity()
+            {
+                return m_after;
+            }
+
+            internal EntitySpeech GetTransformedSpeech()
+            {
+                return new EntitySpeech(
+                    LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TRANSFORMED, m_after.GetName()),
+                    LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED, m_after.GetName())
+                );
+            }
+
+            internal bool HasTransformed()
+            {
+                return m_transformed;
+            }
+
+            private bool HasTransformed(Entity before, Entity after)
+            {
+                if (m_died || m_before.GetZone() != m_after.GetZone())
+                {
+                    return false;
+                }
+
+                return !HasRevealed(before, after) && !m_after.GetName().Equals(m_before.GetName());
+            }
+
+            private bool HasRevealed(Entity before, Entity after)
+            {
+                return before.GetZone() == TAG_ZONE.SECRET && !MovedZone() && !m_after.GetName().Equals(m_before.GetName());
+            }
+
+            internal bool MovedZone()
+            {
+                return !m_died && (m_before.GetZone() != m_after.GetZone()) || (m_before.GetController() != m_after.GetController());
+            }
+
+            internal EntitySpeech GetDiffDescription()
+            {
+                return new EntitySpeech(m_descSingular, m_descPlural);
+            }
+
+            private void InitDiffDescriptions()
+            {
+                if (m_died || m_transformed || m_revealed || IsHeroCardBeingPlayed())
+                {
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (IsInvalid(m_before) || IsInvalid(m_after))
+                {
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (IsDead(m_before) && IsDead(m_after))
+                {
+                    // Has been dead for a while
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (MovedZone() && (m_after.GetZone() != TAG_ZONE.PLAY))
+                {
+                    // We don't want to call out stat changes in things like return to hand
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                List<string> sDescriptions = new List<string>();
+                List<string> pDescriptions = new List<string>();
+                List<string> sGainedDescriptions = new List<string>();
+                List<string> pGainedDescriptions = new List<string>();
+                List<string> sLostDescriptions = new List<string>();
+                List<string> pLostDescriptions = new List<string>();
+
+                bool gainedAtk = m_atkDiff > 0;
+                bool lostAtk = m_atkDiff < 0;
+                bool gainedHealth = m_healthDiff > 0;
+                bool lostHealth = m_healthDiff < 0;
+                bool gainedArmor = m_armorDiff > 0;
+                bool lostArmor = m_armorDiff < 0;
+
+                int dmgTaken = GetDamageTaken();
+
+                if (lostArmor)
+                {
+                    // Armor first so make sure we say "lost 2 armor and took 3 damage" instead of the other way around with the rest of the stats
+                    var lostArmorDescription = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, Math.Abs(m_armorDiff));
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_LOST_STATS, lostArmorDescription));
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS, lostArmorDescription));
+                }
+
+                if (dmgTaken > 0 && !m_after.IsWeapon())
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE, dmgTaken));
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE, dmgTaken));
+                }
+
+                if (m_healedAmt > 0)
+                {
+                    if (m_after.IsWeapon())
+                    {
+                        // You can never have more than 1 weapon at once
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_DURABILITY, m_healedAmt));
+                    }
+                    else
+                    {
+                        sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH, m_healedAmt));
+                        pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH, m_healedAmt));
+                    }
+                }
+
+                if (m_becameInvulnerable && !PlayingTutorial() && !m_becameImmune) // Heroes and minions become invulnerable randomly in tutorial games for some reason (even though they wouldn't even get hit)
+                {
+                    // Don't call out invulnerable + immune e.g. Divine Bell in Garrosh BoH 7
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE));
+                }
+
+                if (!m_before.IsSilenced() && m_after.IsSilenced())
+                {
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED));
+                }
+                else
+                {
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasTaunt(), m_after.HasTaunt(), LocalizedText.GLOBAL_TAUNT);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasDeathrattle(), m_after.HasDeathrattle(), LocalizedText.GLOBAL_DEATHRATTLE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasBattlecry(), m_after.HasBattlecry(), LocalizedText.GLOBAL_BATTLECRY);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasCharge(), m_after.HasCharge(), LocalizedText.GLOBAL_CHARGE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasLifesteal(), m_after.HasLifesteal(), LocalizedText.GLOBAL_LIFESTEAL);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasRush(), m_after.HasRush(), LocalizedText.GLOBAL_RUSH);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasWindfury(), m_after.HasWindfury(), LocalizedText.GLOBAL_WINDFURY);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasDivineShield(), m_after.HasDivineShield(), LocalizedText.GLOBAL_DIVINE_SHIELD);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.IsFreeze(), m_after.IsFreeze(), LocalizedText.GLOBAL_FREEZE);
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsDormant(), m_after.IsDormant(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT));
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsFrozen(), m_after.IsFrozen(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN));
+
+                    if (ShouldReadImmunityChanges())
+                    {
+                        AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsImmune(), m_after.IsImmune(),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE));
+                    }
+
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsMagnet(), m_after.IsMagnet(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC));
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsPoisonous(), m_after.IsPoisonous(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS));
+                    AddGainedDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsStealthed(), m_after.IsStealthed(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED));
+                }
+
+                // Handle weapons to prevent spam on sheathe/unsheathe/break
+                if (lostAtk && s_heroSheathedWeapon.Contains(m_after))
+                {
+                    lostAtk = false;
+                    s_heroSheathedWeapon.Remove(m_after);
+                    AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to sheathe");
+                }
+                else if (lostAtk && s_heroWeaponBroke.Contains(m_after))
+                {
+                    lostAtk = false;
+                    s_heroWeaponBroke.Remove(m_after);
+                    AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to broken weapon");
+                }
+                else if (gainedAtk && s_heroUnsheathedWeapon.Contains(m_after))
+                {
+                    gainedAtk = false;
+                    s_heroUnsheathedWeapon.Remove(m_after);
+                    AccessibilityUtils.LogDebug("WEP Ignoring gainAtk due to unsheathe");
+                }
+
+                // Normal stats
+                if (gainedAtk)
+                {
+                    sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, m_atkDiff));
+                    pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, m_atkDiff));
+                }
+                else if (lostAtk)
+                {
+                    sLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, Math.Abs(m_atkDiff)));
+                    pLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, Math.Abs(m_atkDiff)));
+                }
+
+                if (gainedHealth)
+                {
+                    sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, m_healthDiff));
+                    pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, m_healthDiff));
+                }
+                else if (lostHealth)
+                {
+                    sLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, Math.Abs(m_healthDiff)));
+                    pLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, Math.Abs(m_healthDiff)));
+                }
+
+                if (gainedArmor)
+                {
+                    sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, m_armorDiff));
+                    pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, m_armorDiff));
+                }
+
+                var sGroupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(sGainedDescriptions);
+                var pGroupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(pGainedDescriptions);
+                var sGroupedLostDescriptions = AccessibleSpeechUtils.HumanizeList(sLostDescriptions);
+                var pGroupedLostDescriptions = AccessibleSpeechUtils.HumanizeList(pLostDescriptions);
+
+                if (sGroupedGainedDescriptions.Length > 0)
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_GAINED_STATS, sGroupedGainedDescriptions));
+                }
+                if (pGroupedGainedDescriptions.Length > 0)
+                {
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS, pGroupedGainedDescriptions));
+                }
+
+                if (sGroupedLostDescriptions.Length > 0)
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_LOST_STATS, sGroupedLostDescriptions));
+                }
+                if (pGroupedLostDescriptions.Length > 0)
+                {
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS, pGroupedLostDescriptions));
+                }
+
+                m_descSingular = AccessibleSpeechUtils.HumanizeList(sDescriptions);
+                m_descPlural = AccessibleSpeechUtils.HumanizeList(pDescriptions);
+            }
+
+            private bool IsHeroCardBeingPlayed()
+            {
+                return m_after.IsHero() && m_before.GetZone() == TAG_ZONE.HAND && m_after.GetZone() == TAG_ZONE.PLAY;
+            }
+
+            private bool ShouldReadImmunityChanges()
+            {
+                if (m_after.IsWeapon())
+                {
+                    // e.g. Gorehowl in BoH Garrosh
+                    return false;
+                }
+
+                return true;
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> singularGainedDescriptions, List<string> pluralGainedDescriptions, List<string> singularLostDescriptions, List<string> pluralLostDescriptions, bool hadBefore, bool hasAfter, string gainedOrLostEffect)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularGainedDescriptions.Add(gainedOrLostEffect);
+                    pluralGainedDescriptions.Add(gainedOrLostEffect);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    singularLostDescriptions.Add(gainedOrLostEffect);
+                    pluralLostDescriptions.Add(gainedOrLostEffect);
+                }
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> singularDescriptions, List<string> pluralDescriptions, bool hadBefore, bool hasAfter, string gainedTextSingular, string gainedTextPlural, string lostTextSingular, string lostTextPlural)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularDescriptions.Add(gainedTextSingular);
+                    pluralDescriptions.Add(gainedTextPlural);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    singularDescriptions.Add(lostTextSingular);
+                    pluralDescriptions.Add(lostTextPlural);
+                }
+            }
+
+            private void AddGainedDescriptionIfExists(List<string> singularDescriptions, List<string> pluralDescriptions, bool hadBefore, bool hasAfter, string gainedTextSingular, string gainedTextPlural)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularDescriptions.Add(gainedTextSingular);
+                    pluralDescriptions.Add(gainedTextPlural);
+                }
+            }
+        }
+
+        private class EntityGroup
+        {
+            private string m_name;
+            private List<Entity> m_entities;
+
+            internal EntityGroup(string name, List<Entity> entities)
+            {
+                m_name = name;
+                m_entities = entities;
+            }
+
+            internal bool IsSubsetOf(List<Entity> entities)
+            {
+                var entitiesMap = new HashSet<Entity>(entities, new EntityComparer());
+
+                foreach (var entity in m_entities)
+                {
+                    if (!entitiesMap.Contains(entity))
+                    {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+
+            internal string GetName()
+            {
+                return m_name;
+            }
+
+            internal List<Entity> GetEntities()
+            {
+                return m_entities;
+            }
+        }
+
+        private PowerTaskList m_powerTaskList;
+
+        private bool m_gameCreated;
+
+        private TAG_STEP m_step;
+
+        private Player m_currentPlayer;
+        private int m_playerAvailableResources;
+        private int m_playerResources;
+        private int m_opponentAvailableResources;
+        private int m_opponentResources;
+        private int m_playerNumTurnsInPlay;
+        private int m_playerSpellpower;
+        private int m_opponentSpellpower;
+
+        private Entity m_playerHero, m_opponentHero;
+        private Entity m_playerHeroPower, m_opponentHeroPower;
+        private Entity m_playerWeapon, m_opponentWeapon;
+
+        private List<Entity> m_playerHand, m_opponentHand;
+        private List<Entity> m_playerDeck, m_opponentDeck;
+        private List<Entity> m_playerGraveyard, m_opponentGraveyard;
+        private List<Entity> m_playerMinions, m_opponentMinions;
+        private List<Entity> m_playerSecrets, m_opponentSecrets;
+
+        private List<Entity> m_entities;
+
+        private AccessibleInGameState(PowerTaskList powerTaskList)
+        {
+            m_powerTaskList = powerTaskList;
+
+            if (!GameState.Get().IsGameCreated())
+            {
+                return;
+            }
+
+            m_gameCreated = true;
+
+            m_step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            m_currentPlayer = GameState.Get().GetCurrentPlayer();
+
+            Player player = GameState.Get().GetFriendlySidePlayer();
+            Player opponent = GameState.Get().GetOpposingSidePlayer();
+
+            m_playerAvailableResources = player.GetNumAvailableResources();
+            m_opponentAvailableResources = opponent.GetNumAvailableResources();
+            m_playerResources = player.GetTag(GAME_TAG.RESOURCES);
+            m_opponentResources = opponent.GetTag(GAME_TAG.RESOURCES);
+            m_playerSpellpower = player.TotalSpellpower();
+            m_opponentSpellpower = opponent.TotalSpellpower();
+            m_playerNumTurnsInPlay = player.GetNumTurnsInPlay();
+
+            m_playerHero = Clone(player.GetHero());
+            m_opponentHero = Clone(opponent.GetHero());
+            m_playerHeroPower = Clone(player.GetHeroPower());
+            m_opponentHeroPower = Clone(opponent.GetHeroPower());
+            m_playerWeapon = Clone(player.GetWeaponCard()?.GetEntity());
+            m_opponentWeapon = Clone(opponent.GetWeaponCard()?.GetEntity());
+
+            m_playerHand = Clone(GetEntitiesFromZone(player.GetHandZone()));
+            m_opponentHand = Clone(GetEntitiesFromZone(opponent.GetHandZone()));
+            m_playerDeck = Clone(GetEntitiesFromZone(player.GetDeckZone()));
+            m_opponentDeck = Clone(GetEntitiesFromZone(opponent.GetDeckZone()));
+            m_playerGraveyard = Clone(GetEntitiesFromZone(player.GetGraveyardZone()));
+            m_opponentGraveyard = Clone(GetEntitiesFromZone(opponent.GetGraveyardZone()));
+            m_playerMinions = Clone(GetEntitiesFromZone(player.GetBattlefieldZone()));
+            m_opponentMinions = Clone(GetEntitiesFromZone(opponent.GetBattlefieldZone()));
+            m_playerSecrets = Clone(GetEntitiesFromZone(player.GetSecretZone()));
+            m_opponentSecrets = Clone(GetEntitiesFromZone(opponent.GetSecretZone()));
+
+            m_entities = new List<Entity>();
+            m_entities.Add(m_playerHero);
+            m_entities.Add(m_opponentHero);
+            if (m_playerHeroPower != null) m_entities.Add(m_playerHeroPower);
+            if (m_opponentHeroPower != null) m_entities.Add(m_opponentHeroPower);
+            if (m_playerWeapon != null) m_entities.Add(m_playerWeapon);
+            if (m_opponentWeapon != null) m_entities.Add(m_opponentWeapon);
+            m_entities.AddRange(m_playerHand);
+            m_entities.AddRange(m_opponentHand);
+            m_entities.AddRange(m_playerDeck);
+            m_entities.AddRange(m_opponentDeck);
+            m_entities.AddRange(m_playerGraveyard);
+            m_entities.AddRange(m_opponentGraveyard);
+            m_entities.AddRange(m_playerMinions);
+            m_entities.AddRange(m_opponentMinions);
+            m_entities.AddRange(m_playerSecrets);
+            m_entities.AddRange(m_opponentSecrets);
+        }
+
+        internal bool HasWeaponEquipped(Entity hero)
+        {
+            return GetWeapon(hero.GetController()) != null;
+        }
+
+        private Entity GetWeapon(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerWeapon;
+            }
+            else
+            {
+                return m_opponentWeapon;
+            }
+        }
+
+        private Entity GetHero(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerHero;
+            }
+            else
+            {
+                return m_opponentHero;
+            }
+        }
+
+        internal static AccessibleInGameState GetCurrentState(PowerTaskList powerTaskList)
+        {
+            return new AccessibleInGameState(powerTaskList);
+        }
+
+        internal Entity GetEntity(int entityId)
+        {
+            foreach (var entity in m_entities)
+            {
+                if (entity.GetEntityId() == entityId)
+                {
+                    return entity;
+                }
+            }
+
+            return null;
+        }
+
+        private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            // Groups
+            var allFriendlyCharacters = ConcatEntities(before.m_playerMinions, before.m_playerHero);
+            var allEnemies = ConcatEntities(before.m_opponentMinions, before.m_opponentHero);
+            var allMinions = ConcatEntities(before.m_playerMinions, before.m_opponentMinions);
+            var everyone = ConcatEntities(allFriendlyCharacters, allEnemies);
+            var bothHeroes = ConcatEntities(before.m_playerHero, before.m_opponentHero);
+
+            var groups = new List<EntityGroup>();
+            if (everyone.Count > 2) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_EVERYONE), everyone));
+            groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_BOTH_HEROES), bothHeroes));
+            if (allMinions.Count > 0 && before.m_playerMinions.Count > 0 && before.m_opponentMinions.Count > 0) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ALL_MINIONS), allMinions));
+            if (allEnemies.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ENEMIES), allEnemies));
+            if (allFriendlyCharacters.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS), allFriendlyCharacters));
+            if (before.m_opponentMinions.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS), before.m_opponentMinions));
+            if (before.m_playerMinions.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS), before.m_playerMinions));
+
+            if (sourceEntity != null)
+            {
+                AddOtherThanSourceEntityGroups(sourceEntity, everyone, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE));
+                AddOtherThanSourceEntityGroups(sourceEntity, allMinions, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS));
+                AddOtherThanSourceEntityGroups(sourceEntity, allEnemies, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES));
+                AddOtherThanSourceEntityGroups(sourceEntity, allFriendlyCharacters, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS));
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_opponentMinions, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS));
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_playerMinions, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS));
+            }
+            AddSameNameEntityGroups(before.m_playerMinions, groups, true);
+            AddSameNameEntityGroups(before.m_opponentMinions, groups, false);
+
+            return GetDiffSpeech(sourceEntity, before, after, groups);
+        }
+
+        private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after, List<EntityGroup> groups)
+        {
+            // Note: sourceEntity is a duplicate but I think it can be null in some cases
+
+            List<Entity> destroyedEntities = GetDestroyedEntities(before, after);
+            List<Entity> newEntities = GetNewEntities(before, after);
+
+            var newEntitySpeeches = GetNewEntitySpeeches(newEntities);
+
+            List<EntityDiff> entityDiffs = CreateEntityDiffs(before, after);
+            List<EntityDiff> affectedEntities = GetAffectedEntities(entityDiffs);
+            List<EntityDiff> movedEntities = GetMovedEntities(sourceEntity, entityDiffs, after.m_entities);
+            List<EntityDiff> transformedEntities = GetTransformedEntities(entityDiffs); // Technically a change but we want to state these first due to enchantments (e.g. polymorph on a stormwind champion)
+            List<EntityDiff> justDiedEntities = GetJustDiedEntities(entityDiffs);
+
+            DebugEntityDiffs(entityDiffs);
+
+            AccessibilityUtils.LogDebug($"DBG justDiedEntities: {GetEntityNamesDbg(justDiedEntities)}");
+
+            var ret = new List<string>();
+
+            // Testing
+            var affectedEntitySpeeches = GetEntitySpeeches(affectedEntities);
+            var transformedEntitySpeeches = GetTransformedEntitySpeeches(transformedEntities);
+            var deadEntitySpeeches = GetDeadEntitySpeeches(justDiedEntities);
+
+            var groupedMovementSpeeches = GetZoneMovementSpeeches(movedEntities, groups);
+
+            AccessibilityUtils.LogDebug("DBG Groups");
+            foreach (var group in groups)
+            {
+                AccessibilityUtils.LogDebug($"DBG {group.GetName()}: {GetEntityNamesDbg(group.GetEntities())}");
+            }
+
+            AccessibilityUtils.LogDebug("DBG Grouping affectedEntities speeches");
+            var groupedSpeeches = GroupSpeeches(affectedEntities, groups, affectedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping transformedEntities speeches");
+            var groupedTransformedSpeeches = GroupSpeeches(transformedEntities, groups, transformedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping justDiedEntities speeches");
+            var groupedDeathSpeeches = GroupSpeeches(justDiedEntities, groups, deadEntitySpeeches, false);
+
+            ret.AddRange(newEntitySpeeches);
+            ret.AddRange(groupedMovementSpeeches);
+            ret.AddRange(groupedTransformedSpeeches);
+            ret.AddRange(groupedDeathSpeeches);
+            ret.AddRange(groupedSpeeches);
+
+            return ret;
+        }
+
+        private static void AddOtherThanSourceEntityGroups(Entity source, List<Entity> entities, List<EntityGroup> groups, string groupName)
+        {
+            var otherEntities = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                if (entity.GetEntityId() != source.GetEntityId())
+                {
+                    otherEntities.Add(entity);
+                }
+            }
+
+            if (otherEntities.Count > 1)
+            {
+                groups.Add(new EntityGroup(groupName, otherEntities));
+            }
+        }
+
+        private static void AddSameNameEntityGroups(List<Entity> entities, List<EntityGroup> groups, bool friendlySide)
+        {
+            Dictionary<string, List<Entity>> entitiesByName = new Dictionary<string, List<Entity>>();
+
+            foreach (var entity in entities)
+            {
+                if (!entitiesByName.ContainsKey(entity.GetName()))
+                {
+                    var newList = new List<Entity>();
+                    newList.Add(entity);
+                    entitiesByName.Add(entity.GetName(), newList);
+                }
+                else
+                {
+                    entitiesByName[entity.GetName()].Add(entity);
+                }
+            }
+
+            foreach (var entry in entitiesByName)
+            {
+                if (entry.Value.Count > 1)
+                {
+                    if (friendlySide)
+                    {
+                        groups.Add(new EntityGroup(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES, entry.Value.Count, entry.Key), entry.Value));
+                    }
+                    else
+                    {
+                        groups.Add(new EntityGroup(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES, entry.Value.Count, entry.Key), entry.Value));
+                    }
+                }
+            }
+        }
+
+        private static List<string> GroupSpeeches(List<EntityDiff> entityDiffs, List<EntityGroup> groups, Dictionary<Entity, EntitySpeech> entitySpeeches, bool useZoneOrder)
+        {
+            var handled = new Dictionary<Entity, bool>(new EntityComparer());
+            var entities = new List<Entity>(entityDiffs.Count);
+
+            entityDiffs.ForEach(e => entities.Add(e.GetBeforeEntity()));
+            entityDiffs.ForEach(e => handled.Add(e.GetBeforeEntity(), false));
+
+            var groupedSpeeches = new Dictionary<string, EntitySpeech>();
+
+            AccessibilityUtils.LogDebug("DBG Grouping speeches");
+            AccessibilityUtils.LogDebug($"DBG entities: {GetEntityNamesDbg(entities)}");
+            AccessibilityUtils.LogDebug($"DBG speeches:");
+            foreach (var entry in entitySpeeches)
+            {
+                AccessibilityUtils.LogDebug($"DBG {entry.Key.GetName()}: {entry.Value}");
+            }
+
+            foreach (var group in groups)
+            {
+                if (group.GetEntities().Count > 1 && group.IsSubsetOf(entities))
+                {
+                    AccessibilityUtils.LogDebug($"DBG Group with > 1 and subset found: {group.GetName()}");
+                    if (!SpeechesAlreadyHandled(group, handled) && AllEntitiesShareSpeech(group.GetEntities(), entitySpeeches))
+                    {
+                        AccessibilityUtils.LogDebug($"DBG Handling group {group.GetName()}");
+                        var speech = entitySpeeches[group.GetEntities()[0]];
+                        groupedSpeeches[group.GetName()] = speech;
+                        MarkHandled(group, handled);
+                    }
+                }
+            }
+
+            var remainingSpeeches = new Dictionary<string, EntitySpeech>();
+
+            var remainingEntities = GetUnhandledEntities(handled);
+            AccessibilityUtils.LogDebug($"DBG remainingEntities: {GetEntityNamesDbg(remainingEntities)}");
+            remainingEntities.ForEach(e =>
+            {
+                if (entitySpeeches.ContainsKey(e))
+                {
+                    // Only add if we have proper changes (e.g. being destroyed does not warrant a speech as it would be covered by death anyways)
+                    if (useZoneOrder)
+                    {
+                        remainingSpeeches.Add(GetFullNameInZone(e), entitySpeeches[e]);
+                    }
+                    else
+                    {
+                        // e.g. Death speeches (since we may have more than one in graveyard)
+                        remainingSpeeches.Add(GetFullNameInList(e, remainingEntities), entitySpeeches[e]);
+                    }
+                }
+            });
+
+            return CombineSpeeches(groupedSpeeches, remainingSpeeches);
+        }
+
+        private static string GetEntityNamesDbg(List<Entity> entities)
+        {
+            var sb = new StringBuilder();
+            sb.Append("[");
+
+            for (int i = 0; i < entities.Count; i++)
+            {
+                if (i != 0)
+                {
+                    sb.Append(", ");
+                }
+
+                sb.Append(entities[i].GetName());
+            }
+
+            sb.Append("]");
+            return sb.ToString();
+        }
+
+        private static string GetEntityNamesDbg(List<EntityDiff> entityDiffs)
+        {
+            var entities = new List<Entity>(entityDiffs.Count);
+
+            foreach (var diff in entityDiffs)
+            {
+                entities.Add(diff.GetAfterEntity());
+            }
+
+            return GetEntityNamesDbg(entities);
+        }
+
+        private static List<string> CombineSpeeches(Dictionary<string, EntitySpeech> groupedSpeeches, Dictionary<string, EntitySpeech> remainingSpeeches)
+        {
+            var ret = new List<string>();
+            var speechToEntityNames = new Dictionary<EntitySpeech, List<string>>();
+
+            foreach (var entry in groupedSpeeches)
+            {
+                if (speechToEntityNames.ContainsKey(entry.Value))
+                {
+                    speechToEntityNames[entry.Value].Add(entry.Key);
+                }
+                else
+                {
+                    speechToEntityNames.Add(entry.Value, new List<string> { entry.Key });
+                }
+            }
+
+            foreach (var entry in remainingSpeeches)
+            {
+                if (speechToEntityNames.ContainsKey(entry.Value))
+                {
+                    speechToEntityNames[entry.Value].Add(entry.Key);
+                }
+                else
+                {
+                    speechToEntityNames.Add(entry.Value, new List<string> { entry.Key });
+                }
+            }
+
+            foreach (var entry in speechToEntityNames)
+            {
+                var speech = entry.Key;
+                var entities = entry.Value;
+
+                string resultingSpeech = speech.SingularSpeech;
+
+                if (entities.Count > 1)
+                {
+                    // Single remaining entities joined with a group or other remaining entities, forming a group
+                    resultingSpeech = speech.PluralSpeech;
+                }
+
+                if (entities.Count == 1 && groupedSpeeches.ContainsKey(entities[0]))
+                {
+                    // Was already grouped in the first place
+                    resultingSpeech = speech.PluralSpeech;
+                }
+
+                var entitiesAsList = AccessibleSpeechUtils.HumanizeList(entities);
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT, entitiesAsList, resultingSpeech));
+            }
+
+            return ret;
+        }
+
+        private static bool AllEntitiesShareSpeech(List<Entity> entities, Dictionary<Entity, EntitySpeech> speeches)
+        {
+            EntitySpeech speech = null;
+
+            foreach (var entity in entities)
+            {
+                if (!speeches.ContainsKey(entity))
+                {
+                    return false;
+                }
+
+                if (speech == null)
+                {
+                    speech = speeches[entity];
+                }
+                else if (!speeches[entity].Equals(speech))
+                {
+                    return false;
+                }
+            }
+
+            return speech.SingularSpeech.Length > 0; // We're not interested if they're not saying anything
+        }
+
+        private static bool SpeechesAlreadyHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                if (handled[entity])
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private static void MarkHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                handled[entity] = true;
+            }
+        }
+
+        private static List<Entity> GetUnhandledEntities(Dictionary<Entity, bool> handled)
+        {
+            var ret = new List<Entity>();
+
+            foreach (var entry in handled)
+            {
+                if (!entry.Value)
+                {
+                    ret.Add(entry.Key);
+                }
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetEntitySpeeches(List<EntityDiff> entities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in entities)
+            {
+                var desc = entity.GetDiffDescription();
+
+                if (desc.SingularSpeech.Length > 0)
+                {
+                    ret[entity.GetAfterEntity()] = desc;
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetNewEntitySpeeches(List<Entity> entities)
+        {
+            var ret = new List<string>();
+            var addedToPlayerHand = new List<string>();
+            var addedToOpponentHand = new List<string>();
+            var addedToPlayerDeck = new List<string>();
+            var addedToOpponentDeck = new List<string>();
+            var addedToPlayerBattlefield = new List<string>();
+            var addedToOpponentBattlefield = new List<string>();
+            var addedToPlayerSecrets = new List<string>();
+            var addedToOpponentSecrets = new List<string>();
+
+            foreach (var entity in entities)
+            {
+                Zone curZone = entity.GetCard().GetZone();
+
+                string cardName = GetCardNameForZoneMovement(entity);
+
+                Zone playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+                Zone opponentHand = GameState.Get().GetOpposingSidePlayer().GetHandZone();
+                Zone playerDeck = GameState.Get().GetFriendlySidePlayer().GetDeckZone();
+                Zone opponentDeck = GameState.Get().GetOpposingSidePlayer().GetDeckZone();
+                Zone playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+                Zone opponentBattlefield = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+                Zone playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+                Zone opponentSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone();
+
+                // Spawned card
+                if (curZone == playerHand)
+                {
+                    addedToPlayerHand.Add(cardName);
+                }
+                else if (curZone == opponentHand)
+                {
+                    addedToOpponentHand.Add(cardName);
+                }
+                else if (curZone == playerDeck)
+                {
+                    addedToPlayerDeck.Add(cardName);
+                }
+                else if (curZone == opponentDeck)
+                {
+                    addedToOpponentDeck.Add(cardName);
+                }
+                else if (curZone == playerBattlefield)
+                {
+                    addedToPlayerBattlefield.Add(cardName);
+                }
+                else if (curZone == opponentBattlefield)
+                {
+                    addedToOpponentBattlefield.Add(cardName);
+                }
+                else if (entity.GetCard() == GameState.Get().GetFriendlySidePlayer().GetWeaponCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON, cardName));
+                }
+                else if (entity.GetCard() == GameState.Get().GetOpposingSidePlayer().GetWeaponCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON, cardName));
+                }
+                else if (curZone == playerSecrets)
+                {
+                    if (entity.IsSecret())
+                    {
+                        addedToPlayerSecrets.Add(cardName);
+                    }
+
+                    // TODO: Handle quests, sidequests and questlines differently
+                }
+                else if (curZone == opponentSecrets)
+                {
+                    if (entity.IsSecret())
+                    {
+                        var className = GameStrings.GetClassName(entity.GetClass());
+                        addedToOpponentSecrets.Add(className);
+                    }
+
+                    // TODO: Handle quests, sidequests and questlines differently
+                }
+                else if (entity == GameState.Get().GetFriendlySidePlayer().GetHeroPower())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED, cardName));
+                }
+                else if (entity == GameState.Get().GetOpposingSidePlayer().GetHeroPower())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED, cardName));
+                }
+            }
+
+            InsertZoneMovements(ret, addedToPlayerHand, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND);
+            InsertZoneMovements(ret, addedToOpponentHand, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND);
+            InsertZoneMovements(ret, addedToPlayerDeck, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK);
+            InsertZoneMovements(ret, addedToOpponentDeck, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK);
+            InsertZoneMovements(ret, addedToPlayerBattlefield, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD);
+            InsertZoneMovements(ret, addedToOpponentBattlefield, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD);
+            InsertOpponentSecretMovements(ret, addedToOpponentSecrets);
+
+            return ret;
+        }
+
+        private static List<string> GetZoneMovementSpeeches(List<EntityDiff> entities, List<EntityGroup> groups)
+        {
+            var ret = new List<string>();
+
+            var drawnPlayerCards = new List<string>();
+            var drawnOpponentCards = new List<string>();
+            var discardedPlayerCards = new List<string>();
+            var discardedOpponentCards = new List<string>();
+            var takenControlByPlayerCards = new List<string>();
+            var takenControlByOpponentCards = new List<string>();
+            var castPlayerSecrets = new List<string>();
+            var castOpponentSecrets = new List<string>();
+
+            var speeches = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerHand = player.GetHandZone();
+            var opponentHand = opponent.GetHandZone();
+            var playerMinions = player.GetBattlefieldZone();
+            var opponentMinions = opponent.GetBattlefieldZone();
+            var playerSecrets = player.GetSecretZone();
+            var opponentSecrets = opponent.GetSecretZone();
+            var playerDeck = player.GetDeckZone();
+            var opponentDeck = opponent.GetDeckZone();
+            var playerGraveyard = player.GetGraveyardZone();
+            var opponentGraveyard = opponent.GetGraveyardZone();
+
+            var zoneNames = new Dictionary<Zone, string>();
+            zoneNames.Add(playerHand, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_HAND));
+            zoneNames.Add(opponentHand, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_HAND));
+            zoneNames.Add(playerMinions, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD));
+            zoneNames.Add(opponentMinions, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD));
+            zoneNames.Add(playerSecrets, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS));
+            zoneNames.Add(opponentSecrets, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS));
+            zoneNames.Add(playerDeck, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_DECK));
+            zoneNames.Add(opponentDeck, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_DECK));
+            zoneNames.Add(playerGraveyard, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD));
+            zoneNames.Add(opponentGraveyard, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD));
+
+            foreach (var entity in entities)
+            {
+                var before = entity.GetBeforeEntity();
+                var after = entity.GetAfterEntity();
+
+                var beforeZoneType = before.GetZone();
+                var afterZoneType = after.GetZone();
+
+                var beforeZone = GetZone(before);
+                var afterZone = GetZone(after);
+
+                // Note: play->graveyard movements are currently covered by EntityDiffs themselves (when checking HasMoved)
+                // Other -> graveyard movements aren't though (e.g. secrets being triggered)
+                if (afterZoneType == TAG_ZONE.GRAVEYARD)
+                {
+                    if (beforeZoneType != TAG_ZONE.PLAY && beforeZoneType != TAG_ZONE.SECRET)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+
+                    continue;
+                }
+
+                // Weapons are edge cases since we don't really know if they were equipped before or not
+                if (beforeZoneType == TAG_ZONE.PLAY && before.GetCardType() == TAG_CARDTYPE.WEAPON && before.GetControllerSide() == Player.Side.FRIENDLY)
+                {
+                    if (before.GetControllerSide() == Player.Side.FRIENDLY && afterZone == playerHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if (before.GetControllerSide() == Player.Side.OPPOSING && afterZone == opponentHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE, afterZone),
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE, afterZone)
+                        );
+                        speeches.Add(after, speech);
+                    }
+
+                    continue;
+                }
+
+                // Fallback zones
+                if (beforeZone == null || afterZone == null)
+                {
+                    if (after.GetZone() == TAG_ZONE.SETASIDE && before.IsHeroPower())
+                    {
+                        // A bit of a weird path but this is how Hero cards seem to be working
+                        var newHeroPower = before.GetController().GetHeroPower();
+
+                        if (newHeroPower != null && newHeroPower.GetEntityId() != before.GetEntityId())
+                        {
+                            var newHeroPowerName = newHeroPower.GetName();
+
+                            if (newHeroPower.IsControlledByFriendlySidePlayer())
+                            {
+                                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED, newHeroPowerName));
+                            }
+                            else
+                            {
+                                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED, newHeroPowerName));
+                            }
+                        }
+                    }
+                    else if (after.GetZone() == TAG_ZONE.SETASIDE)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+                    else
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC)
+                        );
+                        speeches.Add(after, speech);
+                    }
+
+                    continue;
+                }
+
+                // Normal scenarios
+                if (zoneNames.ContainsKey(beforeZone) && zoneNames.ContainsKey(afterZone))
+                {
+                    if (beforeZone == playerDeck && afterZone == playerHand)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+                        drawnPlayerCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentDeck && afterZone == opponentHand)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+                        drawnOpponentCards.Add(cardName);
+                    }
+                    else if ((beforeZone == playerMinions || beforeZone == playerSecrets) && afterZone == playerHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if ((beforeZone == opponentMinions || beforeZone == opponentSecrets) && afterZone == opponentHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if (beforeZone == playerMinions && afterZone == opponentMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByOpponentCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentMinions && afterZone == playerMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByPlayerCards.Add(cardName);
+                    }
+                    else if (afterZone == opponentSecrets)
+                    {
+                        if (after.IsSecret())
+                        {
+                            var className = GameStrings.GetClassName(after.GetClass());
+                            castOpponentSecrets.Add(className);
+                        }
+
+                        // TODO: Handle quests, sidequests and questlines differently
+                    }
+                    else if (afterZone == playerSecrets)
+                    {
+                        if (after.IsSecret())
+                        {
+                            var cardName = GetName(after);
+                            castPlayerSecrets.Add(cardName);
+                        }
+
+                        // TODO: Handle quests, sidequests and questlines differently
+                    }
+                    else
+                    {
+                        var beforeZoneName = zoneNames[beforeZone];
+                        var afterZoneName = zoneNames[afterZone];
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE, beforeZoneName, afterZoneName),
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE, beforeZoneName, afterZoneName)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                }
+                else if (zoneNames.ContainsKey(afterZone))
+                {
+                    var toZoneName = zoneNames[afterZone];
+                    var speech = new EntitySpeech(
+                        LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE, toZoneName),
+                        LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE, toZoneName)
+                    );
+                    speeches.Add(after, speech);
+                }
+                else
+                {
+                    var speech = new EntitySpeech(
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC)
+                    );
+                    speeches.Add(after, speech);
+                }
+            }
+
+            var groupedMovementSpeeches = GroupSpeeches(entities, groups, speeches, false);
+
+            InsertPlayerInducedZoneMovements(ret, drawnPlayerCards, LocalizationKey.GAMEPLAY_PLAYER_DREW_CARDS);
+            InsertPlayerInducedZoneMovements(ret, drawnOpponentCards, LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARDS);
+            InsertPlayerInducedZoneMovements(ret, discardedPlayerCards, LocalizationKey.GAMEPLAY_PLAYER_DISCARDED_CARDS);
+            InsertPlayerInducedZoneMovements(ret, discardedOpponentCards, LocalizationKey.GAMEPLAY_OPPONENT_DISCARDED_CARDS);
+            InsertPlayerInducedZoneMovements(ret, takenControlByPlayerCards, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER);
+            InsertPlayerInducedZoneMovements(ret, takenControlByOpponentCards, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT);
+            InsertPlayerInducedZoneMovements(ret, castPlayerSecrets, LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET);
+            InsertOpponentSecretMovements(ret, castOpponentSecrets);
+
+            ret.AddRange(groupedMovementSpeeches);
+
+            return ret;
+        }
+
+        private static void InsertOpponentSecretMovements(List<string> ret, List<string> castOpponentSecrets)
+        {
+            if (castOpponentSecrets.Count == 1)
+            {
+                InsertZoneMovements(ret, castOpponentSecrets, LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, LocalizationKey.GAMEPLAY_OPPONENT_CAST_N_SECRETS);
+            }
+            else if (castOpponentSecrets.Count > 1)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_N_SECRETS, castOpponentSecrets.Count));
+            }
+        }
+
+        private static Zone GetZone(Entity entity)
+        {
+            var controller = entity.GetController();
+
+            switch(entity.GetZone())
+            {
+                case TAG_ZONE.PLAY:
+                    return controller.GetBattlefieldZone();
+                case TAG_ZONE.DECK:
+                    return controller.GetDeckZone();
+                case TAG_ZONE.HAND:
+                    return controller.GetHandZone();
+                case TAG_ZONE.GRAVEYARD:
+                    return controller.GetGraveyardZone();
+                case TAG_ZONE.SECRET:
+                    return controller.GetSecretZone();
+                default:
+                    return null;
+            }
+        }
+
+        private static void InsertZoneMovements(List<string> ret, List<string> cards, LocalizationKey singularKey, LocalizationKey pluralKey)
+        {
+            if (cards.Count == 0)
+            {
+                return;
+            }
+
+            if (cards.Count == 1)
+            {
+                ret.Add(LocalizationUtils.Format(singularKey, cards[0]));
+            }
+            else
+            {
+                var counts = new Dictionary<string, int>();
+                foreach (var card in cards)
+                {
+                    if (!counts.ContainsKey(card))
+                    {
+                        counts.Add(card, 1);
+                    }
+                    else
+                    {
+                        counts[card]++;
+                    }
+                }
+
+                var cardNames = AccessibleSpeechUtils.HumanizeNames(cards, counts);
+
+                ret.Add(LocalizationUtils.Format(pluralKey, cardNames));
+            }
+        }
+
+        private static void InsertPlayerInducedZoneMovements(List<string> ret, List<string> cards, LocalizationKey key)
+        {
+            if (cards.Count == 0)
+            {
+                return;
+            }
+
+            var counts = new Dictionary<string, int>();
+            foreach (var card in cards)
+            {
+                if (!counts.ContainsKey(card))
+                {
+                    counts.Add(card, 1);
+                }
+                else
+                {
+                    counts[card]++;
+                }
+            }
+
+            var cardNames = AccessibleSpeechUtils.HumanizeNames(cards, counts);
+
+            ret.Add(LocalizationUtils.Format(key, cardNames));
+        }
+
+        private static string GetCardNameForZoneMovement(Entity entity)
+        {
+            if (entity.GetCardType() != TAG_CARDTYPE.INVALID)
+            {
+                return entity.GetName();
+            }
+            else
+            {
+                return LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+            }
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetTransformedEntitySpeeches(List<EntityDiff> transformedEntities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in transformedEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetTransformedSpeech();
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetDeadEntitySpeeches(List<EntityDiff> deadEntities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in deadEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetDeathSpeech();
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> list, Entity entity)
+        {
+            var ret = new List<Entity>(list.Count + 1);
+            ret.AddRange(list);
+            ret.Add(entity);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> l1, List<Entity> l2)
+        {
+            var ret = new List<Entity>(l1.Count + l2.Count);
+            ret.AddRange(l1);
+            ret.AddRange(l2);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(Entity e1, Entity e2)
+        {
+            var ret = new List<Entity>(2);
+            ret.Add(e1);
+            ret.Add(e2);
+            return ret;
+        }
+
+        private static void DebugEntityDiffs(List<EntityDiff> entityDiffs)
+        {
+            AccessibilityUtils.LogDebug("DebugEntityDiffs start");
+            foreach (var diff in entityDiffs)
+            {
+                var rawDiff = diff.GetRawDiff();
+                if (rawDiff.Count > 0)
+                {
+                    AccessibilityUtils.LogDebug($"DBG {diff.GetAfterEntity().GetName()}:");
+                    foreach (var entry in rawDiff)
+                    {
+                        AccessibilityUtils.LogDebug($"DBG {entry}");
+                    }
+                }
+                else
+                {
+                    AccessibilityUtils.LogDebug($"DBG {diff.GetAfterEntity().GetName()} - NO CHANGES");
+                }
+            }
+        }
+
+        internal static string DescribeDiff(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var lines = new List<string>();
+
+            // Handle starting turn when the game has just been created
+            if (before == null && after != null && after.m_gameCreated)
+            {
+                // TODO: describer already has logic for this as well and Hogger is weird. Need to think
+                return null;
+            }
+
+            if (before == null || after == null || !before.m_gameCreated || !after.m_gameCreated)
+            {
+                return null;
+            }
+
+            var sourceEntity = taskList.GetSourceEntity();
+
+            AccessibilityUtils.LogDebug($"DBG Describing diff. sourceEntity={sourceEntity}");
+            AccessibilityUtils.LogDebug(Environment.StackTrace);
+            AccessibilityUtils.LogDebug("DebugDiff done");
+
+            lines.AddRange(GetQuestProgressChanges(before, after));
+
+            lines.AddRange(GetHeroChanges(before, after));
+
+            lines.AddRange(GetSpeechLines(taskList, before, after));
+
+            // Turn stuff. At the end so we describe any pending triggers before this (done when NEXT_STEP = MAIN_START)
+            if (before.m_step != after.m_step && after.m_step == TAG_STEP.MAIN_START && after.m_currentPlayer == GameState.Get().GetFriendlySidePlayer())
+            {
+                // TODO: Doing this in powerlist describer now to see if it makes more sense to sync up with the animation
+                //lines.Add($"You have {after.m_playerAvailableResources} mana");
+            }
+            else if (after.m_step > TAG_STEP.MAIN_START && after.m_step < TAG_STEP.MAIN_END)
+            {
+                lines.AddRange(GetResourceChanges(before, after));
+            }
+
+            lines.AddRange(GetSpellpowerChanges(before, after));
+
+            return CombineLines(lines);
+        }
+
+        private static List<string> GetSpellpowerChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            if (before.m_playerSpellpower < after.m_playerSpellpower)
+            {
+                var amt = after.m_playerSpellpower - before.m_playerSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE, amt));
+            }
+            else if (after.m_playerSpellpower < before.m_playerSpellpower)
+            {
+                var amt = before.m_playerSpellpower - after.m_playerSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE, amt));
+            }
+
+            if (before.m_opponentSpellpower < after.m_opponentSpellpower)
+            {
+                var amt = after.m_opponentSpellpower - before.m_opponentSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE, amt));
+            }
+            else if (after.m_opponentSpellpower < before.m_opponentSpellpower)
+            {
+                var amt = before.m_opponentSpellpower - after.m_opponentSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE, amt));
+            }
+
+            return ret;
+        }
+
+        private static string CombineLines(List<string> lines)
+        {
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (sb.Length > 0)
+                {
+                    sb.Append(". ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetQuestProgressChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            // Note: there can only be 1 progress at once since this is part of a quest trigger
+
+            foreach (var entity in after.m_entities)
+            {
+                if (entity.IsQuest() || entity.IsSideQuest() || entity.IsQuestline())
+                {
+                    var beforeEntity = before.GetEntity(entity.GetEntityId());
+
+                    if (beforeEntity != null)
+                    {
+                        var beforeProgress = AccessibleCardUtils.GetQuestProgressLine(beforeEntity);
+                        var afterProgress = AccessibleCardUtils.GetQuestProgressLine(entity);
+
+                        if (!beforeProgress.Equals(afterProgress))
+                        {
+                            ret.Add(afterProgress);
+                        }
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetHeroChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            AddHeroChangeIfNeeded(ret, before.m_playerHero, after.m_playerHero, true);
+            AddHeroChangeIfNeeded(ret, before.m_opponentHero, after.m_opponentHero, false);
+
+            return ret;
+        }
+
+        private static void AddHeroChangeIfNeeded(List<string> ret, Entity heroBefore, Entity heroAfter, bool isFriendlyHero)
+        {
+            if (heroBefore.GetEntityId() != heroAfter.GetEntityId())
+            {
+                var newHeroName = heroAfter.GetName();
+                var translationKey = isFriendlyHero ? LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED : LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED;
+
+                ret.Add(LocalizationUtils.Format(translationKey, newHeroName));
+            }
+        }
+
+        private static List<string> GetResourceChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            var playerAvailableResourcesDiff = after.m_playerAvailableResources - before.m_playerAvailableResources;
+            var playerResourcesDiff = after.m_playerResources - before.m_playerResources;
+            var opponentAvailableResourcesDiff = after.m_opponentAvailableResources - before.m_opponentAvailableResources;
+            var opponentResourcesDiff = after.m_opponentResources - before.m_opponentResources;
+
+            ret.AddRange(GetResourceChanges(true, playerAvailableResourcesDiff, playerResourcesDiff));
+            ret.AddRange(GetResourceChanges(false, opponentAvailableResourcesDiff, opponentResourcesDiff));
+
+            return ret;
+        }
+
+        private static List<string> GetResourceChanges(bool friendlySidePlayer, int availableResourcesDiff, int resourcesDiff)
+        {
+            var ret = new List<string>();
+
+            if (resourcesDiff > 0)
+            {
+                if (availableResourcesDiff > 0)
+                {
+                    if (availableResourcesDiff >= resourcesDiff)
+                    {
+                        if (friendlySidePlayer)
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA, availableResourcesDiff));
+                        }
+                        else
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA, availableResourcesDiff));
+                        }
+                    }
+                    else
+                    {
+                        var numEmptyManaCrystals = resourcesDiff - availableResourcesDiff;
+
+                        if (friendlySidePlayer)
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS, availableResourcesDiff, numEmptyManaCrystals));
+                        }
+                        else
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS, availableResourcesDiff, numEmptyManaCrystals));
+                        }
+                    }
+                }
+                else
+                {
+                    if (friendlySidePlayer)
+                    {
+                        ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS, resourcesDiff));
+                    }
+                    else
+                    {
+                        ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS, resourcesDiff));
+                    }
+                }
+            }
+            else if (availableResourcesDiff > 0)
+            {
+                if (friendlySidePlayer)
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA, availableResourcesDiff));
+                }
+                else
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA, availableResourcesDiff));
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetSpeechLines(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            return GetDiffSpeech(taskList.GetSourceEntity(), before, after);
+        }
+
+        private static List<EntityDiff> GetAffectedEntities(List<EntityDiff> entityDiffs)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (diff.HasChanges())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> CreateEntityDiffs(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                var entityAfter = after.GetEntity(entityBefore.GetEntityId());
+
+                if (entityAfter != null)
+                {
+                    ret.Add(new EntityDiff(entityBefore, entityAfter, before, after));
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetMovedEntities(Entity sourceEntity, List<EntityDiff> entityDiffs, List<Entity> entitiesAfterMovement)
+        {
+            var ret = new List<EntityDiff>();
+
+            // Must iterate through entitiesAfterMovement or they will be out of order. e.g. drawing 2 cards means drawing the last 2 from your deck into your hand in rev order
+            Dictionary<Entity, EntityDiff> entityAfterToEntityDiff = new Dictionary<Entity, EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (!entityAfterToEntityDiff.ContainsKey(diff.GetAfterEntity()))
+                {
+                    entityAfterToEntityDiff.Add(diff.GetAfterEntity(), diff);
+                }
+                else
+                {
+                    Log.Accessibility.Print($"Ignored duplicate entity in GetMovedEntities: {diff.GetAfterEntity().GetName()}");
+                }
+            }
+
+            var orderedEntityDiffs = new List<EntityDiff>(entityDiffs.Count);
+
+            foreach (var entity in entitiesAfterMovement)
+            {
+                if (entityAfterToEntityDiff.ContainsKey(entity))
+                {
+                    orderedEntityDiffs.Add(entityAfterToEntityDiff[entity]);
+                }
+            }
+
+            foreach (var diff in orderedEntityDiffs)
+            {
+                if (sourceEntity != null && diff.GetEntityId() == sourceEntity.GetEntityId())
+                {
+                    // Ignore source as we handle explicit movement outside (in the powerTaskList describer)
+                    continue;
+                }
+
+                if (diff.MovedZone())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetDestroyedEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                if (after.GetEntity(entityBefore.GetEntityId()) == null)
+                {
+                    ret.Add(entityBefore);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetNewEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityAfter in after.m_entities)
+            {
+                if (before.GetEntity(entityAfter.GetEntityId()) == null)
+                {
+                    ret.Add(entityAfter);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetTransformedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasTransformed())
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetJustDiedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasDied() && entityDiff.GetDeathSpeech().SingularSpeech.Length > 0) // Length > 0 is because of replacing weapons e.g. equipping 1 wicked knife when 1 already exists
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> Clone(List<Entity> entities)
+        {
+            List<Entity> ret = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                ret.Add(entity.CloneForAccessibility());
+            }
+
+            return ret;
+        }
+
+        private static Entity Clone(Entity entity)
+        {
+            if (entity == null)
+            {
+                return null;
+            }
+
+            return entity.CloneForAccessibility();
+        }
+
+        private static List<Entity> GetEntitiesFromZone(Zone zone)
+        {
+            var ret = new List<Entity>();
+            var cards = zone.GetCards();
+
+            if (cards == null)
+            {
+                return ret;
+            }
+
+            foreach (var card in cards)
+            {
+                ret.Add(card.GetEntity());
+            }
+
+            return ret;
+        }
+
+        internal static bool PlayingTutorial()
+        {
+            return GameState.Get().GetGameEntity() is TutorialEntity;
+        }
+
+        #region Weapon stuff
+
+        private static HashSet<Entity> s_heroWeaponBroke = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroSheathedWeapon = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroUnsheathedWeapon = new HashSet<Entity>(new EntityComparer());
+
+        internal static void MarkWeaponUnsheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponUnsheathed: {hero}");
+            s_heroUnsheathedWeapon.Add(hero);
+        }
+
+        internal static void MarkWeaponSheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponSheathed: {hero}");
+            s_heroSheathedWeapon.Add(hero);
+        }
+
+
+        internal static void Reset()
+        {
+            s_heroWeaponBroke.Clear();
+            s_heroSheathedWeapon.Clear();
+            s_heroUnsheathedWeapon.Clear();
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
new file mode 100644
index 0000000..8eb7d99
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
@@ -0,0 +1,198 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleInputMgr : MonoBehaviour
+    {
+        private static bool[] m_setMouseButtonDown = new bool[3];
+
+        private static Vector3 m_setMousePosition = Vector3.zero;
+
+        private void LateUpdate()
+        {
+            AccessibleUnityInput.Get().SetMousePosition(m_setMousePosition);
+
+            for (int button = 0; button < m_setMouseButtonDown.Length; button++) 
+            {
+                AccessibleUnityInput.Get().SetMouseButtonDown(button, m_setMouseButtonDown[button]);
+                m_setMouseButtonDown[button] = false; // TODO: Would have to add a lot more logic if we wanted to hold/drag/etc. but don't think that'll be needed
+            }
+
+            if (AccessibleKey.TOGGLE_ACCESSIBILITY.IsPressed())
+            {
+                ToggleAccessibility();
+            }
+
+            // Debug stuff
+            if (HearthstoneAccessConstants.DEV_MODE && Input.GetKeyUp(KeyCode.F6))
+            {
+                Vector3 dbgMousePos = Input.mousePosition;
+                AccessibilityUtils.LogDebug($"[DBG] Mouse position is {dbgMousePos}");
+            }
+        }
+
+        private void ToggleAccessibility()
+        {
+            AccessibleUnityInput.Get().ToggleEnabled();
+            AccessibilityMgr.ToggleEnabled();
+        }
+
+        private static void ClickLeftMouseButtonImpl()
+        {
+            AccessibilityUtils.LogDebug($"[DBG] Clicked left mouse at {m_setMousePosition}");
+            m_setMouseButtonDown[0] = true;
+        }
+
+        public static void ClickLeftMouseButton()
+        {
+            ClickLeftMouseButtonImpl();
+        }
+
+        public static void ClickLeftMouseButton(Component component)
+        {
+            MoveMouseTo(component);
+            ClickLeftMouseButtonImpl();
+        }
+
+        internal static void ClickRightMouseButton()
+        {
+            m_setMouseButtonDown[1] = true;
+        }
+
+        private static void ClickMiddleMouseButton()
+        {
+            m_setMouseButtonDown[2] = true;
+        }
+
+        private static void SetMousePosition(Vector3 pos)
+        {
+            //AccessibilityUtils.LogDebug($"SetMousePosition{pos}");
+            m_setMousePosition = pos;
+        }
+
+        internal static void MoveMouseTo(Component component)
+        {
+            if (component == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(component.transform);
+        }
+
+        internal static Vector3 GetMousePosition(Component component)
+        {
+            return GetMousePosition(component.transform);
+        }
+
+        internal static void MoveMouseToTransform(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+
+            MoveMouseToWorldPosition(transform.position);
+        }
+
+        internal static Vector3 GetMousePosition(Transform transform)
+        {
+            return GetMousePosition(transform.position);
+        }
+
+        public static void ClickCenterOfScreen()
+        {
+            MoveMouseToCenterOfScreen();
+            ClickLeftMouseButton();
+        }
+
+        internal static void MoveMouseToCenterOfScreen()
+        {
+            var center = new Vector3(Screen.width / 2, Screen.height / 2);
+            SetMousePosition(center);
+        }
+
+        internal static void MoveMouseToWorldPosition(Vector3 pos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(pos);
+            screenPos.z = 0;
+            SetMousePosition(screenPos);
+        }
+
+        internal static Vector3 GetMousePosition(Vector3 worldPos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPos);
+            screenPos.z = 0;
+            return screenPos;
+        }
+
+        internal static void HideMouse()
+        {
+            SetMousePosition(Vector3.zero);
+        }
+
+        internal static void Click(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(transform);
+            ClickLeftMouseButton();
+        }
+
+        internal static void Click(Vector3 worldPosition)
+        {
+            SetMousePosition(worldPosition);
+            ClickLeftMouseButton();
+        }
+
+        private static bool m_holdingAnyKeyDown;
+
+        internal static bool AnyKeyUp()
+        {
+            var ret = false;
+
+            if (Input.anyKey)
+            {
+                m_holdingAnyKeyDown = true;
+            }
+
+            if (!Input.anyKey)
+            {
+                if (m_holdingAnyKeyDown)
+                {
+                    ret = true;
+                }
+
+                m_holdingAnyKeyDown = false;
+            }
+
+            return ret;
+        }
+
+        internal static int? TryGetPressedNumKey()
+        {
+            for (var i = 0; i <= 9; i++)
+            {
+                if (Input.GetKeyUp(KeyCode.Alpha0 + i))
+                {
+                    if (i == 0)
+                    {
+                        return 10;
+                    } else
+                    {
+                        return i;
+                    }
+                }
+            }
+
+            return null;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs
new file mode 100644
index 0000000..1ea10f3
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs
@@ -0,0 +1,172 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public abstract class AccessibleItem : AccessibleElement
+    {
+        // TODO: consider having short vs long descriptions in the future?
+        private string[] m_lines;
+
+        private int m_curLine;
+
+        private Action m_finishReadAction;
+
+        public AccessibleItem(AccessibleComponent parent) : this(parent, 0) { }
+
+        public AccessibleItem(AccessibleComponent parent, int startReadingFromLine) : base(parent)
+        {
+            m_curLine = startReadingFromLine;
+        }
+
+        private void SetupLines()
+        {
+            var lines = GetLines();
+            m_lines = lines.ToArray();
+        }
+
+        internal abstract List<string> GetLines();
+
+        internal void ReadLine()
+        {
+            SetupLines();
+            ReadLineImpl();
+        }
+
+        internal void ReadLine(int line)
+        {
+            SetupLines();
+            ReadLineImpl(line);
+        }
+
+        internal string GetLine(int line)
+        {
+            SetupLines();
+
+            if (line >= m_lines.Length)
+            {
+                return "";
+            }
+
+            return m_lines[line];
+        }
+
+        private void ReadLineImpl()
+        {
+            ReadLineImpl(m_curLine);
+        }
+
+        private void ReadLineImpl(int line)
+        {
+            if (line >= m_lines.Length)
+            {
+                return;
+            }
+
+            Output(m_lines[line]);
+        }
+
+        internal void ReadNextLine()
+        {
+            SetupLines();
+
+            if (IncLine(1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void ReadPrevLine()
+        {
+            SetupLines();
+            if (IncLine(-1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void Reset()
+        {
+            m_curLine = 0;
+        }
+
+        private bool IncLine(int inc)
+        {
+            m_curLine += inc;
+
+            if (m_curLine < 0)
+            {
+                m_curLine = 0;
+                return false;
+            }
+            else if (m_curLine >= m_lines.Length)
+            {
+                m_curLine = m_lines.Length - 1;
+                return false;
+            }
+
+            if (m_curLine == m_lines.Length - 1)
+            {
+                OnFinishReading();
+            }
+
+            return true; // new line
+        }
+
+        private void OnFinishReading()
+        {
+            if (m_finishReadAction != null)
+            {
+                m_finishReadAction();
+                m_finishReadAction = null;
+            }
+        }
+
+        internal void RegisterFinishReadListener(Action action)
+        {
+            m_finishReadAction = action;
+        }
+
+        internal void ReadAllLines()
+        {
+            if (m_curLine == 0)
+            {
+                SetupLines();
+            }
+
+            while (m_curLine < m_lines.Length - 1)
+            {
+                ReadLineImpl();
+                IncLine(1); // This has a guard so we need to read after as well
+            }
+
+            ReadLineImpl();
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadNextLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadPrevLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadLineImpl();
+                return true;
+            }
+            else if (AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadAllLines();
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs
new file mode 100644
index 0000000..bc6eb06
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs
@@ -0,0 +1,302 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleKey
+    {
+        public static AccessibleKey CONFIRM = CreateKey(KeyCode.Return);
+        public static AccessibleKey GLOBAL_CONFIRM = CreateGlobalKey(KeyCode.Return);
+        public static AccessibleKey BACK = CreateKey(KeyCode.Backspace);
+        public static AccessibleKey GLOBAL_BACK = CreateGlobalKey(KeyCode.Backspace);
+        public static AccessibleKey OPEN_GAME_MENU = CreateGlobalKey(KeyCode.Escape);
+        public static AccessibleKey HELP = CreateGlobalKey(KeyCode.F1);
+        public static AccessibleKey TOGGLE_ACCESSIBILITY = CreateGlobalKey(KeyCode.F8);
+        public static AccessibleKey READ_NEXT_LINE = CreateKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_LINE = CreateKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_CUR_LINE = CreateKey(KeyCode.UpArrow, true);
+        public static AccessibleKey READ_TO_END = CreateKey(KeyCode.DownArrow, true);
+        public static AccessibleKey READ_NEXT_ITEM = CreateKey(KeyCode.RightArrow);
+        public static AccessibleKey READ_PREV_ITEM = CreateKey(KeyCode.LeftArrow);
+        public static AccessibleKey READ_NEXT_VALID_ITEM = CreateKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_VALID_ITEM = CreateKey(KeyCode.Tab, true);
+        public static AccessibleKey READ_FIRST_ITEM = CreateKey(KeyCode.Home);
+        public static AccessibleKey READ_LAST_ITEM = CreateKey(KeyCode.End);
+        public static AccessibleKey READ_NEXT_PAGE = CreateKey(KeyCode.PageDown);
+        public static AccessibleKey READ_PREV_PAGE = CreateKey(KeyCode.PageUp);
+        public static AccessibleKey SKIP_NOTIFICATION = CreateKey(KeyCode.Space);
+        public static AccessibleKey SPACE = CreateKey(KeyCode.Space);
+
+        public static AccessibleKey DECREASE_GAME_SPEED = CreateKey(KeyCode.F11);
+        public static AccessibleKey INCREASE_GAME_SPEED = CreateKey(KeyCode.F12);
+
+        public static AccessibleKey GLOBAL_LEFT = CreateGlobalKey(KeyCode.LeftArrow);
+        public static AccessibleKey GLOBAL_RIGHT = CreateGlobalKey(KeyCode.RightArrow);
+
+        #region Menu Controls
+        public static AccessibleKey READ_NEXT_MENU_OPTION = CreateKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_MENU_OPTION = CreateKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_NEXT_VALID_MENU_OPTION = CreateKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_VALID_MENU_OPTION = CreateKey(KeyCode.Tab, true);
+        public static AccessibleKey READ_NEXT_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_NEXT_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab, true);
+        #endregion
+
+        #region Hub
+        public static AccessibleKey PLAY_SOLO_ADVENTURES = CreateKey(KeyCode.S);
+        public static AccessibleKey MY_COLLECTION = CreateKey(KeyCode.C);
+        #endregion
+
+        #region My Collection
+        public static AccessibleKey SEE_DECKS = CreateKey(KeyCode.D);
+        public static AccessibleKey CREATE_DECK = CreateKey(KeyCode.N);
+        public static AccessibleKey DELETE_DECK = CreateKey(KeyCode.Delete);
+        public static AccessibleKey EDIT_DECK = CreateKey(KeyCode.E);
+        #endregion
+
+        #region Game Keys
+        public static AccessibleKey MULLIGAN_MARK_CARD = CreateKey(KeyCode.Space);
+        public static AccessibleKey SEE_PLAYER_HAND = CreateKey(KeyCode.C);
+        public static AccessibleKey SEE_OPPONENT_HAND = CreateKey(KeyCode.C, true);
+        public static AccessibleKey SEE_PLAYER_DECK = CreateKey(KeyCode.D);
+        public static AccessibleKey SEE_OPPONENT_DECK = CreateKey(KeyCode.D, true);
+        public static AccessibleKey SEE_PLAYER_MANA = CreateKey(KeyCode.A);
+        public static AccessibleKey SEE_OPPONENT_MANA = CreateKey(KeyCode.A, true);
+        public static AccessibleKey SEE_PLAYER_SECRETS = CreateKey(KeyCode.S);
+        public static AccessibleKey SEE_OPPONENT_SECRETS = CreateKey(KeyCode.S, true);
+        public static AccessibleKey SEE_PLAYER_MINIONS = CreateKey(KeyCode.B);
+        public static AccessibleKey SEE_OPPONENT_MINIONS = CreateKey(KeyCode.G);
+        public static AccessibleKey SEE_OPPONENT_HERO = CreateKey(KeyCode.F);
+        public static AccessibleKey SEND_ALL_MINIONS_TO_FACE = CreateKey(KeyCode.F, true);
+        public static AccessibleKey SEE_PLAYER_HERO = CreateKey(KeyCode.V);
+        public static AccessibleKey SEE_PLAYER_HERO_POWER = CreateKey(KeyCode.R);
+        public static AccessibleKey SEE_OPPONENT_HERO_POWER = CreateKey(KeyCode.R, true);
+        public static AccessibleKey SEE_PLAYER_WEAPON = CreateKey(KeyCode.W);
+        public static AccessibleKey SEE_OPPONENT_WEAPON = CreateKey(KeyCode.W, true);
+        public static AccessibleKey SEE_HISTORY = CreateKey(KeyCode.Y);
+        public static AccessibleKey END_TURN = CreateKey(KeyCode.E);
+        public static AccessibleKey FORCE_END_TURN = CreateKey(KeyCode.E, true);
+        public static AccessibleKey READ_TOOLTIP = CreateKey(KeyCode.I);
+        public static AccessibleKey READ_ORIGINAL_CARD_STATS = CreateKey(KeyCode.K);
+        public static AccessibleKey TRADE_CARD = CreateKey(KeyCode.T);
+        #endregion
+
+        private bool m_requiresModifier;
+
+        private KeyCode m_keyCode;
+
+        private bool m_enabled;
+
+        private AccessibleKey(KeyCode keyCode, bool requiresModifier = false)
+        {
+            m_keyCode = keyCode;
+            m_requiresModifier = requiresModifier;
+            m_enabled = true;
+        }
+
+        public bool IsPressed()
+        {
+            var ret = IsPressedInternal();
+
+            if (ret)
+            {
+                AccessibilityUtils.LogDebug($"Pressed key: {m_keyCode}");
+            }
+
+            return ret;
+        }
+
+        private bool IsPressedInternal()
+        {
+            if (!m_enabled)
+            {
+                if (IsKeyUp(m_keyCode))
+                {
+                    AccessibilityUtils.LogDebug($"ZYY Tried to press {m_keyCode} but it was disabled");
+                }
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && IsKeyUp(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && IsKeyUp(m_keyCode);
+            }
+        }
+
+        private bool IsKeyUp(KeyCode keyCode)
+        {
+            if (keyCode == KeyCode.Return && Input.GetKeyUp(KeyCode.KeypadEnter))
+            {
+                // Quick fix as some players asked for this
+                return true;
+            }
+
+            return Input.GetKeyUp(keyCode);
+        }
+
+        public bool IsDown()
+        {
+            if (!m_enabled)
+            {
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && Input.GetKey(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && Input.GetKey(m_keyCode);
+            }
+        }
+
+        public bool IsPressedDown()
+        {
+            if (!m_enabled)
+            {
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && Input.GetKeyDown(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && Input.GetKeyDown(m_keyCode);
+            }
+        }
+
+        private static bool IsHoldingModifier()
+        {
+            return Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
+        }
+
+        public override string ToString()
+        {
+            if (m_requiresModifier)
+            {
+                return LocalizationUtils.Format(LocalizationKey.INPUT_COMMAND_WITH_MODIFIER_FORMAT, ReadKey(m_keyCode));
+            }
+            else
+            {
+                return ReadKey(m_keyCode);
+            }
+        }
+
+        public string ToEnglishString()
+        {
+            // Used for narrations only (a vs. eh)
+            if (m_requiresModifier)
+            {
+                return $"Shift + {ReadKeyInEnglish(m_keyCode)}";
+            }
+            else
+            {
+                return ReadKeyInEnglish(m_keyCode);
+            }
+        }
+
+        private string ReadKeyInEnglish(KeyCode keyCode)
+        {
+            switch (keyCode)
+            {
+                case KeyCode.Return:
+                    return "Enter";
+                case KeyCode.A:
+                    return "eh";
+                case KeyCode.I:
+                    return "eye";
+                default:
+                    return keyCode.ToString();
+            }
+        }
+
+        private string ReadKey(KeyCode keyCode)
+        {
+            if (LocalizationUtils.HasOverrideForKey(keyCode))
+            {
+                return LocalizationUtils.GetOverrideForKey(keyCode);
+            }
+
+            return keyCode.ToString();
+        }
+
+        public void Enable()
+        {
+            m_enabled = true;
+        }
+
+        public void Disable()
+        {
+            m_enabled = false;
+        }
+
+        #region Key Registation
+        private static HashSet<AccessibleKey> s_allKeys;
+        private static HashSet<AccessibleKey> s_nonGlobalKeys;
+        private static HashSet<AccessibleKey> s_globalKeys;
+
+        private static AccessibleKey CreateKey(KeyCode keyCode, bool requiresModifier=false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresModifier);
+            s_allKeys.Add(newKey);
+            s_nonGlobalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static AccessibleKey CreateGlobalKey(KeyCode keyCode, bool requiresModifier=false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresModifier);
+            s_allKeys.Add(newKey);
+            s_globalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static void InitializeKeySetsIfNeeded()
+        {
+            if (s_allKeys == null)
+            {
+                s_allKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_nonGlobalKeys == null)
+            {
+                s_nonGlobalKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_globalKeys == null)
+            {
+                s_globalKeys = new HashSet<AccessibleKey>();
+            }
+        }
+
+        public static HashSet<AccessibleKey> GetAllKeys(bool includeGlobals=true)
+        {
+            if (includeGlobals)
+            {
+                return s_allKeys;
+            }
+            else
+            {
+                return s_nonGlobalKeys;
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
new file mode 100644
index 0000000..7bb2e1e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
@@ -0,0 +1,162 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleListOfItems<T> : AccessibleElement where T : AccessibleItem
+    {
+        private List<T> m_items;
+
+        private int m_curItemIdx;
+
+        private T m_curItem;
+
+        internal int Count => m_items.Count;
+
+        internal List<T> Items => m_items;
+
+        internal AccessibleListOfItems(AccessibleComponent parent, List<T> items) : base(parent)
+        {
+            m_items = items;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (!IsReading())
+            {
+                return false;
+            }
+
+            if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                return ReadNextItem(1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                return ReadNextItem(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                return ReadNextItem(1, true);
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                return ReadNextItem(-1, true);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+            {
+                ReadFromTop();
+                return true;
+            }
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+            {
+                ReadFromBottom();
+                return true;
+            }
+            else if (m_curItem != null && m_curItem.HandleAccessibleInput())
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        private bool ReadNextItem(int inc, bool wrapAround = false)
+        {
+            int nextItemIdx = m_curItemIdx + inc;
+
+            if (nextItemIdx < 0 || nextItemIdx >= m_items.Count)
+            {
+                if (wrapAround && m_items.Count > 0)
+                {
+                    nextItemIdx = inc < 0 ? m_items.Count - 1 : 0;
+                }
+                else
+                {
+                    return false;
+                }
+            }
+
+            m_curItemIdx = nextItemIdx;
+            m_curItem = m_items[m_curItemIdx];
+            m_curItem.Reset();
+            var line = m_curItem.GetLine(0);
+            if (line.Length > 0)
+            {
+                Output(AccessibleSpeech.MENU_OPTION(line, m_curItemIdx + 1, m_items.Count));
+            }
+
+            return true;
+        }
+
+        internal bool IsReading()
+        {
+            return m_curItem != null;
+        }
+
+        internal void StartReading()
+        {
+            if (m_items.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextItem(0);
+            }
+        }
+
+        private void ReadFromTop()
+        {
+            m_curItemIdx = 0;
+            StartReading();
+        }
+
+        private void ReadFromBottom()
+        {
+            m_curItemIdx = m_items.Count - 1;
+            StartReading();
+        }
+
+        internal void StartReadingReverse()
+        {
+            ReadNextItem(m_items.Count - 1);
+        }
+
+        internal T GetItemBeingRead()
+        {
+            return m_items[m_curItemIdx];
+        }
+
+        internal int GetItemBeingReadIndex()
+        {
+            return m_curItemIdx;
+        }
+
+        internal string GetHelp(bool hasBackButton)
+        {
+            if (m_items.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HORIZONTAL_HELP(hasBackButton);
+            }
+        }
+
+        internal void UpdateItems(List<T> items)
+        {
+            m_items = items;
+
+            if (items.Count == 0)
+            {
+                m_curItemIdx = 0;
+            }
+            else if (m_curItemIdx >= items.Count)
+            {
+                m_curItemIdx = items.Count - 1;
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
new file mode 100644
index 0000000..d75e3bb
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
@@ -0,0 +1,44 @@
+﻿using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleLoginScreen : AccessibleScreen
+    {
+        private static AccessibleLoginScreen s_instance = new AccessibleLoginScreen();
+
+        private PegUIElement m_startButton;
+
+        internal static AccessibleLoginScreen Get() {
+            return s_instance;
+        }
+
+        public void OnGameLoaded(PegUIElement startButton)
+        {
+            AccessibilityMgr.SetScreen(this);
+
+            m_startButton = startButton;
+
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_GAME_LOADED);
+            AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_START;
+        }
+
+        public void HandleInput()
+        {
+            if (m_startButton != null && AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_startButton.TriggerRelease();
+                AccessibilityMgr.TransitioningScreens();
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+            // TODO: Review if this really isn't needed
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs
new file mode 100644
index 0000000..64afe88
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs
@@ -0,0 +1,219 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class AccessibleMenu : AccessibleElement
+    {
+        private class MenuOption
+        {
+            internal string m_text;
+            internal Action m_onClickAction;
+            internal Action m_onReadAction;
+
+            internal MenuOption(string text, Action onClickAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+            }
+
+            internal MenuOption(string text, Action onClickAction, Action onReadAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+                m_onReadAction = onReadAction;
+            }
+        }
+
+        private string m_menuName;
+
+        private List<MenuOption> m_options;
+
+        private int m_curOptionIdx;
+
+        private Action m_goBackAction;
+
+        private bool m_isReading;
+
+        private bool m_isGlobalMenu;
+
+        public AccessibleMenu(AccessibleComponent parent, string menuName, Action goBackAction, bool globalMenu=false) : base(parent)
+        {
+            m_menuName = menuName;
+            m_options = new List<MenuOption>();
+            m_goBackAction = goBackAction;
+            m_isGlobalMenu = globalMenu;
+        }
+
+        public void AddOption(string option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(string option, Action onClickAction, Action onReadAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction, onReadAction));
+        }
+
+        public bool HandleAccessibleInput()
+        {
+            try
+            {
+                if (ReadNextIsPressed())
+                {
+                    return ReadNextOption(1);
+                }
+                else if (ReadPrevIsPressed())
+                {
+                    return ReadNextOption(-1);
+                }
+                else if (ConfirmIsPressed())
+                {
+                    return SelectOption();
+                }
+                else if (BackIsPressed())
+                {
+                    return GoBack();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+
+        private bool BackIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.BackIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.BACK.IsPressed();
+            }
+        }
+
+        private bool ConfirmIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ConfirmIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.CONFIRM.IsPressed();
+            }
+        }
+
+        private bool ReadPrevIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ReadPrevIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_PREV_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadNextIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ReadNextIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_NEXT_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadNextOption(int inc)
+        {
+            int nextOptionIdx = m_curOptionIdx + inc;
+
+            if (nextOptionIdx < 0 || nextOptionIdx >= m_options.Count)
+            {
+                return false;
+            }
+
+            m_curOptionIdx = nextOptionIdx;
+            var curOption = m_options[m_curOptionIdx];
+
+            var speech = AccessibleSpeech.MENU_OPTION(curOption.m_text, m_curOptionIdx + 1, m_options.Count);
+            Output(speech);
+
+            if (curOption.m_onReadAction != null)
+            {
+                curOption.m_onReadAction();
+            }
+
+            return true;
+        }
+
+        private bool SelectOption()
+        {
+            if (!m_isReading || m_options.Count == 0)
+            {
+                return false;
+            }
+
+            m_options[m_curOptionIdx].m_onClickAction();
+
+            return true;
+        }
+
+        private bool GoBack()
+        {
+            if (m_goBackAction == null)
+            {
+                return false;
+            }
+
+            m_goBackAction();
+
+            return true;
+        }
+
+        public void StartReading()
+        {
+            Output(m_menuName);
+
+            ReadCurrentOption();
+        }
+
+        public void ReadCurrentOption()
+        {
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public void SetIndex(int index)
+        {
+            m_curOptionIdx = index;
+        }
+
+        internal string GetHelp()
+        {
+            if (m_options.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HELP(m_goBackAction != null);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
new file mode 100644
index 0000000..3f40f12
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
@@ -0,0 +1,20 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleMultilineText : AccessibleItem
+    {
+        private List<string> m_lines;
+
+        internal AccessibleMultilineText(AccessibleComponent parent, List<string> lines) : base(parent)
+        {
+            m_lines = lines;
+        }
+
+        internal override List<string> GetLines()
+        {
+            return m_lines;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
new file mode 100644
index 0000000..a2fd21e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
@@ -0,0 +1,26 @@
+﻿using System;
+
+namespace Accessibility
+{
+    static class AccessibleNotificationMgr
+    {
+        public static void OnCreateNotificationWithoutSound(Notification notification)
+        {
+            ReadNotification(notification);
+        }
+
+        public static void OnCreateNotificationWithSound(Notification notification)
+        {
+            if (!AccessibilityConfig.CAN_HEAR)
+            {
+                // Could look into doing something like this for deaf-blind support
+                ReadNotification(notification);
+            }
+        }
+
+        private static void ReadNotification(Notification notification)
+        {
+            AccessibilityMgr.OutputNotification(notification.speechUberText.Text);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
new file mode 100644
index 0000000..ac3a7f8
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
@@ -0,0 +1,522 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePlayDescriber
+    {
+        private static AccessiblePlayDescriber s_AccessiblePlayDescriber;
+
+        private HashSet<PowerTaskList> m_describedTaskLists = new HashSet<PowerTaskList>();
+
+        private int m_pendingReadings;
+
+        private AccessiblePlayDescriber() { }
+
+        internal static AccessiblePlayDescriber Get()
+        {
+            if (s_AccessiblePlayDescriber == null)
+            {
+                s_AccessiblePlayDescriber = new AccessiblePlayDescriber();
+            }
+
+            return s_AccessiblePlayDescriber;
+        }
+
+        internal void Reset()
+        {
+            m_describedTaskLists.Clear();
+        }
+
+        private bool ShouldCalloutTrigger(Entity entity)
+        {
+            if (entity == null)
+            {
+                return false;
+            }
+
+            if (entity.IsHero())
+            {
+                return false; // Don't think we need this since it just seems to be mission events
+            }
+
+            if (entity.IsCharacter() || entity.IsWeapon() || entity.IsSecret() || entity.IsQuest() || entity.IsQuestline() || entity.IsSideQuest() || entity.IsHeroPower())
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal string OnCardTriggered(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity();
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (ShouldShowTriggeredBigCard(card, taskList))
+            {
+                return GetBigCardTriggeredText(card);
+            }
+
+            if (!ShouldCalloutTrigger(card))
+            {
+                return null;
+            }
+
+            var fullCardName = AccessibleSpeechUtils.GetFullNameInZone(card);
+
+            // Not really a play but the card itself may be useful if the player wants to read it
+            var play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_CARD_IN_ZONE_TRIGGERED, fullCardName);
+            return RegisterPlay(play);
+        }
+
+        private bool ShouldShowTriggeredBigCard(Entity card, PowerTaskList taskList)
+        {
+            if (PowerProcessor.ShouldShowTriggeredBigCard(card))
+            {
+                return true;
+            }
+
+            if (card.IsControlledByOpposingSidePlayer())
+            {
+                // e.g. Baku the Mooneater
+                foreach (var task in taskList.GetTaskList())
+                {
+                    if (task.IsShowStartOfGameCard())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        internal string OnCardPlayed(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity();
+            var blockStart = taskList.GetBlockStart();
+
+            AccessibilityUtils.LogDebug($"OnCardPlayed taskList ID: {taskList.GetId()}");
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (PowerProcessor.ShouldShowPlayedBigCard(card, blockStart))
+            {
+                var text = GetBigCardPlayedText(card, taskList);
+
+                if (text.Length > 0)
+                {
+                    return text; // We ignore some things like hero powers 
+                }
+            }
+
+            bool isFriendlySide = card.IsControlledByFriendlySidePlayer();
+            var cardName = card.GetName();
+            string play;
+
+            if (IsCardTrade(taskList))
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TRADED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_TRADED_CARD, cardName);
+                }
+            }
+            else if (card.IsMinion())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_SUMMONED_MINION, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION, cardName);
+                }
+            }
+            else if (card.IsWeapon())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_EQUIPPED_WEAPON, cardName);
+                }
+            }
+            else if (card.IsHeroPower())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_USED_HERO_POWER, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_USED_HERO_POWER, cardName);
+                }
+            }
+            else if (card.IsSecret())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET, cardName);
+                }
+                else
+                {
+                    var cardClass = GameStrings.GetClassName(card.GetClass());
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, cardClass);
+                }
+                // FIXME: not sure if this won't break
+            }
+            else
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD, cardName);
+                }
+            }
+
+            return RegisterPlay(play);
+        }
+
+        private bool IsCardTrade(PowerTaskList taskList)
+        {
+            if (taskList == null || !taskList.IsOrigin() || !taskList.IsPlayBlock())
+            {
+                return false;
+            }
+
+            var source = taskList.GetSourceEntity();
+            var target = taskList.GetTargetEntity();
+
+            if (source == null || target == null)
+            {
+                return false;
+            }
+
+            if (source.GetEntityId() != target.GetEntityId())
+            {
+                return false;
+            }
+
+            foreach (var task in taskList.GetTaskList())
+            {
+                if (task.IsCardTrade(source.GetEntityId()))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private string GetBigCardPlayedText(Entity card, PowerTaskList taskList)
+        {
+            var cardName = card.GetName();
+            var cardText = card.GetCardTextBuilder().BuildCardTextInHand(card);
+            var isFriendlySide = card.IsControlledByFriendlySidePlayer();
+            string play;
+
+            if (IsCardTrade(taskList))
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TRADED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_TRADED_CARD, cardName);
+                }
+            }
+            else if (card.IsMinion())
+            {
+                var atk = card.GetATK();
+                var hp = card.GetHealth();
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD, cardName, atk, hp, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD, cardName, atk, hp, cardText);
+                }
+            }
+            else if (card.IsSpell())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+            }
+            else if (card.IsHeroPower()) // This is tricky as it would fire after ptldescriber + we probably don't want to repeat this all the time
+            {
+                // Note: This wasn't being read but I think it's a good idea to do so since they're short anyways and can be read in the animation - experimenting
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD, cardName, cardText);
+                }
+            } 
+            else if (card.IsWeapon())
+            {
+                var atk = card.GetATK();
+                var durability = card.GetDurability();
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD, cardName, atk, durability, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD, cardName, atk, durability, cardText);
+                }
+            }
+            else if (card.IsSecret())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    var cardClass = GameStrings.GetClassName(card.GetClass());
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, cardClass);
+                }
+            }
+            else if (card.GetCardType() == TAG_CARDTYPE.ENCHANTMENT)
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+            }
+            else
+            {
+                Log.Accessibility.Print($"GetBigCardPlayedText unknown type: {card.GetName()} / type = {card.GetCardType()}");
+                return "";
+            }
+
+            return RegisterPlay(play);
+        }
+
+        private string GetBigCardTriggeredText(Entity card)
+        {
+            var cardName = card.GetName();
+            var cardText = $"{card.GetCardTextBuilder().BuildCardTextInHand(card)}";
+            string play;
+
+            if (card.IsControlledByFriendlySidePlayer())
+            {
+                // This might be the one that shows up for things like random spells and whatnot - confirm this
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CARD_TRIGGERED, cardName);
+            }
+            else
+            {
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD, cardName, cardText);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        internal void OnBigCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardPlayed called with null taskList");
+            }
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return;
+            }
+
+            var text = GetBigCardPlayedText(card, taskList);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+        }
+
+        internal void OnBigCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardTriggered called with null curTaskList - dropping");
+            }
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return;
+            }
+
+            var text = GetBigCardTriggeredText(card);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+        }
+
+        internal string OnFatigue(PowerTaskList taskList)
+        {
+            var source = taskList.GetSourceEntity();
+
+            if (source == null)
+            {
+                Log.Accessibility.Print("Fatigue had null source");
+                return null;
+            }
+
+            var side = source.GetControllerSide();
+            string play;
+
+            if (side == Player.Side.FRIENDLY)
+            {
+                play = LocalizationUtils.Get(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK);
+            }
+            else
+            {
+                play = LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        internal List<string> OnCardsBurned(List<Entity> burnedCards)
+        {
+            var ret = new List<string>();
+
+            foreach(var card in burnedCards)
+            {
+                var cardName = card.GetName();
+                string play;
+
+                if (card.IsControlledByFriendlySidePlayer())
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED, cardName);
+                }
+
+                ret.Add(RegisterPlay(play));
+            }
+
+            return ret;
+        }
+
+        internal void OnAttack(PowerTaskList taskList)
+        {
+            var text = GetAttackText(taskList);
+
+            if (text != null)
+            {
+                AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+            }
+        }
+
+        internal string GetAttackText(PowerTaskList taskList)
+        {
+            if (m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            var attacker = taskList.GetAttacker();
+            var defender = taskList.GetDefender();
+            var proposedDefender = taskList.GetProposedDefender();
+
+            string play;
+
+            if (proposedDefender != null && proposedDefender.GetEntityId() != defender.GetEntityId())
+            {
+                var attackerName = GetFullNameInZone(attacker);
+                var proposedDefenderName = GetFullNameInZone(proposedDefender);
+                var defenderName = GetFullNameInZone(defender);
+
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_ENTITY_ATTACKED_OTHER, attackerName, proposedDefenderName, defenderName);
+            } 
+            else
+            {
+                var attackerName = GetFullNameInZone(attacker);
+                var defenderName = GetFullNameInZone(defender);
+
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_ENTITY_ATTACKED, attackerName, defenderName);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        private void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPSGP Unblocking power processor");
+            m_pendingReadings--;
+        }
+
+        public bool IsBusy()
+        {
+            return m_pendingReadings > 0;
+        }
+
+        // History stuff
+        private string RegisterPlay(string action)
+        {
+            AccessibleHistoryMgr.Get().AddEntry(action);
+            return action;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
new file mode 100644
index 0000000..a946f24
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
@@ -0,0 +1,456 @@
+﻿using PegasusGame;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePowerTaskListDescriber
+    {
+        private static AccessibleInGameState s_lastDescribedState;
+
+        private static bool s_blocked;
+
+        private static bool s_canSnapshot;
+
+        private static bool s_waitingForYourTurnBanner;
+
+        private static List<string> s_descriptionsWaitingForTurnChange = new List<string>();
+
+        private static TAG_STEP s_prevStep;
+
+        private static bool s_gameOfficiallyStarted;
+
+        private static bool s_turnStarted;
+
+        private static int s_numEndTurnAttempts;
+
+        public static void OnGameStart()
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug("PTL OnGameStart");
+
+                s_lastDescribedState = null;
+                s_canSnapshot = false;
+                s_waitingForYourTurnBanner = false;
+                s_descriptionsWaitingForTurnChange.Clear();
+                s_prevStep = TAG_STEP.INVALID;
+                s_gameOfficiallyStarted = false;
+                s_turnStarted = false;
+                s_numEndTurnAttempts = 0;
+
+                AccessiblePlayDescriber.Get().Reset();
+                AccessibleInGameState.Reset();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void OnPowerTaskListStart(PowerTaskList taskList)
+        {
+            try
+            {
+                taskList.SetGlobalCompleteCallback(OnPowerTaskListEnd);
+
+                Network.HistBlockStart blockStart = taskList.GetBlockStart();
+                AccessibilityUtils.LogDebug($">>> Starting PowerTaskList.Id: {taskList.GetId()}. BlockType: {blockStart?.BlockType}");
+
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void OnPowerTaskListEnd(PowerTaskList taskList)
+        {
+            try
+            {
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+                AccessibilityUtils.LogDebug($">>> Ending PowerTaskList. Id: {taskList.GetId()}.");
+                AccessibilityUtils.LogDebug("SPS blocking power processor");
+                s_blocked = true;
+
+                var lines = new List<string>();
+
+                var canDescribe = true;
+
+                if (!GameHasOfficiallyStarted())
+                {
+                    canDescribe = false;
+                }
+
+                if (taskList.IsOrigin() && taskList.IsPlayBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardPlayed(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.FATIGUE))
+                {
+                    AccessibilityUtils.LogDebug("Fatigue");
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnFatigue(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.ATTACK))
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().GetAttackText(taskList));
+                    canDescribe = false;
+
+                    if ((taskList.GetAttacker()?.IsHero() ?? false) || (taskList.GetDefender()?.IsHero() ?? false))
+                    {
+                        canDescribe = true; // Describe state when a Hero is involved as dmg taken is more important there
+                    }
+                }
+
+                if (taskList.IsOrigin() && taskList.IsTriggerBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardTriggered(taskList));
+                }
+
+                var burnedCards = GetBurnedCards(taskList);
+                if (burnedCards.Count > 0)
+                {
+                    lines.AddRange(AccessiblePlayDescriber.Get().OnCardsBurned(burnedCards));
+                }
+
+                SnapshotAndDescribeGameState(lines, taskList, canDescribe);
+            }
+            catch (Exception e)
+            {
+                s_blocked = false;
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static bool GameHasOfficiallyStarted()
+        {
+            if (!GameState.Get().IsGameCreated())
+            {
+                return false;
+            }
+
+            if (s_gameOfficiallyStarted)
+            {
+                return true;
+            }
+
+            // Tutorial games (no mulligan) must all go through one initial MAIN_READY step before they start (or so it seems)
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_READY)
+            {
+                s_gameOfficiallyStarted = true;
+            }
+
+            return s_gameOfficiallyStarted;
+        }
+
+        private static void AddIfNotNull(List<string> lines, string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                return;
+            }
+
+            lines.Add(text);
+        }
+
+        private static List<Entity> GetBurnedCards(PowerTaskList taskList)
+        {
+            var ret = new List<Entity>();
+
+            List<PowerTask> taskList2 = taskList.GetTaskList();
+            for (int i = 0; i < taskList2.Count; i++)
+            {
+                Network.PowerHistory power = taskList2[i].GetPower();
+                if (power.Type != Network.PowerType.META_DATA)
+                {
+                    continue;
+                }
+                Network.HistMetaData histMetaData = (Network.HistMetaData)power;
+                if (histMetaData.MetaType != HistoryMeta.Type.BURNED_CARD)
+                {
+                    continue;
+                }
+                if (histMetaData.Info.Count == 0)
+                {
+                    continue;
+                }
+
+                foreach (var entityId in histMetaData.Info)
+                {
+                    var entity = GameState.Get().GetEntity(entityId);
+
+                    if (entity != null)
+                    {
+                        ret.Add(entity);
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private static void SnapshotAndDescribeGameState(List<string> lines, PowerTaskList taskList, bool canDescribe=true)
+        {
+            AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState canDescribe={canDescribe}");
+
+            var nextStep = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.NEXT_STEP);
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_END)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D1");
+
+                if (s_prevStep != step && s_turnStarted && IsRealEndTurn()) // IsRealEndTurn is because of Hemet Nesingwary and Illidan who break the game by ending the turn twice
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D2");
+                    lines.Add(LocalizedText.GAMEPLAY_TURN_ENDED);
+
+                    OnTurnEnded();
+                    s_canSnapshot = true;
+                }
+            }
+            else if (step == TAG_STEP.MAIN_READY) // Allow trigger effects to be described before turn-related stuff
+            {
+                lines.AddRange(OnTurnChange());
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D3");
+                s_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START_TRIGGERS)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D4");
+                s_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D5");
+                s_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.BEGIN_MULLIGAN)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D6");
+                s_canSnapshot = true;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn() && !s_turnStarted)
+                {
+                    // Start of game card (e.g. C'Thun) trigger during the mulligan and the banner comes first
+                    s_waitingForYourTurnBanner = true;
+                }
+            }
+            else if (s_prevStep == TAG_STEP.BEGIN_MULLIGAN && step != s_prevStep)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D7");
+                s_canSnapshot = false;
+            }
+
+            s_prevStep = step;
+
+            if (s_lastDescribedState == null)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D8");
+                s_canSnapshot = true; // Start snapshotting after game starts due to tutorial stuff
+            }
+
+            if (!s_canSnapshot)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D9");
+
+                if (!s_waitingForYourTurnBanner)
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D10");
+                    Output(lines);
+                }
+                else
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D11");
+                    s_descriptionsWaitingForTurnChange.AddRange(lines);
+                    s_blocked = false;
+                }
+                return;
+            }
+
+            var newState = AccessibleInGameState.GetCurrentState(taskList);
+
+            if (canDescribe) // TODO: Rethink this
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D12");
+                var description = AccessibleInGameState.DescribeDiff(taskList, s_lastDescribedState, newState);
+
+                AddIfNotNull(lines, description);
+                AccessibleHistoryMgr.Get().AddEntry(description);
+            }
+
+            s_lastDescribedState = newState;
+
+            if (!s_waitingForYourTurnBanner)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D13");
+                Output(lines);
+            }
+            else
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D14");
+                s_descriptionsWaitingForTurnChange.AddRange(lines);
+                s_blocked = false;
+            }
+        }
+
+        private static bool IsRealEndTurn()
+        {
+            s_numEndTurnAttempts++;
+
+            if (GameState.Get().GetGameEntity() is Tutorial_04 && s_numEndTurnAttempts == 3)
+            {
+                return false;
+            }
+            else if (GameState.Get().GetGameEntity() is Tutorial_05 && s_numEndTurnAttempts == 7)
+            {
+                return false;
+            }
+
+            return true;
+        }
+
+        private static List<string> OnTurnChange()
+        {
+            var ret = new List<string>();
+
+            if (s_turnStarted)
+            {
+                return ret;
+            }
+
+            s_turnStarted = true;
+
+            if (GameState.Get().IsFriendlySidePlayerTurn())
+            {
+                s_waitingForYourTurnBanner = true;
+            }
+            else
+            {
+                ret.Add(LocalizedText.GAMEPLAY_OPPONENT_TURN);
+                DescribeInitialBoardStateIfNeeded(ret);
+            }
+
+            return ret;
+        }
+
+        internal static void OnTurnStart()
+        {
+            s_waitingForYourTurnBanner = false;
+            s_turnStarted = true;
+
+            var descriptions = new List<string>();
+            descriptions.Add(LocalizedText.GAMEPLAY_YOUR_TURN);
+            descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TURN_START_READ_MANA, GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources()));
+            DescribeInitialBoardStateIfNeeded(descriptions);
+            descriptions.AddRange(s_descriptionsWaitingForTurnChange);
+            s_descriptionsWaitingForTurnChange.Clear();
+
+            Output(descriptions);
+        }
+
+        private static void DescribeInitialBoardStateIfNeeded(List<string> descriptions)
+        {
+            if (GameState.Get().GetTurn() != 1)
+            {
+                return;
+            }
+
+            // This is needed for some BoH such as Jaina 6 and Rexxar 3
+            var friendlySideMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCards();
+            if (friendlySideMinions.Count > 0)
+            {
+                var friendlySideMinionNames = AccessibleSpeechUtils.GetNames(friendlySideMinions);
+                descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD, friendlySideMinionNames));
+            }
+
+            var opposingSideMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCards();
+            if (opposingSideMinions.Count > 0)
+            {
+                var opposingSideMinionNames = AccessibleSpeechUtils.GetNames(opposingSideMinions);
+                descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD, opposingSideMinionNames));
+            }
+        }
+
+        private static void Output(string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                s_blocked = false;
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"SPS Describing blocked task list: {text}");
+            AccessibilityMgr.OutputAndWait(text, OnOutputStart, OnOutputEnd);
+        }
+
+        private static void Output(List<string> lines)
+        {
+            if (lines == null || lines.Count == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                s_blocked = false;
+            }
+            else
+            {
+                Output(AccessibleSpeechUtils.CombineLines(lines));
+            }
+        }
+
+        private static void OnOutputStart()
+        {
+        }
+
+        private static void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+            s_blocked = false;
+        }
+
+        public static bool IsBusy()
+        {
+            return s_blocked;
+        }
+
+        #region Weapon stuff
+
+        private static void OnTurnEnded()
+        {
+            var curPlayer = GameState.Get().GetCurrentPlayer();
+            var otherPlayer = GameState.Get().GetFirstOpponentPlayer(curPlayer);
+
+            if (curPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponSheathed(curPlayer.GetHero());
+            }
+
+            if (otherPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponUnsheathed(otherPlayer.GetHero());
+            }
+
+            s_turnStarted = false;
+        }
+
+        internal static void OnReconnected()
+        {
+            AccessibilityUtils.LogDebug("PTL OnReconnected");
+            s_gameOfficiallyStarted = true;
+            s_turnStarted = true;
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs
new file mode 100644
index 0000000..1112ecd
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs
@@ -0,0 +1,30 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessiblePracticeAIButton : AccessibleItem
+    {
+        private readonly PracticeAIButton m_button;
+
+        internal AccessiblePracticeAIButton(AccessibleComponent parent, PracticeAIButton button) : base(parent)
+        {
+            m_button = button;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            // Name
+            ret.Add(m_button.m_name.Text);
+
+            // Undefeated label
+            if (m_button.m_questBang.activeInHierarchy)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs
new file mode 100644
index 0000000..328a27f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs
@@ -0,0 +1,90 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuest : AccessibleItem
+    {
+        private readonly QuestDataModel m_quest;
+
+        internal AccessibleQuest(AccessibleComponent parent, QuestDataModel quest) : base(parent)
+        {
+            m_quest = quest;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            if (m_quest.Name?.Length > 0) // New quests don't have a name. Instead, they have the XP scroll at the top so we use GetRewards as the name
+            {
+                ret.Add(m_quest.Name);
+            }
+
+            var rewards = GetRewards();
+
+            if (rewards.Length > 0)
+            {
+                ret.Add(rewards);
+            }
+
+            ret.Add(m_quest.Description);
+
+            var progress = GetProgress();
+
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            // TODO: Reroll
+
+            return ret;
+        }
+
+        private string GetRewards()
+        {
+            if (m_quest.RewardTrackXp > 0) // New quests give XP as rewards instead of anything else
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_NO_NAME_XP_ONLY, m_quest.RewardTrackXp);
+            }
+
+            var rewards = m_quest.Rewards; // Non-XP quests give other rewards
+
+            if (rewards == null)
+            {
+                return "";
+            }
+
+            if (rewards.Description?.Length > 0)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, rewards.Description);
+            }
+
+            var rwds = new List<string>();
+            foreach (var rwd in rewards.Items)
+            {
+                rwds.Add(new AccessibleRewardItemDataModel(m_parent, rwd).GetLine(0));
+            }
+
+            var lst = AccessibleSpeechUtils.HumanizeList(rwds);
+
+            if (rewards.ChooseOne)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION, lst);
+            }
+
+            return lst;
+        }
+
+        private string GetProgress()
+        {
+            if (m_quest.Quota == 0)
+            {
+                return "";
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, m_quest.Progress, m_quest.Quota);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
new file mode 100644
index 0000000..040d6fc
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
@@ -0,0 +1,82 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuestTile : AccessibleItem
+    {
+        private readonly QuestTile m_quest;
+
+        internal AccessibleQuestTile(AccessibleComponent parent, QuestTile quest) : base(parent)
+        {
+            m_quest = quest;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_quest.m_questName.Text);
+            ret.Add(GetRewards());
+            ret.Add(m_quest.m_requirement.Text);
+
+            var progress = GetProgress();
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            return ret;
+        }
+
+        private string GetRewards()
+        {
+            var rewards = m_quest.m_quest.Rewards;
+
+            var rewardTexts = new List<string>();
+
+            foreach (var reward in rewards)
+            {
+                rewardTexts.Add(StringifyRewardType(reward.RewardType));
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, AccessibleSpeechUtils.HumanizeList(rewardTexts));
+        }
+
+        private string GetProgress()
+        {
+            var achievement = m_quest.m_quest;
+            if (achievement.MaxProgress > 1)
+            {
+                return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, achievement.Progress, achievement.MaxProgress);
+            }
+
+            return "";
+        }
+
+        private string StringifyRewardType(Reward.Type rewardType)
+        {
+            switch (rewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_DUST);
+                case Reward.Type.BOOSTER_PACK:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_PACK);
+                case Reward.Type.CARD:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD);
+                case Reward.Type.CARD_BACK:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_BACK);
+                case Reward.Type.GOLD:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_GOLD);
+                case Reward.Type.MOUNT:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT);
+                case Reward.Type.ARCANE_ORBS:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_ORBS);
+                case Reward.Type.MINI_SET:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MINI_SET);
+                default:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
new file mode 100644
index 0000000..69c6d17
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
@@ -0,0 +1,234 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Accessibility
+{
+    class AccessibleRewardData : AccessibleItem
+    {
+        internal RewardData RewardData { get; }
+
+        private List<string> m_cachedLines;
+
+        internal AccessibleRewardData(AccessibleComponent parent, RewardData rewardData) : base(parent)
+        {
+            RewardData = rewardData;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            switch (RewardData.RewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return GetLinesForArcaneDustReward();
+                case Reward.Type.BOOSTER_PACK:
+                    return GetLinesForBoosterPackReward();
+                case Reward.Type.GOLD:
+                    return GetLinesForGoldReward();
+                 case Reward.Type.CARD:
+                    return GetLinesForCardReward();
+                 case Reward.Type.CARD_BACK:
+                    return GetLinesForCardBackReward();
+                 case Reward.Type.MOUNT:
+                    return GetLinesForMountReward();
+                 case Reward.Type.ARCANE_ORBS:
+                    return GetLinesForArcaneOrbsReward();
+                 case Reward.Type.MINI_SET:
+                    return GetLinesForMiniSetReward();
+                 case Reward.Type.FORGE_TICKET:
+                    return GetLinesForForgeTicketReward();
+                 case Reward.Type.CRAFTABLE_CARD:
+                 case Reward.Type.CLASS_CHALLENGE:
+                 case Reward.Type.EVENT:
+                 case Reward.Type.RANDOM_CARD:
+                 case Reward.Type.BONUS_CHALLENGE:
+                 case Reward.Type.ADVENTURE_DECK:
+                 case Reward.Type.ADVENTURE_HERO_POWER:
+                 case Reward.Type.DECK:
+                 default:
+                    var ret = new List<string>();
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN));
+                    return ret;
+            }
+        }
+
+        private List<string> GetLinesForForgeTicketReward()
+        {
+            var ret = new List<string>();
+
+            ForgeTicketRewardData reward = (ForgeTicketRewardData)RewardData;
+
+            var numTickets = reward.Quantity;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_TICKETS, numTickets));
+            return ret;
+        }
+
+        private List<string> GetLinesForMiniSetReward()
+        {
+            var ret = new List<string>();
+
+            MiniSetRewardData reward = (MiniSetRewardData)RewardData;
+
+			MiniSetDbfRecord record = GameDbf.MiniSet.GetRecord(reward.MiniSetID);
+			int count = record.DeckRecord.Cards.Count;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_MINI_SET_WITH_N_CARDS, count));
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneOrbsReward()
+        {
+            var ret = new List<string>();
+
+            SimpleRewardData reward = (SimpleRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_ORBS, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForMountReward()
+        {
+            var ret = new List<string>();
+
+            MountRewardData reward = (MountRewardData)RewardData;
+
+            // Localizing this would be pointless
+            /*switch (reward.Mount)
+            {
+                case MountRewardData.MountType.HEROES_MAGIC_CARPET_CARD:
+                    ret.Add($"You got a Magic Carpet mount in Heroes of the Storm");
+                    break;
+                case MountRewardData.MountType.WOW_HEARTHSTEED:
+                    ret.Add($"You got a Hearthsteed mount in World of Warcraft");
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT));
+                    break;
+                default:
+                    break;
+
+            }*/
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT));
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneDustReward()
+        {
+            var ret = new List<string>();
+
+            ArcaneDustRewardData reward = (ArcaneDustRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForBoosterPackReward()
+        {
+            var ret = new List<string>();
+
+            BoosterPackRewardData reward = (BoosterPackRewardData)RewardData;
+
+            var numPacks = reward.Count;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, numPacks));
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetCardPackName(reward.Id), ret);
+
+            return ret;
+        }
+
+        private List<string> GetLinesForGoldReward()
+        {
+            var ret = new List<string>();
+
+            GoldRewardData reward = (GoldRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            CardRewardData reward = (CardRewardData)RewardData;
+
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(reward.CardID);
+            if (entityDef.IsHeroSkin())
+            {
+                return GetLinesForUnlockedHero(reward);
+            }
+            else
+            {
+                var ret = new List<string>();
+                var numCards = reward.Count;
+                var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, reward.Premium);
+                var cardClass = GameStrings.GetClassName(entityDef.GetClass());
+
+                if (entityDef.IsCoreCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CORE_CARD_FROM_CLASS, numCards, cardClass));
+                }
+                else
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CARD_FROM_CLASS, numCards, cardClass));
+                }
+
+                ret.AddRange(new AccessibleCollectibleCard(m_parent, collectibleCard, false).GetLines());
+
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForUnlockedHero(CardRewardData reward)
+        {
+            var ret = new List<string>();
+
+            var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, TAG_PREMIUM.NORMAL);
+            var heroName = collectibleCard.Name;
+            var className = GameStrings.GetClassName(DefLoader.Get().GetEntityDef(reward.CardID).GetClass());
+
+            if (reward.Premium == TAG_PREMIUM.GOLDEN)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_GOLDEN_HERO, heroName));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                return ret;
+            }
+            else if (GameUtils.IsVanillaHero(reward.CardID))
+            {
+                var numHeroes = AchieveManager.Get().NumDefaultHeroesUnlocked();
+                var numUnlockedHeroes = AchieveManager.Get().NumDefaultHeroesUnlocked();
+
+                ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_NEW_CLASS_UNLOCKED));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_UNLOCK_PROGRESS, numUnlockedHeroes, numHeroes));
+                return ret;
+            }
+            else
+            {
+                ret.Add(heroName);
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForCardBackReward()
+        {
+            var ret = new List<string>();
+
+            CardBackRewardData reward = (CardBackRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_BACK));
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
new file mode 100644
index 0000000..11ae726
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
@@ -0,0 +1,117 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleRewardItemDataModel : AccessibleItem
+    {
+        private RewardItemDataModel m_reward;
+
+        private List<string> m_cachedLines;
+
+        internal AccessibleRewardItemDataModel(AccessibleComponent parent, RewardItemDataModel reward) : base(parent)
+        {
+            m_reward = reward;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            switch (m_reward.ItemType)
+            {
+                case RewardItemType.BOOSTER:
+                    //return AsList($"{m_reward.Quantity} {m_reward.Booster.BoosterName} card pack{suffix}"); Would be hard to localize
+                    return GetLinesForCardPackReward();
+                case RewardItemType.DUST:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, m_reward.Quantity));
+                case RewardItemType.HERO_SKIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_HERO_SKINS, m_reward.Quantity));
+                case RewardItemType.CARD_BACK:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_BACKS, m_reward.Quantity));
+                /*case RewardItemType.ADVENTURE_WING:
+                    return AsList($"{m_reward.Quantity} Adventure Wing{suffix}");*/
+                case RewardItemType.ARENA_TICKET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARENA_TICKETS, m_reward.Quantity));
+                /*case RewardItemType.RANDOM_CARD:
+                    return AsList($"{m_reward.Quantity} random card{suffix}");*/
+                case RewardItemType.RUNESTONES:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_RUNESTONES, m_reward.Quantity));
+                case RewardItemType.ARCANE_ORBS:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_ORBS, m_reward.Quantity));
+                case RewardItemType.ADVENTURE:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ADVENTURES, m_reward.Quantity));
+                case RewardItemType.CARD:
+                    return GetLinesForCardReward();
+                /*case RewardItemType.BATTLEGROUNDS_BONUS:
+                    return AsList($"{m_reward.Quantity} Battlegrounds bonus{bonusSuffix}");*/
+                case RewardItemType.TAVERN_BRAWL_TICKET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_TAVERN_BRAWL_TICKETS, m_reward.Quantity));
+                case RewardItemType.GOLD:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, m_reward.Quantity));
+                case RewardItemType.CUSTOM_COIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CUSTOM_COINS, m_reward.Quantity));
+                /*case RewardItemType.PROGRESSION_BONUS:
+                    return AsList($"{m_reward.Quantity} progression bonus{bonusSuffix}");*/
+                case RewardItemType.REWARD_TRACK_XP_BOOST:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_XP_BOOST, m_reward.Quantity));
+                case RewardItemType.MINI_SET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_MINI_SETS, m_reward.Quantity));
+                /*case RewardItemType.CARD_SUBSET:
+                    return AsList($"{m_reward.Quantity} Card subset{suffix}");
+                case RewardItemType.SELLABLE_DECK:
+                    return AsList($"{m_reward.Quantity} Sellable deck{suffix}");*/
+                case RewardItemType.BATTLEGROUNDS_HERO_SKIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS, m_reward.Quantity));
+                case RewardItemType.BATTLEGROUNDS_GUIDE_SKIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS, m_reward.Quantity));
+                default:
+                    var ret = new List<string>();
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN));
+                    return ret;
+            }
+        }
+
+        private List<string> GetLinesForCardPackReward()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, m_reward.Quantity));
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetCardPackName((int)m_reward.Booster.Type), ret);
+
+            return ret;
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CARD, m_reward.Quantity));
+
+            var card = CollectionManager.Get().GetCard(m_reward.Card.CardId, m_reward.Card.Premium);
+            var accessibleCard = new AccessibleCollectibleCard(m_parent, card, false);
+
+            ret.AddRange(accessibleCard.GetLines());
+
+            return ret;
+        }
+
+        private List<string> AsList(string str)
+        {
+			var ret = new List<string>();
+			ret.Add(str);
+			return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
new file mode 100644
index 0000000..95f52a6
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
@@ -0,0 +1,35 @@
+﻿using System;
+using System.Collections.Generic;
+using static RewardBoxesDisplay;
+
+namespace Accessibility
+{
+    class AccessibleRewardPackage : AccessibleItem
+    {
+        internal RewardBoxData RewardBoxData { get; }
+
+        internal AccessibleRewardData RewardData { get; }
+
+        internal bool Open { get; set; }
+
+        internal AccessibleRewardPackage(AccessibleComponent parent, RewardBoxData rewardBoxData, RewardData rewardData) : base(parent)
+        {
+            RewardBoxData = rewardBoxData;
+            RewardData = new AccessibleRewardData(parent, rewardData);
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (!Open)
+            {
+                var ret = new List<string>();
+                ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_REWARD_PACKAGE));
+                return ret;
+            }
+            else
+            {
+                return RewardData.GetLines();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs
new file mode 100644
index 0000000..d960e73
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs
@@ -0,0 +1,11 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleScreen : AccessibleComponent
+    {
+        void HandleInput();
+
+        string GetHelp();
+
+        void OnGainedFocus();
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs
new file mode 100644
index 0000000..aa0cd2f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs
@@ -0,0 +1,48 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleScrollbarControl : AccessibleElement
+    {
+        private readonly ScrollbarControl m_scrollbar;
+
+        private Action m_onDone;
+
+        internal AccessibleScrollbarControl(AccessibleComponent parent, ScrollbarControl scrollbar, Action onDone) : base(parent)
+        {
+            m_scrollbar = scrollbar;
+            m_onDone = onDone;
+        }
+
+        public void HandleInput()
+        {
+			if (AccessibleKey.GLOBAL_LEFT.IsPressed())
+            {
+				Inc(-1);
+            }
+			else if (AccessibleKey.GLOBAL_RIGHT.IsPressed())
+            {
+				Inc(1);
+            }
+			else if (AccessibleKey.GLOBAL_BACK.IsPressed() || AccessibleKey.GLOBAL_CONFIRM.IsPressed())
+            {
+                m_onDone();
+            }
+        }
+
+        private void Inc(int sign)
+        {
+            float val = sign >= 0 ? 0.1f : -0.1f;
+
+            float target = m_scrollbar.GetValue() + val;
+
+            m_scrollbar.SetValue(target);
+            m_scrollbar.FireUpdateEvent();
+            m_scrollbar.FireFinishEvent();
+
+            Output(AccessibleSpeech.OPTIONS_SCROLLBAR_STATE(m_scrollbar.GetValue()));
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
new file mode 100644
index 0000000..e117d6b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
@@ -0,0 +1,319 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Runtime.CompilerServices;
+using static Accessibility.HSASpeech;
+
+namespace Accessibility
+{
+    public class AccessibleSpeech
+    {
+        #region Global
+        public static string PRESS_ENTER_TO_START => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM);
+        public static string PRESS_ENTER_TO_CONTINUE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+        public static string PRESS_CONFIRM_ONCE_DONE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_ONCE_DONE, AccessibleKey.CONFIRM);
+        public static string PRESS_BACK_ONCE_DONE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_ONCE_DONE, AccessibleKey.BACK);
+        public static string PRESS_BACK_TO_GO_BACK => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_GO_BACK, AccessibleKey.BACK);
+
+        public static HSASpeech PRESS_ENTER_TO_START_VOICE = CreateSpeech(L10N.Of(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to start");
+        #endregion
+
+        #region Menus
+        private static string MENU_HELP_NO_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HELP_NO_BACK_BUTTON, AccessibleKey.CONFIRM);
+        private static string MENU_HELP_WITH_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HELP_WITH_BACK_BUTTON, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        private static string MENU_HORIZONTAL_HELP_NO_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HORIZONTAL_HELP_NO_BACK_BUTTON, AccessibleKey.CONFIRM);
+        private static string MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        public static string MENU_HELP(bool hasBackButton) => hasBackButton ? MENU_HELP_WITH_BACK_BUTTON : MENU_HELP_NO_BACK_BUTTON;
+        public static string MENU_HORIZONTAL_HELP(bool hasBackButton) => hasBackButton ? MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON : MENU_HORIZONTAL_HELP_NO_BACK_BUTTON;
+        public static string MENU_OPTION(string optionName, int optionNumber, int optionsCount) => LocalizationUtils.Format(LocalizationKey.MENU_OPTION_FORMAT, optionName, optionNumber, optionsCount);
+        public static string MENU_NO_ITEMS_HELP => AccessibleSpeechUtils.CombineSentences(LocalizedText.MENU_NO_ITEMS, PRESS_BACK_TO_GO_BACK);
+        public static string OPTIONS_SCROLLBAR_STATE(float val) => $"{(int)Math.Round(val*100)}";
+        #endregion
+
+        #region Tutorial Progress Screen
+        public static HSASpeech TUTORIAL_WELCOME_BACK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_WELCOME_BACK), "Welcome back to the tutorial");
+        public static HSASpeech TUTORIAL_DEFEATED_HOGGER = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_HOGGER), "You've defeated Hogger");
+        public static HSASpeech TUTORIAL_DEFEATED_MILLHOUSE = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_MILLHOUSE), "You've defeated Millhouse Manastorm");
+        public static HSASpeech TUTORIAL_DEFEATED_CHO = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_CHO), "You've defeated Lorewalker Cho");
+        public static HSASpeech TUTORIAL_DEFEATED_MUKLA = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_MUKLA), "You've defeated King Mukla");
+        public static HSASpeech TUTORIAL_DEFEATED_NESINGWARY = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_NESINGWARY), "You've defeated Hemet Nesingwary");
+        public static HSASpeech TUTORIAL_DEFEATED_ILLIDAN = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_DEFEATED_ILLIDAN), "You've defeated Illidan Stormrage");
+        public static HSASpeech TUTORIAL_NEXT_HOGGER = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_HOGGER), "Your next opponent is Hogger");
+        public static HSASpeech TUTORIAL_NEXT_MILLHOUSE = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_MILLHOUSE), "Your next opponent is Millhouse Manastorm");
+        public static HSASpeech TUTORIAL_NEXT_CHO = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_CHO), "Your next opponent is Lorewalker Cho");
+        public static HSASpeech TUTORIAL_NEXT_MUKLA = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_MUKLA), "Your next opponent is King Mukla");
+        public static HSASpeech TUTORIAL_NEXT_NESINGWARY = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_NESINGWARY), "Your next opponent is Hemet Nesingwary");
+        public static HSASpeech TUTORIAL_NEXT_ILLIDAN = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NEXT_ILLIDAN), "Your next and final opponent is Illidan Stormrage");
+        #endregion
+
+        #region Gameplay Help Speeches
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_HERO_HELP, AccessibleKey.SEE_PLAYER_HERO), $"Press {AccessibleKey.SEE_PLAYER_HERO.ToEnglishString()} to look at your hero");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_OPPONENT_HERO_HELP, AccessibleKey.SEE_OPPONENT_HERO), $"Press {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()} to look at your opponent's hero");
+        public static HSASpeech GAMEPLAY_READ_CARDS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARDS_HELP), "Use the up and down arrow keys to read cards");
+        public static HSASpeech GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CONFIRM_TO_ATTACK_TARGET, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack this target");
+
+        public static HSASpeech GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to summon this minion");
+
+        // General gameplay ones
+        public static HSASpeech GAMEPLAY_OPPONENT_TURN_VOICE = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_OPPONENT_TURN), $"Your opponent is playing");
+        public static HSASpeech GAMEPLAY_CONFIRM_END_TURN_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CONFIRM_END_TURN_HELP, AccessibleKey.CONFIRM, AccessibleKey.END_TURN), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} or {AccessibleKey.END_TURN.ToEnglishString()} to end your turn. Press any other key to cancel");
+        public static HSASpeech GAMEPLAY_SEE_VALID_OPTIONS = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_VALID_OPTIONS, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid options");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_HAND_HELP, AccessibleKey.SEE_PLAYER_HAND), $"Press {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at your hand");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_HAND_HELP, AccessibleKey.SEE_OPPONENT_HAND), $"Press {AccessibleKey.SEE_OPPONENT_HAND.ToEnglishString()} to count the cards in your opponent's hand");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_MINIONS_HELP, AccessibleKey.SEE_PLAYER_MINIONS), $"Press {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to look at your summoned minions");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP, AccessibleKey.SEE_OPPONENT_MINIONS), $"Press {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} to look at your opponent's minions");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_SECRETS_HELP, AccessibleKey.SEE_PLAYER_SECRETS), $"Press {AccessibleKey.SEE_PLAYER_SECRETS.ToEnglishString()} to look at your secrets");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP, AccessibleKey.SEE_OPPONENT_SECRETS), $"Press {AccessibleKey.SEE_OPPONENT_SECRETS.ToEnglishString()} to count your opponent's secrets");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_WEAPON_HELP, AccessibleKey.SEE_PLAYER_WEAPON), $"Press {AccessibleKey.SEE_PLAYER_WEAPON.ToEnglishString()} to read your weapon");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_WEAPON_HELP, AccessibleKey.SEE_OPPONENT_WEAPON), $"Press {AccessibleKey.SEE_OPPONENT_WEAPON.ToEnglishString()} to read your opponent's weapon");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP, AccessibleKey.SEE_PLAYER_HERO_POWER), $"Press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to read your hero power");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP, AccessibleKey.SEE_OPPONENT_HERO_POWER), $"Press {AccessibleKey.SEE_OPPONENT_HERO_POWER.ToEnglishString()} to read your opponent's hero power");
+        public static HSASpeech GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_PLAYER_DECK_HELP, AccessibleKey.SEE_PLAYER_DECK), $"Press {AccessibleKey.SEE_PLAYER_DECK.ToEnglishString()} to count the remaining cards in your deck");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_DECK_HELP, AccessibleKey.SEE_OPPONENT_DECK), $"Press {AccessibleKey.SEE_OPPONENT_DECK.ToEnglishString()} to count the remaining cards in your opponent's deck");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA_HELP, AccessibleKey.SEE_PLAYER_MANA), $"Press {AccessibleKey.SEE_PLAYER_MANA.ToEnglishString()} to read your mana");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_MANA_HELP, AccessibleKey.SEE_OPPONENT_MANA), $"Press {AccessibleKey.SEE_OPPONENT_MANA.ToEnglishString()} to read your opponent's mana");
+        public static HSASpeech GAMEPLAY_READ_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARD_HELP), "Use the up and down arrow keys to read this card");
+        public static HSASpeech GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARD_TOOLTIP_HELP, AccessibleKey.READ_TOOLTIP), $"Press {AccessibleKey.READ_TOOLTIP.ToEnglishString()} to get a description of this card's abilities");
+        public static HSASpeech GAMEPLAY_PLAY_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_PLAY_CARD_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to play this card");
+        public static HSASpeech GAMEPLAY_TRADE_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_TRADE_CARD_HELP, AccessibleKey.TRADE_CARD), $"Press {AccessibleKey.TRADE_CARD.ToEnglishString()} to trade this card");
+        public static HSASpeech GAMEPLAY_SUMMON_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SUMMON_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to summon this minion");
+        public static HSASpeech GAMEPLAY_CHOICE_MODE_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CHOICE_MODE_HELP, AccessibleKey.CONFIRM), $"Use the arrow keys to go through your options. Press {AccessibleKey.CONFIRM.ToEnglishString()} to choose one");
+        public static HSASpeech GAMEPLAY_CHOOSE_TARGET_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CHOOSE_TARGET_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.CONFIRM, AccessibleKey.BACK), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or the Zone keys to go through your targets. Press {AccessibleKey.CONFIRM.ToEnglishString()} to choose a target or {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_WITH_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with this minion");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_WITH_HERO_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with your hero");
+        public static HSASpeech GAMEPLAY_USE_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_USE_HERO_POWER_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to use your hero power");
+        public static HSASpeech GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_THROUGH_VALID_TARGETS, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to read through your valid targets");
+        public static HSASpeech GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_THIS_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack this minion");
+        public static HSASpeech GAMEPLAY_CANCEL_ATTACK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CANCEL_ATTACK_HELP, AccessibleKey.BACK), $"Press {AccessibleKey.BACK.ToEnglishString()} to cancel the attack");
+        public static HSASpeech GAMEPLAY_CANCEL_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CANCEL_HELP, AccessibleKey.BACK), $"Press {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP), $"Use the left and right arrow keys to choose a position for this minion");
+        public static HSASpeech GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_OPEN_HISTORY_LOG_HELP, AccessibleKey.SEE_HISTORY), $"Press {AccessibleKey.SEE_HISTORY.ToEnglishString()} to open the play history log");
+        public static HSASpeech GAMEPLAY_READ_HISTORY_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_HISTORY_HELP, AccessibleKey.BACK), $"Use the up and down arrow keys to read the play history. Press {AccessibleKey.BACK.ToEnglishString()} to close the history log");
+        public static HSASpeech GAMEPLAY_END_TURN_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_END_TURN_HELP, AccessibleKey.END_TURN), $"Press {AccessibleKey.END_TURN.ToEnglishString()} to end your turn");
+        #endregion
+
+        #region Tutorials
+        public static HSASpeech WELCOME_TO_HEARTHSTONE = CreateSpeech(L10N.Of(LocalizationKey.WELCOME_TO_HEARTHSTONE), "Welcome to Hearthstone");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_INTRO), $"I'll be teaching you how to play through a set of six tutorial games");
+        public static HSASpeech TUTORIAL_NARRATOR_HELP_KEYS = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_HELP_KEYS, AccessibleKey.HELP), $"If you ever feel lost, press {AccessibleKey.HELP.ToEnglishString()}. Even after the tutorial or when navigating menus, you can always use {AccessibleKey.HELP.ToEnglishString()} whenever you need help");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO_END = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_INTRO_END), "Alright, let's get on with it");
+        public static HSASpeech TUTORIAL_FREE_STARTING_PACK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_FREE_STARTING_PACK, AccessibleKey.CONFIRM), $"Here's a basic Mage pack of cards to get you started. Press {AccessibleKey.CONFIRM.ToEnglishString()} to open it");
+
+        public static HSASpeech TUTORIAL_NICE_WORK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_WORK), "Nice work");
+        public static HSASpeech TUTORIAL_NICE_JOB = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_JOB), "Nice job");
+        public static HSASpeech TUTORIAL_NICE_ONE = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_ONE), "Nice one");
+        public static HSASpeech TUTORIAL_GOOD_JOB = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_GOOD_JOB), "Good job");
+        public static HSASpeech TUTORIAL_YOU_GOT_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_YOU_GOT_IT), "You got it!");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_REMEMBER_HOW_TO_DO_IT), "Remember how to do it?");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_REMEMBER_HOW_TO_DO_THAT), "Remember how to do that?");
+        public static HSASpeech TUTORIAL_TRY_IT_OUT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_TRY_IT_OUT), "Try it out!");
+        public static HSASpeech TUTORIAL_ALL_RIGHT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ALL_RIGHT), "All right!");
+        public static HSASpeech TUTORIAL_LETS_LEARN_HOW = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_LETS_LEARN_HOW), "Let's learn how");
+        public static HSASpeech TUTORIAL_CAN_YOU_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_CAN_YOU_DO_IT), "Can you do it?");
+        public static HSASpeech TUTORIAL_THINK_YOU_CAN_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_THINK_YOU_CAN_DO_IT), "Think you can do it?");
+        public static HSASpeech TUTORIAL_GOT_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_GOT_IT), "Got it");
+
+        // General tutorial notifications
+        public static HSASpeech TUTORIAL_NO_ENDTURN_ATK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN_ATK), "Not yet! You can still attack");
+        public static HSASpeech TUTORIAL_NO_ENDTURN = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN), "Not yet! You have more cards to play!");
+        public static HSASpeech TUTORIAL_NO_ENDTURN_HP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN_HP, AccessibleKey.SEE_PLAYER_HERO_POWER), $"Not yet! Use your Hero Power. Press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to select it");
+
+        #region Hogger
+        public static HSASpeech TUTORIAL_HOGGER_START = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_START), $"Your first opponent is a gnoll named Hogger. You will be playing as the powerful mage Jaina Proudmoore");
+
+        // Notifications
+        public static HSASpeech TUTORIAL01_HELP_07 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL01_HELP_07), "Save that for the enemy!");
+        public static HSASpeech TUTORIAL01_HELP_08 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL01_HELP_08), "Ignore the puny gnoll and finish off Hogger");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_CARD_READ = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_FORCE_CARD_READ), $"Use the up and down arrow keys to read this card first");
+        public static HSASpeech TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_SUMMON_MINION_FIRST), $"Summon the minion you just got first");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST, AccessibleKey.SEE_OPPONENT_MINIONS), $"Use {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} and the arrow keys to read your opponent's minions first");
+
+        // Turn 2
+        public static HSASpeech TUTORIAL_HOGGER_2_0 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_0), $"When a turn starts, you always begin by drawing a card from your deck. Let's see the one we just drew");
+        public static HSASpeech TUTORIAL_HOGGER_2_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_1, AccessibleKey.SEE_PLAYER_HAND), $"Press  {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at the cards in your hand");
+        // Use the arrow keys to read this card
+        public static HSASpeech TUTORIAL_HOGGER_2_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2), $"Ok, so... This card is a minion named Murloc Raider");
+        public static HSASpeech TUTORIAL_HOGGER_2_2B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2B), $"Minions are creatures that you can summon onto the battlefield to fight for your Hero");
+        public static HSASpeech TUTORIAL_HOGGER_2_2D = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2D), $"This one costs 1 mana to summon and has 2 attack and 1 health");
+        public static HSASpeech TUTORIAL_HOGGER_2_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_3), $"Let's start by summoning this minion");
+        public static HSASpeech TUTORIAL_HOGGER_2_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_4, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_2_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_5, AccessibleKey.CONFIRM, AccessibleKey.BACK), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to confirm or {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech TUTORIAL_HOGGER_2_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_6), $"Minions must wait a turn to attack once they're summoned, so we have nothing left to do");
+        // Press E to end your turn
+
+        // Turn 3
+        public static HSASpeech TUTORIAL_HOGGER_3_0 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_0), "Your opponent's minion attacked your Hero so you took some damage");
+        public static HSASpeech TUTORIAL_HOGGER_3_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_1), "Let's see how much health we have left");
+        // Press V to look at your Hero
+        public static HSASpeech TUTORIAL_HOGGER_3_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_2), $"Use the up and down arrow keys to read your hero card");
+        public static HSASpeech TUTORIAL_HOGGER_3_2_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_2_HELP, AccessibleKey.SEE_PLAYER_HERO), $"Use {AccessibleKey.SEE_PLAYER_HERO.ToEnglishString()} and the arrow keys to find out how much health your Hero has");
+        public static HSASpeech TUTORIAL_HOGGER_3_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_3), $"If your Hero runs out of health, you lose. 28 health is still plenty though");
+        public static HSASpeech TUTORIAL_HOGGER_3_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_4, AccessibleKey.SEE_OPPONENT_HERO), $"Let's look at your opponent's hero now. Press {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_3_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_5), $"Can you find how much health he has?");
+        public static HSASpeech TUTORIAL_HOGGER_3_5_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_5_HELP), $"Use the up and down arrow keys to read your opponent's hero card");
+        // Ues the arrow keys to read cards
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_3_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_6), $"Once your opponent's Hero runs out of health, you win");
+        public static HSASpeech TUTORIAL_HOGGER_3_7 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_7), $"Let's carry on");
+
+        // Turn 4
+        public static HSASpeech TUTORIAL_HOGGER_4_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_1), $"Looks like you got another minion. Can you summon this one yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_1_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_1_HELP, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to summon your minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_2), $"When you already have minions on the battlefield, you can use the left and right arrow keys to select where the new minion will be placed");
+        // Try it out
+        public static HSASpeech TUTORIAL_HOGGER_4_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_4), $"You now have two minions on the battlefield. This one was just summoned so it must wait a turn to attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_5), "Let's learn how to navigate the battlefield");
+        // Press B to look at your summoned minions
+        public static HSASpeech TUTORIAL_HOGGER_4_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_6), $"Use the left and right arrow keys to navigate your minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_6_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_6_HELP, AccessibleKey.SEE_PLAYER_MINIONS), $"Use {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} and the arrow keys to navigate your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_8 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_8, AccessibleKey.SEE_OPPONENT_MINIONS), $"Let's look at your opponent's minions now. Press {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_4_9 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_9), $"Can you read this minion by yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_9_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_9_HELP), $"Use the up and down arrow keys to read your opponent's minions");
+        // You got it
+        public static HSASpeech TUTORIAL_HOGGER_4_10 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_10), $"Let's try to attack this minion now");
+        public static HSASpeech TUTORIAL_HOGGER_4_11 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_11), $"Select the Murloc Raider you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_4_11_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_11_HELP, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to get to your minion and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_12 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_12, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with this minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_13 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_13), $"Can you attack your opponent's minion?");
+        public static HSASpeech TUTORIAL_HOGGER_4_13_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_13_HELP, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to attack your opponent's minion");
+        // Press G to look at your opponent's minions and enter to attack
+        // Nice one
+        public static HSASpeech TUTORIAL_HOGGER_4_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_16), $"Both minions had 2 attack and 1 health so they killed each other");
+        public static HSASpeech TUTORIAL_HOGGER_4_17 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_17), $"Your other minion is still exhausted so there's nothing left to do. Remember how to end your turn?");
+
+        // Turn 6
+        public static HSASpeech TUTORIAL_HOGGER_6_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_1), $"Looks like you got another minion");
+        public static HSASpeech TUTORIAL_HOGGER_6_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_2), $"This means you have two possible options right now");
+        public static HSASpeech TUTORIAL_HOGGER_6_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_3), $"You can either summon the minion you just got, or use the one you summoned last turn to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_4, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.SEE_PLAYER_MINIONS), $"One way to do this would be using keys such as {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at your hand or {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to look at your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_6_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_5), $"However, there's an easier way to do it");
+        // Let's learn how
+        public static HSASpeech TUTORIAL_HOGGER_6_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_6, AccessibleKey.READ_NEXT_VALID_ITEM), $"Press {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_6_7 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_7), $"You're now looking at your first option, which would be to summon the minion you just got");
+        public static HSASpeech TUTORIAL_HOGGER_6_8 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_8, AccessibleKey.READ_NEXT_VALID_ITEM), $"Try pressing {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} again");
+        public static HSASpeech TUTORIAL_HOGGER_6_9 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_9), $"You're now looking at your second option, which would be to attack with the minion you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_6_10 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_10, AccessibleKey.READ_NEXT_VALID_ITEM), $"You can always use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid options, so make sure to remember this key!");
+        public static HSASpeech TUTORIAL_HOGGER_6_12 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_12), $"Alright. Let's begin by summoning the minion we just got"); // TODO: We may be too strict here
+        // Can you do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_12_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_12_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to summon your minion");
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_6_13 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_13), $"Let's try to attack with our other minion now");
+        // Think you can do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_13_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_13_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to find your minion and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_14 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_14), $"You now have another choice to make. You can either attack one of your opponent's minions, or your opponent's hero himself");
+        public static HSASpeech TUTORIAL_HOGGER_6_15 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_15, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.SEE_OPPONENT_HERO), $"You can either use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid targets or select your target directly using {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} or {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_6_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_16), $"Go ahead and choose a target to attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_16_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_16_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        // Nice work
+        public static HSASpeech TUTORIAL_HOGGER_6_21 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_21), $"We're ready to end our turn!");
+
+        // Turn 8
+        public static HSASpeech TUTORIAL_HOGGER_8_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_8_1), $"I'll let you continue playing by yourself. Just let me know if you need anything");
+
+        #endregion
+
+        #region Millhouse
+        public static HSASpeech TUTORIAL_02_HELP_01 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_01), "You gain a Mana Crystal every turn");
+        public static HSASpeech TUTORIAL02_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_03), "Your used Mana Crystals refill each turn");
+        public static HSASpeech TUTORIAL02_HELP_06 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_06), "Get Millhouse!");
+        public static HSASpeech TUTORIAL02_HELP_07 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_07), "Expend your Mana each turn to crush this annoying gnome!");
+
+        public static HSASpeech TUTORIAL_RAID_LEADER_DESCRIPTION = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_RAID_LEADER_DESCRIPTION), "This minion has a power that lasts until he dies");
+        public static HSASpeech TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ARCANE_INTELLECT_DESCRIPTION), "You can have 10 cards in your hand");
+
+        // Turn 1
+        public static HSASpeech TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MILLHOUSE_SEE_MANA_HELP, AccessibleKey.SEE_PLAYER_MANA), $"Press {AccessibleKey.SEE_PLAYER_MANA.ToEnglishString()} at any time to see how much mana you have");
+        #endregion
+
+        #region Lorewalker Cho
+        public static HSASpeech TUTORIAL06_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_03), "Minions with Battlecry do something special when you summon them");
+        public static HSASpeech TUTORIAL_CHO_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_CHO_1), "This Voodoo Doctor healed your opponent's Hero");
+        public static HSASpeech TUTORIAL06_HELP_02 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_02), "When minions fight each other, they both take damage");
+        public static HSASpeech TUTORIAL06_HELP_04 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_04), "Kill enemy minions before they become a problem!");
+        #endregion
+
+        #region King Mukla
+        public static HSASpeech TUTORIAL_MUKLA_START = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START), "In this game, you'll see some cards with abilities you haven't seen before");
+        public static HSASpeech TUTORIAL_MUKLA_START_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START_B, AccessibleKey.READ_TOOLTIP), $"If you run into something you don't understand when reading a card such as Charge or Taunt, press {AccessibleKey.READ_TOOLTIP.ToEnglishString()} to get more information");
+        public static HSASpeech TUTORIAL_MUKLA_START_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START_C, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} whenever you're ready to start");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP), $"This gorilla your opponent just summoned has an ability named Taunt");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_B), $"Minions with Taunt must always be killed before you can attack anyone else");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_C), $"Taunt is an important ability as it can be used to protect your Hero");
+        #endregion
+
+        #region Nesingwary
+        public static HSASpeech TUTORIAL04_HELP_14 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_14), $"Welcome to the Jungle");
+        public static HSASpeech TUTORIAL04_HELP_15 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_15), $"Kill his minions or he'll overwhelm you!");
+        public static HSASpeech TUTORIAL04_HELP_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_16), $"Subdue minions with your hero power and spells!");
+        public static HSASpeech TUTORIAL04_HELP_02 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_02), $"Sheep it!");
+        public static HSASpeech TUTORIAL04_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_03), $"Save that for the Fen Creeper!");
+
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP), $"From now on, your Hero and your opponent's Hero will normally have a Hero Power");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_B), $"Every Hero has its own Hero Power and you can use it once per turn");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_C, AccessibleKey.SEE_PLAYER_HERO_POWER, AccessibleKey.SEE_OPPONENT_HERO_POWER), $"You can always press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to see your Hero Power and {AccessibleKey.SEE_OPPONENT_HERO_POWER.ToEnglishString()} to see your opponent's Hero Power");
+        // Try it out!
+        #endregion
+
+        #region Illidan
+        public static HSASpeech TUTORIAL05_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL05_HELP_03), $"This fight is totally not fair. Blame the terrible game designers");
+        public static HSASpeech TUTORIAL05_HELP_04 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL05_HELP_04), $"Your Taunt minions can protect you from attacks!");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP), $"It looks like your opponent equipped a weapon");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B), $"Weapons are special cards which can be equipped by heroes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C), $"Each weapon has some attack and some durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D), $"Once equipped, heroes can attack other characters during their turn");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E), $"Your opponent equipped Warglaive of Azzinoth: a weapon with 2 attack and 2 durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F), $"This means your opponent's Hero will have 2 attack during his turn, and will be able to attack any of your characters");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G), $"Mages don't often use weapons, but you'll be able to play with some later on once you've unlocked other classes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H, AccessibleKey.SEE_PLAYER_WEAPON, AccessibleKey.SEE_OPPONENT_WEAPON), $"You can press {AccessibleKey.SEE_PLAYER_WEAPON.ToEnglishString()} at any time to see your weapon or {AccessibleKey.SEE_OPPONENT_WEAPON.ToEnglishString()} to see your opponent's one");
+
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP), $"Hear that sound? Weapons lose durability every time their Hero attacks");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B), $"Once they reach 0 durability, they break and the Hero can no longer attack");
+        #endregion
+
+        #endregion
+
+        #region In-game "Tutorials"
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME), $"Every normal game starts with the mulligan phase");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B), $"In this phase, both players can replace cards in their starting hand with random ones from their deck");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use the arrow keys or {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your starting hand");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D, AccessibleKey.MULLIGAN_MARK_CARD), $"If you see a card you don't like, press {AccessibleKey.MULLIGAN_MARK_CARD.ToEnglishString()} to mark it for replacement");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E, AccessibleKey.CONFIRM), $"Once you've marked all cards you'd like to replace, press {AccessibleKey.CONFIRM.ToEnglishString()} to draw new ones and start the game");
+        #endregion
+
+        private static List<HSASpeech> s_speeches;
+        private static Dictionary<string, HSASpeech> s_speechDict;
+
+        private static HSASpeech CreateSpeech(L10N l10n, string value, [CallerMemberName] string key=null)
+        {
+            if (key == null)
+            {
+                throw new ArgumentException($"Invoked CreateSpeech in an invalid context");
+            }
+
+            var newSpeech = new HSASpeech(key, value, l10n);
+            if (s_speeches == null)
+            {
+                s_speeches = new List<HSASpeech>();
+            }
+
+            if (s_speechDict == null)
+            {
+                s_speechDict = new Dictionary<string, HSASpeech>();
+            }
+
+            if (s_speechDict.ContainsKey(key))
+            {
+                throw new ArgumentException($"Fatal error initializing accessible speeches. Found duplicate speech: {key}");
+            }
+
+            s_speeches.Add(newSpeech);
+            s_speechDict.Add(key, newSpeech);
+
+            return newSpeech;
+        }
+
+        public static List<HSASpeech> GetAllSpeeches()
+        {
+            return s_speeches;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
new file mode 100644
index 0000000..75d0eea
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
@@ -0,0 +1,432 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleSpeechMgr : MonoBehaviour
+    {
+        class QueuedHSASpeech
+        {
+            internal HSASpeech Speech;
+            internal bool Interruptable;
+            internal Action OnFinishListener;
+
+            internal void OnFinish()
+            {
+                if (OnFinishListener != null)
+                {
+                    OnFinishListener();
+                }
+            }
+        }
+
+        private Queue<QueuedHSASpeech> m_queuedNarrations = new Queue<QueuedHSASpeech>();
+        private QueuedHSASpeech m_curNarration;
+
+        private Queue<QueuedText> m_queuedTexts = new Queue<QueuedText>();
+        private QueuedText m_curText;
+        private List<QueuedText> m_prevTexts = new List<QueuedText>();
+
+        private List<int> m_WPMSpeeds = new List<int>() { 100, 125, 150, 175, 200, 225, 250, 275, 300, 10000 };
+        private int m_curGameSpeed = 3; // Index based i.e. 150WPM
+        private int m_curCPS = CalcCPS(150);
+        private bool m_gameSpeedOptionLoaded;
+
+        private void Update()
+        {
+            if (Input.anyKeyDown && m_curText != null)
+            {
+                InterruptTexts();
+            }
+
+            if (m_curText == null && m_curNarration == null)
+            {
+                if (m_queuedTexts.Count > 0)
+                {
+                    var nextText = m_queuedTexts.Dequeue();
+                    AccessibleSpeechOptimizer.OptimizeText(nextText, m_prevTexts);
+                    StartCoroutine(OutputText(nextText));
+                }
+                else if (m_queuedNarrations.Count > 0)
+                {
+                    StartCoroutine(Play(m_queuedNarrations.Dequeue()));
+                }
+            }
+        }
+
+        internal void InterruptTexts()
+        {
+            m_curText?.Interrupt();
+
+            while (m_queuedTexts.Count > 0)
+            {
+                var queuedText = m_queuedTexts.Dequeue();
+
+                if (queuedText != null && queuedText.IsNarration())
+                {
+                    return;
+                }
+                queuedText?.Interrupt();
+            }
+        }
+
+        internal void Narrate(bool interruptable, Action onFinish, params HSASpeech[] speeches)
+        {
+            if (IsSpeechAudioAvailable())
+            {
+                foreach (var speech in speeches)
+                {
+                    m_queuedNarrations.Enqueue(new QueuedHSASpeech()
+                    {
+                        Speech = speech,
+                        Interruptable = interruptable,
+                        OnFinishListener = onFinish,
+                    });
+                }
+            }
+            else
+            {
+                foreach (var speech in speeches)
+                {
+                    OutputNarrationAsText(speech.GetLocalizedText());
+                }
+            }
+        }
+
+        internal void InterruptNarrations()
+        {
+            var source = GetAudioSource();
+
+            if (m_curNarration != null)
+            {
+                if (m_curNarration.Interruptable)
+                {
+                    source?.Stop();
+                }
+                else
+                {
+                    return;
+                }
+            }
+
+            while (m_queuedNarrations.Count > 0 && m_queuedNarrations.Peek().Interruptable)
+            {
+                var s = m_queuedNarrations.Dequeue();
+                s?.OnFinish();
+            }
+        }
+
+        internal void InterruptTextSpeeches()
+        {
+            InterruptTexts();
+        }
+
+        private AudioSource GetAudioSource()
+        {
+            return GetComponent<AudioSource>();
+        }
+
+        internal IEnumerator Narrate(HSASpeech speech)
+        {
+            if (!IsSpeechAudioAvailable())
+            {
+                OutputNarrationAsText(speech.GetLocalizedText());
+                yield break;
+            }
+
+            InterruptNarrations();
+
+            var newSpeech = new QueuedHSASpeech
+            {
+                Interruptable = false,
+                Speech = speech
+            };
+
+            m_queuedNarrations.Enqueue(newSpeech);
+
+            while (m_curNarration != newSpeech)
+            {
+                yield return null;
+            }
+
+            while (m_curNarration == newSpeech)
+            {
+                yield return null;
+            }
+        }
+
+        private IEnumerator Play(QueuedHSASpeech speech)
+        {
+            if (speech == null)
+            {
+                yield break;
+            }
+
+            m_curNarration = speech;
+
+            var hsDir = Directory.GetCurrentDirectory();
+            AccessibilityUtils.LogDebug($"CurrentWorkDir: {hsDir}");
+            var speechFileName = speech.Speech.GetFileName();
+            AccessibilityUtils.LogDebug($"Play: {speechFileName}");
+            var speechPath = Path.Combine(hsDir, "Accessibility", "Speeches", speechFileName);
+
+            var uri = new Uri(speechPath);
+            string url = uri.AbsoluteUri;
+
+            WWW www = new WWW(url);
+            yield return www;
+
+            var source = GetAudioSource();
+            source.clip = www.GetAudioClip(false, false, AudioType.OGGVORBIS);
+            source.Play();
+            // TODO: Figure out a way to play with the Narrator volume
+            //SoundManager.Get().Play(source, new SoundDef() { m_IgnoreDucking = true }); Not quite
+            //SoundManager.Get().PlayOneShot(source, null);
+
+            while (source.isPlaying)
+            {
+                yield return null;
+            }
+
+            speech.OnFinish();
+            m_curNarration = null;
+        }
+
+        internal void CalibrateScreenReaderSpeed(KeyCode key)
+        {
+            StartCoroutine(Calibrate(key));
+        }
+
+        private IEnumerator Calibrate(KeyCode key)
+        {
+            var text1 = "Your turn.";
+            var text2 = "You draw Firelands.";
+            var text3 = "You draw Shadow Word: Death.";
+            var text4 = "Your River Crocolisk attacks your opponent's Gurubashi Berserker.";
+
+            yield return RunCalibrationTest(text1, key);
+            yield return RunCalibrationTest(text2, key);
+            yield return RunCalibrationTest(text3, key);
+            yield return RunCalibrationTest(text4, key);
+        }
+
+        private IEnumerator RunCalibrationTest(string text, KeyCode key)
+        {
+            ScreenReader.Output("Ready?");
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            var stopwatch = new Stopwatch();
+            stopwatch.Start();
+            ScreenReader.Output(text);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            stopwatch.Stop();
+
+            LogCalibrationTime(text, stopwatch.ElapsedMilliseconds);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+        }
+
+        private void LogCalibrationTime(string text, float elapsedMillis)
+        {
+            var cps = (1000 * text.Length) / elapsedMillis;
+            var numWords = NumWords(text);
+            var wpm = (1000*60 * numWords) / elapsedMillis;
+
+            AccessibilityUtils.LogDebug($"CPS: {cps} / WPM: {wpm} ({numWords} words in {elapsedMillis}ms) text: {text}");
+        }
+
+        private int NumWords(string text)
+        {
+            var ret = 1;
+
+            foreach (var c in text)
+            {
+                if (c == ' ')
+                {
+                    ret++;
+                }
+            }
+
+            return ret;
+        }
+
+        #region TTS
+
+        private IEnumerator OutputText(QueuedText text)
+        {
+            m_curText = text;
+
+            text.Play();
+
+            while (text.IsPlaying())
+            {
+                yield return null;
+            }
+
+            m_prevTexts.Add(m_curText);
+            m_curText = null;
+        }
+
+        internal void OutputTextAndWait(string text, Action onStart=null, Action onEnd=null)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            if (text.Length == 0)
+            {
+                if (onStart != null) onStart();
+                if (onEnd != null) onEnd();
+                return;
+            }
+
+            m_queuedTexts.Enqueue(new QueuedText(text, onStart, onEnd));
+        }
+
+        internal void OutputNarrationAsText(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, false, true, true));
+        }
+
+        internal void OutputText(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, false, false));
+        }
+
+        internal void OutputTextImmediately(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            InterruptTexts();
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, true, false));
+        }
+
+        internal void IncreaseSpeechRate()
+        {
+            IncWPM(1);
+        }
+
+        internal void DecreaseSpeechRate()
+        {
+            IncWPM(-1);
+        }
+
+        private void IncWPM(int inc)
+        {
+            LoadGameSpeedOptionIfNecessary();
+
+            var curIndex = m_curGameSpeed - 1;
+            var targetIndex = curIndex + inc;
+
+            if (targetIndex < 0 || targetIndex >= m_WPMSpeeds.Count)
+            {
+                return;
+            }
+            else
+            {
+                m_curGameSpeed = targetIndex + 1;
+                UpdateCPS();
+                SaveGameSpeed();
+                ScreenReader.Output(LocalizationUtils.Format(LocalizationKey.GLOBAL_GAME_SPEED, m_curGameSpeed));
+
+                foreach(var text in m_queuedTexts)
+                {
+                    text.UpdateSpeed();
+                }
+            }
+        }
+
+        private void SaveGameSpeed()
+        {
+            Options.Get().SetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+        }
+
+        private void UpdateCPS()
+        {
+            var wpm = m_WPMSpeeds[m_curGameSpeed - 1];
+            m_curCPS = CalcCPS(wpm);
+        }
+
+        private static int CalcCPS(int wpm)
+        {
+            return wpm * 6 / 60;
+        }
+
+        internal int GetCPS()
+        {
+            LoadGameSpeedOptionIfNecessary();
+
+            return m_curCPS;
+        }
+
+        private void LoadGameSpeedOptionIfNecessary()
+        {
+            if (!m_gameSpeedOptionLoaded)
+            {
+                m_gameSpeedOptionLoaded = true;
+
+                int gameSpeed = Options.Get().GetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+
+                int wpmIndex = gameSpeed - 1;
+                if (wpmIndex < 0 || wpmIndex >= m_WPMSpeeds.Count)
+                {
+                    SaveGameSpeed();
+                    return;
+                }
+
+                m_curGameSpeed = gameSpeed;
+                UpdateCPS();
+            }
+        }
+
+        #endregion
+
+        private bool IsSpeechAudioAvailable()
+        {
+            var locale = Localization.GetLocale();
+
+            if (locale == Locale.enUS || locale == Locale.enGB)
+            {
+                return true;
+            }
+
+            if (LocalizationUtils.HasKey(LocalizationKey.TUTORIAL_NARRATOR_INTRO))
+            {
+                return false; // Heuristic: if the narrator intro has been localized, we're distributing a version of HSA with the tutorial translated
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
new file mode 100644
index 0000000..d7d60b6
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
@@ -0,0 +1,265 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleSpeechOptimizer
+    {
+        // TODO: Think about this whole thing re: localization
+
+        public static void OptimizeText(QueuedText text, List<QueuedText> prevTexts)
+        {
+            try
+            {
+                if (text == null)
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndDiedText(text, prevTexts))
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndTookDamageText(text, prevTexts))
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Attack and Died
+
+        private static bool OptimizeAttackAndDiedText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneDied(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            attacker = CleanUpOrderIfNeeded(attacker);
+            defender = CleanUpOrderIfNeeded(defender);
+
+            if (EqualsIgnoreCase(text, $"{attacker} and {defender} died.") ||
+                EqualsIgnoreCase(text, $"{defender} and {attacker} died.") ||
+                EqualsIgnoreCase(text, "All minions died."))
+            {
+                var entityTypes = "minions";
+
+                if (IsHero(attacker) || IsHero(defender))
+                {
+                    entityTypes = "characters";
+                }
+
+                queuedText.UpdateText($"Both {entityTypes} died.");
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{attacker} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(attacker);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{defender} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(defender);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+
+            return false;
+        }
+        private static bool OptimizeAttackAndTookDamageText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneTookDamage(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            var aAndBTookNDamageMatch = Regex.Match(text, $@"{attacker} and {defender} took (.*) damage.");
+            string dmgTaken;
+
+            if (aAndBTookNDamageMatch.Success)
+            {
+                dmgTaken = aAndBTookNDamageMatch.Groups[1].Value;
+            }
+            else
+            {
+                var bAndATookNDamageMatch = Regex.Match(text, $@"{defender} and {attacker} took (.*) damage.");
+
+                if (!bAndATookNDamageMatch.Success)
+                {
+                    return false;
+                }
+                else
+                {
+                    dmgTaken = bAndATookNDamageMatch.Groups[1].Value;
+                }
+            }
+
+            var entityTypes = "minions";
+
+            if (IsHero(attacker) || IsHero(defender))
+            {
+                entityTypes = "characters";
+            }
+            queuedText.UpdateText($"Both {entityTypes} took {dmgTaken} damage.");
+
+            return true;
+        }
+
+        private static string CleanUpOrderIfNeeded(string fullEntityName)
+        {
+            var parts = fullEntityName.Split(' ');
+
+            if (parts.Length == 0)
+            {
+                return fullEntityName;
+            }
+
+            if (EqualsIgnoreCase(parts[0], "your"))
+            {
+                if (parts.Length >= 2 && EqualsIgnoreCase(parts[1], "opponent's"))
+                {
+
+                    if (parts.Length >= 3 && LocalizationUtils.IsOrdinalNumber(parts[2]))
+                    {
+                        return CreateNameWithoutOrder(parts, 2);
+                    }
+                }
+                else if (parts.Length >= 2 && LocalizationUtils.IsOrdinalNumber(parts[1]))
+                {
+                    return CreateNameWithoutOrder(parts, 1);
+                }
+            }
+
+            return fullEntityName;
+        }
+
+        private static string CreateNameWithoutOrder(string[] parts, int orderIndex)
+        {
+            var sb = new StringBuilder();
+
+            for (int i = 0; i < parts.Length; i++)
+            {
+                if (i != orderIndex)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(' ');
+                    }
+
+                    sb.Append(parts[i]);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string SimplifyEntityDiedText(string entity)
+        {
+            if (IsHero(entity))
+            {
+                return $"{entity} died.";
+            }
+            else if (IsOpponentEntity(entity))
+            {
+                return "Your opponent's minion died.";
+            }
+            else if (IsPlayerEntity(entity))
+            {
+                return "Your minion died.";
+            }
+
+            Log.Accessibility.PrintWarning($"Failed to simplify entity died text: {entity}");
+            return entity;
+        }
+
+        private static bool SomeoneDied(string text)
+        {
+            return Regex.Match(text, @"(.*) died.").Success;
+        }
+
+        private static bool SomeoneTookDamage(string text)
+        {
+            return Regex.Match(text, @"(.*) took .* damage.").Success;
+        }
+
+        #endregion
+
+        private static bool IsOpponentEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your opponent's ");
+        }
+
+        private static bool IsPlayerEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your ");
+        }
+
+        private static bool StartsWithIgnoreCase(string s1, string s2)
+        {
+            return s1.ToLowerInvariant().StartsWith(s2.ToLowerInvariant());
+        }
+
+        private static bool IsHero(string entity)
+        {
+            return EqualsIgnoreCase(entity, "Your hero") || EqualsIgnoreCase(entity, "Your opponent's hero");
+        }
+
+        private static bool EqualsIgnoreCase(string a, string b)
+        {
+            return a.Equals(b, StringComparison.InvariantCultureIgnoreCase);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
new file mode 100644
index 0000000..c15c030
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
@@ -0,0 +1,275 @@
+﻿using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class AccessibleSpeechUtils
+    {
+        internal static string GetFullName(Entity entity)
+        {
+            if (entity.IsControlledByFriendlySidePlayer())
+            {
+                return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME, GetName(entity));
+            }
+            else
+            {
+                return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME, GetName(entity));
+            }
+        }
+
+        internal static string GetFullNameInZone(Entity entity)
+        {
+            if (entity.GetZone() == TAG_ZONE.GRAVEYARD ||
+                entity.GetZone() == TAG_ZONE.INVALID ||
+                entity.GetZone() == TAG_ZONE.REMOVEDFROMGAME ||
+                entity.GetZone() == TAG_ZONE.SETASIDE)
+            {
+                return GetFullName(entity);
+            }
+
+            var entitiesInZone = new List<Entity>();
+
+            foreach (var card in entity.GetCard().GetZone()?.GetCards())
+            {
+                entitiesInZone.Add(card.GetEntity());
+            }
+
+            return GetFullNameInList(entity, entitiesInZone);
+        }
+
+        internal static string GetFullNameInList(Entity entity, List<Entity> entitiesInZone)
+        {
+            // TODO: entities are not necessarily in the same zone so there may be cases where this is confusing.. e.g. your X (in your hand) and your X (in your battlefield) did Y
+            // Haven't really run into anything yet so keeping it like this for now
+
+            int entityNum = 0;
+            int entityCount = 0;
+
+            foreach(var ent in entitiesInZone)
+            {
+                if (GetFullName(ent).Equals(GetFullName(entity)))
+                {
+                    entityCount++;
+                }
+
+                if (ent.GetEntityId() == entity.GetEntityId())
+                {
+                    entityNum = entityCount;
+                }
+            }
+
+            if (entityCount <= 1)
+            {
+                return GetFullName(entity);
+            }
+            else
+            {
+                var order = LocalizationUtils.GetOrdinalNumber(entityNum);
+                var entityName = GetName(entity);
+
+                if (entity.IsControlledByFriendlySidePlayer())
+                {
+                    return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST, order, entityName);
+                }
+                else
+                {
+                    return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST, order, entityName);
+                }
+            }
+        }
+
+        internal static string GetName(Entity entity)
+        {
+            if (entity.IsHero())
+            {
+                return GameStrings.GetCardTypeName(entity.GetCardType());
+            }
+            else if (entity.IsHeroPower())
+            {
+                return GameStrings.GetCardTypeName(entity.GetCardType());
+            }
+            else if (entity.GetCardType() == TAG_CARDTYPE.INVALID)
+            {
+                return LocalizedText.GLOBAL_CARD;
+            }
+            else
+            {
+                return entity.GetName();
+            }
+        }
+
+        internal static string GetNames(List<Card> cards)
+        {
+            // Mostly used for mulligan (cards only i.e. no heroes)
+            var nameCounts = new Dictionary<string, int>();
+            var orderedCardNames = new List<string>(); // Could just create an insertion-order dictionary but whatever
+
+            foreach (var card in cards)
+            {
+                var cardName = card.GetEntity().GetName();
+
+                if (nameCounts.ContainsKey(cardName))
+                {
+                    nameCounts[cardName]++;
+                }
+                else
+                {
+                    nameCounts.Add(cardName, 1);
+                    orderedCardNames.Add(cardName);
+                }
+            }
+
+            return HumanizeNames(orderedCardNames, nameCounts);
+        }
+
+        internal static string HumanizeNames(List<string> orderedNames, Dictionary<string, int> nameCounts)
+        {
+            var separator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_SEPARATOR);
+            var finalSeparator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_FINAL_SEPARATOR);
+            var cardString = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+            var cardStringPlural = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD_PLURAL);
+
+            var sb = new StringBuilder();
+            int idx = 0;
+
+            orderedNames = GetDistinct(orderedNames);
+
+            foreach(var name in orderedNames)
+            {
+                if (idx > 0)
+                {
+                    if (idx < orderedNames.Count - 1)
+                    {
+                        sb.Append(separator);
+                    }
+                    else
+                    {
+                        sb.Append(finalSeparator);
+                    }
+                }
+
+                var curNameCount = nameCounts[name];
+
+                if (curNameCount > 1 && name.Equals(cardString))
+                {
+                    sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, curNameCount, cardStringPlural));
+                }
+                else
+                {
+                    sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, curNameCount, name));
+                }
+
+                idx++;
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetDistinct(List<string> elems)
+        {
+            var ret = new List<string>();
+            var handled = new HashSet<string>();
+
+            foreach(var elem in elems)
+            {
+                if (!handled.Contains(elem))
+                {
+                    ret.Add(elem);
+                    handled.Add(elem);
+                } 
+            }
+
+            return ret;
+        }
+
+        public static string HumanizeList(List<string> list)
+        {
+            var separator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_SEPARATOR);
+            var finalSeparator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_FINAL_SEPARATOR);
+
+            if (list.Count == 0)
+            {
+                return "";
+            }
+
+            if (list.Count == 1)
+            {
+                return list[0];
+            }
+            else
+            {
+                var sb = new StringBuilder();
+
+                for (int i = 0; i < list.Count - 1; i++)
+                {
+                    if (i != 0)
+                    {
+                        sb.Append(separator);
+                    }
+
+                    sb.Append(list[i]);
+                }
+
+                sb.Append(finalSeparator);
+                sb.Append(list[list.Count - 1]);
+
+                return sb.ToString();
+            }
+        }
+
+        internal static string CombineLines(List<string> lines)
+        {
+            var sentenceEndingChars = LocalizationUtils.Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+            var period = LocalizationUtils.Get(LocalizationKey.FORMATTING_PERIOD);
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (line.Length == 0)
+                {
+                    continue;
+                }
+
+                if (sb.Length > 0)
+                {
+                    if (!sentenceEndingChars.Contains(sb[sb.Length - 1]))
+                    {
+                        sb.Append(period);
+                    }
+
+                    sb.Append(" ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        internal static string CombineSentences(string a, string b)
+        {
+            var sentenceEndingChars = LocalizationUtils.Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+            var period = LocalizationUtils.Get(LocalizationKey.FORMATTING_PERIOD);
+
+            if (a.Length == 0)
+            {
+                return b;
+            }
+            else if (b.Length == 0)
+            {
+                return a;
+            }
+
+            var lastAChar = a[a.Length - 1];
+            if (sentenceEndingChars.Contains(lastAChar))
+            {
+                return $"{a} {b}";
+            }
+            else
+            {
+                return $"{a}{period} {b}";
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
new file mode 100644
index 0000000..17662cd
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
@@ -0,0 +1,151 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleTutorialProgressScreen : AccessibleScreen
+    {
+        private static AccessibleTutorialProgressScreen s_instance = new AccessibleTutorialProgressScreen();
+
+        internal static AccessibleTutorialProgressScreen Get()
+        {
+            return s_instance;
+        }
+
+        private enum AccessibleTutorialProgressScreenState {
+            READY_TO_START,
+            WAITING_FOR_ANIMATIONS
+        }
+
+        private AccessibleTutorialProgressScreenState m_curState;
+
+        private HeroCoin m_nextOpponentCoin;
+
+        public void OnStartTutorial()
+        {
+            AccessibilityMgr.SetScreen(this);
+            AccessibilityMgr.Output(this, LocalizedText.TUTORIAL_LOADING_TUTORIAL);
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed() && m_curState == AccessibleTutorialProgressScreenState.READY_TO_START)
+            {
+                m_nextOpponentCoin.TriggerRelease();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case AccessibleTutorialProgressScreenState.READY_TO_START:
+                    return AccessibleSpeech.PRESS_ENTER_TO_START;
+                default:
+                    return "";
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+        }
+
+        public void OnDefeatedOpponent(HeroCoin heroCoin)
+        {
+            try
+            {
+                AccessibilityMgr.SetScreen(this);
+
+                var missionId = heroCoin.GetMissionId();
+                ScenarioDbId scenario = (ScenarioDbId)missionId;
+
+                HSASpeech speech = null;
+
+                switch (scenario)
+                {
+                    case ScenarioDbId.TUTORIAL_HOGGER:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_HOGGER;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MILLHOUSE:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_MILLHOUSE;
+                        break;
+                    case ScenarioDbId.TUTORIAL_CHO:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_CHO;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MUKLA:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_MUKLA;
+                        break;
+                    case ScenarioDbId.TUTORIAL_NESINGWARY:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_NESINGWARY;
+                        break;
+                    case ScenarioDbId.TUTORIAL_ILLIDAN:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_ILLIDAN;
+                        break;
+                }
+
+                if (speech != null)
+                {
+                    AccessibilityMgr.NarrateAndWait(speech);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnNextOpponent(HeroCoin heroCoin)
+        {
+            try
+            {
+                AccessibilityMgr.SetScreen(this);
+                m_nextOpponentCoin = heroCoin;
+
+                var missionId = heroCoin.GetMissionId();
+                ScenarioDbId scenario = (ScenarioDbId)missionId;
+
+                HSASpeech speech = null;
+
+                switch (scenario)
+                {
+                    case ScenarioDbId.TUTORIAL_HOGGER:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_HOGGER;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MILLHOUSE:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_MILLHOUSE;
+                        break;
+                    case ScenarioDbId.TUTORIAL_CHO:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_CHO;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MUKLA:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_MUKLA;
+                        break;
+                    case ScenarioDbId.TUTORIAL_NESINGWARY:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_NESINGWARY;
+                        break;
+                    case ScenarioDbId.TUTORIAL_ILLIDAN:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_ILLIDAN;
+                        break;
+                }
+
+                if (speech != null)
+                {
+                    AccessibilityMgr.NarrateAndWait(speech);
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE, () => m_curState = AccessibleTutorialProgressScreenState.READY_TO_START);
+                }
+                else
+                {
+                    Log.Accessibility.PrintWarning($"Failed to describe next tutorial. Unknown tutorial missionID: {scenario}");
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    m_curState = AccessibleTutorialProgressScreenState.READY_TO_START;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs
new file mode 100644
index 0000000..b2f7644
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs
@@ -0,0 +1,9 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleUI : AccessibleComponent
+    {
+        void HandleAccessibleInput();
+
+        string GetAccessibleHelp();
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
new file mode 100644
index 0000000..0306ff0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
@@ -0,0 +1,137 @@
+﻿using UnityEngine;
+
+public class AccessibleUnityInput : IInput
+{
+	private Vector3 m_mousePosition;
+	private bool[] m_buttonIsDown = new bool[3];
+	private bool[] m_buttonWasDown = new bool[3];
+
+	private static AccessibleUnityInput s_instance;
+
+	private static bool m_enabled = true;
+
+	private AccessibleUnityInput() { }
+
+	public static AccessibleUnityInput Get()
+    {
+		if (s_instance == null)
+        {
+			s_instance = new AccessibleUnityInput();
+        }
+
+		return s_instance;
+    }
+
+	public bool GetMousePosition(out Vector3 position)
+	{
+		position = m_mousePosition;
+		return m_enabled;
+	}
+
+	public Vector3 GetMousePosition()
+	{
+		return m_mousePosition;
+	}
+
+	public bool GetAnyKey(out bool value)
+	{
+		value = Input.anyKey;
+		return m_enabled;
+	}
+
+	public bool GetAnyKeyDown(out bool value)
+	{
+		value = Input.anyKeyDown;
+		return m_enabled;
+	}
+
+	public bool GetKey(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKey(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyDown(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyDown(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyUp(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyUp(keycode);
+		return m_enabled;
+	}
+
+	public bool GetMouseButton(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButton on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonDown(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonDown on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = !m_buttonWasDown[button] && m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonUp(int button, out bool value)
+	{
+        if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonUp on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonWasDown[button] && !m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	internal void SetMousePosition(Vector3 pos)
+    {
+		m_mousePosition = pos;
+    }
+
+	// Must only be called once per frame per button!
+	internal void SetMouseButtonDown(int button, bool isDown)
+    {
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to SetMouseButtonDown on invalid button {button}");
+			return;
+        }
+
+		m_buttonWasDown[button] = m_buttonIsDown[button];
+		m_buttonIsDown[button] = isDown;
+    }
+
+	internal void ToggleEnabled()
+    {
+		m_enabled = !m_enabled;
+    }
+
+	private bool IsValidButton(int button)
+    {
+		return button >= 0 && button <= 2;
+    }
+
+	internal bool Enabled
+    {
+		get { return m_enabled;  }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs b/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
new file mode 100644
index 0000000..114321a
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
@@ -0,0 +1,429 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    public class CardEffectInterpreter
+    {
+        private static HashSet<string> friendlyCards = new HashSet<string>() { "AT_002", "AT_006", "AT_009", "AT_010", "AT_013", "AT_015", "AT_016", "AT_018", "AT_019", "AT_019e", "AT_024", "AT_028", "AT_029", "AT_031", "AT_033", "AT_035", "AT_035t", "AT_037b", "AT_038", "AT_039", "AT_040", "AT_041", "AT_042", "AT_043", "AT_046", "AT_047", "AT_048", "AT_049", "AT_053", "AT_054", "AT_055", "AT_057", "AT_058", "AT_060", "AT_061", "AT_062", "AT_066", "AT_068", "AT_069", "AT_072", "AT_073", "AT_074", "AT_076", "AT_077", "AT_079", "AT_082", "AT_083", "AT_084", "AT_089", "AT_090", "AT_091", "AT_096", "AT_099", "AT_100", "AT_104", "AT_108", "AT_111", "AT_112", "AT_113", "AT_115", "AT_115e", "AT_118", "AT_119", "AT_127", "AT_128", "AT_132", "AT_132_WARLOCKa", "AT_132_WARLOCKb", "AT_133", "BAR_021", "BAR_025", "BAR_026", "BAR_030", "BAR_031", "BAR_034", "BAR_034t", "BAR_034t2", "BAR_037", "BAR_038", "BAR_041", "BAR_042", "BAR_060", "BAR_061", "BAR_063", "BAR_065", "BAR_070", "BAR_072", "BAR_073", "BAR_077", "BAR_079t10", "BAR_079t10b", "bar_079t10c", "BAR_079t11", "BAR_079t15", "BAR_079t15b", "BAR_079t15c", "BAR_080", "BAR_081", "BAR_308", "BAR_309", "BAR_310", "BAR_318", "BAR_321", "BAR_323", "BAR_324", "BAR_325", "BAR_326", "BAR_327", "BAR_328", "BAR_329", "BAR_330", "BAR_533", "BAR_534", "BAR_535", "BAR_537e", "BAR_539", "BAR_540", "BAR_542", "BAR_546", "BAR_549", "BAR_550", "BAR_551", "BAR_552e", "BAR_552o", "BAR_721t", "BAR_751", "BAR_812", "BAR_841", "BAR_842", "BAR_842t", "BAR_842t2", "BAR_843", "BAR_854e", "BAR_873", "BAR_880", "BAR_880t", "BAR_880t2", "BAR_881", "BAR_888", "BAR_891", "BAR_891t", "BAR_891t2", "BAR_896", "BAR_914", "BAR_914t", "BAR_914t2", "BAR_915", "BAR_COIN1", "BAR_COIN2", "BAR_COIN3", "BCON_004", "BCON_012", "BCON_015", "BCON_016", "BCON_024", "BG20_100", "BG20_100_G", "BG20_101", "BG20_101_G", "BG20_105", "BG20_105_G", "BG20_204", "BG20_GEM", "BG20_GEMt", "BG20_HERO_102p", "BG20_HERO_102pe", "BG20_HERO_201p", "BG20_HERO_201p2", "BG20_HERO_242p", "BG20_HERO_283p_t2", "BGS_001", "BGS_006", "BGS_010", "BGS_012", "BGS_014", "BGS_017", "BGS_018", "BGS_020", "BGS_021", "BGS_023", "BGS_024", "BGS_025", "BGS_028", "BGS_030", "BGS_031", "BGS_038", "BGS_040", "BGS_044", "BGS_046t", "BGS_048", "BGS_053", "BGS_056", "BGS_061", "BGS_069", "BGS_071", "BGS_079", "BGS_080", "BGS_082", "BGS_083", "BGS_112", "BGS_121", "BGS_123", "BGS_128", "BGS_200", "BGS_204", "BGS_Treasures_000", "BGS_Treasures_001", "BGS_Treasures_004", "BGS_Treasures_007", "BGS_Treasures_009", "BGS_Treasures_010", "BGS_Treasures_011", "BGS_Treasures_012", "BGS_Treasures_013", "BGS_Treasures_015", "BGS_Treasures_016", "BGS_Treasures_018", "BGS_Treasures_019", "BGS_Treasures_020", "BGS_Treasures_026", "BGS_Treasures_028", "BGS_Treasures_032", "BOM_003p", "BOM_01_ArrivalInOrgrimmar_01s", "BOM_01_Brukan_01p", "BOM_01_ForTheHorde_05s", "BOM_01_Golem_05p", "BOM_01_Guff_03p2", "BOM_01_Guff_04p2", "BOM_01_Guff_05p2", "BOM_01_Guff_06p2", "BOM_01_Guff_07p2", "BOM_01_HezrulBloodmark_02p", "BOM_01_IshaAwak_04p", "BOM_01_Plaguemaw_03p", "BOM_01_PrideOfTheFrostwolves_0", "BOM_01_StrengthAndHonor_05s_Copy", "BOM_01_Tamsin_03t", "BOM_01_Tamsin_04p3", "BOM_01_Tamsin_05p3", "BOM_01_Tamsin_06p3", "BOM_01_Tamsin_07p3", "BOM_02_AWildAnimal_01s", "BOM_02_Garona_008hb", "BOM_02_Kargal_01p", "BOM_02_Octobot_07p", "BOM_02_OneCoin_01s", "BOM_02_SludgeBeast_03p", "BOM_02_TavishSharesHisLoot_01s", "BOM_02_TavishTamesABeast_01s", "BOM_02_ThreeCoins_01s", "BOM_02_TwoCoins_01s", "BOM_02_Whirleygig_04p", "BOM_02_Xyrella_01p1", "BOM_02_Xyrella_01p2", "BOM_02_XyrellasPrayer_06s", "BOM_03_Anacondra_06p", "BOM_03_AngryTreant_01p", "BOM_03_Barak_03p", "BOM_03_Dawngrasp_02p", "BOM_03_Guff_01p", "BOM_03_Guff_08p", "BOM_03_GuffTrips_01s", "BOM_03_Mutanus_07p", "BOM_03_Party_05p", "BOM_03_RestAndRelaxation_03s", "BOM_03_Rokara_02p", "BOM_03_Smythe_04p", "BOM_03_Snapjaw_04s", "BOM_03_Tamsin_08t", "BOM_03_Vapos_02p", "BOM_04_Aquarrior_006t", "BOM_04_BurningBladeSummoner_005t", "BOM_04_Cariel_005p", "BOM_04_Cariel_006p", "BOM_04_Kurtrus_001p4", "BOM_04_Tamsin_008p", "BOM_04_TamsinsPerfume_008s", "BOM_04_Tavish_005p", "BOM_04_Tavish_006p", "BOM_04_Xyrella_005p", "BOM_04_Xyrella_006p", "BOT_034", "BOT_038", "BOT_042", "BOT_054", "BOT_066", "BOT_067", "BOT_069", "BOT_079", "BOT_083", "BOT_084", "BOT_087", "BOT_093", "BOT_099", "BOT_101", "BOT_218", "BOT_219", "BOT_219t", "BOT_224", "BOT_226", "BOT_234", "BOT_238p2", "BOT_238p4", "BOT_238p6", "BOT_242", "BOT_243", "BOT_254", "BOT_256", "BOT_258e", "BOT_263", "BOT_267", "BOT_270", "BOT_280", "BOT_283", "BOT_286", "BOT_288", "BOT_291", "BOT_299", "BOT_312", "BOT_312e", "BOT_401", "BOT_402", "BOT_404", "BOT_407", "BOT_411e", "BOT_411e2", "BOT_413", "BOT_419", "BOT_420", "BOT_422", "BOT_422a", "BOT_422b", "BOT_429", "BOT_431", "BOT_433", "BOT_435", "BOT_436", "BOT_437", "BOT_438", "BOT_438e", "BOT_443", "BOT_444", "BOT_444e", "BOT_445", "BOT_451", "BOT_507", "BOT_508", "BOT_509", "BOT_511", "BOT_517", "BOT_521", "BOT_529", "BOT_532", "BOT_533", "BOT_535", "BOT_537", "BOT_539", "BOT_562", "BOT_565", "BOT_567", "BOT_568", "BOT_573", "BOT_576", "BOT_600", "BOT_700", "BOT_700e", "BOT_908", "BOT_909", "BOT_910", "BOT_912", "BOT_913", "BOTA_203", "BOTA_207", "BOTA_211", "BOTA_231", "BOTA_231e", "BOTA_232", "BOTA_241", "BRM_001", "BRM_006", "BRM_007", "BRM_012", "BRM_017", "BRM_018", "BRM_018e", "BRM_019", "BRM_022", "BRM_026", "BRM_027", "BRM_030", "BRMA_01", "BRMA01_4", "BRMA02_2", "BRMA02_2_2_TB", "BRMA02_2_2c_TB", "BRMA02_2H", "BRMA04_4", "BRMA04_4H", "BRMA06_2", "BRMA06_2H", "BRMA06_2H_TB", "BRMA09_2", "BRMA09_2_TB", "BRMA09_2H", "BRMA09_3", "BRMA09_3H", "BRMA09_4", "BRMA09_4H", "BRMA09_5", "BRMA09_5H", "BRMA10_3", "BRMA10_3H", "BRMA11_2H", "BRMA11_2H_2_TB", "BRMA15_3", "BRMA17_5", "BRMA17_5_TB", "BRMA17_5H", "BRMC_84", "BRMC_87", "BRMC_92", "BRMC_93", "BRMC_95h", "BRMC_95he", "BRMC_96", "BRMC_99", "BT_003", "BT_006", "BT_008", "BT_009", "BT_010", "BT_014", "BT_018", "BT_019t", "BT_021", "BT_022", "BT_024", "BT_025", "BT_025e", "BT_035", "BT_036", "BT_042", "BT_101", "BT_109", "BT_113", "BT_115", "BT_124", "BT_128", "BT_129", "BT_130", "BT_132", "BT_135", "BT_136t", "BT_136ta", "BT_136tb", "BT_142", "BT_155", "BT_159", "BT_160", "BT_160e", "BT_163", "BT_173", "BT_175", "BT_175t", "BT_188", "BT_198", "BT_202", "BT_203", "BT_210", "BT_210t", "BT_212", "BT_213", "BT_214", "BT_249", "BT_252", "BT_253", "BT_257", "BT_292", "BT_300", "BT_302", "BT_304", "BT_306", "BT_309t", "BT_321", "BT_352", "BT_407", "BT_416", "BT_416e", "BT_427", "BT_480", "BT_481", "BT_486", "BT_488", "BT_491", "BT_509", "BT_512", "BT_702", "BT_703", "BT_707", "BT_709", "BT_713", "BT_720", "BT_726", "BT_728", "BT_735", "BT_752", "BT_753", "BT_761", "BT_814", "BT_922", "BTA_01p", "BTA_03", "BTA_05", "BTA_06", "BTA_07", "BTA_08", "BTA_09", "BTA_15", "BTA_16", "BTA_BOSS_03p", "BTA_BOSS_07s4", "BTA_BOSS_10t", "BTA_BOSS_12p", "BTA_BOSS_13p", "BTA_BOSS_14p", "BTA_BOSS_16s", "BTA_BOSS_16t2", "BTA_BOSS_16te3", "BTA_BOSS_22p", "BTA_BOSS_24t", "BTA_BOSS_25p", "BTA_BOSS_26s", "CFM_026", "CFM_061", "CFM_062", "CFM_063", "CFM_064", "CFM_067", "CFM_095", "CFM_120", "CFM_305", "CFM_308", "CFM_308a", "CFM_310", "CFM_312", "CFM_313", "CFM_315", "CFM_316", "CFM_321", "CFM_334", "CFM_336", "CFM_338", "CFM_343", "CFM_344", "CFM_602", "CFM_602a", "CFM_602b", "CFM_604", "CFM_605", "CFM_606", "CFM_610", "CFM_611", "CFM_614", "CFM_616", "CFM_619", "CFM_620", "CFM_621t10", "CFM_621t17", "CFM_621t20", "CFM_621t22", "CFM_621t23", "CFM_621t24", "CFM_621t26", "CFM_621t28", "CFM_621t3", "CFM_621t30", "CFM_621t31", "CFM_621t32", "CFM_621t37", "CFM_621t38", "CFM_621t39", "CFM_621t6", "CFM_621t8", "CFM_621t9", "CFM_626", "CFM_630", "CFM_643", "CFM_648", "CFM_649", "CFM_650", "CFM_651", "CFM_659", "CFM_660", "CFM_661", "CFM_668", "CFM_668t", "CFM_668t2", "CFM_669", "CFM_672", "CFM_685", "CFM_691", "CFM_694", "CFM_713", "CFM_715", "CFM_717", "CFM_750", "CFM_752", "CFM_753", "CFM_755", "CFM_800", "CFM_806", "CFM_811", "CFM_816", "CFM_852", "CFM_853", "CFM_902", "CFM_905", "CFM_940", "CORE_AT_047", "CORE_AT_055", "CORE_AT_061", "CORE_BOT_083", "CORE_BOT_420", "CORE_BOT_533", "CORE_BT_035", "CORE_BT_036", "CORE_BT_416", "CORE_BT_427", "CORE_BT_480", "CORE_BT_491", "CORE_CS2_009", "CORE_CS2_013", "CORE_CS2_023", "CORE_CS2_039", "CORE_CS2_045", "CORE_CS2_073", "CORE_CS2_074", "CORE_CS2_077", "CORE_CS2_088", "CORE_CS2_089", "CORE_CS2_092", "CORE_CS2_117", "CORE_CS2_188", "CORE_DS1_184", "CORE_EX1_011", "CORE_EX1_012", "CORE_EX1_014", "CORE_EX1_046", "CORE_EX1_059", "CORE_EX1_084", "CORE_EX1_093", "CORE_EX1_096", "CORE_EX1_103", "CORE_EX1_110", "CORE_EX1_130", "CORE_EX1_145", "CORE_EX1_158", "CORE_EX1_160", "CORE_EX1_164", "CORE_EX1_165", "CORE_EX1_169", "CORE_EX1_178", "CORE_EX1_188", "CORE_EX1_189", "CORE_EX1_190", "CORE_EX1_193", "CORE_EX1_194", "CORE_EX1_195", "CORE_EX1_248", "CORE_EX1_287", "CORE_EX1_289", "CORE_EX1_294", "CORE_EX1_362", "CORE_EX1_506", "CORE_EX1_509", "CORE_EX1_534", "CORE_EX1_554", "CORE_EX1_571", "CORE_EX1_573", "CORE_EX1_611", "CORE_EX1_623", "CORE_FP1_007", "CORE_FP1_011", "CORE_FP1_020", "CORE_GIL_191", "CORE_GIL_828", "CORE_GVG_053", "CORE_ICC_026", "CORE_ICC_809", "CORE_KAR_009", "CORE_KAR_065", "CORE_KAR_069", "CORE_LOE_012", "CORE_NEW1_018", "CORE_NEW1_026", "CORE_OG_047", "CORE_OG_070", "CORE_OG_241", "CORE_OG_273", "CORE_TRL_243", "CORE_UNG_020", "CRED_02", "CRED_04", "CRED_09", "CRED_103", "CRED_106", "CRED_107", "CRED_109", "CRED_11", "CRED_111", "CRED_115", "CRED_12", "CRED_20", "CRED_25", "CRED_28", "CRED_37", "CRED_41", "CRED_51", "CRED_53", "CRED_57", "CRED_59", "CRED_74", "CRED_75", "CRED_77", "CRED_79", "CRED_80", "CRED_82", "CRED_90", "CRED_91", "CRED_92", "CRED_94", "CRED_95", "CRED_99", "CS1h_001_H1", "CS1h_001_H1_AT_132", "CS1h_001_H2", "CS1h_001_H2_AT_132", "CS1h_001_H3", "CS2_003", "CS2_004", "CS2_004_Puzzle", "CS2_005", "CS2_007", "CS2_009", "CS2_011", "CS2_013", "CS2_013t", "CS2_023", "CS2_027", "CS2_038", "CS2_039", "CS2_041", "CS2_045", "CS2_046", "CS2_049_H1", "CS2_049_H1_AT_132", "CS2_049_H2", "CS2_049_H2_AT_132", "CS2_049_H3", "CS2_049_H3_AT_132", "CS2_049_H4", "CS2_049_H4_AT_132", "CS2_049_H5", "CS2_053", "CS2_053e", "CS2_056_H1", "CS2_056_H2", "CS2_056_H3", "CS2_073", "CS2_074", "CS2_077", "CS2_087", "CS2_088", "CS2_089", "CS2_092", "CS2_101_H1", "CS2_101_H1_AT_132", "CS2_101_H2", "CS2_101_H2_AT_132", "CS2_101_H3", "CS2_101_H3_AT_132", "CS2_101_H4", "CS2_102_H1", "CS2_102_H1_AT_132", "CS2_102_H2", "CS2_102_H2_AT_132", "CS2_102_H3", "CS2_102_H3_AT_132", "CS2_102_H4", "CS2_102_H4_AT_132", "CS2_103", "CS2_104", "CS2_105", "CS2_117", "CS2_147", "CS2_151", "CS2_188", "CS2_196", "CS2_226", "CS2_236", "CS2_237", "CS3_005", "CS3_008e", "CS3_009", "CS3_012e", "CS3_015", "CS3_017", "CS3_024", "CS3_028", "CS3_029", "CS3_033", "CS3_034", "DAL_007", "DAL_008", "DAL_010", "DAL_040", "DAL_049", "DAL_059", "DAL_060", "DAL_062", "DAL_064", "DAL_070", "DAL_077", "DAL_078", "DAL_087", "DAL_088", "DAL_095", "DAL_141", "DAL_141ts", "DAL_146", "DAL_147", "DAL_163", "DAL_256", "DAL_256ts", "DAL_350b", "DAL_351", "DAL_351ts", "DAL_352", "DAL_354", "DAL_355", "DAL_357", "DAL_376", "DAL_377", "DAL_378", "DAL_378ts", "DAL_400", "DAL_413", "DAL_415", "DAL_416", "DAL_422", "DAL_432", "DAL_433", "DAL_544", "DAL_550", "DAL_553", "DAL_554", "DAL_560", "DAL_563", "DAL_565", "DAL_568", "DAL_568ts", "DAL_570", "DAL_575", "DAL_578", "DAL_579p", "DAL_581", "DAL_582", "DAL_582t", "DAL_587", "DAL_589", "DAL_602", "DAL_604", "DAL_607", "DAL_608", "DAL_609", "DAL_613", "DAL_710", "DAL_710e", "DAL_720", "DAL_724", "DAL_727", "DAL_729", "DAL_731", "DAL_733", "DAL_736", "DAL_739", "DAL_741", "DAL_743", "DAL_747", "DAL_752", "DAL_773", "DAL_774", "DAL_799", "DALA_702", "DALA_703", "DALA_704", "DALA_705", "DALA_707", "DALA_708", "DALA_711", "DALA_716", "DALA_717", "DALA_719", "DALA_721", "DALA_725", "DALA_727", "DALA_733", "DALA_736", "DALA_737", "DALA_738", "DALA_740ts5", "DALA_743", "DALA_747e", "DALA_829t", "DALA_854", "DALA_854e", "DALA_854e2", "DALA_902", "DALA_905", "DALA_907", "DALA_908", "DALA_910", "DALA_913", "DALA_BOSS_03p", "DALA_BOSS_03px", "DALA_BOSS_03t3", "DALA_BOSS_03t4", "DALA_BOSS_04p", "DALA_BOSS_05p", "DALA_BOSS_06p", "DALA_BOSS_06px", "DALA_BOSS_09p", "DALA_BOSS_09px", "DALA_BOSS_14p", "DALA_BOSS_14px", "DALA_BOSS_16p", "DALA_BOSS_16px", "DALA_BOSS_18p", "DALA_BOSS_18px", "DALA_BOSS_25t", "DALA_BOSS_27p", "DALA_BOSS_30p", "DALA_BOSS_31p", "DALA_BOSS_31px", "DALA_BOSS_32p", "DALA_BOSS_37p", "DALA_BOSS_37px", "DALA_BOSS_38p", "DALA_BOSS_38px", "DALA_BOSS_38t", "DALA_BOSS_39p", "DALA_BOSS_41p", "DALA_BOSS_41px", "DALA_BOSS_42p", "DALA_BOSS_42px", "DALA_BOSS_44p", "DALA_BOSS_44px", "DALA_BOSS_46p", "DALA_BOSS_46px", "DALA_BOSS_47p", "DALA_BOSS_47px", "DALA_BOSS_51p", "DALA_BOSS_52p", "DALA_BOSS_52px", "DALA_BOSS_53p", "DALA_BOSS_53px", "DALA_BOSS_55p", "DALA_BOSS_55px", "DALA_BOSS_56p", "DALA_BOSS_60p", "DALA_BOSS_60px", "DALA_BOSS_62p", "DALA_BOSS_66p", "DALA_BOSS_67p", "DALA_BOSS_68p", "DALA_BOSS_68px", "DALA_BOSS_69p", "DALA_BOSS_69px", "DALA_BOSS_71p", "DALA_BOSS_71px", "DALA_BOSS_73p", "DALA_BOSS_73px", "DALA_BOSS_74p", "DALA_BOSS_74px", "DALA_BOSS_75p", "DALA_Druid_HP1", "DALA_Druid_HP2", "DALA_Hunter_HP1", "DALA_Hunter_HP2", "DALA_Paladin_HP1", "DALA_Paladin_HP2", "DALA_Priest_HP1", "DALA_Priest_HP2", "DALA_Shaman_HP2", "DALA_Warlock_HP2", "DALA_Warrior_HP2", "DMF_002", "DMF_004t1", "DMF_004t2", "DMF_055", "DMF_056", "DMF_057e", "DMF_057o", "DMF_058", "DMF_058e", "DMF_058o", "DMF_061", "DMF_061a", "DMF_061b", "DMF_061t", "DMF_064", "DMF_065t", "DMF_069", "DMF_073", "DMF_075", "DMF_080", "DMF_083", "DMF_084", "DMF_086", "DMF_088", "DMF_089", "DMF_090", "DMF_090t", "DMF_091", "DMF_100", "DMF_104", "DMF_105", "DMF_105t", "DMF_106", "DMF_107", "DMF_109", "DMF_111", "DMF_113", "DMF_119", "DMF_121", "DMF_122", "DMF_123", "DMF_124", "DMF_124t", "DMF_125", "DMF_163", "DMF_184", "DMF_186", "DMF_186a", "DMF_189", "DMF_194", "DMF_195", "DMF_202", "DMF_219", "DMF_223", "DMF_224", "DMF_224e", "DMF_229", "DMF_235", "DMF_236", "DMF_237", "DMF_238", "DMF_244", "DMF_244t", "DMF_247", "DMF_249", "DMF_254t5", "DMF_511e", "DMF_512", "DMF_513", "DMF_514", "DMF_514t", "DMF_515", "DMF_516", "DMF_517", "DMF_520", "DMF_523", "DMF_525", "DMF_526", "DMF_526a", "DMF_530", "DMF_531", "DMF_534", "DMF_703", "DMF_703t", "DMF_704", "DMF_706", "DMF_707", "DMF_730", "DMF_730t", "DMF_732", "DMF_733", "DMF_734", "DMF_734e", "DMF_COIN1", "DMF_COIN2", "DRG_008", "DRG_010", "DRG_019", "DRG_020", "DRG_024", "DRG_028", "DRG_030", "DRG_031", "DRG_033", "DRG_035", "DRG_036", "DRG_036t", "DRG_049", "DRG_051", "DRG_052", "DRG_054", "DRG_060", "DRG_064", "DRG_070", "DRG_071", "DRG_072", "DRG_074", "DRG_075", "DRG_077", "DRG_084", "DRG_086", "DRG_099", "DRG_099t2", "DRG_099t3", "DRG_102", "DRG_104", "DRG_107", "DRG_202", "DRG_207", "DRG_208", "DRG_215", "DRG_217", "DRG_224", "DRG_225", "DRG_226", "DRG_229", "DRG_233", "DRG_235", "DRG_235e", "DRG_238p", "DRG_238p3", "DRG_238p4", "DRG_238p5", "DRG_250", "DRG_251", "DRG_254", "DRG_255", "DRG_258", "DRG_270", "DRG_270t1", "DRG_270t2", "DRG_301", "DRG_302", "DRG_302e", "DRG_308", "DRG_308e", "DRG_311", "DRG_311a", "DRG_311b", "DRG_312", "DRG_313", "DRG_314", "DRG_315", "DRG_317", "DRG_318", "DRG_320", "DRG_320t", "DRG_323", "DRG_324", "DRG_401", "DRG_401e", "DRG_402", "DRG_610", "DRG_610t2", "DRG_610t3", "DRG_620", "DRG_620t2", "DRG_620t3", "DRG_650", "DRG_650t2", "DRG_650t3", "DRGA_002", "DRGA_011ts5", "DRGA_01q", "DRGA_099t3", "DRGA_BOSS_02t", "DRGA_BOSS_02t3", "DRGA_BOSS_02tt", "DRGA_BOSS_03p", "DRGA_BOSS_03p_H", "DRGA_BOSS_03t", "DRGA_BOSS_03t2", "DRGA_BOSS_05p", "DRGA_BOSS_05p_H", "DRGA_BOSS_05t", "DRGA_BOSS_06t2", "DRGA_BOSS_07t", "DRGA_BOSS_08p", "DRGA_BOSS_08p_H", "DRGA_BOSS_08t", "DRGA_BOSS_08t2", "DRGA_BOSS_09p", "DRGA_BOSS_09p_H", "DRGA_BOSS_09t2", "DRGA_BOSS_11p", "DRGA_BOSS_11p_H", "DRGA_BOSS_11t", "DRGA_BOSS_12p", "DRGA_BOSS_12p_H", "DRGA_BOSS_12t", "DRGA_BOSS_13p", "DRGA_BOSS_13p_H", "DRGA_BOSS_15p", "DRGA_BOSS_18p", "DRGA_BOSS_18p_H", "DRGA_BOSS_21p", "DRGA_BOSS_21t2", "DRGA_BOSS_22p", "DRGA_BOSS_22p_H", "DRGA_BOSS_25p", "DRGA_BOSS_25p_H", "DRGA_BOSS_27p", "DRGA_BOSS_27p_H", "DRGA_BOSS_29p", "DRGA_BOSS_30p", "DRGA_BOSS_30p_H", "DRGA_BOSS_30t2", "DRGA_BOSS_30t4", "DRGA_BOSS_30t6", "DRGA_BOSS_30t7", "DRGA_BOSS_31p", "DRGA_BOSS_31p_H", "DRGA_BOSS_31p2", "DRGA_BOSS_35p", "DRGA_BOSS_36p", "DRGA_BOSS_37p", "DRGA_BOSS_38p", "DS1_055", "DS1_070", "DS1_184", "EX1_011", "EX1_012", "EX1_014", "EX1_014t", "EX1_015", "EX1_019", "EX1_025", "EX1_043", "EX1_046", "EX1_058", "EX1_059", "EX1_076", "EX1_084", "EX1_089", "EX1_093", "EX1_096", "EX1_103", "EX1_110", "EX1_112", "EX1_116", "EX1_128", "EX1_130", "EX1_131", "EX1_132", "EX1_136", "EX1_145", "EX1_145e", "EX1_145o", "EX1_155", "EX1_158", "EX1_158e", "EX1_160", "EX1_160a", "EX1_160b", "EX1_164", "EX1_164a", "EX1_164b", "EX1_165", "EX1_169", "EX1_178", "EX1_180", "EX1_181", "EX1_182", "EX1_183", "EX1_184", "EX1_188", "EX1_189", "EX1_190", "EX1_191", "EX1_192", "EX1_193", "EX1_194", "EX1_195", "EX1_196", "EX1_244", "EX1_248", "EX1_284", "EX1_287", "EX1_289", "EX1_294", "EX1_295", "EX1_316", "EX1_317", "EX1_339", "EX1_345", "EX1_349", "EX1_350", "EX1_354", "EX1_355", "EX1_362", "EX1_363", "EX1_365", "EX1_366", "EX1_371", "EX1_379", "EX1_392", "EX1_409", "EX1_506", "EX1_509", "EX1_533", "EX1_534", "EX1_538", "EX1_549", "EX1_554", "EX1_556", "EX1_562", "EX1_570", "EX1_571", "EX1_573", "EX1_573a", "EX1_573b", "EX1_577", "EX1_583", "EX1_584", "EX1_587", "EX1_590", "EX1_597", "EX1_606", "EX1_611", "EX1_613", "EX1_614", "EX1_621", "EX1_623", "EX1_tk33", "EX1_tk33_2_TB", "FB_Annoyo_001", "FB_BuildABrawl001c", "FB_BuildABrawl001c_ench", "FB_BuildABrawl002a", "FB_BuildABrawl002a_ench", "FB_BuildABrawl002b", "FB_BuildABrawl002b_ench", "FB_BuildABrawl002c", "FB_BuildABrawl003b", "FB_Champs_CS2_013", "FB_Champs_CS2_073", "FB_Champs_CS2_188", "FB_Champs_DAL_736", "FB_Champs_EX1_164", "FB_Champs_EX1_165", "FB_Champs_EX1_169", "FB_Champs_EX1_556", "FB_Champs_EX1_571", "FB_Champs_FP1_028", "FB_Champs_ICC_221", "FB_Champs_ICC_466", "FB_Champs_ICC_705", "FB_Champs_LOOT_080", "FB_Champs_LOOT_080t2", "FB_Champs_LOOT_080t3", "FB_Champs_LOOT_093", "FB_Champs_LOOT_306", "FB_Champs_LOOT_333", "FB_Champs_LOOT_539", "FB_Champs_NEW1_008", "FB_Champs_NEW1_008a", "FB_Champs_NEW1_008b", "FB_Champs_UNG_067", "FB_ELO002", "FB_ELO002_copy", "FB_ELO002a_copy", "FB_ELO002a_ench_copy", "FB_ELO002c", "FB_ELO002c_copy", "FB_ELO002c_ench", "FB_ELO002c_ench_copy", "FB_LK001", "FB_LK002", "FB_LK006", "FB_RagRaid_DeckRefresh", "FB_RagRaid_Draw", "FB_RagRaid_InnkeeperReset", "FB_SPT_Annoyo_HP", "FB_SPT_Annoyo_HP_0", "FB_SPT_Annoyo_HP_1", "FB_Toki_Boss_mental", "FB_Toki_BossSpell_01", "FB_Toki_IncreaseHealth", "FB_Toki_Quest", "FB_Toki_SummonParadoxes", "FB_Toki_TimePortal_Reload", "FB_Toki2_Hero", "FP1_001", "FP1_002", "FP1_003", "FP1_007", "FP1_011", "FP1_012", "FP1_013", "FP1_014", "FP1_015", "FP1_018", "FP1_020", "FP1_023", "FP1_028", "GAME_005", "GIL_116", "GIL_118", "GIL_128", "GIL_145", "GIL_188", "GIL_190", "GIL_191", "GIL_198", "GIL_203", "GIL_507", "GIL_508", "GIL_513", "GIL_531", "GIL_537", "GIL_548", "GIL_553", "GIL_557", "GIL_571", "GIL_577", "GIL_578", "GIL_580", "GIL_581", "GIL_584", "GIL_586", "GIL_607", "GIL_608", "GIL_616", "GIL_616t", "GIL_620", "GIL_637", "GIL_646", "GIL_653", "GIL_661", "GIL_663", "GIL_664", "GIL_665", "GIL_667", "GIL_677", "GIL_682", "GIL_683", "GIL_696", "GIL_803", "GIL_805", "GIL_813", "GIL_815", "GIL_816", "GIL_819", "GIL_827", "GIL_828", "GIL_835", "GIL_836", "GIL_902", "GIL_903", "GILA_400p", "GILA_401", "GILA_410", "GILA_411", "GILA_412", "GILA_500p2", "GILA_503e", "GILA_506t", "GILA_513", "GILA_610", "GILA_802", "GILA_806", "GILA_811", "GILA_816a", "GILA_816b", "GILA_816c", "GILA_817", "GILA_818", "GILA_819", "GILA_824", "GILA_825", "GILA_825e", "GILA_827", "GILA_850b", "GILA_852a", "GILA_852b", "GILA_852c", "GILA_853b", "GILA_903", "GILA_906", "GILA_BOSS_20p", "GILA_BOSS_21p", "GILA_BOSS_31p", "GILA_BOSS_32p", "GILA_BOSS_35p", "GILA_BOSS_37e2", "GILA_BOSS_37p", "GILA_BOSS_37t", "GILA_BOSS_38p", "GILA_BOSS_40p", "GILA_BOSS_43p", "GILA_BOSS_43t", "GILA_BOSS_48p", "GILA_BOSS_49t", "GILA_BOSS_52p", "GILA_BOSS_52p2", "GILA_BOSS_55p", "GILA_BOSS_57t", "GILA_BOSS_58p", "GILA_BOSS_60p", "GILA_BOSS_60t", "GILA_BOSS_99t", "GILA_BOSS_99t2", "GILA_BOSS_99t3", "GVG_003", "GVG_005", "GVG_010", "GVG_011", "GVG_012", "GVG_014", "GVG_017", "GVG_022", "GVG_023", "GVG_025", "GVG_026", "GVG_028t", "GVG_029", "GVG_030", "GVG_031", "GVG_032", "GVG_032a", "GVG_033", "GVG_034", "GVG_035", "GVG_036", "GVG_041", "GVG_041b", "GVG_042", "GVG_043", "GVG_046", "GVG_048", "GVG_053", "GVG_055", "GVG_056", "GVG_057", "GVG_059", "GVG_060", "GVG_061", "GVG_062", "GVG_069", "GVG_078", "GVG_082", "GVG_083", "GVG_092", "GVG_096", "GVG_097", "GVG_102", "GVG_104", "GVG_105", "GVG_107", "GVG_110", "GVG_114", "GVG_115", "GVG_116", "GVG_117", "GVG_118", "HERO_01bp", "HERO_01bp2", "HERO_01dbp", "HERO_01dbp2", "HERO_01fbp", "HERO_01fbp2", "HERO_02bp", "HERO_02bp2", "HERO_02fbp", "HERO_02fbp2", "HERO_02mbp", "HERO_02mbp2", "HERO_04bp", "HERO_04bp2", "HERO_04ebp", "HERO_04ebp2", "HERO_04fbp", "HERO_04fbp2", "HERO_04fbp3", "HERO_04lbp", "HERO_04lbp2", "HERO_07bp", "HERO_07bp2", "HERO_07dbp", "HERO_07dbp2", "HERO_07ebp", "HERO_07ebp2", "HERO_09bp", "HERO_09bp2", "HERO_09dbp", "HERO_09dbp2", "ICC_018", "ICC_019", "ICC_025", "ICC_026", "ICC_027", "ICC_028", "ICC_034", "ICC_039", "ICC_047a", "ICC_050", "ICC_052", "ICC_054", "ICC_056", "ICC_065", "ICC_069", "ICC_079", "ICC_082", "ICC_086", "ICC_089", "ICC_091", "ICC_092", "ICC_093", "ICC_094", "ICC_200", "ICC_201", "ICC_206", "ICC_207", "ICC_213", "ICC_215", "ICC_221", "ICC_235", "ICC_257", "ICC_281", "ICC_289", "ICC_314t1", "ICC_314t2", "ICC_314t4", "ICC_314t7", "ICC_415", "ICC_450", "ICC_466", "ICC_467", "ICC_702", "ICC_705", "ICC_801", "ICC_807", "ICC_808", "ICC_809", "ICC_810", "ICC_812", "ICC_823", "ICC_827", "ICC_827p", "ICC_829p", "ICC_831", "ICC_832", "ICC_832a", "ICC_832b", "ICC_832p", "ICC_833", "ICC_835", "ICC_838", "ICC_854", "ICC_900", "ICC_904", "ICC_912", "ICCA01_004", "ICCA01_009", "ICCA05_002p", "ICCA06_002p", "ICCA08_002p", "ICCA08_027", "KAR_004", "KAR_005", "KAR_009", "KAR_010", "KAR_021", "KAR_025", "KAR_026", "KAR_029", "KAR_030a", "KAR_044", "KAR_057", "KAR_061", "KAR_062", "KAR_065", "KAR_069", "KAR_075", "KAR_077", "KAR_091", "KAR_094", "KAR_095", "KAR_114", "KAR_204", "KAR_205", "KAR_702", "KAR_710", "KAR_A01_02", "KAR_A02_06", "KAR_A02_06H", "KAR_A02_09", "KAR_A02_09H", "KAR_A02_10", "KAR_A02_11", "KAR_A02_13", "KAR_A02_13H", "KAR_A10_05", "KAR_A10_06", "KAR_A10_22", "KARA_00_02", "KARA_00_02H", "KARA_00_04", "KARA_00_04H", "KARA_00_07", "KARA_00_09", "KARA_00_11", "KARA_06_03hp", "KARA_06_03hpheroic", "KARA_07_03", "KARA_07_03heroic", "KARA_07_05", "KARA_07_05heroic", "KARA_07_06", "KARA_07_06heroic", "KARA_07_07", "KARA_07_07heroic", "KARA_07_08", "KARA_07_08heroic", "KARA_08_02", "KARA_08_02H", "KARA_08_04", "KARA_09_03", "KARA_09_03heroic", "KARA_09_05", "KARA_09_05heroic", "KARA_13_02", "KARA_13_02H", "KARA_13_12", "KARA_13_12H", "KARA_13_13", "KARA_13_13H", "LOE_007", "LOE_009", "LOE_012", "LOE_017", "LOE_019", "LOE_019t", "LOE_019t2", "LOE_026", "LOE_039", "LOE_050", "LOE_061", "LOE_079", "LOE_086", "LOE_089", "LOE_105", "LOE_105e", "LOE_110", "LOE_113", "LOE_115", "LOE_115a", "LOE_115b", "LOE_118", "LOE_118e", "LOEA_01", "LOEA_01H", "LOEA02_02", "LOEA02_02h", "LOEA02_03", "LOEA02_04", "LOEA02_05", "LOEA02_06", "LOEA02_10", "LOEA04_28a", "LOEA04_28b", "LOEA04_29a", "LOEA04_29b", "LOEA05_02", "LOEA05_02a", "LOEA05_02h", "LOEA05_02ha", "LOEA05_03", "LOEA05_03h", "LOEA06_02", "LOEA06_02h", "LOEA06_03", "LOEA06_03h", "LOEA07_26", "LOEA07_28", "LOEA09_2", "LOEA09_2H", "LOEA09_3", "LOEA09_3b", "LOEA09_3c", "LOEA09_3d", "LOEA09_3H", "LOEA10_2", "LOEA10_2H", "LOEA10_5", "LOEA10_5H", "LOEA13_2", "LOEA13_2H", "LOEA15_2", "LOEA15_2H", "LOEA16_12", "LOEA16_13", "LOEA16_15", "LOEA16_19", "LOEA16_20", "LOEA16_23", "LOEA16_23H", "LOEA16_3", "LOEA16_7", "LOOT_008", "LOOT_026", "LOOT_026e", "LOOT_033", "LOOT_047", "LOOT_054", "LOOT_054b", "LOOT_054c", "LOOT_054d", "LOOT_056", "LOOT_062", "LOOT_064", "LOOT_064t1", "LOOT_064t2", "LOOT_069", "LOOT_079", "LOOT_080", "LOOT_080t2", "LOOT_080t3", "LOOT_088", "LOOT_091", "LOOT_091t1", "LOOT_091t2", "LOOT_093", "LOOT_103", "LOOT_103t1", "LOOT_103t2", "LOOT_104", "LOOT_106", "LOOT_106t", "LOOT_131", "LOOT_144", "LOOT_152", "LOOT_153", "LOOT_154", "LOOT_161", "LOOT_165", "LOOT_167", "LOOT_170", "LOOT_184", "LOOT_187", "LOOT_203", "LOOT_203t2", "LOOT_203t3", "LOOT_204", "LOOT_209", "LOOT_210", "LOOT_211", "LOOT_214", "LOOT_217", "LOOT_233", "LOOT_278", "LOOT_278t1", "LOOT_278t2", "LOOT_278t3", "LOOT_278t4", "LOOT_285", "LOOT_285t", "LOOT_285t3", "LOOT_285t4", "LOOT_286t1", "LOOT_286t2", "LOOT_286t3", "LOOT_286t4", "LOOT_291", "LOOT_306", "LOOT_309", "LOOT_314", "LOOT_329", "LOOT_333", "LOOT_344", "LOOT_344e", "LOOT_351", "LOOT_353", "LOOT_357", "LOOT_357l", "LOOT_368", "LOOT_370", "LOOT_373", "LOOT_375", "LOOT_380", "LOOT_383", "LOOT_388", "LOOT_392", "LOOT_394", "LOOT_412", "LOOT_413", "LOOT_415", "LOOT_415t1", "LOOT_415t2", "LOOT_415t3", "LOOT_415t4", "LOOT_415t5", "LOOT_420", "LOOT_500", "LOOT_506", "LOOT_507", "LOOT_507t", "LOOT_507t2", "LOOT_511", "LOOT_516", "LOOT_518", "LOOT_519", "LOOT_520", "LOOT_521", "LOOT_526", "LOOT_529", "LOOT_534", "LOOT_535", "LOOT_539", "LOOT_540", "LOOT_541", "LOOT_541t", "LOOT_542", "LOOT_998h", "LOOT_998j", "LOOT_998k", "LOOTA_104", "LOOTA_800", "LOOTA_813", "LOOTA_816", "LOOTA_817", "LOOTA_820", "LOOTA_823", "LOOTA_836", "LOOTA_837", "LOOTA_838", "LOOTA_841", "LOOTA_842b", "LOOTA_BOSS_04p", "LOOTA_BOSS_10p", "LOOTA_BOSS_110", "LOOTA_BOSS_12p", "LOOTA_BOSS_15p", "LOOTA_BOSS_18p", "LOOTA_BOSS_22p", "LOOTA_BOSS_24p", "LOOTA_BOSS_26p5", "LOOTA_BOSS_27p", "LOOTA_BOSS_31p", "LOOTA_BOSS_36p", "LOOTA_BOSS_37p", "LOOTA_BOSS_40p", "LOOTA_BOSS_41p", "LOOTA_BOSS_42p", "LOOTA_BOSS_45p", "LOOTA_BOSS_46p", "LOOTA_BOSS_48p", "LOOTA_BOSS_49p", "NAX1_04", "NAX11_04", "NAX12_04", "NAX13_02", "NAX13_03", "NAX1h_04", "NAX6_03t", "NAX8_02", "NAX8_02H", "NAX8_02H_TB", "NAX8_03", "NAX8_04", "NAX8_05", "NAX9_06", "NAX9_07", "NEW1_008", "NEW1_008a", "NEW1_008b", "NEW1_014", "NEW1_016", "NEW1_018", "NEW1_024", "NEW1_026", "NEW1_031", "NEW1_036", "NEW1_040", "OG_006", "OG_006b", "OG_023", "OG_026", "OG_031", "OG_045", "OG_047", "OG_047a", "OG_047b", "OG_048", "OG_051", "OG_070", "OG_072", "OG_073", "OG_080", "OG_080b", "OG_080d", "OG_080e", "OG_087", "OG_090", "OG_094", "OG_101", "OG_102", "OG_104", "OG_109", "OG_113", "OG_114", "OG_118", "OG_122", "OG_133", "OG_134", "OG_147", "OG_156", "OG_158", "OG_195", "OG_195a", "OG_195b", "OG_198", "OG_202", "OG_202a", "OG_202b", "OG_207", "OG_211", "OG_216", "OG_221", "OG_222", "OG_223", "OG_234", "OG_241", "OG_249", "OG_255", "OG_256", "OG_267", "OG_272", "OG_273", "OG_276", "OG_281", "OG_283", "OG_284", "OG_291", "OG_292", "OG_293", "OG_309", "OG_310", "OG_311", "OG_313", "OG_316", "OG_318", "OG_320", "OG_323", "OG_330", "OG_335", "OG_337", "OG_339", "PART_001", "PART_003", "PART_004", "PART_006", "PART_007", "PCVPDR_SCH_Paladint1", "PRO_001", "PRO_001a", "PRO_001c", "Prologue_Azshara", "Prologue_CenariusHP", "Prologue_ChaosStrike", "Prologue_ManaBurn", "Prologue_MoongladePortal", "Prologue_Ravencrest", "Prologue_Sorcerer", "PVPDR_022", "PVPDR_036", "PVPDR_BAR_Passive01", "PVPDR_BAR_Passive01e1", "PVPDR_BAR_Passive04", "PVPDR_BAR_Passive04e1", "PVPDR_BAR_Passive07", "PVPDR_BAR_Passive07e1", "PVPDR_BAR_Passive08", "PVPDR_BAR_Passive08e1", "PVPDR_BAR_Passive11", "PVPDR_BAR_Passive11e1", "PVPDR_BAR_Passive15", "PVPDR_BAR_Passive15e1", "PVPDR_BAR_Passive17", "PVPDR_BAR_Passive17e1", "PVPDR_BAR_Passive22", "PVPDR_BAR_Passive22e1", "PVPDR_BAR_Passive25", "PVPDR_BAR_Passive25e1", "PVPDR_BAR_Passive26", "PVPDR_BAR_Passive26e1", "PVPDR_BAR_Passive28", "PVPDR_DMF_Hunterp1", "PVPDR_DMF_Huntert2", "PVPDR_DMF_Magep1", "PVPDR_DMF_Paladinp1", "PVPDR_DMF_Paladint2", "PVPDR_DMF_Priestt2", "PVPDR_DMF_Shamant2", "PVPDR_DMF_Warlockp1", "PVPDR_DMF_Warlockt3", "PVPDR_DMF_Warriorp1", "PVPDR_DMF_Warriort1", "PVPDR_DMF_Warriort2", "PVPDR_LOOT_SmartyPants", "PVPDR_SCH_Active03", "PVPDR_SCH_Active08", "PVPDR_SCH_Active11", "PVPDR_SCH_Active14", "PVPDR_SCH_Active17e1", "PVPDR_SCH_Active19", "PVPDR_SCH_Active19e1", "PVPDR_SCH_Active23", "PVPDR_SCH_Active28", "PVPDR_SCH_Active28s1", "PVPDR_SCH_Active28s2", "PVPDR_SCH_Active30", "PVPDR_SCH_Active31", "PVPDR_SCH_Active31s1", "PVPDR_SCH_Active31s2", "PVPDR_SCH_Active34", "PVPDR_SCH_Active35", "PVPDR_SCH_Active35s1", "PVPDR_SCH_Active35s2", "PVPDR_SCH_Active38", "PVPDR_SCH_Active46", "PVPDR_SCH_Active47", "PVPDR_SCH_Active50", "PVPDR_SCH_Active60", "PVPDR_SCH_DemonHunterp1", "PVPDR_SCH_DemonHuntert2", "PVPDR_SCH_Druidp3", "PVPDR_SCH_Druidp3s1", "PVPDR_SCH_Druidp3s3", "PVPDR_SCH_Druidt1s2", "PVPDR_SCH_Druidt2", "PVPDR_SCH_Druidt5", "PVPDR_SCH_Druidt6", "PVPDR_SCH_Huntert2", "PVPDR_SCH_Maget5e", "PVPDR_SCH_Paladinp1", "PVPDR_SCH_Paladint1", "PVPDR_SCH_Passive05", "PVPDR_SCH_Passive05e1", "PVPDR_SCH_Passive12", "PVPDR_SCH_Passive22", "PVPDR_SCH_Passive22e", "PVPDR_SCH_Passive32", "PVPDR_SCH_Passive32e", "PVPDR_SCH_Passive34", "PVPDR_SCH_Passive34e", "PVPDR_SCH_Priestp1", "PVPDR_SCH_Roguet1", "PVPDR_SCH_Roguet2", "PVPDR_SCH_Shamanp1", "PVPDR_SCH_Warlockp3", "PVPDR_SCH_Warlockt2", "PVPDR_SCH_Warlockt5", "PVPDR_SCH_Warriort1", "PVPDR_SW_Passive_01", "PVPDR_SW_Passive_01e1", "PVPDR_YOP_Active01", "PVPDR_YOP_Active02", "PVPDR_YOP_DemHun", "PVPDR_YOP_DemonHunterP1", "PVPDR_YOP_DemonHuntert2", "PVPDR_YOP_HunterT1", "PVPDR_YOP_LocPriT1", "PVPDR_YOP_MageT3", "PVPDR_YOP_PriestP1", "PVPDR_YOP_PriestT2", "PVPDR_YOP_RogMagT1", "PVPDR_YOP_RogueP1", "PVPDR_YOP_ShamanT1", "PVPDR_YOP_ShamanT2", "PVPDR_YOP_WarPalT1", "PVPDR_YOP_WarriorT1", "SCH_120", "SCH_126", "SCH_133", "SCH_136", "SCH_138", "SCH_149", "SCH_157", "SCH_158", "SCH_158e", "SCH_159", "SCH_160", "SCH_162", "SCH_181", "SCH_182", "SCH_199t10", "SCH_199t11", "SCH_199t12", "SCH_199t13", "SCH_199t15", "SCH_199t18", "SCH_199t19", "SCH_199t21", "SCH_199t23", "SCH_199t24", "SCH_199t25", "SCH_199t26", "SCH_199t27", "SCH_199t28", "SCH_199t3", "SCH_199t5", "SCH_199t6", "SCH_199t8", "SCH_199t9", "SCH_224", "SCH_230", "SCH_231", "SCH_232", "SCH_233", "SCH_233e", "SCH_234", "SCH_237", "SCH_237e", "SCH_242", "SCH_243", "SCH_244", "SCH_245", "SCH_247", "SCH_250", "SCH_252", "SCH_259t", "SCH_270", "SCH_270e", "SCH_300", "SCH_300e", "SCH_302", "SCH_305", "SCH_307t", "SCH_311", "SCH_317", "SCH_333", "SCH_333e", "SCH_337", "SCH_340", "SCH_350", "SCH_351", "SCH_352", "SCH_353", "SCH_356", "SCH_357", "SCH_422", "SCH_426", "SCH_427", "SCH_507", "SCH_507e", "SCH_522", "SCH_523", "SCH_524", "SCH_525", "SCH_530", "SCH_532", "SCH_533", "SCH_600", "SCH_603", "SCH_606", "SCH_607b", "SCH_609", "SCH_610", "SCH_612", "SCH_612a", "SCH_612b", "SCH_615", "SCH_617", "SCH_623", "SCH_700", "SCH_702", "SCH_703", "SCH_705", "SCH_706", "SCH_707", "SCH_708", "SCH_709", "SCH_710", "SCH_711", "SCH_714", "Story_01_ArcaneKeysmith", "Story_01_ArchimondeHP", "Story_01_Bigglesworth", "Story_01_CobaltSpellkin", "Story_01_FeralSpirit", "Story_01_GrayCat", "Story_01_JainaMidHP", "Story_01_JainaMidHP2", "Story_01_JainaMidHP3", "Story_01_LibramofWisdom", "Story_01_ThrallHP", "Story_01_Upgrade", "Story_01_VoltaicBurst", "Story_02_BeastCompanion", "Story_02_BloodmaulBrute", "Story_02_Burgle", "Story_02_Cairne", "Story_02_DaelinHP", "Story_02_EVILCableRat", "Story_02_EVILMiscreant", "Story_02_GorgromHP", "Story_02_HenchClanBurglar", "Story_02_Intimidation", "Story_02_Marshspawn", "Story_02_QuilboarHP", "Story_02_RexxarMidHP", "Story_02_RexxarMidHP2", "Story_02_RexxarMidHP3", "Story_02_RexxarWarHP", "Story_02_TeachersPet", "Story_02_Warship", "Story_02_WinkFox", "Story_03_Baine", "Story_03_ChargedDoomhammer", "Story_03_DivineBell", "Story_03_GarroshHP", "Story_03_GarroshHP2", "Story_03_GeyahHP", "Story_03_JainaHP", "Story_03_Karnuk", "Story_03_MightofHellscream", "Story_03_RehgarHP", "Story_03_Rexxar", "Story_03_Runespear", "Story_03_ThrallMinion", "Story_03_YShaarjsPower", "Story_04_AlonsusHP", "Story_04_ArthasHP", "Story_04_ArthasMinion", "Story_04_DarknessBeckons", "Story_04_DivertForces", "Story_04_DragonRoar", "Story_04_FinalStand", "Story_04_Frostmourne", "Story_04_HolyWrath", "Story_04_Jaina", "Story_04_KelThuzad", "Story_04_KingTerenas", "Story_04_LibramofCompassion", "Story_04_LibramofHoliness", "Story_04_SaurfangHP", "Story_04_TimeOut", "Story_04_UnbrokenFaith", "Story_05_AllianceCommander", "Story_05_AllianceCommanderts", "Story_05_AnduinYoungHP", "Story_05_AnduinYoungHP2", "Story_05_Apotheosis", "Story_05_Bananas", "Story_05_FaithsDefender", "Story_05_FaithsDefenderts", "Story_05_JourneyBelow", "Story_05_LightProphecy", "Story_05_Lorthemar", "Story_05_MassResurrection", "Story_05_Mekkatorque", "Story_05_MercifulHeart", "Story_05_MetalBrew", "Story_05_MoiraHP", "Story_05_SaurfangHP", "Story_05_SolvetheRiddles", "Story_05_StewardofScrolls", "Story_05_TownCrier", "Story_05_UndercityHuckster", "Story_05_VarianMinion", "Story_06_CleverDisguise", "Story_06_Daerion_03p", "Story_06_EbonGryphon", "Story_06_FelFuror", "Story_06_FutureGladiator", "Story_06_HastyBlade", "Story_06_Helka_02p", "Story_06_JainaMinion", "Story_06_Kathranatir", "Story_06_Kingslayers", "Story_06_LoGosh", "Story_06_ManaWyrm", "Story_06_NoMercy", "Story_06_Rehgar_01p", "Story_06_RehgarMinion", "Story_06_ShadyBusiness", "Story_06_Steeldancer", "Story_06_ThistleDagger", "Story_06_ToxicVial", "Story_06_Valeera_03p", "Story_06_Valeera_04p", "Story_06_Valeera_06p", "Story_06_Valeera_09p", "Story_06_Varian", "Story_06_WandThief", "Story_06_Wrathion", "Story_06_Wyvern", "Story_07_Archimonde_005p", "Story_07_AthleticStudies", "Story_07_Blackmoore_001p", "Story_07_CallWarchief", "Story_07_DrekThar_002p", "Story_07_DrekTharMinion", "Story_07_EarthenMight", "Story_07_ElementalGathering", "Story_07_EventheOdds", "Story_07_FireSpiritWolf", "Story_07_FocusingIrisSpell", "Story_07_Jaina_007p", "Story_07_Kalecgos", "Story_07_PepTalk", "Story_07_RegenerativeBlood", "Story_07_SpiritofAirt", "Story_07_SpiritofEartht", "Story_07_SpiritoftheWildt", "Story_07_SpiritofWatert", "Story_07_Taretha", "Story_07_TarethasMemory", "Story_07_TarethasMemorye", "Story_07_Thrall_006p", "Story_07_Thrall_007p", "Story_07_Warmaster", "Story_07_WildSpiritWolf", "Story_08_AncientofWind", "Story_08_AncientofWindta", "Story_08_AncientofWindtb", "Story_08_ArchdruidsBlessing", "Story_08_Archimonde_004p", "Story_08_Cenarius_001p", "Story_08_CenariusMinion", "Story_08_DarnassianNightsaber", "Story_08_EmeraldExplorer", "Story_08_Fertilize", "Story_08_ForestOwl", "Story_08_Gibberling", "Story_08_Guidance", "Story_08_Malfurion_007p", "Story_08_Malfurion_008p", "Story_08_MalfurionBear", "Story_08_MalfurionBear_001p", "Story_08_MalfurionCat", "Story_08_MalfurionCat_001p", "Story_08_Naisha", "Story_08_NatureStudies", "Story_08_Planting", "Story_08_Powershifting", "Story_08_TyrandePriestess", "Story_08_UndercityHuckster", "Story_08_WellofEternity", "Story_08_WildStag", "Story_09_AnimatedBroomstick", "Story_09_CacheofCash", "Story_09_CurseofWeakness", "Story_09_DragonEggPuzzle", "Story_09_ElekkGrazer", "Story_09_FelLordBetrug", "Story_09_FiendishCircle", "Story_09_FontofPower", "Story_09_Guldan_001p", "Story_09_Guldan_002p", "Story_09_HandofGuldan", "Story_09_Helboar", "Story_09_HoardingDragon", "Story_09_HungryDragon", "Story_09_PrimordialProtector", "Story_09_PrimordialStudies", "Story_09_RavenFamiliar", "Story_09_RingToss", "Story_09_RingTosst", "Story_09_SenseDemons", "Story_09_ServantofKalimos", "Story_09_ShadowCouncil", "Story_09_ShadowCouncil_Puzzle", "Story_09_ShadowreaverWarlock", "Story_09_Soularium", "Story_09_Soulwringer", "Story_09_SpiritJailer", "Story_09_TerongorShaman", "Story_09_ViciousFelhound", "Story_09_VioletWurm", "Story_09_ZuluhedMinion", "Story_10_BloodElfAllies", "Story_10_BrokenAllies", "Story_10_BrothersStormrage_004", "Story_10_FatesDemand", "Story_10_GreaterMyrmidon", "Story_10_Illidan_003p", "Story_10_Illidan_004p", "Story_10_Illidan_005p", "Story_10_Illidan_006p", "Story_10_Illidan_008p", "Story_10_IllidariStudies", "Story_10_KaldoreiMemories", "Story_10_LadyVashj2", "Story_10_LordofOutland", "Story_10_Malfurion_004p", "Story_10_MoargPainsmith", "Story_10_MurgulReaver", "Story_10_NagaAllies", "Story_10_NagaMyrmidon", "Story_10_ParasiticShadowfiend", "Story_10_PrimordialStudies", "Story_10_SecondSlice", "Story_10_ShadowStrike", "Story_10_SkullofGuldanSpell", "Story_10_SummonShadowDemons", "Story_10_Tranquility", "Story_10_TwinSlice", "Story_10_UnleashedTerrorguard", "Story_10_Velas_004p", "Story_10_VengefulCryptLord", "Story_10_WardensDetermination", "SW_001e", "SW_006", "SW_021", "SW_023", "SW_026", "SW_028", "SW_028t5", "SW_028t6", "SW_029", "SW_031", "SW_031t", "SW_034", "SW_035", "SW_039t3", "SW_041", "SW_042", "SW_045", "SW_049", "SW_052", "SW_052t", "SW_052t6", "SW_054", "SW_056", "SW_059", "SW_064", "SW_065", "SW_067", "SW_068", "SW_070", "SW_076", "SW_079e4", "SW_079e5", "SW_079t", "SW_079te", "SW_081", "SW_085", "SW_086", "SW_087", "SW_087e", "SW_087e2", "SW_087t", "SW_091", "SW_093", "SW_094", "SW_095", "SW_097t", "SW_114", "SW_305", "SW_307", "SW_310", "SW_313", "SW_313t", "SW_313t2", "SW_315", "SW_316", "SW_316e", "SW_320", "SW_400", "SW_405", "SW_411", "SW_418", "SW_418e2", "SW_422", "SW_422a", "SW_422b", "SW_428", "SW_428t", "SW_428t2", "SW_428t4", "SW_429", "SW_432", "SW_432e", "SW_433", "SW_433t", "SW_433t3", "SW_434", "SW_437", "SW_437e", "SW_439", "SW_439t", "SW_440", "SW_443", "SW_443e", "SW_450", "SW_450t", "SW_455", "SW_457", "SW_458", "SW_458e", "SW_462", "SW_462e", "SW_463", "SW_COIN1", "SW_COIN2", "TB_006", "TB_007", "TB_011", "TB_207_BagOfSpells", "TB_207_MaskedBall", "TB_207CatacombQ", "TB_207masterChest", "TB_3Wishes_Spell", "TB_3Wishes_Spell_2", "TB_Bacon_Secrets_01", "TB_Bacon_Secrets_02", "TB_Bacon_Secrets_04", "TB_Bacon_Secrets_05", "TB_Bacon_Secrets_07", "TB_Bacon_Secrets_08", "TB_Bacon_Secrets_10", "TB_Bacon_Secrets_11", "TB_Bacon_Secrets_12", "TB_Bacon_Secrets_13", "TB_BaconShop_HP_001", "TB_BaconShop_HP_008a", "TB_BaconShop_HP_010", "TB_BaconShop_HP_011", "TB_BaconShop_HP_017", "TB_BaconShop_HP_017e", "TB_BaconShop_HP_018", "TB_BaconShop_HP_020", "TB_BaconShop_HP_024", "TB_BaconShop_HP_036", "TB_BaconShop_HP_037a", "TB_BaconShop_HP_038t", "TB_BaconShop_HP_039", "TB_BaconShop_HP_040", "TB_BaconShop_HP_041", "TB_BaconShop_HP_041a", "TB_BaconShop_HP_041b", "TB_BaconShop_HP_041c", "TB_BaconShop_HP_041d", "TB_BaconShop_HP_041f", "TB_BaconShop_HP_041g", "TB_BaconShop_HP_041h", "TB_BaconShop_HP_041i", "TB_BaconShop_HP_047t", "TB_BaconShop_HP_050", "TB_BaconShop_HP_051", "TB_BaconShop_HP_057", "TB_BaconShop_HP_064", "TB_BaconShop_HP_072", "TB_BaconShop_HP_076", "TB_BaconShop_HP_080", "TB_BaconShop_HP_084", "TB_BaconShop_HP_085", "TB_BaconShop_HP_086", "TB_BaconShop_HP_101", "TB_BaconShop_HP_101t2", "TB_BaconShop_HP_103", "TB_BaconShop_HP_106", "TB_BaconShop_HP_107", "TB_BaconShop_Triples_01", "TB_BaconUps_002", "TB_BaconUps_003", "TB_BaconUps_004", "TB_BaconUps_006", "TB_BaconUps_009", "TB_BaconUps_011", "TB_BaconUps_014", "TB_BaconUps_019", "TB_BaconUps_025", "TB_BaconUps_026", "TB_BaconUps_027", "TB_BaconUps_030", "TB_BaconUps_031", "TB_BaconUps_032", "TB_BaconUps_032e", "TB_BaconUps_034", "TB_BaconUps_035", "TB_BaconUps_039", "TB_BaconUps_040", "TB_BaconUps_041", "TB_BaconUps_042", "TB_BaconUps_049", "TB_BaconUps_050", "TB_BaconUps_051", "TB_BaconUps_052", "TB_BaconUps_059", "TB_BaconUps_061", "TB_BaconUps_062", "TB_BaconUps_063", "TB_BaconUps_064", "TB_BaconUps_066", "TB_BaconUps_068", "TB_BaconUps_069", "TB_BaconUps_070", "TB_BaconUps_072", "TB_BaconUps_073", "TB_BaconUps_074", "TB_BaconUps_077", "TB_BaconUps_080", "TB_BaconUps_083", "TB_BaconUps_084", "TB_BaconUps_085", "TB_BaconUps_086", "TB_BaconUps_087", "TB_BaconUps_089", "TB_BaconUps_090", "TB_BaconUps_093", "TB_BaconUps_100", "TB_BaconUps_108", "TB_BaconUps_112", "TB_BaconUps_113", "TB_BaconUps_121", "TB_BaconUps_123", "TB_BaconUps_124", "TB_BaconUps_132t", "TB_BaconUps_137", "TB_BaconUps_138", "TB_BaconUps_139", "TB_BaconUps_140", "TB_BaconUps_141", "TB_BaconUps_142", "TB_BaconUps_144", "TB_BaconUps_145", "TB_BaconUps_152", "TB_BaconUps_154", "TB_BaconUps_162", "TB_BaconUps_165", "TB_Baconups_203", "TB_BaconUps_256", "TB_BaconUps_303", "TB_BaconUps_304", "TB_BaconUps_308", "TB_BaconUps_320", "TB_BBR3_BOSS_02p", "TB_BBR3_Boss_04p", "TB_BBR3_BOSS_05p", "TB_BBR3_BOSS_07p", "TB_BBR3_BOSS_09p", "TB_BlingBrawl_Blade1e", "TB_BossRumble_001hp", "TB_BossRumble_002hp", "TB_BossRumble_003hp", "TB_BRMA10_3H", "TB_Champs_EX1_145", "TB_Champs_EX1_145e", "TB_Champs_EX1_145o", "TB_CheaterChess_Black", "TB_Chupacabran_HP", "TB_CoOpBossSpell_3", "TB_CoOpBossSpell_4", "TB_CoOpv3_003", "TB_CoOpv3_009", "TB_CoOpv3_010", "TB_Coopv3_102", "TB_Coopv3_102b", "TB_Coopv3_104", "TB_Coopv3_104_NewClasses", "TB_DiscoverMyDeck_Discovery", "TB_DK_Guldan", "TB_DK_Jaina", "TB_DK_Malfurion", "TB_DK_Valeera", "TB_DK_Valeera_HP", "TB_EVILBRM_BoomHeroPower", "TB_EVILBRM_GarrSummon", "TB_EVILBRM_LOOTA_813", "TB_EVILBRM_OnyxiaHeroPower", "TB_EVILBRM_RafaamHeroPower", "TB_EVILBRM_RafaamHeroPower2", "TB_Firefest2_003", "TB_Firefest2a", "TB_Firefest2b", "TB_Firefest2c", "TB_Firefest2d", "TB_FW_DrBoomMega", "TB_FW_ImbaTron", "TB_FW_OmegaMax", "TB_GiftExchange_Treasure", "TB_GiftExchange_Treasure_Spell", "TB_GiftReceiptSpell", "TB_HeadlessHorseman_003", "TB_HeadlessHorseman_004", "TB_HeadlessHorseman_HP5", "TB_HeadlessHorseman_HP6", "TB_HeadlessHorseman_s001a", "TB_HeadlessHorseman_s001b", "TB_HeadlessHorseman_s001c", "TB_HeadlessHorseman_s001d", "TB_Henchmania_ChuH", "TB_Henchmania_DiscoverC", "TB_Henchmania_MyraH", "TB_Ignoblegarden1", "TB_Ignoblegarden2", "TB_Ignoblegarden2e", "TB_KaraPortal_001", "TB_KaraPortal_002", "TB_KaraPortal_003", "TB_KoboldGiftMinion", "TB_KT_AnubarakHP", "TB_KTRAF_1", "TB_KTRAF_10", "TB_KTRAF_101", "TB_KTRAF_2", "TB_KTRAF_3", "TB_KTRAF_4", "TB_KTRAF_6", "TB_KTRAF_HP_KT_3", "TB_KTRAF_HP_RAF3", "TB_KTRAF_HP_RAF4", "TB_KTRAF_HP_RAF5", "TB_LEAGUE_REVIVAL_BrannAIHp", "TB_LEAGUE_REVIVAL_FinleyChest", "TB_LEAGUE_REVIVAL_TekahnAIHp", "TB_LEAGUE_REVIVAL_TerravisHp", "TB_LOEA13_2", "TB_Lunar_Dog", "TB_Lunar_DogE", "TB_Lunar_DogEe", "TB_Lunar_Dragon", "TB_Lunar_DragonE", "TB_Lunar_Ox", "TB_Lunar_OxE", "TB_Lunar_Pig", "TB_Lunar_PigE", "TB_Lunar_Rabbit", "TB_Lunar_RabbitE", "TB_Lunar_Rat", "TB_Lunar_RatE", "TB_Lunar_Snake", "TB_Lunar_SnakeE", "TB_Lunar_Tiger", "TB_Lunar_TigerE", "TB_MammothParty_302", "TB_Marin_001", "TB_MechWar_Boss1_HeroPower", "TB_MP_02e", "TB_Noblegarden_005", "TB_Noblegarden_006", "TB_PickYourFate_11b", "TB_PickYourFate_4_EnchMinion", "TB_PickYourFate_6", "TB_Presents_001", "TB_Presents_002", "TB_Presents_003", "TB_ReturningPlayer_HoundmastHP", "TB_RoadToNR_Finley_HP", "TB_RoadToNR_OrgrimmarHP", "TB_RoadToNR_RenoHP", "TB_SC20_001a", "TB_SC20_001b", "TB_SC20_001c", "TB_SC20_002", "TB_SC20_003", "TB_SC20_004", "TB_SPT_BossHeroPower", "TB_SPT_DALA_BossHeroPower", "TB_SPT_DALA_Minion1", "TB_SPT_DALA_Minion3", "TB_SPT_DPromoHP", "TB_SPT_DPromoSecre8", "TB_SPT_DPromoSecret1", "TB_SPT_DPromoSecret10", "TB_SPT_DPromoSecret2", "TB_SPT_DPromoSecret3", "TB_SPT_DPromoSecret4", "TB_SPT_DPromoSecret5", "TB_SPT_DPromoSecret6", "TB_SPT_DPromoSecret9", "TB_SPT_DPromoSpell2", "TB_SPT_DPromoSpellBovine1", "TB_SPT_DPromoSpellPortal2", "TB_SPT_Minion1", "TB_SPT_Minion3", "TB_SPT_MTH_BossHeroPower", "TB_SPT_MTH_Minion1", "TB_SPT_MTH_Minion3", "TB_Superfriends001e", "TB_Superfriends002e", "TB_TagTeam_Warlock", "TB_TempleOutrun_DALA_719", "TB_TempleOutrun_Lazul_HP", "TB_TempleOutrun_Lazul_HP3", "TB_TempleOutrun_Treasure_Reno1", "TB_ThunderdomeWeaponC", "TB_ThunderdomeWeaponD", "TB_ThunderdomeWeaponF", "TBA01_5", "TBA01_6", "TBST_004", "TBUD_1", "TOT_030", "TOT_030t1", "TOT_030t2", "TOT_030t3", "TOT_056", "TOT_067", "TOT_069", "TOT_102", "TOT_103", "TOT_107", "TOT_108", "TOT_111", "TOT_112", "TOT_204", "TOT_308", "TOT_313", "TOT_316", "TOT_320", "TOT_330", "TOT_334", "TOT_341", "TOT_343", "TOT_345", "TRL_010", "TRL_015", "TRL_020", "TRL_058", "TRL_058e", "TRL_071", "TRL_074", "TRL_077", "TRL_082", "TRL_082e", "TRL_096", "TRL_097", "TRL_119", "TRL_124", "TRL_126", "TRL_128", "TRL_131", "TRL_151", "TRL_156", "TRL_232", "TRL_243", "TRL_244", "TRL_247", "TRL_254", "TRL_254a", "TRL_254b", "TRL_255", "TRL_259", "TRL_260", "TRL_302", "TRL_304", "TRL_305", "TRL_306", "TRL_307", "TRL_310", "TRL_310e", "TRL_318", "TRL_324", "TRL_329", "TRL_339", "TRL_349", "TRL_351", "TRL_362", "TRL_363", "TRL_400", "TRL_405", "TRL_503", "TRL_504", "TRL_506", "TRL_507", "TRL_509", "TRL_509t", "TRL_517", "TRL_520", "TRL_521", "TRL_523", "TRL_525", "TRL_527", "TRL_528", "TRL_531", "TRL_537", "TRL_541", "TRL_542", "TRL_566", "TRL_900", "TRL_901", "TRLA_105", "TRLA_106", "TRLA_115", "TRLA_121", "TRLA_122", "TRLA_123", "TRLA_125", "TRLA_127", "TRLA_130", "TRLA_134", "TRLA_135", "TRLA_139", "TRLA_140", "TRLA_144", "TRLA_148", "TRLA_150", "TRLA_151", "TRLA_156", "TRLA_159", "TRLA_161", "TRLA_163", "TRLA_164", "TRLA_165", "TRLA_166", "TRLA_169", "TRLA_170", "TRLA_172", "TRLA_173", "TRLA_176", "TRLA_178", "TRLA_180", "TRLA_184", "TRLA_186", "TRLA_188", "TRLA_192", "TRLA_807", "TRLA_807e2", "TRLA_809", "TRLA_809e2", "tt_010", "TU4c_006", "TU4c_008", "TU4e_002", "TU4f_004", "TU5_CS2_023", "TU5_CS2_147", "TU5_CS2_196", "TU5_DS1_055", "TU5_EX1_011", "TU5_EX1_015", "ULD_131", "ULD_134", "ULD_135", "ULD_135a", "ULD_135b", "ULD_136", "ULD_140", "ULD_140p", "ULD_143", "ULD_145", "ULD_152", "ULD_154", "ULD_155", "ULD_155p", "ULD_156", "ULD_160", "ULD_167", "ULD_171", "ULD_174", "ULD_177", "ULD_178", "ULD_178a", "ULD_178a2", "ULD_178a3", "ULD_178a4", "ULD_183", "ULD_186", "ULD_189", "ULD_191", "ULD_195", "ULD_196", "ULD_197", "ULD_208", "ULD_209", "ULD_209t", "ULD_212", "ULD_216", "ULD_229", "ULD_231", "ULD_236", "ULD_250", "ULD_253", "ULD_256", "ULD_262", "ULD_265", "ULD_266", "ULD_268", "ULD_273", "ULD_285", "ULD_286", "ULD_286t", "ULD_291", "ULD_292", "ULD_292a", "ULD_292b", "ULD_304", "ULD_309", "ULD_326", "ULD_327", "ULD_328", "ULD_413", "ULD_429", "ULD_430", "ULD_431", "ULD_431p", "ULD_433", "ULD_433p", "ULD_438", "ULD_439", "ULD_500", "ULD_616", "ULD_702", "ULD_705", "ULD_711", "ULD_711p3", "ULD_712", "ULD_713", "ULD_715", "ULD_716", "ULD_719", "ULD_720", "ULD_724", "ULD_724p", "ULD_726", "ULD_727", "ULDA_001", "ULDA_002", "ULDA_003", "ULDA_004", "ULDA_004e", "ULDA_008", "ULDA_012", "ULDA_013", "ULDA_014", "ULDA_016", "ULDA_018", "ULDA_021", "ULDA_023", "ULDA_039", "ULDA_040", "ULDA_045t", "ULDA_111", "ULDA_203", "ULDA_205", "ULDA_301", "ULDA_302", "ULDA_303", "ULDA_304", "ULDA_305", "ULDA_307", "ULDA_307ts", "ULDA_402", "ULDA_402e", "ULDA_405", "ULDA_406", "ULDA_407", "ULDA_502", "ULDA_504", "ULDA_507", "ULDA_601", "ULDA_602", "ULDA_603", "ULDA_604", "ULDA_606", "ULDA_607", "ULDA_701e2", "ULDA_712", "ULDA_801t", "ULDA_804t", "ULDA_BOSS_01p", "ULDA_BOSS_01px", "ULDA_BOSS_02p", "ULDA_BOSS_02px", "ULDA_BOSS_03p", "ULDA_BOSS_04p", "ULDA_BOSS_04px", "ULDA_BOSS_07p", "ULDA_BOSS_08p", "ULDA_BOSS_08px", "ULDA_BOSS_09p", "ULDA_BOSS_11p", "ULDA_BOSS_12p", "ULDA_BOSS_12px", "ULDA_BOSS_13p", "ULDA_BOSS_15p", "ULDA_BOSS_15px", "ULDA_BOSS_16e", "ULDA_BOSS_17e", "ULDA_BOSS_17p", "ULDA_BOSS_17px", "ULDA_BOSS_19p", "ULDA_BOSS_19px", "ULDA_BOSS_21p", "ULDA_BOSS_25p", "ULDA_BOSS_27px", "ULDA_BOSS_31p", "ULDA_BOSS_31px", "ULDA_BOSS_32p", "ULDA_BOSS_36p", "ULDA_BOSS_36px", "ULDA_BOSS_37p1", "ULDA_BOSS_39m", "ULDA_BOSS_39p3", "ULDA_BOSS_39px3", "ULDA_BOSS_40p3", "ULDA_BOSS_41p", "ULDA_BOSS_41px", "ULDA_BOSS_42e", "ULDA_BOSS_42e2", "ULDA_BOSS_42p", "ULDA_BOSS_42px", "ULDA_BOSS_43p", "ULDA_BOSS_43px", "ULDA_BOSS_47p", "ULDA_BOSS_48p", "ULDA_BOSS_49p", "ULDA_BOSS_49px", "ULDA_BOSS_55p", "ULDA_BOSS_56p", "ULDA_BOSS_62p", "ULDA_BOSS_66p", "ULDA_BOSS_66px", "ULDA_BOSS_70p", "ULDA_BOSS_70px", "ULDA_BOSS_71p", "ULDA_BOSS_71px", "ULDA_BOSS_77p", "ULDA_BOSS_77px", "ULDA_BOSS_79p", "ULDA_Brann_HP3", "ULDA_Elise_HP1", "ULDA_Elise_HP2", "ULDA_Finley_HP1", "ULDA_Finley_HP2", "ULDA_Finley_HP3", "UNG_002", "UNG_010", "UNG_011", "UNG_020", "UNG_022", "UNG_024", "UNG_028", "UNG_029", "UNG_030", "UNG_032", "UNG_037", "UNG_057", "UNG_060", "UNG_063", "UNG_065t", "UNG_067", "UNG_072", "UNG_073", "UNG_075", "UNG_076", "UNG_078", "UNG_082", "UNG_083", "UNG_086", "UNG_088", "UNG_089", "UNG_100", "UNG_101", "UNG_103", "UNG_108", "UNG_109", "UNG_111t1", "UNG_116", "UNG_201", "UNG_208", "UNG_211b", "UNG_800", "UNG_809", "UNG_816", "UNG_823", "UNG_829", "UNG_829t2", "UNG_830", "UNG_832", "UNG_836", "UNG_843", "UNG_845", "UNG_846", "UNG_851", "UNG_851t1", "UNG_854", "UNG_856", "UNG_900", "UNG_907", "UNG_912", "UNG_913", "UNG_914", "UNG_915", "UNG_916", "UNG_917", "UNG_917t1", "UNG_920", "UNG_920t1", "UNG_920t2", "UNG_922", "UNG_922t1", "UNG_923", "UNG_925", "UNG_926", "UNG_927", "UNG_934", "UNG_937", "UNG_938", "UNG_940", "UNG_942", "UNG_942t", "UNG_948", "UNG_952", "UNG_952e", "UNG_954", "UNG_954t1", "UNG_957", "UNG_960", "UNG_961", "UNG_962", "UNG_963", "UNG_999t2", "UNG_999t2e", "VAN_CS2_003", "VAN_CS2_004", "VAN_CS2_005", "VAN_CS2_007", "VAN_CS2_009", "VAN_CS2_011", "VAN_CS2_013", "VAN_CS2_023", "VAN_CS2_027", "VAN_CS2_038", "VAN_CS2_039", "VAN_CS2_041", "VAN_CS2_045", "VAN_CS2_046", "VAN_CS2_053", "VAN_CS2_073", "VAN_CS2_074", "VAN_CS2_077", "VAN_CS2_087", "VAN_CS2_088", "VAN_CS2_089", "VAN_CS2_092", "VAN_CS2_102_H3", "VAN_CS2_103", "VAN_CS2_103_Puzzle", "VAN_CS2_104", "VAN_CS2_105", "VAN_CS2_117", "VAN_CS2_147", "VAN_CS2_151", "VAN_CS2_188", "VAN_CS2_196", "VAN_CS2_226", "VAN_CS2_236", "VAN_CS2_237", "VAN_DS1_055", "VAN_DS1_070", "VAN_DS1_184", "VAN_EX1_011", "VAN_EX1_012", "VAN_EX1_014", "VAN_EX1_015", "VAN_EX1_019", "VAN_EX1_025", "VAN_EX1_043", "VAN_EX1_046", "VAN_EX1_058", "VAN_EX1_059", "VAN_EX1_076", "VAN_EX1_084", "VAN_EX1_089", "VAN_EX1_093", "VAN_EX1_096", "VAN_EX1_103", "VAN_EX1_110", "VAN_EX1_112", "VAN_EX1_116", "VAN_EX1_128", "VAN_EX1_130", "VAN_EX1_131", "VAN_EX1_132", "VAN_EX1_136", "VAN_EX1_145", "VAN_EX1_145e", "VAN_EX1_145o", "VAN_EX1_155", "VAN_EX1_158", "VAN_EX1_158e", "VAN_EX1_160", "VAN_EX1_160a", "VAN_EX1_160b", "VAN_EX1_164", "VAN_EX1_164a", "VAN_EX1_164b", "VAN_EX1_165", "VAN_EX1_169", "VAN_EX1_178", "VAN_EX1_244", "VAN_EX1_248", "VAN_EX1_284", "VAN_EX1_287", "VAN_EX1_289", "VAN_EX1_294", "VAN_EX1_295", "VAN_EX1_316", "VAN_EX1_317", "VAN_EX1_339", "VAN_EX1_345", "VAN_EX1_349", "VAN_EX1_350", "VAN_EX1_354", "VAN_EX1_355", "VAN_EX1_362", "VAN_EX1_363", "VAN_EX1_365", "VAN_EX1_366", "VAN_EX1_371", "VAN_EX1_379", "VAN_EX1_392", "VAN_EX1_409", "VAN_EX1_506", "VAN_EX1_533", "VAN_EX1_534", "VAN_EX1_538", "VAN_EX1_549", "VAN_EX1_554", "VAN_EX1_556", "VAN_EX1_562", "VAN_EX1_570", "VAN_EX1_571", "VAN_EX1_573", "VAN_EX1_573a", "VAN_EX1_573b", "VAN_EX1_577", "VAN_EX1_583", "VAN_EX1_584", "VAN_EX1_587", "VAN_EX1_590", "VAN_EX1_597", "VAN_EX1_606", "VAN_EX1_611", "VAN_EX1_613", "VAN_EX1_614", "VAN_EX1_621", "VAN_EX1_623", "VAN_EX1_tk33", "VAN_HERO_01bp", "VAN_HERO_01bp2", "VAN_HERO_02bp", "VAN_HERO_02bp2", "VAN_HERO_04bp", "VAN_HERO_04bp2", "VAN_HERO_07bp", "VAN_HERO_07bp2", "VAN_HERO_09bp", "VAN_HERO_09bp2", "VAN_NEW1_008", "VAN_NEW1_008a", "VAN_NEW1_008b", "VAN_NEW1_014", "VAN_NEW1_016", "VAN_NEW1_018", "VAN_NEW1_024", "VAN_NEW1_026", "VAN_NEW1_031", "VAN_NEW1_036", "VAN_NEW1_040", "VAN_PRO_001", "VAN_PRO_001c", "VAN_tt_010", "WC_003", "WC_005", "WC_007", "WC_008", "WC_013", "WC_016", "WC_026", "WC_027", "WC_030", "WC_032", "WC_033", "WC_034", "WC_036", "WC_803", "WC_805", "YOD_001", "YOD_001b", "YOD_001c", "YOD_001ts", "YOD_004", "YOD_005", "YOD_005ts", "YOD_012", "YOD_012ts", "YOD_013", "YOD_015", "YOD_016", "YOD_017", "YOD_023", "YOD_024", "YOD_025", "YOD_026", "YOD_028", "YOD_029", "YOD_035", "YOD_038", "YOD_041", "YOD_043", "YOP_001", "YOP_001e", "YOP_003", "YOP_003t", "YOP_004", "YOP_005", "YOP_009", "YOP_010", "YOP_011", "YOP_015", "YOP_015t", "YOP_017", "YOP_018", "YOP_018e", "YOP_019", "YOP_022", "YOP_024", "YOP_024t", "YOP_025", "YOP_026", "YOP_029", "YOP_030", "YOP_031", "YOP_032" };
+        private static HashSet<string> unfriendlyCards = new HashSet<string>() { "AT_001", "AT_004", "AT_005", "AT_012", "AT_022", "AT_023", "AT_025", "AT_030", "AT_036", "AT_037", "AT_037a", "AT_044", "AT_050", "AT_050t", "AT_051", "AT_056", "AT_059", "AT_063", "AT_063t", "AT_064", "AT_078", "AT_081", "AT_094", "AT_103", "AT_105", "AT_106", "AT_110", "AT_122", "AT_123", "AT_130", "AT_131", "AT_132_HUNTER_H1", "BAR_024", "BAR_027", "BAR_032", "BAR_044", "BAR_044t", "BAR_044t2", "BAR_069", "BAR_071", "BAR_078", "BAR_079t12", "BAR_079t12c", "BAR_079t13", "BAR_079t13b", "BAR_079t13c", "BAR_305", "BAR_306", "BAR_311", "BAR_314", "BAR_314t", "BAR_314t2", "BAR_315", "BAR_316", "BAR_319", "BAR_319t", "BAR_319t2", "BAR_320", "BAR_334", "BAR_536", "BAR_536t", "BAR_536t2", "BAR_538", "BAR_541", "BAR_547", "BAR_705", "BAR_745", "BAR_748", "BAR_750", "BAR_801", "BAR_840", "BAR_845", "BAR_879", "BAR_879t", "BAR_888t", "BAR_910", "BAR_911", "BAR_913", "BAR_916", "BCON_008", "BCON_021", "BGS_002", "BGS_004", "BGS_032", "BGS_055", "BGS_077", "BGS_Treasures_003", "BGS_Treasures_014", "BGS_Treasures_014e", "BGS_Treasures_034", "BOM_01_Brukan_02p1", "BOM_01_Brukan_03p1", "BOM_01_Brukan_04p1", "BOM_01_Brukan_05p1", "BOM_01_Brukan_06p1", "BOM_01_Brukan_07p1", "BOM_01_Dawngrasp_05p4", "BOM_01_Dawngrasp_06p4", "BOM_01_Dawngrasp_07p4", "BOM_01_Feegly_07p", "BOM_01_Twinbraid_06p", "BOM_02_Serena_02p", "BOM_02_TavishFiresAShot_01s", "BOM_02_Trixie_05p", "BOM_03_Brukan_02p", "BOM_03_Dawngrasp_08t", "BOM_03_PowerOfLove_08s", "BOM_03_Tamsin_02p", "BOM_03_ThunderBluff_01t", "BOM_04_Dawngrasp_006p", "BOM_04_HurlGlaive_002s", "BOM_04_Samuro_001p", "BOM_04_Sarilus_004p", "BOM_04_Scabbs_005p", "BOM_04_Scabbs_006p", "BOT_031", "BOT_033", "BOT_104", "BOT_107e", "BOT_222", "BOT_238p1", "BOT_238p3", "BOT_245", "BOT_246", "BOT_251", "BOT_251e", "BOT_257", "BOT_308", "BOT_447", "BOT_448", "BOT_453", "BOT_540", "BOT_544", "BOT_558", "BOT_601", "BOT_907", "BOTA_101", "BOTA_202", "BOTA_212", "BOTA_223", "BOTA_229", "BOTA_235", "BOTA_240", "BOTA_244", "BOTA_702", "BOTA_BOSS_20p4", "BRM_002", "BRM_003", "BRM_005", "BRM_008", "BRM_010", "BRM_011", "BRM_013", "BRM_015", "BRM_016", "BRM_027p", "BRM_027pH", "BRM_030t", "BRM_034", "BRMA03_2", "BRMA04_2", "BRMA04_3", "BRMA04_3H", "BRMA05_2", "BRMA05_2H", "BRMA05_3", "BRMA05_3e", "BRMA05_3H", "BRMA05_3He", "BRMA07_2", "BRMA07_2_2_TB", "BRMA07_2_2c_TB", "BRMA07_2H", "BRMA07_3", "BRMA08_3", "BRMA09_6", "BRMA11_3", "BRMA12_8", "BRMA13_5", "BRMA13_8", "BRMA14_5", "BRMA14_5H", "BRMA16_3", "BRMA16_4", "BRMA17_4", "BRMC_100", "BRMC_100e", "BRMC_91", "BT_002", "BT_011", "BT_020", "BT_026", "BT_072", "BT_100", "BT_106", "BT_109t", "BT_110", "BT_114", "BT_117", "BT_126", "BT_134", "BT_196", "BT_199", "BT_205", "BT_230", "BT_233", "BT_235", "BT_291", "BT_354", "BT_355", "BT_429", "BT_429p", "BT_429p2", "BT_490", "BT_493", "BT_514", "BT_601", "BT_714", "BT_717", "BT_722", "BT_723", "BT_724", "BT_729", "BT_732", "BT_740", "BT_801", "BT_937", "BTA_13", "BTA_BOSS_01p", "BTA_BOSS_05p", "BTA_BOSS_07s2", "BTA_BOSS_10p", "BTA_BOSS_10p2", "BTA_BOSS_15s", "BTA_BOSS_17p", "BTA_BOSS_19p", "BTA_BOSS_19s", "BTA_BOSS_20p", "BTA_BOSS_20t", "BTA_BOSS_21p", "BTA_BOSS_22s", "BTA_BOSS_22t", "BTA_BOSS_24p", "BTA_BOSS_25s", "CFM_021", "CFM_065", "CFM_094", "CFM_335", "CFM_341", "CFM_603", "CFM_608", "CFM_609", "CFM_621t16", "CFM_621t18", "CFM_621t2", "CFM_621t21", "CFM_621t25", "CFM_621t29", "CFM_621t33", "CFM_621t4", "CFM_621t5", "CFM_623", "CFM_646", "CFM_647", "CFM_657", "CFM_662", "CFM_667", "CFM_690", "CFM_693", "CFM_696", "CFM_707", "CFM_716", "CFM_751", "CFM_855", "CFM_900", "CORE_BOT_453", "CORE_BRM_013", "CORE_BT_235", "CORE_BT_801", "CORE_CS1_112", "CORE_CS1_130", "CORE_CS2_029", "CORE_CS2_032", "CORE_CS2_033", "CORE_CS2_042", "CORE_CS2_062", "CORE_CS2_064", "CORE_CS2_072", "CORE_CS2_075", "CORE_CS2_076", "CORE_CS2_093", "CORE_CS2_108", "CORE_CS2_181", "CORE_CS2_189", "CORE_CS2_203", "CORE_DS1_185", "CORE_EX1_005", "CORE_EX1_049", "CORE_EX1_066", "CORE_EX1_082", "CORE_EX1_134", "CORE_EX1_144", "CORE_EX1_186", "CORE_EX1_197", "CORE_EX1_198", "CORE_EX1_238", "CORE_EX1_246", "CORE_EX1_249", "CORE_EX1_259", "CORE_EX1_275", "CORE_EX1_302", "CORE_EX1_304", "CORE_EX1_309", "CORE_EX1_312", "CORE_EX1_319", "CORE_EX1_382", "CORE_EX1_391", "CORE_EX1_400", "CORE_EX1_407", "CORE_EX1_410", "CORE_EX1_603", "CORE_EX1_610", "CORE_EX1_617", "CORE_EX1_619", "CORE_EX1_622", "CORE_EX1_625", "CORE_GIL_801", "CORE_GVG_076", "CORE_ICC_055", "CORE_UNG_817", "CRED_10", "CRED_118", "CRED_32", "CRED_44", "CRED_60", "CRED_67", "CRED_83", "CS1_112", "CS1_113", "CS1_129", "CS1_130", "CS1_130_Puzzle", "CS2_008", "CS2_012", "CS2_022", "CS2_024", "CS2_025", "CS2_026", "CS2_028", "CS2_029", "CS2_031", "CS2_032", "CS2_033", "CS2_034_H1", "CS2_034_H1_AT_132", "CS2_034_H2", "CS2_034_H2_AT_132", "CS2_034_H3", "CS2_034_H3_AT_132", "CS2_034_H4", "CS2_037", "CS2_042", "CS2_057", "CS2_061", "CS2_062", "CS2_063", "CS2_064", "CS2_072", "CS2_075", "CS2_076", "CS2_084", "CS2_093", "CS2_094", "CS2_108", "CS2_114", "CS2_141", "CS2_150", "CS2_181", "CS2_189", "CS2_203", "CS2_233", "CS2_234", "CS3_002", "CS3_003", "CS3_016", "CS3_027", "CS3_031", "CS3_036", "DAL_009", "DAL_011", "DAL_030", "DAL_039", "DAL_052", "DAL_065", "DAL_071", "DAL_173", "DAL_177", "DAL_177ts", "DAL_182", "DAL_350", "DAL_350a", "DAL_366", "DAL_366t1", "DAL_366t2", "DAL_366t3", "DAL_366t4", "DAL_371", "DAL_373", "DAL_373ts", "DAL_539", "DAL_577", "DAL_577ts", "DAL_605", "DAL_606", "DAL_614", "DAL_615", "DAL_716", "DAL_723", "DAL_728", "DAL_769", "DAL_775", "DALA_706", "DALA_712", "DALA_713", "DALA_714", "DALA_714a", "DALA_714b", "DALA_714c", "DALA_720", "DALA_724", "DALA_726", "DALA_740ts4", "DALA_865", "DALA_865e", "DALA_865e2", "DALA_901", "DALA_903", "DALA_914", "DALA_BOSS_01p", "DALA_BOSS_01px", "DALA_BOSS_03t", "DALA_BOSS_03t2", "DALA_BOSS_08p", "DALA_BOSS_08px", "DALA_BOSS_12p", "DALA_BOSS_12px", "DALA_BOSS_13p", "DALA_BOSS_19p", "DALA_BOSS_19px", "DALA_BOSS_22p", "DALA_BOSS_22px", "DALA_BOSS_23p", "DALA_BOSS_23px", "DALA_BOSS_29p", "DALA_BOSS_45p", "DALA_BOSS_45px", "DALA_BOSS_47t", "DALA_BOSS_48t", "DALA_BOSS_50p", "DALA_BOSS_50px", "DALA_BOSS_51t2", "DALA_BOSS_56e", "DALA_BOSS_58p", "DALA_BOSS_59t2", "DALA_BOSS_59t3", "DALA_BOSS_63p", "DALA_BOSS_63px", "DALA_BOSS_64p", "DALA_BOSS_64px", "DALA_BOSS_70p", "DALA_BOSS_70px", "DALA_Mage_HP1", "DALA_Mage_HP2", "DALA_Rogue_HP2", "DALA_Shaman_HP1", "DALA_Warlock_HP1", "DALA_Warrior_HP1", "DH_Prologue_CS2_057", "DH_Prologue_EX1_277", "DMF_004t4", "DMF_004t5", "DMF_054", "DMF_054t", "DMF_057", "DMF_066", "DMF_071", "DMF_101", "DMF_101t", "DMF_103", "DMF_108", "DMF_110", "DMF_115", "DMF_116", "DMF_117", "DMF_117t", "DMF_117t2", "DMF_174", "DMF_174t", "DMF_187", "DMF_191", "DMF_221", "DMF_225", "DMF_227", "DMF_254t3", "DMF_254t4", "DMF_254t7", "DMF_518", "DMF_519", "DMF_522", "DMF_529", "DMF_700", "DMF_701", "DMF_701t", "DMF_702", "DREAM_02", "DREAM_04", "DREAM_05", "DRG_006", "DRG_022", "DRG_023", "DRG_037", "DRG_062", "DRG_067", "DRG_069", "DRG_078", "DRG_081", "DRG_095", "DRG_099t1", "DRG_099t4", "DRG_106", "DRG_201", "DRG_204", "DRG_205", "DRG_206", "DRG_213", "DRG_219", "DRG_223", "DRG_246", "DRG_247", "DRG_248", "DRG_249", "DRG_255t2", "DRG_256", "DRG_257", "DRG_270t11", "DRG_270t4", "DRG_270t5", "DRG_270t6", "DRG_270t7", "DRG_270t8", "DRG_270t9", "DRG_304", "DRG_307", "DRG_321", "DRG_500", "DRG_660", "DRG_660t2", "DRG_660t3", "DRGA_004", "DRGA_011ts4", "DRGA_06", "DRGA_099t4", "DRGA_BOSS_04p", "DRGA_BOSS_04t", "DRGA_BOSS_05t2", "DRGA_BOSS_05t3", "DRGA_BOSS_05t4", "DRGA_BOSS_05t5", "DRGA_BOSS_06p", "DRGA_BOSS_06p_H", "DRGA_BOSS_07p", "DRGA_BOSS_07p4", "DRGA_BOSS_09t", "DRGA_BOSS_10p", "DRGA_BOSS_10p_H", "DRGA_BOSS_13t", "DRGA_BOSS_15t2", "DRGA_BOSS_16p", "DRGA_BOSS_16p2", "DRGA_BOSS_20p", "DRGA_BOSS_20p_H", "DRGA_BOSS_20t", "DRGA_BOSS_21t", "DRGA_BOSS_22t2", "DRGA_BOSS_22t3", "DRGA_BOSS_24p", "DRGA_BOSS_24p_H", "DRGA_BOSS_30t", "DRGA_BOSS_30t2t", "DRGA_BOSS_30t3", "DRGA_BOSS_30t5", "DRGA_BOSS_32p", "DRGA_BOSS_32p_H", "DRGA_BOSS_33t", "DS1_183", "DS1_185", "DS1_233", "DS1h_292_H1", "DS1h_292_H1_AT_132", "DS1h_292_H2", "DS1h_292_H3", "DS1h_292_H3_AT_132", "EX1_002", "EX1_005", "EX1_029", "EX1_048", "EX1_049", "EX1_057", "EX1_066", "EX1_082", "EX1_091", "EX1_102", "EX1_124", "EX1_126", "EX1_129", "EX1_133", "EX1_134", "EX1_137", "EX1_144", "EX1_154", "EX1_154a", "EX1_154b", "EX1_161", "EX1_166", "EX1_166a", "EX1_166b", "EX1_173", "EX1_179", "EX1_186", "EX1_197", "EX1_198", "EX1_238", "EX1_241", "EX1_245", "EX1_246", "EX1_249", "EX1_251", "EX1_259", "EX1_275", "EX1_277", "EX1_278", "EX1_279", "EX1_283", "EX1_298", "EX1_301", "EX1_302", "EX1_303", "EX1_304", "EX1_308", "EX1_309", "EX1_312", "EX1_313", "EX1_319", "EX1_320", "EX1_332", "EX1_334", "EX1_360", "EX1_382", "EX1_384", "EX1_391", "EX1_400", "EX1_407", "EX1_408", "EX1_410", "EX1_537", "EX1_539", "EX1_544", "EX1_558", "EX1_578", "EX1_581", "EX1_593", "EX1_594", "EX1_596", "EX1_603", "EX1_607", "EX1_609", "EX1_610", "EX1_617", "EX1_619", "EX1_622", "EX1_624", "EX1_625", "EX1_625t", "EX1_625t2", "EX1_626", "FB_Champs_CS2_084", "FB_Champs_CS2_108", "FB_Champs_CS2_233", "FB_Champs_EX1_005", "FB_Champs_EX1_029", "FB_Champs_EX1_166", "FB_Champs_EX1_246", "FB_Champs_EX1_308", "FB_Champs_EX1_619", "FB_Champs_LOOT_017", "FB_Champs_NEW1_019", "FB_Duelers_Endl", "FB_ELO002a", "FB_ELO002a_ench", "FB_ELO002b", "FB_ELO002b_copy", "FB_ELO002b_ench", "FB_ELO002b_ench_copy", "FB_IKC_SetupYes", "FB_Juggernaut_Bomb_Effect", "FB_Juggernaut_MinionEnchant", "FB_LK_ClearBoard", "FB_LK005", "FB_LK007p", "FB_LK011", "FB_LKStats001d", "FB_RagRaid_Amulet", "FB_RagRaid_DestroyEverything", "FB_RagRaid_DoubleBlast", "FB_Toki_Boss_Minion1", "FB_Toki_do_auto", "FB_Toki_TimePortalSpell", "FP1_006", "FP1_019", "FP1_021", "FP1_024", "FP1_025", "FP1_026", "GIL_000", "GIL_117", "GIL_124", "GIL_134", "GIL_147", "GIL_504", "GIL_506", "GIL_515", "GIL_518", "GIL_543", "GIL_583", "GIL_600", "GIL_614", "GIL_614e2", "GIL_622", "GIL_648", "GIL_654", "GIL_687", "GIL_693", "GIL_694", "GIL_801", "GIL_825", "GILA_500h4", "GILA_500p2t", "GILA_501", "GILA_503", "GILA_508", "GILA_510", "GILA_600h2", "GILA_601", "GILA_803", "GILA_804", "GILA_820", "GILA_821a", "GILA_821b", "GILA_821c", "GILA_900h2", "GILA_904", "GILA_910", "GILA_BOSS_22p", "GILA_BOSS_23p", "GILA_BOSS_24t", "GILA_BOSS_26t", "GILA_BOSS_27p", "GILA_BOSS_27t", "GILA_BOSS_29p", "GILA_BOSS_29t", "GILA_BOSS_33p", "GILA_BOSS_35t", "GILA_BOSS_36p", "GILA_BOSS_41t", "GILA_BOSS_42p", "GILA_BOSS_44p", "GILA_BOSS_49t2", "GILA_BOSS_51p", "GILA_BOSS_54p", "GILA_BOSS_55t2", "GILA_BOSS_56p", "GILA_BOSS_57p", "GILA_BOSS_59p", "GILA_BOSS_61t3", "GILA_BOSS_62p", "GILA_BOSS_66p", "GILA_BOSS_68p", "GILA_BOSS_68t", "GVG_001", "GVG_002", "GVG_004", "GVG_007", "GVG_008", "GVG_009", "GVG_015", "GVG_019", "GVG_020", "GVG_038", "GVG_045", "GVG_047", "GVG_050", "GVG_052", "GVG_072", "GVG_073", "GVG_074", "GVG_075", "GVG_076", "GVG_090", "GVG_099", "GVG_101", "GVG_108", "GVG_110t", "GVG_120", "HERO_05bp", "HERO_05bp2", "HERO_05dbp", "HERO_05dbp2", "HERO_08bp", "HERO_08bp2", "HERO_08ebp", "HERO_08ebp2", "HERO_08fbp", "HERO_08fbp2", "HERO_08fbp3", "HERO_08lbp", "HERO_08lbp2", "ICC_021", "ICC_041", "ICC_047", "ICC_047b", "ICC_047t", "ICC_047t2", "ICC_049", "ICC_051", "ICC_055", "ICC_058", "ICC_064", "ICC_075", "ICC_078", "ICC_085", "ICC_088", "ICC_099", "ICC_214", "ICC_233", "ICC_236", "ICC_238", "ICC_244", "ICC_244e", "ICC_314t3", "ICC_314t5", "ICC_314t6", "ICC_314t8", "ICC_468", "ICC_469", "ICC_481", "ICC_481p", "ICC_701", "ICC_802", "ICC_828", "ICC_830", "ICC_830p", "ICC_831p", "ICC_833h", "ICC_833t", "ICC_834h", "ICC_836", "ICC_837", "ICC_849", "ICC_903", "ICC_910", "ICCA01_011", "ICCA04_002", "ICCA04_008p", "ICCA04_011p", "ICCA05_004p", "ICCA05_021", "ICCA06_004", "ICCA06_005", "ICCA07_008", "ICCA08_024", "ICCA08_025", "ICCA08_026", "ICCA08_028", "ICCA08_030p", "KAR_013", "KAR_041", "KAR_073", "KAR_076", "KAR_092", "KAR_A10_01", "KAR_A10_02", "KAR_A10_03", "KAR_A10_04", "KAR_A10_09", "KAR_A10_10", "KAR_A10_33", "KARA_04_02hp", "KARA_08_03", "KARA_08_03H", "KARA_08_05", "KARA_08_05H", "KARA_09_06", "KARA_09_06heroic", "KARA_09_07", "KARA_09_07heroic", "KARA_12_03", "KARA_12_03H", "KARA_13_11", "LOE_002", "LOE_002t", "LOE_016", "LOE_021", "LOE_027", "LOE_046", "LOE_104", "LOE_111", "LOEA01_12", "LOEA01_12h", "LOEA04_25", "LOEA04_25h", "LOEA06_04", "LOEA06_04h", "LOEA07_18", "LOEA07_20", "LOEA07_29", "LOEA09_6", "LOEA09_6H", "LOEA09_9", "LOEA09_9H", "LOEA15_3", "LOEA15_3H", "LOEA16_10", "LOEA16_11", "LOEA16_4", "LOEA16_6", "LOEA16_8", "LOEA16_9", "LOOT_013", "LOOT_014", "LOOT_017", "LOOT_043", "LOOT_043t2", "LOOT_043t3", "LOOT_051", "LOOT_051t1", "LOOT_051t2", "LOOT_060", "LOOT_077", "LOOT_101", "LOOT_111", "LOOT_118", "LOOT_122", "LOOT_132", "LOOT_150", "LOOT_172", "LOOT_278t4e", "LOOT_285t2", "LOOT_347", "LOOT_358", "LOOT_364", "LOOT_389", "LOOT_410", "LOOT_415t6", "LOOT_417", "LOOT_503", "LOOT_503t", "LOOT_503t2", "LOOT_504", "LOOT_504t", "LOOT_522", "LOOT_998l", "LOOTA_102", "LOOTA_805", "LOOTA_806", "LOOTA_811", "LOOTA_826", "LOOTA_827", "LOOTA_842", "LOOTA_843", "LOOTA_BOSS_05p", "LOOTA_BOSS_06p", "LOOTA_BOSS_09p", "LOOTA_BOSS_11p", "LOOTA_BOSS_13p", "LOOTA_BOSS_20p", "LOOTA_BOSS_21p", "LOOTA_BOSS_23p", "LOOTA_BOSS_25p", "LOOTA_BOSS_26p2", "LOOTA_BOSS_26p3", "LOOTA_BOSS_26p4", "LOOTA_BOSS_26p6", "LOOTA_BOSS_26p7", "LOOTA_BOSS_28p", "LOOTA_BOSS_29p", "LOOTA_BOSS_30p", "LOOTA_BOSS_39p", "LOOTA_BOSS_44p", "LOOTA_BOSS_47p", "LOOTA_BOSS_49t2", "LOOTA_BOSS_51p", "LOOTA_BOSS_53p", "LOOTA_BOSS_99t", "Mission_ForceDrawInOrder", "NAX1_05", "NAX10_03", "NAX10_03H", "NAX11_02", "NAX11_02H", "NAX11_02H_2_TB", "NAX12_02", "NAX12_02H", "NAX12_02H_2_TB", "NAX12_02H_2c_TB", "NAX14_02", "NAX14_04", "NAX15_02", "NAX15_02H", "NAX15_04", "NAX15_04H", "NAX3_02", "NAX3_02_TB", "NAX3_02H", "NAX3_03", "NAX4_05", "NAX5_02", "NAX5_02H", "NAX6_02", "NAX6_02H", "NAX6_03", "NAX6_04", "NAX7_03", "NAX7_03H", "NAX8_03t", "NAX8_04t", "NAX8_05t", "NAXM_001", "NAXM_002", "NEW1_003", "NEW1_004", "NEW1_005", "NEW1_007", "NEW1_007a", "NEW1_007b", "NEW1_017", "NEW1_019", "NEW1_020", "NEW1_030", "NEW1_041", "OG_027", "OG_033", "OG_061", "OG_080c", "OG_080f", "OG_081", "OG_083", "OG_085", "OG_086", "OG_100", "OG_116", "OG_120", "OG_149", "OG_151", "OG_161", "OG_162", "OG_176", "OG_179", "OG_206", "OG_239", "OG_254", "OG_279", "OG_280", "OG_282", "OG_314", "OG_328", "PART_002", "PART_005", "PRO_001b", "Prologue_Captain", "Prologue_ChaosNova", "Prologue_Jarod", "Prologue_MannorothHP", "Prologue_UnstableEnergy3", "Prologue_XaviusHP", "PVPDR_035", "PVPDR_042", "PVPDR_BAR_Passive10", "PVPDR_BAR_Passive10e1", "PVPDR_BAR_Passive19", "PVPDR_BAR_Passive19e1", "PVPDR_BAR_Passive20", "PVPDR_BAR_Passive20e1", "PVPDR_BAR_Passive21", "PVPDR_BAR_Passive21e1", "PVPDR_BAR_Passive23", "PVPDR_BAR_Passive23e1", "PVPDR_BAR_Passive27", "PVPDR_BAR_Passive27e1", "PVPDR_DMF_Druidp1", "PVPDR_DMF_Roguet2", "PVPDR_SCH_Active02", "PVPDR_SCH_Active07", "PVPDR_SCH_Active17", "PVPDR_SCH_Active25", "PVPDR_SCH_Active39", "PVPDR_SCH_Active39s1", "PVPDR_SCH_Active39s2", "PVPDR_SCH_Active42", "PVPDR_SCH_Active43", "PVPDR_SCH_Active44", "PVPDR_SCH_Active52", "PVPDR_SCH_Active54", "PVPDR_SCH_Active55", "PVPDR_SCH_Active57", "PVPDR_SCH_Active61", "PVPDR_SCH_Hunterp1", "PVPDR_SCH_Magep3", "PVPDR_SCH_Maget5", "PVPDR_SCH_Passive23", "PVPDR_SCH_Passive23e", "PVPDR_SCH_Passive39", "PVPDR_SCH_Passive39e", "PVPDR_SCH_Priestt1", "PVPDR_SCH_Warlockt4", "PVPDR_SCH_Warriorp1", "PVPDR_SCH_Warriort2", "PVPDR_YOP_DruidP1", "PVPDR_YOP_DruidT1", "PVPDR_YOP_MageP1", "PVPDR_YOP_MageP1m1", "PVPDR_YOP_MageT1t", "PVPDR_YOP_PaladinT3", "PVPDR_YOP_PriestT1", "PVPDR_YOP_PriestT1e1", "PVPDR_YOP_RogueT1", "SCH_199t2", "SCH_235", "SCH_236", "SCH_239", "SCH_241", "SCH_248", "SCH_253", "SCH_271", "SCH_276", "SCH_307", "SCH_313", "SCH_348", "SCH_355", "SCH_509", "SCH_512", "SCH_514", "SCH_517", "SCH_521", "SCH_526", "SCH_535", "SCH_604", "SCH_607", "SCH_607a", "SCH_701", "SCH_704", "Story_01_AethasHP", "Story_01_ArthasHP", "Story_01_GarroshHP", "Story_01_Iceball", "Story_01_JainaHP", "Story_01_JainaHP2", "Story_01_JainaYoungHP", "Story_01_JainaYoungHP2", "Story_01_JainaYoungHP3", "Story_01_LordaeronAttendant", "Story_01_Shandris", "Story_01_TheramoreGates", "Story_01_TheramoreGuard", "Story_01_WaterElemental", "Story_01_WaterElemental2", "Story_02_BlackhandHP", "Story_02_DarkscaleHP", "Story_02_GronnTrap", "Story_02_Haratha", "Story_02_KulTiranGuard", "Story_02_LeoroxxHP", "Story_02_MishaHP", "Story_02_Monsoon", "Story_02_RexxarHP", "Story_02_RexxarMidHP4", "Story_02_Spirit", "Story_02_StuffedSack", "Story_02_WoundedFootman", "Story_03_AnduinHP", "Story_03_CairneHP", "Story_03_CorruptGarrosh", "Story_03_ElementalRift", "Story_03_EvenTotem", "Story_03_FireElementalHP", "Story_03_FreshPerspective", "Story_03_GarroshArmadaHP", "Story_03_OddTotem", "Story_03_Saurfang", "Story_03_ZarzhetHP", "Story_04_BlademasterHP", "Story_04_DarkPortalHP", "Story_04_FightTrainer", "Story_04_GuldanReinforcements", "Story_04_IcebladeWeapon", "Story_04_LibramofJustice", "Story_04_RadiantLightspawn", "Story_04_UtherHP3", "Story_04_UtherHP4", "Story_04_WallsLordaeron", "Story_04_YoungUtherHP", "Story_05_Alleria", "Story_05_AncientBrewmaster", "Story_05_AnduinHP", "Story_05_AnduinHP2", "Story_05_ForbiddenWords", "Story_05_JadeWarlord", "Story_05_JainaHP", "Story_05_JainaMinion", "Story_05_MarkedShot", "Story_05_MonkeyKingHP", "Story_05_UntamedAmbertail", "Story_05_VarianHP", "Story_05_VelenHP", "Story_05_WarMachine", "Story_05_YouthfulBrewmaster", "Story_06_AssassinsTraining", "Story_06_Broll", "Story_06_ChoGall_07p", "Story_06_GaronaShadow", "Story_06_Lilian", "Story_06_SanguineStrike", "Story_06_SilentShadow", "Story_06_SilentShadow2", "Story_06_SilentShadow3", "Story_06_SilentShadow4", "Story_06_Stasia_05p", "Story_06_Taoshi", "Story_06_TessGreymane", "Story_06_Tethys", "Story_06_Upheaval", "Story_06_Valeera_07p", "Story_06_Valeera_08p", "Story_06_Vendellin_04p", "Story_07_Deathwing_006p", "Story_07_Deathwing_006p2", "Story_07_Deathwing_006p3", "Story_07_Devastate", "Story_07_FeverPitch", "Story_07_HideousAmalgamation", "Story_07_Jaina_007p2", "Story_07_Mannoroth_004p", "Story_07_RouseRabble", "Story_07_SpiritofFire", "Story_07_SpiritofFiret", "Story_08_ArchdruidsRage", "Story_08_CorruptingRage", "Story_08_Hopelessness", "Story_08_Illidan_005p", "Story_08_Keeper", "Story_08_KeeperCorrupt", "Story_08_Mannoroth_002p", "Story_08_NightmareDemon", "Story_08_Nordrassil", "Story_08_Ragnaros_007p", "Story_08_Saurfang", "Story_08_Tyrande", "Story_08_WayofArchdruid", "Story_08_Weeding", "Story_09_AbyssalEnforcer", "Story_09_BlastcrystalPotion", "Story_09_BloodclawDragon", "Story_09_CouncilNecrolyte", "Story_09_DarkestHour", "Story_09_DemonfirePuzzle", "Story_09_DrainSoul", "Story_09_DreadInfernal", "Story_09_Duskbreaker", "Story_09_EnsnareSoul", "Story_09_FelfirePotion", "Story_09_Felrattler", "Story_09_FlameImp", "Story_09_ForgottenShaman", "Story_09_ForgottenShaman2", "Story_09_ForgottenWarrior", "Story_09_GrimoireofSacrifice", "Story_09_Guldan_005p", "Story_09_Guldan_006p", "Story_09_Guldan_007p", "Story_09_Guldan_008p", "Story_09_HarvestSoul", "Story_09_HellfirePuzzle", "Story_09_Hysteria", "Story_09_KilroggMinion", "Story_09_Lethal", "Story_09_MortalCoilPuzzle", "Story_09_Nerzhul_003p", "Story_09_PowerofGuldan", "Story_09_RainofFire", "Story_09_RaiseDead", "Story_09_Riftcleaver", "Story_09_RitualofDoom", "Story_09_SchoolSpirits", "Story_09_SerpentshrinePortal", "Story_09_Shadowbolt", "Story_09_SoulRend", "Story_09_SoulShear", "Story_09_SuspiciousElemental", "Story_09_Terongor", "Story_09_TombGuardian_008p", "Story_09_TormentSoul", "Story_09_VulgarHomunculus", "Story_09_WeakenedElemental", "Story_10_Akama", "Story_10_Akama_008p", "Story_10_Anubarak_006p", "Story_10_FesteringGhoul", "Story_10_FlameCrash", "Story_10_IcecrownObelisk", "Story_10_LadyVashj", "Story_10_Magtheridon_005p", "Story_10_PoisonTreant", "Story_10_SkullofGuldan", "Story_10_StolenVengeance", "Story_10_SulkingImp", "Story_10_Tichondrius_002p", "SW_012", "SW_027", "SW_028t", "SW_032", "SW_039", "SW_039t", "SW_040", "SW_043", "SW_046", "SW_052t4", "SW_072", "SW_078", "SW_079e6", "SW_079t3", "SW_079t3e", "SW_084", "SW_088", "SW_089", "SW_090", "SW_107", "SW_108", "SW_108t", "SW_110", "SW_311", "SW_311t", "SW_321", "SW_322", "SW_412", "SW_417", "SW_433t3a", "SW_441", "SW_442", "SW_445", "SW_452", "SW_460", "TB_008", "TB_BaconShop_HP_009", "TB_BaconShop_HP_014", "TB_BaconShop_HP_019", "TB_BaconShop_HP_027", "TB_BaconShop_HP_043", "TB_BaconUps_075", "TB_BaconUps_079", "TB_BaconUps_103", "TB_BaconUps_118", "TB_BaconUps_126", "TB_BaconUps_128", "TB_BaconUps_148", "TB_BBR3_BOSS_01p", "TB_BBR3_BOSS_03p1", "TB_BoomBotFestival_001e", "TB_BountyHunt_Consume", "TB_BuildaBoss_404p", "TB_CoOpBossSpell_6", "TB_CoopHero_001", "TB_CoOpv3_002", "TB_CoOpv3_004", "TB_CoOpv3_005", "TB_CoOpv3_006", "TB_CoOpv3_007", "TB_CoOpv3_008", "TB_CoOpv3_012", "TB_CoOpv3_013", "TB_CoOpv3_200", "TB_CoOpv3_201", "TB_DK_Anduin", "TB_DK_Rexxar", "TB_DK_Thrall", "TB_EVILBRM_LOOTA_805", "TB_FactionWar_Boss_Rag_0", "TB_Firefest2_001", "TB_Firefest2_002", "TB_Firefest2_005", "TB_Firefest2_Ahune_HP", "TB_GiftExchange_Snowball", "TB_HeadlessHorseman_001", "TB_HeadlessHorseman_002", "TB_HeadlessHorseman_HP1", "TB_HeadlessHorseman_s004", "TB_HeadlessHorseman_s005", "TB_Henchmania_BoomEnchantBan", "TB_Henchmania_DiscoverB", "TB_HunterPrince_02", "TB_HunterPrince_03", "TB_HunterPrince_03a", "TB_HunterPrince_03b", "TB_Ignoblegarden3", "TB_KTRAF_11", "TB_KTRAF_12", "TB_KTRAF_4m", "TB_KTRAF_7", "TB_LEAGUE_REVIVAL_FinleySandHP", "TB_LevelUp_002", "TB_Lunar_Rooster", "TB_Lunar_RoosterE", "TB_MammothParty_301", "TB_MammothParty_hp002", "TB_MammothParty_s004", "TB_MammothParty_s101", "TB_MammothParty_s101b", "TB_MechWar_Boss2_HeroPower", "TB_OG_027", "TB_RoadToNR_DinoHP", "TB_RoadToNR_MurgathaHP", "TB_SPT_DPromoMinion2", "TB_SPT_DPromoSecret7", "TB_SPT_DPromoSpell1", "TB_TagTeam_ClearBoard", "TB_TempleOutrun_HHHead", "TB_TempleOutrun_Toggwaggle_HP", "TB_ThunderdomeWeaponA", "TB_ThunderdomeWeaponE", "TB_Zombeast_H", "TBST_002", "TOT_030t4", "TOT_100e", "TOT_103e", "TOT_116", "TOT_118", "TOT_340", "TP_Bling_HP2", "TRL_012", "TRL_059", "TRL_065h", "TRL_127", "TRL_157", "TRL_240", "TRL_245", "TRL_246", "TRL_249", "TRL_257", "TRL_258", "TRL_313", "TRL_316t", "TRL_317", "TRL_321", "TRL_341", "TRL_343", "TRL_345", "TRL_347", "TRL_360", "TRL_500", "TRL_505", "TRL_512", "TRL_524", "TRL_526", "TRL_543", "TRL_546", "TRL_555", "TRL_569", "TRLA_065p", "TRLA_129", "TRLA_129s", "TRLA_132", "TRLA_137", "TRLA_157", "TRLA_162e", "TRLA_167", "TRLA_177", "TRLA_182", "TRLA_806e2", "TRLA_808e2", "TU4a_004", "TU4c_002", "TU4c_004", "TU4d_003", "TU4e_005", "TU5_CS2_022", "TU5_CS2_025", "TU5_CS2_029", "TU5_DS1_185", "TU5_EX1_593", "ULD_158", "ULD_161", "ULD_162", "ULD_165", "ULD_172", "ULD_181", "ULD_184", "ULD_190", "ULD_238", "ULD_239", "ULD_240", "ULD_269", "ULD_271", "ULD_272", "ULD_280", "ULD_288", "ULD_293", "ULD_324", "ULD_410", "ULD_435", "ULD_705t", "ULD_707", "ULD_714", "ULD_717", "ULD_718", "ULD_728", "ULDA_006", "ULDA_010", "ULDA_019", "ULDA_024", "ULDA_032", "ULDA_034", "ULDA_044", "ULDA_113", "ULDA_115", "ULDA_204", "ULDA_207", "ULDA_401", "ULDA_404", "ULDA_703e2", "ULDA_713", "ULDA_912", "ULDA_BOSS_05p", "ULDA_BOSS_18e", "ULDA_BOSS_18p", "ULDA_BOSS_18px", "ULDA_BOSS_22p", "ULDA_BOSS_22px", "ULDA_BOSS_23p", "ULDA_BOSS_26p", "ULDA_BOSS_33p", "ULDA_BOSS_34p", "ULDA_BOSS_37p3", "ULDA_BOSS_37px3", "ULDA_BOSS_37t", "ULDA_BOSS_38p1", "ULDA_BOSS_38px1", "ULDA_BOSS_39p2", "ULDA_BOSS_39px2", "ULDA_BOSS_40p2", "ULDA_BOSS_40px2", "ULDA_BOSS_46p", "ULDA_BOSS_52p1", "ULDA_BOSS_54p", "ULDA_BOSS_59p", "ULDA_BOSS_59px", "ULDA_BOSS_60p", "ULDA_BOSS_60px", "ULDA_BOSS_61p", "ULDA_BOSS_61px", "ULDA_BOSS_67p2", "ULDA_BOSS_67p2e", "ULDA_BOSS_68p", "ULDA_BOSS_72e", "ULDA_BOSS_72ex", "ULDA_BOSS_74p", "ULDA_BOSS_74px", "ULDA_BOSS_75p", "ULDA_BOSS_75px", "ULDA_BOSS_76p", "ULDA_BOSS_76px", "ULDA_Brann_HP1", "ULDA_Reno_HP1", "UNG_004", "UNG_018", "UNG_025", "UNG_027", "UNG_027t2", "UNG_047", "UNG_057t1", "UNG_064", "UNG_084", "UNG_087", "UNG_111", "UNG_113", "UNG_116t", "UNG_202", "UNG_205", "UNG_211c", "UNG_211d", "UNG_803", "UNG_807", "UNG_817", "UNG_818", "UNG_831", "UNG_834", "UNG_835", "UNG_840", "UNG_847", "UNG_848", "UNG_910", "UNG_933", "UNG_934t2", "UNG_941", "UNG_946", "UNG_953", "UNG_955", "UNG_956", "UNG_956e", "VAN_CS1_112", "VAN_CS1_113", "VAN_CS1_129", "VAN_CS1_130", "VAN_CS2_008", "VAN_CS2_012", "VAN_CS2_022", "VAN_CS2_024", "VAN_CS2_025", "VAN_CS2_026", "VAN_CS2_028", "VAN_CS2_029", "VAN_CS2_031", "VAN_CS2_032", "VAN_CS2_033", "VAN_CS2_037", "VAN_CS2_042", "VAN_CS2_057", "VAN_CS2_061", "VAN_CS2_062", "VAN_CS2_063", "VAN_CS2_064", "VAN_CS2_072", "VAN_CS2_075", "VAN_CS2_076", "VAN_CS2_084", "VAN_CS2_093", "VAN_CS2_094", "VAN_CS2_108", "VAN_CS2_114", "VAN_CS2_141", "VAN_CS2_150", "VAN_CS2_181", "VAN_CS2_189", "VAN_CS2_203", "VAN_CS2_233", "VAN_CS2_234", "VAN_DREAM_02", "VAN_DREAM_04", "VAN_DREAM_05", "VAN_DS1_183", "VAN_DS1_185", "VAN_DS1_233", "VAN_EX1_002", "VAN_EX1_005", "VAN_EX1_029", "VAN_EX1_048", "VAN_EX1_049", "VAN_EX1_057", "VAN_EX1_066", "VAN_EX1_082", "VAN_EX1_091", "VAN_EX1_102", "VAN_EX1_124", "VAN_EX1_126", "VAN_EX1_129", "VAN_EX1_133", "VAN_EX1_134", "VAN_EX1_137", "VAN_EX1_144", "VAN_EX1_154", "VAN_EX1_154a", "VAN_EX1_154b", "VAN_EX1_161", "VAN_EX1_166", "VAN_EX1_166a", "VAN_EX1_166b", "VAN_EX1_170", "VAN_EX1_173", "VAN_EX1_238", "VAN_EX1_241", "VAN_EX1_245", "VAN_EX1_246", "VAN_EX1_249", "VAN_EX1_251", "VAN_EX1_259", "VAN_EX1_275", "VAN_EX1_277", "VAN_EX1_278", "VAN_EX1_279", "VAN_EX1_283", "VAN_EX1_298", "VAN_EX1_301", "VAN_EX1_302", "VAN_EX1_303", "VAN_EX1_304", "VAN_EX1_308", "VAN_EX1_309", "VAN_EX1_312", "VAN_EX1_313", "VAN_EX1_319", "VAN_EX1_320", "VAN_EX1_323", "VAN_EX1_332", "VAN_EX1_334", "VAN_EX1_360", "VAN_EX1_382", "VAN_EX1_384", "VAN_EX1_391", "VAN_EX1_400", "VAN_EX1_407", "VAN_EX1_408", "VAN_EX1_410", "VAN_EX1_522", "VAN_EX1_537", "VAN_EX1_539", "VAN_EX1_544", "VAN_EX1_558", "VAN_EX1_578", "VAN_EX1_581", "VAN_EX1_593", "VAN_EX1_594", "VAN_EX1_596", "VAN_EX1_603", "VAN_EX1_607", "VAN_EX1_609", "VAN_EX1_610", "VAN_EX1_617", "VAN_EX1_619", "VAN_EX1_622", "VAN_EX1_624", "VAN_EX1_625", "VAN_EX1_626", "VAN_HERO_05bp", "VAN_HERO_05bp2", "VAN_HERO_08bp", "VAN_HERO_08bp2", "VAN_NEW1_003", "VAN_NEW1_004", "VAN_NEW1_005", "VAN_NEW1_007", "VAN_NEW1_007a", "VAN_NEW1_007b", "VAN_NEW1_017", "VAN_NEW1_019", "VAN_NEW1_020", "VAN_NEW1_030", "VAN_NEW1_041", "WC_004", "WC_014", "WC_017", "WC_020", "WC_021", "WC_022", "WC_041", "WC_701", "YOD_014", "YOD_018", "YOD_020", "YOD_022", "YOD_029t", "YOP_006", "YOP_007", "YOP_020", "YOP_023", "YOP_027", "YOP_033" };
+
+        public enum CardEffect { UNKNOWN, FRIENDLY, UNFRIENDLY };
+
+        public static CardEffect ExtractEffect(string cardText)
+        {
+            try
+            {
+                return GetSpellEffect(cardText);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        public static CardEffect GetEffect(string cardId)
+        {
+            if (friendlyCards.Contains(cardId))
+            {
+                return CardEffect.FRIENDLY;
+            }
+            else if (unfriendlyCards.Contains(cardId))
+            {
+                return CardEffect.UNFRIENDLY;
+            }
+            else
+            {
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        private static CardEffect GetSpellEffect(string cardText)
+        {
+            var isFriendly = false;
+            var isUnfriendly = false;
+
+            if (IsSecret(cardText) ||
+                IsChooseAFriendlyMinion(cardText) ||
+                IsDiscover(cardText) ||
+                IsChooseN(cardText) ||
+                IsGiveSomething(cardText) ||
+                IsGainSomething(cardText) ||
+                IsDrawSomething(cardText) ||
+                IsRestoreSomething(cardText) ||
+                IsDoubleSomething(cardText) ||
+                IsPutACopyOf(cardText) ||
+                IsQuest(cardText) ||
+                IsWheneverItAttacks(cardText) ||
+                IsShuffle(cardText) ||
+                IsTrigger(cardText) ||
+                IsReveal(cardText) ||
+                IsSwap(cardText) ||
+                IsAddToHand(cardText) ||
+                IsReplaceYour(cardText) ||
+                IsAdapt(cardText) ||
+                IsResurrect(cardText) ||
+                IsSetGoodStats(cardText) ||
+                IsReturn(cardText) ||
+                IsRecruit(cardText) ||
+                IsSummon(cardText) ||
+                IsCostsLess(cardText) ||
+                IsWildcard(cardText)
+                )
+            {
+                isFriendly = true;
+            }
+
+            if (IsDealNDamage(cardText) ||
+                IsDestroySomething(cardText) ||
+                IsFreezeSomething(cardText) ||
+                IsTakeControl(cardText) ||
+                IsGainControl(cardText) ||
+                IsTransformSomething(cardText) ||
+                IsChangeSomething(cardText) ||
+                IsReturnSomething(cardText) ||
+                IsSilenceSomething(cardText) ||
+                IsShoot(cardText) ||
+                IsDealDamage(cardText) ||
+                IsThrowWeaponAt(cardText) ||
+                IsReduce(cardText) ||
+                IsChooseAnEnemyMinion(cardText) ||
+                IsSetBadStats(cardText) ||
+                IsForceMinion(cardText)
+                )
+            {
+                isUnfriendly = true;
+            }
+
+            if (isFriendly && isUnfriendly)
+            {
+                // Most cards that are both friendly and unfriendly are something like deal X damage to someone and gain Y health so we want to target unfriendly characters first
+                return CardEffect.UNFRIENDLY;
+            }
+            else if (isFriendly)
+            {
+                return CardEffect.FRIENDLY;
+            }
+            else if (isUnfriendly)
+            {
+                return CardEffect.UNFRIENDLY;
+            }
+            else
+            {
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        private static Regex s_costsLessRegex = new Regex(@" costs \(\d\) less.");
+        private static bool IsCostsLess(string cardText)
+        {
+            return s_costsLessRegex.Match(cardText).Success;
+        }
+
+        private static bool IsChooseAnEnemyMinion(string cardText)
+        {
+            return cardText.Contains("Choose an enemy minion");
+        }
+
+        private static bool IsReduce(string cardText)
+        {
+            return cardText.Contains("Reduce ");
+        }
+
+        private static bool IsThrowWeaponAt(string cardText)
+        {
+            return cardText.Contains("Throw your weapon ");
+        }
+
+        private static bool IsRecruit(string cardText)
+        {
+            return cardText.Contains("<b>Recruit</b>");
+        }
+
+        private static bool IsReturn(string cardText)
+        {
+            return cardText.Contains(" return it ");
+        }
+
+        private static Regex s_setAtkHealthRegex = new Regex(@"Set a minion's Attack and Health to (\d).");
+        private static bool IsSetBadStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val < 3;
+        }
+
+        private static bool IsSetGoodStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val >= 3;
+        }
+
+        private static bool IsResurrect(string cardText)
+        {
+            return cardText.Contains("Resurrect ");
+        }
+
+        private static bool IsAdapt(string cardText)
+        {
+            return cardText.Contains("<b>Adapt</b>");
+        }
+
+        private static bool IsReplaceYour(string cardText)
+        {
+            return cardText.Contains("Replace your ");
+        }
+
+        private static Regex s_addToHandRegex = new Regex(@"Add .* to your hand.*");
+        private static Regex s_addToHandLCRegex = new Regex(@" add .* to your hand.*");
+        private static Regex s_addToHandBrokenRegex = new Regex(@"Add .* to_your hand.*");
+        private static Regex s_addToHandBroken2Regex = new Regex(@"Add .* to your_hand.*");
+        private static bool IsAddToHand(string cardText)
+        {
+            return s_addToHandRegex.Match(cardText).Success ||
+                s_addToHandLCRegex.Match(cardText).Success ||
+                s_addToHandBrokenRegex.Match(cardText).Success ||
+                s_addToHandBroken2Regex.Match(cardText).Success;
+        }
+
+        private static bool IsSwap(string cardText)
+        {
+            return cardText.Contains("Swap ");
+        }
+
+        private static bool IsReveal(string cardText)
+        {
+            return cardText.Contains("Reveal ");
+        }
+
+        private static bool IsTrigger(string cardText)
+        {
+            return cardText.Contains("Trigger ");
+        }
+
+        private static bool IsShuffle(string cardText)
+        {
+            return cardText.Contains("Shuffle ");
+        }
+
+        private static bool IsDealDamage(string cardText)
+        {
+            return cardText.Contains("Deal damage ") || cardText.Contains("Deal that much damage");
+        }
+
+        private static bool IsWheneverItAttacks(string cardText)
+        {
+            return cardText.Contains("Whenever it attacks");
+        }
+
+        private static bool IsShoot(string cardText)
+        {
+            return cardText.Contains("Shoot ");
+        }
+
+        private static bool IsQuest(string cardText)
+        {
+            return cardText.Contains("<b>Quest:</b>") || cardText.Contains("<b>Sidequest:</b>");
+        }
+
+        private static bool IsPutACopyOf(string cardText)
+        {
+            return cardText.Contains("Put a copy of");
+        }
+
+        private static bool IsDoubleSomething(string cardText)
+        {
+            return cardText.Contains("Double ");
+        }
+
+        private static bool IsSilenceSomething(string cardText)
+        {
+            return cardText.Contains("<b>Silence</b> ");
+        }
+
+        private static bool IsRestoreSomething(string cardText)
+        {
+            return cardText.Contains("Restore ");
+        }
+
+        private static bool IsReturnSomething(string cardText)
+        {
+            return cardText.Contains("Return ");
+        }
+
+        private static bool IsChangeSomething(string cardText)
+        {
+            return cardText.Contains("Change ");
+        }
+
+        private static bool IsTransformSomething(string cardText)
+        {
+            return cardText.Contains("Transform ");
+        }
+
+        private static bool IsDrawSomething(string cardText)
+        {
+            return cardText.Contains("Draw ");
+        }
+
+        private static bool IsGainSomething(string cardText)
+        {
+            return cardText.Contains("Gain ");
+        }
+
+        private static bool IsForceMinion(string cardText)
+        {
+            return cardText.Contains("Force ");
+        }
+
+        private static bool IsGainControl(string cardText)
+        {
+            return cardText.Contains("Gain control ") || cardText.Contains("gain control");
+        }
+
+        private static bool IsFreezeSomething(string cardText)
+        {
+            return cardText.Contains("<b>Freeze</b> a");
+        }
+
+        private static bool IsSummon(string cardText)
+        {
+            return cardText.Contains("Summon ") || cardText.Contains(" summon ");
+        }
+
+        private static bool IsDestroySomething(string cardText)
+        {
+            return cardText.Contains("Destroy ") || cardText.Contains(" destroy it");
+        }
+
+        private static bool IsGiveSomething(string cardText)
+        {
+            return cardText.Contains("Give ") || cardText.Contains(" give it") || cardText.Contains("G[x]ive ");
+        }
+
+        private static Regex s_dealNDamageRegex = new Regex(@".*Deal \*?\d+\*? damage.*");
+        private static Regex s_dealXYDamageRegex = new Regex(@".*Deal \*?\d+\*?-\*?\d\*? damage.*");
+        private static Regex s_dealNDamageBrokenRegex = new Regex(@".*Deal_\*?\d+\*? damage.*");
+        private static Regex s_dealNDamageBroken2Regex = new Regex(@".*Deal_\*?\d+\*?_damage.*");
+        private static Regex s_dealNDamageMidStringRegex = new Regex(@".*, deal \*?\d+\*? damage.*"); // See Scalerider
+        private static bool IsDealNDamage(string cardText)
+        {
+            return s_dealNDamageRegex.Match(cardText).Success ||
+                s_dealXYDamageRegex.Match(cardText).Success ||
+                s_dealNDamageBrokenRegex.Match(cardText).Success ||
+                s_dealNDamageBroken2Regex.Match(cardText).Success ||
+                s_dealNDamageMidStringRegex.Match(cardText).Success;
+        }
+
+        private static bool IsTakeControl(string cardText)
+        {
+            return cardText.Contains("Take control ");
+        }
+
+        private static bool IsChooseN(string cardText)
+        {
+            return cardText.Contains("<b>Choose One ") || cardText.Contains("<b>Choose Twice");
+        }
+
+        private static bool IsDiscover(string cardText)
+        {
+            return cardText.Contains("<b>Discover</b>");
+        }
+
+        private static bool IsSecret(string cardText)
+        {
+            return cardText.Contains("<b>Secret:</b>");
+        }
+
+        private static bool IsChooseAFriendlyMinion(string cardText)
+        {
+            return cardText.Contains("Choose a friendly minion");
+        }
+
+        private static HashSet<string> s_wildcards = new HashSet<string>()
+        {
+            "The next spell you cast this turn costs (2) less.",
+"Put a random minion from each player's hand into the battlefield.",
+"When you play or discard this, deal 4 damage to a random enemy.",
+"This turn, your healing effects deal damage instead.",
+"Add two Razorpetals to_your hand that deal_1 damage.",
+"Each time you play a Beast this turn, add_a_random Beast to_your hand.",
+"The next spell you cast this turn costs Health instead of Mana.",
+"Copy the lowest Cost minion in your hand.",
+"Each turn this is in your hand, transform it into a random Mage spell.",
+"Enemy spells cost (5) more next turn.",
+"Each player gains 2_Mana Crystals.",
+"Add 2 random <b>Deathrattle</b> cards to_your hand.",
+"Each player draws 2_cards.",
+"Whenever a minion dies this turn, gain 1 Mana Crystal this turn only.",
+"Your hero is <b>Immune</b> until your next turn.",
+"The next Elemental you_play this turn costs (2) less.",
+"Choose a minion. Add_a copy of it to your hand.",
+"Each player transforms a random minion in their hand into a Demon.",
+"Add a random card from another class to_your hand.",
+"Copy all Beasts in your_hand.",
+"Add a random Hunter Beast, <b>Secret</b>, and weapon to your_hand.",
+"Your hero can't take damage this turn.",
+"Your opponent has 2 fewer Mana Crystals next turn.",
+"Set the Attack of all enemy minions to 1 until your next turn.",
+"Your next spell this turn casts twice.",
+"Set each player to 0 Mana Crystals. Set the Cost of cards in all hands and decks to (1).",
+"Cast 10 random spells <i>(targets chosen randomly).</i>",
+        };
+
+        private static HashSet<string> s_wildcardSubsets = new HashSet<string>()
+        {
+            "Put one of each <b>Secret</b> from your deck into",
+            "Each player equips",
+            "Set the Attack and Health of all minions",
+            "Cast a random",
+            "Fill your hand with",
+            "When you play",
+            "At the start of your next turn",
+            "Increase the damage of",
+            "Play 3 cards\n with",
+            "Play 3 different",
+            "At the start of your next",
+            "Unlock your <b>Overloaded</b>",
+            "Take 6\n damage on your turns",
+            "Take 6\ndamage on your turns",
+        };
+
+        private static bool IsWildcard(string cardText)
+        {
+            if (s_wildcards.Contains(cardText))
+            {
+                return true;
+            }
+
+            foreach (var wc in s_wildcardSubsets)
+            {
+                if (cardText.Contains(wc))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollection.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollection.cs
new file mode 100644
index 0000000..98f65b1
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollection.cs
@@ -0,0 +1,28 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionDeckTrayButton : AccessibleItem
+    {
+        private readonly CollectionDeckTrayButton m_button;
+
+        internal AccessibleCollectionDeckTrayButton(AccessibleComponent parent, CollectionDeckTrayButton button) : base(parent)
+        {
+            m_button = button;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_button.m_buttonText.Text);
+
+            return ret;
+        }
+
+        internal CollectionDeckTrayButton GetCollectionDeckTrayButton()
+        {
+            return m_button;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs
new file mode 100644
index 0000000..b0d6730
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs
@@ -0,0 +1,84 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionDeckBoxVisual : AccessibleItem
+    {
+        private readonly CollectionDeckBoxVisual m_deck;
+
+        private bool m_inCollectionManager;
+
+        internal AccessibleCollectionDeckBoxVisual(AccessibleComponent parent, CollectionDeckBoxVisual deck, bool inCollectionManager=false) : base(parent)
+        {
+            m_deck = deck;
+            m_inCollectionManager = inCollectionManager;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_inCollectionManager)
+            {
+                return GetLinesForCollectionManager();
+            }
+            else
+            {
+                return GetLinesForDeckSelectionScreen();
+            }
+        }
+
+        private List<string> GetLinesForDeckSelectionScreen()
+        {
+            // Name and class
+            var ret = GetCommonDeckLines();
+
+            try
+            {
+                // Hero level
+                var heroLevel = GameUtils.GetHeroLevel(m_deck.GetClass());
+                var currentLevel = heroLevel.CurrentLevel?.Level;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_DECK_HERO_LEVEL, currentLevel));
+            }
+            catch (Exception)
+            {
+                // In some scenarios such as the first time we open practice mode right after the tutorial ends the hero level isn't populated
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForCollectionManager()
+        {
+            // Name and class for now. TODO: Missing cards later
+            return GetCommonDeckLines();
+        }
+
+        private List<string> GetCommonDeckLines()
+        {
+            var ret = new List<string>();
+
+            // Deck name
+            var deckName = m_deck.GetDeckNameText().Text;
+            ret.Add(deckName);
+
+            // Hero name
+            var className = GameStrings.GetClassName(m_deck.GetClass());
+            if (!className.Equals(deckName, System.StringComparison.InvariantCultureIgnoreCase))
+            {
+                ret.Add(className);
+            }
+
+            // Missing cards
+            if (m_deck.IsMissingCards)
+            {
+                var collectionDeck = m_deck.GetCollectionDeck();
+				int maxCardCount = collectionDeck.GetMaxCardCount();
+				int totalValidCardCount = collectionDeck.GetTotalValidCardCount();
+
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK, totalValidCardCount, maxCardCount));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs
new file mode 100644
index 0000000..ed220d7
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs
@@ -0,0 +1,856 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleCollectionManager : AccessibleScreen
+    {
+        private enum State {
+            LOADING,
+            MAIN_MENU,
+            BROWSING_COLLECTION,
+            MANAGE_DECKS_MENU,
+            BROWSING_DECKS_FOR_EDITING,
+            BROWSING_DECKS_FOR_DELETING,
+            EDIT_DECK_MENU,
+            EDIT_DECK_SEE_COLLECTION,
+            EDIT_DECK_SEE_DECK,
+            EDIT_DECK_RENAME_DECK,
+            CREATE_DECK_FROM_CLIPBOARD,
+        };
+
+        private State m_curState;
+
+        private AccessibleMenu m_mainMenu;
+
+        private AccessibleMenu m_manageDecksMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_editDecksMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_deleteDecksMenu;
+
+        private AccessibleMenu m_editDeckMenu;
+
+        // Collection book stuff
+        private TAG_CLASS m_curClassContext;
+        private AccessibleListOfItems<AccessibleCollectibleCard> m_curPageCards;
+        private List<CollectionCardActors> m_curPageCardActors;
+        private bool m_justPressedLeft;
+        private int m_curPageNum;
+
+        private static AccessibleCollectionManager s_instance = new AccessibleCollectionManager();
+
+        internal static AccessibleCollectionManager Get() {
+            return s_instance;
+        }
+
+        internal void OnCollectionManagerOpened()
+        {
+            m_curState = State.LOADING;
+
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerOpened");
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        private void HandlePageInput()
+        {
+            if (m_curPageCards != null)
+            {
+                if (AccessibleKey.READ_NEXT_PAGE.IsPressed())
+                {
+                    GetCollectionPageManager().m_pageRightClickableRegion.TriggerRelease();
+                }
+                else if (AccessibleKey.READ_PREV_PAGE.IsPressed())
+                {
+                    GetCollectionPageManager().m_pageLeftClickableRegion.TriggerRelease();
+                }
+                else if (!m_curPageCards.HandleAccessibleInput())
+                {
+                    if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+                    {
+                        m_justPressedLeft = true;
+                        GetCollectionPageManager().m_pageLeftClickableRegion.TriggerRelease();
+                    }
+                    else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+                    {
+                        GetCollectionPageManager().m_pageRightClickableRegion.TriggerRelease();
+                    }
+                }
+                else
+                {
+                    m_justPressedLeft = false;
+                }
+            }
+        }
+
+        private CollectionManagerDisplay GetCollectionManagerDisplay()
+        {
+            return CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        }
+
+        private ManaFilterTabManager GetManaFilterTabManager()
+        {
+            return GetCollectionManagerDisplay().m_manaTabManager;
+        }
+
+        private CollectionPageManager GetCollectionPageManager()
+        {
+            return GetCollectionManagerDisplay().m_pageManager;
+        }
+
+        internal void OnPageChanged(int curPageNum, List<CollectibleCard> cardsToDisplay, List<CollectionCardActors> cardActors)
+        {
+            AccessibilityUtils.LogDebug("CM OnPageChanged");
+            AccessibilityUtils.LogDebug($"CM curPageNum {curPageNum}");
+            AccessibilityUtils.LogDebug($"CM cardsToDisplay {cardsToDisplay.Count}");
+
+            foreach (var card in cardsToDisplay)
+            {
+                AccessibilityUtils.LogDebug($"CM -- {card.Name}");
+            }
+
+            var classContext = GetCollectionPageManager().m_currentClassContext;
+
+            AccessibilityUtils.LogDebug($"CM classContext={classContext} | m_curClassContext={m_curClassContext}");
+
+            if (curPageNum != m_curPageNum && (m_curState == State.BROWSING_COLLECTION || m_curState == State.EDIT_DECK_SEE_COLLECTION))
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, curPageNum));
+                AccessibilityMgr.Output(this, GameStrings.GetClassName(classContext));
+            }
+
+            var accessibleCards = new List<AccessibleCollectibleCard>(cardsToDisplay.Count);
+            cardsToDisplay.ForEach(c => accessibleCards.Add(new AccessibleCollectibleCard(this, c)));
+
+            var curPageCards = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+
+            if (m_curPageCards == null || !SameCards(curPageCards.Items, m_curPageCards.Items))
+            {
+                if (m_curState == State.BROWSING_COLLECTION || m_curState == State.EDIT_DECK_SEE_COLLECTION)
+                {
+                    if (m_justPressedLeft)
+                    {
+                        curPageCards.StartReadingReverse();
+                    }
+                    else
+                    {
+                        curPageCards.StartReading();
+                    }
+                }
+            }
+
+            m_curPageCards = curPageCards;
+            m_curPageCardActors = cardActors;
+            m_curClassContext = classContext;
+            m_curPageNum = curPageNum;
+            m_justPressedLeft = false;
+        }
+
+        private bool SameCards(List<AccessibleCollectibleCard> l1, List<AccessibleCollectibleCard> l2)
+        {
+            if (l1.Count != l2.Count)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < l1.Count; i++)
+            {
+                if (!l1[i].GetName().Equals(l2[i].GetName()))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        internal void OnCollectionManagerClosed()
+        {
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerClosed");
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        internal void OnCollectibleDisplayReady()
+        {
+            AccessibilityUtils.LogDebug("CM OnCollectibleDisplayReady");
+
+            SetupMainMenu();
+            // CollectionManager.Get().GetCollectibleDisplay().
+        }
+
+        #region Input
+
+        public void HandleInput()
+        {
+            switch (m_curState)
+            {
+                case State.BROWSING_COLLECTION:
+                    HandleBrowsingCollectionInput();
+                    break;
+                case State.MANAGE_DECKS_MENU:
+                    m_manageDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSING_DECKS_FOR_EDITING:
+                    m_editDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSING_DECKS_FOR_DELETING:
+                    m_deleteDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.MAIN_MENU:
+                    m_mainMenu?.HandleAccessibleInput();
+                    break;
+                case State.EDIT_DECK_MENU:
+                    m_editDeckMenu?.HandleAccessibleInput();
+                    break;
+                case State.EDIT_DECK_SEE_COLLECTION:
+                    HandleBrowsingCollectionInput(true);
+                    break;
+                case State.EDIT_DECK_SEE_DECK:
+                    HandleEditDeckSeeDeck();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private void HandleBrowsingCollectionInput(bool inEditDeck=false)
+        {
+            UpdateMouseWhenBrowsingCollection();
+
+            // TODO: If mode etc
+            HandleManaFiltersInput();
+            if (!HandleClassTabsInput())
+            {
+                HandlePageInput(); // Protect against tabs
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                AccessibilityUtils.ReadTooltip(this);
+            }
+
+            // TODO: Refactor this entire thing out
+            if (inEditDeck)
+            {
+                if (AccessibleKey.BACK.IsPressed())
+                {
+                    SetupEditDeckMenu();
+                }
+                else if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    if (AccessibleKey.CONFIRM.IsPressed() && inEditDeck)
+                    {
+                        AccessibleInputMgr.ClickLeftMouseButton();
+                    }
+                }
+                else
+                {
+                    HandleEditDeckShortcuts();
+                }
+            }
+            else
+            {
+                if (AccessibleKey.BACK.IsPressed())
+                {
+                    SetupMainMenu();
+                }
+            }
+        }
+
+        private void HandleEditDeckShortcuts()
+        {
+            if (AccessibleKey.SEE_PLAYER_DECK.IsPressed())
+            {
+                EditDeckSeeDeck();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HAND.IsPressed())
+            {
+                EditDeckAddCards();
+            }
+        }
+
+        private void HandleEditDeckSeeDeck()
+        {
+            UpdateMouseWhenEditingDeck();
+
+            m_editingDeckCards?.HandleAccessibleInput();
+
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                SetupEditDeckMenu();
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    AccessibleInputMgr.ClickLeftMouseButton();
+                }
+            }
+            else
+            {
+                HandleEditDeckShortcuts();
+            }
+        }
+
+        private void UpdateMouseWhenBrowsingCollection()
+        {
+            var idx = m_curPageCards.GetItemBeingReadIndex();
+
+            if (m_curPageCardActors != null && idx < m_curPageCardActors.Count)
+            {
+                var actor = m_curPageCardActors[idx].GetPreferredActor(); // Only 1 in this scenario. Crafting would be different though
+                AccessibleInputMgr.MoveMouseTo(actor);
+            }
+        }
+
+        private AccessibleEditingDeckCard m_prevCardBeingRead;
+
+        private void UpdateMouseWhenEditingDeck()
+        {
+            var curCard = m_editingDeckCards?.GetItemBeingRead();
+
+            if (curCard != m_prevCardBeingRead)
+            {
+                AccessibilityUtils.CenterScrollbarAroundObject(CollectionDeckTray.Get().m_scrollbar, curCard.GetCardTile().gameObject);
+            }
+
+            AccessibleInputMgr.MoveMouseTo(curCard.GetCardTile().GetActor());
+
+            m_prevCardBeingRead = curCard;
+        }
+
+        private void HandleManaFiltersInput()
+        {
+            // TODO: Disable this for now as it could confuse people until we find a proper way of enunciating it
+            return;
+
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                int pressedTab = numKeyPressed.Value;
+
+                if (pressedTab == 10)
+                {
+                    pressedTab = 0;
+                }
+                else if (pressedTab > ManaFilterTabManager.NUM_MANA_FILTERS)
+                {
+                    return;
+                }
+
+                var tabs = GetManaFilterTabManager().m_tabs;
+
+                if (pressedTab >= tabs.Count)
+                {
+                    return;
+                }
+
+                m_justPressedLeft = false;
+                tabs[pressedTab].TriggerRelease();
+            }
+        }
+
+        private bool HandleClassTabsInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(1);
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(-1);
+                return true;
+            }
+
+            return false;
+        }
+
+        private void FlipToNextClass(int inc)
+        {
+            m_justPressedLeft = false;
+
+            var classTabs = GetCollectionPageManager().m_classTabs.FindAll(t => t.IsVisible()); // Show only visible tabs due to filters
+
+            var curClassTab = 0;
+            for (int i = 0; i < classTabs.Count; i++)
+            {
+                if (classTabs[i].IsSelected())
+                {
+                    curClassTab = i;
+                    break;
+                }
+            }
+
+            int targetClassTab = curClassTab + inc;
+
+            if (targetClassTab < 0)
+            {
+                targetClassTab = classTabs.Count - 1;
+            }
+            else if (targetClassTab >= classTabs.Count)
+            {
+                targetClassTab = 0;
+            }
+
+            classTabs[targetClassTab].TriggerRelease();
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION), () => Navigation.GoBack());
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION), OnBrowseCollection);
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS), SetupDeckManagementMenu);
+
+            m_mainMenu.StartReading();
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void OnBrowseCollection()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext));
+            m_curPageCards.StartReading();
+
+            m_curState = State.BROWSING_COLLECTION;
+        }
+
+        private void SetupDeckManagementMenu()
+        {
+            m_manageDecksMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS), SetupMainMenu);
+
+            if (HasDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), SetupEditDecksMenu);
+            }
+
+            if (CanCreateDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_NEW_DECK), OnNewDeck);
+            }
+
+            if (CanDeleteDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_DELETE_DECK), SetupDeleteDecksMenu);
+            }
+
+            m_manageDecksMenu.StartReading();
+            m_curState = State.MANAGE_DECKS_MENU;
+        }
+
+        private void SetupDeleteDecksMenu()
+        {
+            m_deleteDecksMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_DELETE_DECK), SetupDeckManagementMenu);
+            var scrollbar = CollectionDeckTray.Get().m_scrollbar;
+
+            foreach (var traySection in GetVisibleTraySections())
+            {
+                var deckBox = traySection.m_deckBox;
+
+                m_deleteDecksMenu.AddOption(new AccessibleCollectionDeckBoxVisual(this, deckBox, true), () => DeleteDeck(deckBox), () => AccessibilityUtils.CenterScrollbarAroundObject(scrollbar, deckBox.gameObject));
+            }
+
+            m_deleteDecksMenu.StartReading();
+            m_curState = State.BROWSING_DECKS_FOR_DELETING;
+        }
+
+        private void DeleteDeck(CollectionDeckBoxVisual deck)
+        {
+            CollectionManager.Get().RegisterDeckDeletedListener(OnDeckDeleted);
+            deck.m_deleteButton.TriggerRelease();
+        }
+
+        private void OnDeckDeleted(CollectionDeck removedDeck)
+        {
+            SetupDeckManagementMenu();
+
+            CollectionManager.Get().RemoveDeckDeletedListener(OnDeckDeleted);
+        }
+
+        private void SetupEditDecksMenu()
+        {
+            m_editDecksMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), SetupDeckManagementMenu);
+            var scrollbar = CollectionDeckTray.Get().m_scrollbar;
+
+            foreach (var traySection in GetVisibleTraySections())
+            {
+                var deckBox = traySection.m_deckBox;
+                m_editDecksMenu.AddOption(new AccessibleCollectionDeckBoxVisual(this, deckBox, true), () => EditDeck(deckBox), () => AccessibilityUtils.CenterScrollbarAroundObject(scrollbar, deckBox.gameObject));
+            }
+
+            m_editDecksMenu.StartReading();
+            m_curState = State.BROWSING_DECKS_FOR_EDITING;
+        }
+
+        internal void OnFinishRenamingDeck()
+        {
+            AccessibilityMgr.DisallowTextInput();
+
+            if (m_curState == State.EDIT_DECK_RENAME_DECK)
+            {
+                // Prevent against rename notifications when the deck closes
+                SetupEditDeckMenu();
+            }
+        }
+
+        private List<TraySection> GetVisibleTraySections()
+        {
+            var ret = new List<TraySection>();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+
+            foreach (var traySection in decksContent.m_traySections)
+            {
+                if (traySection.IsDeckBoxShown())
+                {
+                    ret.Add(traySection);
+                }
+            }
+
+            return ret;
+        }
+
+        private void SetupEditDeckMenu()
+        {
+            AccessibilityUtils.LogDebug("Setup EditDeckMenu");
+
+            AccessibleInputMgr.HideMouse();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+            var deckName = collectionDeckTray.GetEditingDeckBox().GetDeckNameText().Text;
+
+            //m_editDeckMenu = new AccessibleMenu(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), null); // TODO: Back from both edit and create new
+            m_editDeckMenu = new AccessibleMenu(this, deckName, null); // TODO: Back from both edit and create new
+
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION), EditDeckAddCards);
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION), EditDeckSeeDeck);
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION), EditDeckRenameDeck);
+            m_editDeckMenu.AddOption(CollectionDeckTray.Get().m_doneButton.GetText(), EditDeckDone);
+
+            m_editDeckMenu.StartReading();
+            m_curState = State.EDIT_DECK_MENU;
+
+            CollectionDeckTray.Get().m_cardsContent.UnregisterCardCountUpdated(OnCardCountUpdated);
+            CollectionDeckTray.Get().m_cardsContent.RegisterCardCountUpdated(OnCardCountUpdated);
+        }
+
+        private void OnCardCountUpdated(int cardCount)
+        {
+            if (m_curState == State.EDIT_DECK_SEE_DECK || m_curState == State.EDIT_DECK_SEE_COLLECTION)
+            {
+                int deckSize = CollectionManager.Get().GetDeckSize();
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK, cardCount, deckSize));
+            }
+
+            // Update deck cards if needed
+            if (m_curState == State.EDIT_DECK_SEE_DECK)
+            {
+                UpdateEditingDeckCardsAfterCardRemoved();
+            }
+        }
+
+        private void UpdateEditingDeckCardsAfterCardRemoved()
+        {
+            var numCardsBeforeRemovingCard = m_editingDeckCards.Count;
+            var editingDeckCards = BuildAccessibleEditingDeckCards();
+            var numCardsAfterRemovingCard = editingDeckCards.Count;
+
+            AccessibilityUtils.LogDebug($"CM card removed numCardsBeforeRemovingCard={numCardsBeforeRemovingCard} numCardsAfterRemovingCard={numCardsAfterRemovingCard}");
+
+
+            if (editingDeckCards.Count == 0)
+            {
+                SetupEditDeckMenu();
+            }
+            else if (numCardsBeforeRemovingCard != numCardsAfterRemovingCard)
+            {
+                m_editingDeckCards.UpdateItems(editingDeckCards);
+                m_editingDeckCards.StartReading();
+            }
+            else
+            {
+                m_editingDeckCards.GetItemBeingRead().Reset();
+                m_editingDeckCards.StartReading();
+            }
+        }
+
+        private void EditDeckRenameDeck()
+        {
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT));
+
+            decksContent.m_editingTraySection.m_deckBox.SetDeckName("");
+            decksContent.RenameCurrentlyEditingDeck();
+            AccessibilityMgr.AllowTextInput();
+
+            m_curState = State.EDIT_DECK_RENAME_DECK;
+        }
+
+        private AccessibleListOfItems<AccessibleEditingDeckCard> m_editingDeckCards;
+
+        private void EditDeckSeeDeck()
+        {
+            var editingDeckCards = BuildAccessibleEditingDeckCards();
+
+            if (editingDeckCards.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK));
+            }
+            else
+            {
+                AccessibleInputMgr.HideMouse();
+
+                int cardCount = CountCards(editingDeckCards);
+                int deckSize = CollectionManager.Get().GetDeckSize();
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK, cardCount, deckSize));
+
+                m_editingDeckCards = new AccessibleListOfItems<AccessibleEditingDeckCard>(this, BuildAccessibleEditingDeckCards());
+                m_editingDeckCards.StartReading();
+                m_curState = State.EDIT_DECK_SEE_DECK;
+            }
+        }
+
+        private int CountCards(List<AccessibleEditingDeckCard> editingDeckCards)
+        {
+            int ret = 0;
+
+            foreach(var card in editingDeckCards)
+            {
+                ret += card.GetCardTile().GetSlot()?.Count ?? 0;
+            }
+
+            return ret;
+        }
+
+        private List<AccessibleEditingDeckCard> BuildAccessibleEditingDeckCards()
+        {
+            var editingDeckCards = new List<AccessibleEditingDeckCard>();
+
+            foreach(var cardTile in GetNonMissingCardTiles())
+            {
+                editingDeckCards.Add(new AccessibleEditingDeckCard(this, cardTile));
+            }
+
+            return editingDeckCards;
+        }
+
+        private List<DeckTrayDeckTileVisual> GetNonMissingCardTiles()
+        {
+            var ret = new List<DeckTrayDeckTileVisual>();
+
+            CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+            var cardTiles = collectionDeckTray.GetCardsContent().GetCardTiles();
+
+            foreach(var cardTile in cardTiles)
+            {
+                if (cardTile.IsInUse() && !IsMissing(cardTile))
+                {
+                    ret.Add(cardTile);
+                }
+            }
+
+            return ret;
+        }
+
+        private bool IsMissing(DeckTrayDeckTileVisual cardTile)
+        {
+            return cardTile.GetGhostedState() != CollectionDeckTileActor.GhostedState.NONE;
+        }
+
+        private void EditDeckAddCards()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext));
+            m_curPageCards.StartReading();
+            m_curState = State.EDIT_DECK_SEE_COLLECTION;
+        }
+
+        private void EditDeckDone()
+        {
+            CollectionManager.Get().RegisterEditedDeckChanged(OnEditedDeckDone);
+            CollectionDeckTray.Get().m_doneButton.TriggerRelease();
+        }
+
+        private void EditDeck(CollectionDeckBoxVisual deckBox)
+        {
+            CollectionManager.Get().RegisterEditedDeckChanged(OnEditedDeckChanged);
+            AccessibleInputMgr.Click(deckBox.transform);
+        }
+
+        private void OnEditedDeckChanged(CollectionDeck newDeck, CollectionDeck oldDeck, object callbackData)
+        {
+            AccessibilityUtils.LogDebug("CM OnEditDeckChanged");
+            CollectionManager.Get().RemoveEditedDeckChanged(OnEditedDeckChanged);
+            SetupEditDeckMenu();
+        }
+
+        private void OnEditedDeckDone(CollectionDeck newDeck, CollectionDeck oldDeck, object callbackData)
+        {
+            AccessibilityUtils.LogDebug("CM OnEditDeckDone");
+            CollectionManager.Get().RemoveEditedDeckChanged(OnEditedDeckDone);
+
+            SetupMainMenu();
+        }
+
+        private void OnNewDeck()
+        {
+            GetNewDeckButton().TriggerRelease();
+        }
+
+        private bool CanCreateDecks()
+        {
+            var newDeckButton = GetNewDeckButton();
+
+            return newDeckButton != null && newDeckButton.IsEnabled() && newDeckButton.IsUsable();
+        }
+
+        private bool CanDeleteDecks()
+        {
+            return HasDecks(); // TODO
+        }
+
+        private CollectionDeckTrayButton GetNewDeckButton()
+        {
+            return CollectionDeckTray.Get()?.GetDecksContent()?.m_newDeckButton;
+        }
+
+        private bool HasDecks()
+        {
+            return GetVisibleTraySections().Count > 0;
+        }
+
+        internal void OnEditDeckScreen()
+        {
+            // Just wait if we're creating from clipboard as it'll switch back once the cards fill
+            if (m_curState != State.CREATE_DECK_FROM_CLIPBOARD)
+            {
+                AccessibilityMgr.SetScreen(this);
+
+                SetupEditDeckMenu();
+            }
+        }
+
+        #endregion
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.StartReading();
+            }
+            else if (m_curState == State.BROWSING_DECKS_FOR_DELETING)
+            {
+                if (!CollectionManager.Get().IsDeleteDeckPending())
+                {
+                    m_deleteDecksMenu?.StartReading();
+                }
+            }
+        }
+
+        #region Help
+
+        public string GetHelp()
+        {
+            switch(m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                case State.BROWSING_COLLECTION:
+                    return GetHelpForBrowsingCollection();
+                case State.MANAGE_DECKS_MENU:
+                    return m_manageDecksMenu?.GetHelp();
+                case State.BROWSING_DECKS_FOR_EDITING:
+                    return m_editDecksMenu?.GetHelp();
+                case State.BROWSING_DECKS_FOR_DELETING:
+                    return m_deleteDecksMenu?.GetHelp();
+                case State.EDIT_DECK_MENU:
+                    return m_editDeckMenu?.GetHelp();
+                case State.EDIT_DECK_SEE_COLLECTION:
+                    return GetHelpForEditDeckSeeCollection();
+                case State.EDIT_DECK_SEE_DECK:
+                    return GetHelpForEditDeckSeeDeck();
+                case State.EDIT_DECK_RENAME_DECK:
+                    return GetHelpForEditDeckRenameDeck();
+            }
+
+            return "";
+        }
+
+        internal void OnFinishingDeckAutoFill()
+        {
+            m_curState = State.LOADING;
+        }
+
+        private string GetHelpForBrowsingCollection()
+        {
+            return AccessibleSpeechUtils.CombineLines(GetHelpLinesForBrowsingCollection());
+        }
+
+        private List<string> GetHelpLinesForBrowsingCollection()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP, AccessibleKey.READ_NEXT_VALID_ITEM));
+            // TODO: MANA FILTERS
+            //ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP));
+
+            return ret;
+        }
+
+        internal void OnDeleteDeckCanceled()
+        {
+            m_deleteDecksMenu?.StartReading();
+        }
+
+        private string GetHelpForEditDeckSeeDeck()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP));
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP, AccessibleKey.CONFIRM));
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        private string GetHelpForEditDeckSeeCollection()
+        {
+            var ret = GetHelpLinesForBrowsingCollection();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP, AccessibleKey.CONFIRM));
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        private string GetHelpForEditDeckRenameDeck()
+        {
+            return LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT);
+        }
+
+        #endregion
+
+        internal void OnCreateDeckFromClipboard()
+        {
+            m_curState = State.CREATE_DECK_FROM_CLIPBOARD;
+        }
+
+        internal void OnFinishAutoAddCardsWithTiming()
+        {
+            if (m_curState == State.CREATE_DECK_FROM_CLIPBOARD)
+            {
+                AccessibilityMgr.SetScreen(this);
+                SetupEditDeckMenu();
+            }
+        }
+
+        internal bool IsCreatingDeckFromClipboard()
+        {
+            return m_curState == State.CREATE_DECK_FROM_CLIPBOARD;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs
new file mode 100644
index 0000000..8116cec
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs
@@ -0,0 +1,35 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleDeckTemplatePickerButton : AccessibleItem
+    {
+        private readonly DeckTemplatePickerButton m_button;
+
+        private bool m_isCustomDeck;
+
+        internal AccessibleDeckTemplatePickerButton(AccessibleComponent parent, DeckTemplatePickerButton button, bool isCustomDeck = false) : base(parent)
+        {
+            m_button = button;
+            m_isCustomDeck = isCustomDeck;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            // Template name
+            ret.Add(m_button.m_title.Text);
+
+            if (!m_isCustomDeck)
+            {
+                // Owned cards
+                var ownedCardCount = m_button.GetOwnedCardCount();
+                int deckSize = CollectionManager.Get().GetDeckSize();
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT, ownedCardCount, deckSize));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs
new file mode 100644
index 0000000..ac76d3d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs
@@ -0,0 +1,35 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleEditingDeckCard : AccessibleItem
+    {
+        private AccessibleCollectibleCard m_card;
+
+        private readonly CollectibleCard m_collectibleCard;
+
+        private readonly DeckTrayDeckTileVisual m_cardTile;
+
+        public AccessibleEditingDeckCard(AccessibleComponent parent, DeckTrayDeckTileVisual cardTile) : base(parent)
+        {
+            var cardId = cardTile.GetCardID();
+            var cardRecord = GameUtils.GetCardRecord(cardId);
+            var cardEntityDef = DefLoader.Get().GetEntityDef(cardId);
+
+            m_collectibleCard = new CollectibleCard(cardRecord, cardEntityDef, cardTile.GetPremium());
+            m_cardTile = cardTile;
+        }
+
+        internal override List<string> GetLines()
+        {
+            int count = m_cardTile.GetSlot()?.Count ?? 1;
+            m_card = new AccessibleCollectibleCard(m_parent, m_collectibleCard, count);
+            return m_card.GetLines();
+        }
+
+        public DeckTrayDeckTileVisual GetCardTile()
+        {
+            return m_cardTile;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs b/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs
new file mode 100644
index 0000000..9ad24e7
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs
@@ -0,0 +1,38 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class EntityComparer : IEqualityComparer<Entity>
+    {
+        public bool Equals(Entity e1, Entity e2)
+        {
+            if (e1 == null || e2 == null)
+            {
+                // None of this should happen but..
+                if (e1 == e2)
+                {
+                    return true; // Keep the hashCode contract
+                }
+
+                return false;
+            }
+
+            return e1.GetEntityId() == e2.GetEntityId();
+        }
+
+        public int GetHashCode(Entity e)
+        {
+            if (e == null)
+            {
+                return 0;
+            }
+
+            return e.GetEntityId().GetHashCode();
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs
new file mode 100644
index 0000000..15674a5
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs
@@ -0,0 +1,28 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class GlobalAccessibleMenuUtils
+    {
+        public static bool ReadPrevIsPressed()
+        {
+            return AccessibleKey.READ_PREV_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_GLOBAL_VALID_MENU_OPTION.IsPressed();
+        }
+
+        public static bool ReadNextIsPressed()
+        {
+            return AccessibleKey.READ_NEXT_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_GLOBAL_VALID_MENU_OPTION.IsPressed();
+        }
+
+        internal static bool ConfirmIsPressed()
+        {
+            return AccessibleKey.GLOBAL_CONFIRM.IsPressed();
+        }
+
+        internal static bool BackIsPressed()
+        {
+            return AccessibleKey.GLOBAL_BACK.IsPressed();
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs b/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs
new file mode 100644
index 0000000..8dc39fa
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs
@@ -0,0 +1,270 @@
+﻿using PegasusShared;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    class HSADevTools
+    {
+        private static int s_curCheat;
+
+        internal static void Init()
+        {
+            // Disable cinematics and other things blind users wouldn't be able to enjoy
+            InitNecessaryOverrides();
+
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+
+            //ResetRotationTutorial();
+
+            //ShowFakeNerfedCards();
+
+            //ShowFakeAddedCards();
+
+            //ShowGoldCapAlert();
+
+            //ShowFakeBreakingNews();
+
+            //ResetLoginPopupSequence();
+
+            //SetNewPlayerFirstTime();
+
+            //SetFirstTimeHub(); // Only applies on the next login actually
+
+            //SetNotReturningPlayer(); // Ran into something weird here and had to fix it -- TODO: Rethink this
+
+            //SetReturningPlayer(); // Done via method -- TODO: Rethink this
+        }
+
+        private static void ResetRotationTutorial()
+        {
+            SetNotReturningPlayer();
+            CheatMgr.Get().ProcessCheat("resetrotationtutorial veteran");
+        }
+
+        private static void ShowGoldCapAlert()
+        {
+            NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().Cap = -1;
+        }
+
+        private static void ShowFakeBreakingNews()
+        {
+            Vars.Key("Cheats.ShowFakeBreakingNews").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeAddedCards()
+        {
+            Vars.Key("Cheats.ShowFakeAddedCards").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeNerfedCards()
+        {
+            Vars.Key("Cheats.ShowFakeNerfedCards").Set(true.ToString(), false);
+        }
+
+        private static void ResetLoginPopupSequence()
+        {
+            GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.PLAYER_OPTIONS, GameSaveKeySubkeyId.LOGIN_POPUP_SEQUENCE_SEEN_POPUPS, new long[0]));
+        }
+
+        private static void InitNecessaryOverrides()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_NEW_CINEMATIC, true);
+        }
+
+        private static void SetNotReturningPlayer()
+        {
+            ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_NOT_RETURNING_PLAYER);
+        }
+
+        private static void SetReturningPlayer()
+        {
+            ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_ACTIVE);
+            Options.Get().SetInt(Option.RETURNING_PLAYER_BANNER_SEEN, 0);
+        }
+
+        private static void SetFirstTimeHub()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_HUB, false);
+            Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_TRAY, false);
+            Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, false);
+        }
+
+        private static void SetNewPlayerFirstTime()
+        {
+            var profileProgress = ReactiveNetCacheObject<NetCache.NetCacheProfileProgress>.CreateInstance();
+            profileProgress.Value.CampaignProgress = TutorialProgress.NOTHING_COMPLETE;
+        }
+
+        internal static void RunTests()
+        {
+            //ShowFatalError(); // TODO: Figure out where we want to test this given that it forces a close
+
+            RunManualTests();
+
+            //TestFreeDeckPopup();
+        }
+
+        private static void TestFreeDeckPopup()
+        {
+            // Must cancel
+			AssetLoader.Get().InstantiatePrefab(PopupDisplayManager.CHOOSE_A_DECK_PREFAB, (assetRef, go, cb) => { OverlayUI.Get().AddGameObject(go); });
+            return;
+        }
+
+        private static void RunManualTests()
+        {
+            var cheats = new string[]{
+                // vvv All of this is automated now. Keeping the list as it might be useful to test new features
+
+                // Testing requires bronze 10 thingy
+                "notice card 2 NEW1_040 true",
+
+                // Daily quests on login
+                "iks",
+
+                // ReconnectHelperDialog
+                "hsashowreconnecthelperdialog false false false",
+                "hsashowreconnecthelperdialog false true false",
+                "hsashowreconnecthelperdialog true false false",
+
+                // Quest toasts
+                "notice gold 327 1 true",
+                "notice arcane_orbs 327 1 true",
+                "notice dust 327 1 true",
+                "notice booster 2 1 true",
+                "notice booster 1 10 true",
+                "notice card 2 NEW1_040 true",
+                "notice cardback 1 1 true",
+                "notice cardback 2 1 true",
+                "hsashowquesttoastmount",
+                "hsashowquesttoastminiset",
+
+                // Welcome quests
+                "hsashowwelcomequests",
+
+                // Returning player banner
+                "hsashowreturningplayerbanner",
+
+                // Show Set Rotation Tutorial Popup
+                "setrotationrotatedboosterspopup",
+
+                // Show Ranked Intro Popup
+                "rankedintropopup",
+
+                // Show login popup sequence - Not used for now as we're blocking it
+                // "loginpopupsequence",
+
+                // Show arena coming soon popup
+                // TODO: CheatMgr has an "arena popup" command for this but we never have prefabs for the next one so
+
+                // Alerts & Warnings
+                "alert",
+                "warning",
+
+                // Other popups
+                "hsashowstandardcomingsoonpopup",
+                "hsashowcoresetavailablepopup",
+                "hsashowwhizbangpopup",
+
+                // Quest progress legacy popup
+                "questprogresspopup QuestTitle QuestDescription 3 10",
+
+                // Quest complete popups
+                //"questcompletepopup 1", // Hero -> this is that empty broken one
+                "questcompletepopup 11", // Card pack
+                "questcompletepopup 12", // Gold
+                "questcompletepopup 55", // Arcane Dust
+                "questcompletepopup 58", // Card
+                "questcompletepopup 59", // Gold Card
+                "questcompletepopup 60", // Rare Card
+                "questcompletepopup 61", // Gold legendary card
+                "questcompletepopup 94", // Free ticket
+                "questcompletepopup 98", // Golden hero unlocked (druid)
+                "questcompletepopup 110", // Mount
+                "questcompletepopup 130", // Two cards
+                "questcompletepopup 215", // Card back
+                "questcompletepopup 2628", // Arcane orbs
+
+                // Season end dialog with reward chests
+                "seasondialog diamond1",
+
+                // Banners
+                "banner",
+
+                // End of game experience
+                "simendofgamexp 7",
+
+                // Quote
+                "quote default",
+
+                // Fixed rewards
+                "fixedrewardcomplete 5794",
+
+                // Legacy rewards
+                //"hsashowleaguepromotionrewards", // Seems broken as it's missing a "done" button at the end when all packages open
+                //"hsashowquestchestreward", // Seems broken as it's missing a "done" button at the end when all packages open
+
+                // Rank rewards
+                "rankreward bronze5 all", // TODO: Not implemented yet
+
+                // Track rewards
+                "showtrackreward 1 1 1", // 1 Card
+                "showtrackreward 1 1 2", // 2 Boosters
+                "showtrackreward 1 1 4", // 1 Random card
+                "showtrackreward 1 1 5", // 1 Custom coin
+                "showtrackreward 1 1 7", // GOLD; DUST; BOOSTER; BOOSTER; TAVERN_TICKET; CARD; RANDOM_CARD; CARD_BACK; HERO_SKIN; CUSTOM_COIN;
+                "showtrackreward 1 1 10", // CARD; REWARD_TRACK_XP_BOOST;
+                "showtrackreward 1 1 15", // Hero skin
+                "showtrackreward 1 1 16", // Gold
+                "showtrackreward 1 1 20", // Card back
+                "showtrackreward 1 1 26", // Tavern ticket
+                "showtrackreward 1 1 68", // 10 Hero skins (Choose one)
+                "showtrackreward 1 1 78", // Arcane orbs
+                "showtrackreward 1 1 162", // Card subset (all from 162 - 205)
+
+                // ReconnectHelperDialog forcing a close
+                "hsashowreconnecthelperdialog true false true",
+
+                ///
+                ///
+                ///
+
+                // TODO: Decide how we're going to handle these which require something to change at login time (e.g. returning player, veteran, etc.)
+                // Used to test track rewards scroll vvv
+                //"hsashowchangedcardspopup", // 5 changed cards
+                //"hsashowaddedcardspopup", // 5 added cards
+
+                // TODO: Test fatal errors?
+            };
+
+            var curCheat = s_curCheat % cheats.Length;
+            var cheat = cheats[curCheat];
+
+            AccessibilityUtils.LogDebug($"Running test cheat: {cheat}");
+            CheatMgr.Get().ProcessCheat(cheat);
+
+            s_curCheat++;
+        }
+
+        private static void ShowFatalError()
+        {
+            /*var fatalErrorMessage = new FatalErrorMessage();
+            FatalErrorMgr.Get().Add(fatalErrorMessage);*/
+            Error.AddFatal(FatalErrorReason.INACTIVITY_TIMEOUT, "GLOBAL_ERROR_INACTIVITY_KICK");
+            var fatalErrorMessage = new FatalErrorMessage();
+            fatalErrorMessage.m_text = "It's been a while since your last Hearthstone action and your connection was shut down. Relaunch the game when you're ready!";
+            fatalErrorMessage.m_reason = FatalErrorReason.INACTIVITY_TIMEOUT;
+
+            SceneMgr.Get().GoToFatalErrorScreen(fatalErrorMessage);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs b/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs
new file mode 100644
index 0000000..9473d38
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs
@@ -0,0 +1,88 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class HSASpeech
+    {
+        public class L10N
+        {
+            // Used for falling back to TTS in languages other than English while we think about this..
+            private LocalizationKey m_localizationKey;
+            private object[] m_args;
+
+            public static L10N Of(LocalizationKey localizationKey, params object[] args)
+            {
+                return new L10N
+                {
+                    m_localizationKey = localizationKey,
+                    m_args = args
+                };
+            }
+
+            public string GetLocalizedText()
+            {
+                if (m_args == null || m_args.Length == 0)
+                {
+                    return LocalizationUtils.Get(m_localizationKey);
+                }
+                else
+                {
+                    return LocalizationUtils.Format(m_localizationKey, m_args);
+                }
+            }
+        }
+
+        public static string FILE_EXTENSION = ".ogg";
+
+        public string Key { get; }
+
+        public string Value { get; }
+
+        public int Hash { get; }
+
+        private L10N m_l10n;
+
+        public HSASpeech(string key, string value, L10N l10n)
+        {
+            Key = key;
+            Value = value;
+            Hash = ComputeHashCode(value);
+            m_l10n = l10n;
+        }
+
+        public HSASpeech(string key, int hash)
+        {
+            Key = key;
+            Hash = hash;
+        }
+
+        public string GetFileName()
+        {
+            return $"{Key}-{Hash}{FILE_EXTENSION}";
+        }
+
+        private int ComputeHashCode(string value)
+        {
+            unchecked
+            {
+                int hash1 = 5381;
+                int hash2 = hash1;
+
+                for (int i = 0; i < value.Length && value[i] != '\0'; i += 2)
+                {
+                    hash1 = ((hash1 << 5) + hash1) ^ value[i];
+                    if (i == value.Length - 1 || value[i + 1] == '\0')
+                        break;
+                    hash2 = ((hash2 << 5) + hash2) ^ value[i + 1];
+                }
+
+                return Math.Abs(hash1 + (hash2 * 1566083941));
+            }
+        }
+
+        public string GetLocalizedText()
+        {
+            return m_l10n.GetLocalizedText();
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs b/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
new file mode 100644
index 0000000..12b7361
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
@@ -0,0 +1,32 @@
+﻿using System.IO;
+
+namespace Accessibility
+{
+    public class HearthstoneAccessConstants
+    {
+        public static string HEARTHSTONE_VERSION = "21.2.0.91456";
+
+        public static string HEARTHSTONE_ACCESS_VERSION = "8";
+
+        public static bool DEV_MODE = false;
+
+        public static bool DEBUG_SOUND = false;
+
+        public static string GetGithubToken()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-token.txt")) : null;
+        }
+
+        private static string GetGithubGroupName()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-group.txt")) : "HearthstoneAccess";
+        }
+
+        public static string GetHearthstoneAccessRepoUrl()
+        {
+            var githubGroupName = GetGithubGroupName();
+
+            return $"https://raw.githubusercontent.com/{githubGroupName}/HearthstoneAccess";
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs b/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs
new file mode 100644
index 0000000..3b92c94
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs
@@ -0,0 +1,284 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class InGameSystemTests
+    {
+        internal static void Run()
+        {
+            TestCardEffectInterpreter();
+            TestLocalization();
+        }
+
+        #region Card Effects
+
+        internal static void BuildTestCardEffectInterpreter()
+        {
+            // Build using enUS and just record the IDs so other languages are ok
+            var allCards = GameUtils.GetAllCardIds();
+            AccessibilityUtils.LogDebug($"Building {allCards.Count} cards");
+
+            int okCount = 0;
+            int failCount = 0;
+
+            var friendlyCards = new SortedSet<string>();
+            var unfriendlyCards = new SortedSet<string>();
+
+            foreach (var cardId in allCards)
+            {
+                EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+                var cardTextInHand = entityDef.GetCardTextInHand();
+                var effect = CardEffectInterpreter.ExtractEffect(cardTextInHand);
+
+                if (effect == CardEffectInterpreter.CardEffect.FRIENDLY)
+                {
+                    friendlyCards.Add(cardId);
+                    okCount++;
+                }
+                else if (effect == CardEffectInterpreter.CardEffect.UNFRIENDLY)
+                {
+                    unfriendlyCards.Add(cardId);
+                    okCount++;
+                }
+                else
+                {
+                    failCount++;
+                }
+            }
+
+            AccessibilityUtils.LogDebug("Build ended");
+            AccessibilityUtils.LogDebug($"#OK: {okCount}");
+            AccessibilityUtils.LogDebug($"#FAIL: {failCount}");
+            AccessibilityUtils.LogDebug($"#TOTAL: {okCount + failCount}");
+
+            AccessibilityUtils.LogDebug("friendlyCards:");
+            AccessibilityUtils.LogDebug(GenerateCardsHashSetCode("friendlyCards", friendlyCards));
+            AccessibilityUtils.LogDebug("unfriendlyCards:");
+            AccessibilityUtils.LogDebug(GenerateCardsHashSetCode("unfriendlyCards", unfriendlyCards));
+        }
+
+        private static string GenerateCardsHashSetCode(string variableName, SortedSet<string> cardIds)
+        {
+            var sb = new StringBuilder();
+            sb.Append($"private static HashSet<string> {variableName} = new HashSet<string>() {{");
+
+            int i = 0;
+            foreach (var cardId in cardIds)
+            {
+                if (i > 0)
+                {
+                    sb.Append(",");
+                }
+
+                sb.Append($"\"{cardId}\"");
+
+                i++;
+            }
+            sb.Append("};");
+
+            return sb.ToString();
+        }
+
+        internal static void TestCardEffectInterpreter()
+        {
+            AccessibilityMgr.Output(null, "Testing card effects interpreter");
+
+            var allCards = CollectionManager.Get().GetAllCards(); // TODO: We probably should include hero powers here as well..
+            AccessibilityUtils.LogDebug($"Testing {allCards.Count} cards");
+
+            int okCount = 0;
+            int failCount = 0;
+
+            foreach (var card in allCards)
+            {
+                //if (card.CardType == TAG_CARDTYPE.SPELL || IsBattlecryMinion(card)) // We don't really care about battlecries right now as none of the unhandled ones is really in a grey area
+                if (card.CardType == TAG_CARDTYPE.SPELL || card.CardType == TAG_CARDTYPE.HERO_POWER)
+                {
+                    if (IsEffectHandled(card))
+                    {
+                        okCount++;
+                    }
+                    else
+                    {
+                        failCount++;
+                        AccessibilityUtils.LogDebug($"Failed to handle {card.Name} - {card.CardInHandText}");
+                    }
+                }
+            }
+
+            AccessibilityUtils.LogDebug("Test ended");
+            AccessibilityUtils.LogDebug($"#OK: {okCount}");
+            AccessibilityUtils.LogDebug($"#FAIL: {failCount}");
+            AccessibilityUtils.LogDebug($"#TOTAL: {okCount + failCount}");
+
+            AccessibilityMgr.Output(null, $"OK count: {okCount}");
+            AccessibilityMgr.Output(null, $"Fail count: {failCount}");
+        }
+
+        private static bool IsBattlecryMinion(CollectibleCard card)
+        {
+            if (card.CardType != TAG_CARDTYPE.MINION)
+            {
+                return false;
+            }
+
+            return card.CardInHandText.Contains("<b>Battlecry:</b>");
+        }
+
+        private static bool IsEffectHandled(CollectibleCard card)
+        {
+            return CardEffectInterpreter.GetEffect(card.CardId) != CardEffectInterpreter.CardEffect.UNKNOWN;
+            //return CardEffectInterpreter.GetEffect(card.CardInHandText) != CardEffectInterpreter.CardEffect.UNKNOWN;
+        }
+
+        #endregion
+
+        #region Localization
+
+        // Used to test any localization we get from Blizzard to ensure TTS doesn't break in HS updates
+        internal static void TestLocalization()
+        {
+            AccessibilityMgr.Output(null, "Testing localization");
+            s_failedAssertions = 0;
+
+            AccessibilityUtils.LogDebug($"Testing localization");
+
+            AccessibilityUtils.LogDebug($"Making sure all strings exist");
+            foreach (var key in LocalizationKey.GetAllKeys())
+            {
+                if (!GameStrings.HasKey(key.Key))
+                {
+                    AccessibilityUtils.LogDebug($"Missing key: {key.Key}");
+                }
+            }
+
+            AccessibilityUtils.LogDebug($"Testing Blizzard provided strings");
+
+            AssertEquals("Game Menu", LocalizationUtils.Get(LocalizationKey.MENU_GAME_MENU_TITLE));
+            AssertEquals("Solo Adventures", LocalizationUtils.Get(LocalizationKey.GLOBAL_SOLO_ADVENTURES));
+            AssertEquals("Help", LocalizationUtils.Get(LocalizationKey.GLOBAL_HELP));
+            AssertEquals("Your Turn", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOUR_TURN));
+            AssertEquals("Reconnected", LocalizationUtils.Get(LocalizationKey.GLOBAL_RECONNECTED));
+            AssertEquals("Choose One", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_ONE));
+            AssertEquals("Starting Hand", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN));
+            AssertEquals("Keep or Replace Cards", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS));
+            AssertEquals("Taunt", LocalizationUtils.Get(LocalizationKey.GLOBAL_TAUNT));
+            AssertEquals("Deathrattle", LocalizationUtils.Get(LocalizationKey.GLOBAL_DEATHRATTLE));
+            AssertEquals("Battlecry", LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLECRY));
+            AssertEquals("Charge", LocalizationUtils.Get(LocalizationKey.GLOBAL_CHARGE));
+            AssertEquals("Lifesteal", LocalizationUtils.Get(LocalizationKey.GLOBAL_LIFESTEAL));
+            AssertEquals("Rush", LocalizationUtils.Get(LocalizationKey.GLOBAL_RUSH));
+            AssertEquals("Windfury", LocalizationUtils.Get(LocalizationKey.GLOBAL_WINDFURY));
+            AssertEquals("Divine Shield", LocalizationUtils.Get(LocalizationKey.GLOBAL_DIVINE_SHIELD));
+            AssertEquals("Freeze", LocalizationUtils.Get(LocalizationKey.GLOBAL_FREEZE));
+            AssertEquals("Frozen", LocalizationUtils.Get(LocalizationKey.GLOBAL_FROZEN));
+            AssertEquals("Poisonous", LocalizationUtils.Get(LocalizationKey.GLOBAL_POISONOUS));
+            AssertEquals("Stealth", LocalizationUtils.Get(LocalizationKey.GLOBAL_STEALTH));
+            AssertEquals("Immune", LocalizationUtils.Get(LocalizationKey.GLOBAL_IMMUNE));
+            AssertEquals("Dormant", LocalizationUtils.Get(LocalizationKey.GLOBAL_DORMANT));
+            AssertEquals("The following sets are now Wild!", LocalizationUtils.Get(LocalizationKey.UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE));
+            AssertEquals("Reconnecting", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING));
+            AssertEquals("Options", LocalizationUtils.Get(LocalizationKey.GLOBAL_OPTIONS));
+            AssertEquals("Practice", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION));
+            AssertEquals("Arcane Dust", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_DUST));
+            AssertEquals("Gold", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_GOLD));
+            AssertEquals("Arcane Orbs", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_ORBS));
+            AssertEquals("New Class Unlocked!", LocalizationUtils.Get(LocalizationKey.UI_REWARD_NEW_CLASS_UNLOCKED));
+            AssertEquals("You are currently offline", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_OFFLINE));
+            AssertEquals("You must reconnect before you can proceed. However, you can still access your collection offline.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED));
+            AssertEquals("Reconnect Failed", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED));
+            AssertEquals("Please verify that your device has Internet access enabled and try again.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_NO_INTERNET));
+            AssertEquals("New version available", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER));
+            AssertEquals("You must update before you can proceed.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY));
+            AssertEquals("It's been a while since your last Hearthstone action and your connection was shut down.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT));
+            AssertEquals("Unable to reconnect. Please relaunch Hearthstone.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED));
+            AssertEquals("Not yet! You can still attack.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_NO_ENDTURN_ATK));
+            AssertEquals("Not yet! You have more cards to play!", LocalizationUtils.Get(LocalizationKey.TUTORIAL_NO_ENDTURN));
+            AssertEquals("Save that for the enemy!", LocalizationUtils.Get(LocalizationKey.TUTORIAL01_HELP_07));
+            AssertEquals("Ignore the puny gnoll and finish off Hogger.", LocalizationUtils.Get(LocalizationKey.TUTORIAL01_HELP_08));
+            AssertEquals("You gain a Mana Crystal every turn.", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_01));
+            AssertEquals("Your used Mana Crystals refill each turn.", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_03));
+            AssertEquals("Get Millhouse!", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_06));
+            AssertEquals("Expend your Mana each turn to crush this annoying gnome!", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_07));
+            AssertEquals("'Battlecry' minions do something special when you play them.", LocalizationUtils.Get(LocalizationKey.TUTORIAL06_HELP_03));
+            AssertEquals("Kill enemy minions before they become a problem!", LocalizationUtils.Get(LocalizationKey.TUTORIAL06_HELP_04));
+            AssertEquals("Welcome to the Jungle", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_14));
+            AssertEquals("Kill his minions or he'll overwhelm you!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_15));
+            AssertEquals("Subdue minions with your hero power and spells!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_16));
+            AssertEquals("Sheep it!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_02));
+            AssertEquals("Save that for the Fen Creeper!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_03));
+            AssertEquals("This fight is totally not fair. Blame the terrible game designers.", LocalizationUtils.Get(LocalizationKey.TUTORIAL05_HELP_03));
+            AssertEquals("Your Taunt minions can protect you from attacks!", LocalizationUtils.Get(LocalizationKey.TUTORIAL05_HELP_04));
+            AssertEquals("This minion has a power that lasts until he dies.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_RAID_LEADER_DESCRIPTION));
+            AssertEquals("You can have 10 cards in your hand.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_ARCANE_INTELLECT_DESCRIPTION));
+            AssertEquals("Level 42", LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_DECK_HERO_LEVEL, 42));
+            AssertEquals("My Collection", LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION));
+            AssertEquals("My Decks", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS));
+            AssertEquals("New Deck", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_NEW_DECK));
+            AssertEquals("Rename", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION));
+            AssertEquals("Page 2", LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, 2));
+            AssertEquals("235 FREE Cards!", LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_HEADER));
+            AssertEquals("Core set now available!", LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_SUBHEADER));
+            AssertEquals("Standard Format will update soon! You've been playing Standard, which allows only Basic, Classic, and the newest 2 years of sets. You will also gain access to Wild Format, which allows all cards!", LocalizationUtils.Get(LocalizationKey.UI_STANDARD_FORMAT_POPUP_TEXT));
+            AssertEquals("Choose Your Deck", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE));
+            AssertEquals("Choose Opponent", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_TITLE));
+            AssertEquals("Choose Your Hero", LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE));
+            AssertEquals("Master Volume", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MASTER_VOLUME_OPTION));
+            AssertEquals("Music Volume", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MUSIC_VOLUME_OPTION));
+            AssertEquals("Fullscreen", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FULLSCREEN_OPTION));
+            AssertEquals("Sound In Background", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION));
+            AssertEquals("Allow Friends to Spectate my Games", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ALLOW_SPECTATORS_OPTION));
+            AssertEquals("Enable Screen Shake", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION));
+            AssertEquals("Modes", LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_MODES));
+            AssertEquals("Choose a Mode", LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE));
+            AssertEquals("Claim a Free Deck", LocalizationUtils.Get(LocalizationKey.UI_CHOOSE_FREE_DECK_TITLE));
+            AssertEquals("Open Packs", LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS));
+            AssertEquals("NEW!", LocalizationUtils.Get(LocalizationKey.COLLECTION_CARD_NEW));
+            AssertEquals("Enchantment", LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT));
+
+            // GameStrings we depend on
+            // Made turns to hold out generic so need to signal if something else shows up
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_UTHER_08"));
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_GULDAN_01"));
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_ILLIDAN_08"));
+            AssertEquals(3, GameStrings.FindKeysWithValue("|4(Turn,Turns) to Hold Out").Count);
+
+            AccessibilityUtils.LogDebug($"Localization test ended");
+
+            if (s_failedAssertions > 0)
+            {
+                AccessibilityMgr.Output(null, $"Failed {s_failedAssertions} assertions");
+            }
+            else
+            {
+                AccessibilityMgr.Output(null, "All tests OK");
+            }
+        }
+
+        private static int s_failedAssertions;
+
+        private static void AssertEquals(string expected, string actual)
+        {
+            if (!expected.Equals(actual))
+            {
+                AccessibilityUtils.LogDebug($"Assertion failed. Expected: {expected} , Actual: {actual}");
+                s_failedAssertions++;
+            }
+        }
+
+        private static void AssertEquals(int expected, int actual)
+        {
+            if (!expected.Equals(actual))
+            {
+                AccessibilityUtils.LogDebug($"Assertion failed. Expected: {expected} , Actual: {actual}");
+                s_failedAssertions++;
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs b/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
new file mode 100644
index 0000000..6a622be
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
@@ -0,0 +1,20 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    public abstract class InaccessibleDialogBase : DialogBase
+    {
+        public override string GetAccessibleHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.UI_UNKNOWN_DIALOG);
+        }
+
+        public override void HandleAccessibleInput()
+        {
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs
new file mode 100644
index 0000000..63cbf4b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs
@@ -0,0 +1,503 @@
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using Assets;
+using Blizzard.T5.Core;
+using Blizzard.T5.Jobs;
+using PegasusShared;
+using UnityEngine;
+using Accessibility;
+
+// Simplified copy of GameStrings.cs without logging and forcing enUS locale
+// Used for defaults for non-localized versions
+// Could do it some other way but might as well use what's already proven and tested
+public class DefaultGameStrings
+{
+    #region Accessibility
+    private static Locale DEFAULT_LOCALE = Locale.enUS;
+	private static CultureInfo DEFAULT_CULTURE_INFO = new CultureInfo("en-US");
+	#endregion
+
+	public const string s_UnknownName = "UNKNOWN";
+
+	private static Map<Global.GameStringCategory, GameStringTable> s_tables = new Map<Global.GameStringCategory, GameStringTable>();
+
+	private static readonly char[] LANGUAGE_RULE_ARG_DELIMITERS = new char[1] { ',' };
+
+	private static List<Global.GameStringCategory> s_nativeGameStringCatetories = new List<Global.GameStringCategory>
+	{
+		Global.GameStringCategory.GLOBAL,
+		Global.GameStringCategory.GLUE
+	};
+
+	public static void LoadAll()
+	{
+		AccessibilityUtils.LogDebug("DefaultGameStrings.LoadAll()");
+		float realtimeSinceStartup = Time.realtimeSinceStartup;
+        LoadCategory(Global.GameStringCategory.ACCESSIBILITY, native: false);
+        float realtimeSinceStartup2 = Time.realtimeSinceStartup;
+	}
+	public static IAsyncJobResult CreateLoadCategoryJob(Global.GameStringCategory category, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.CreateLoadCategoryJob({category}, {native})");
+
+		return new JobDefinition($"DefaultGameStrings.LoadCategory[{category}]", Job_LoadCategory(category, native));
+	}
+
+	private static IEnumerator<IAsyncJobResult> Job_LoadCategory(Global.GameStringCategory category, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Job_LoadCategory({category}, {native})");
+		if (!s_tables.ContainsKey(category))
+		{
+            LoadCategory(category, native);
+		}
+        yield break;
+    }
+
+	private static void ReloadAllInternal(bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.ReloadAllInternal({native})");
+
+		float realtimeSinceStartup = Time.realtimeSinceStartup;
+		foreach (Global.GameStringCategory value in Enum.GetValues(typeof(Global.GameStringCategory)))
+		{
+			if (value != 0 && (!native || s_nativeGameStringCatetories.Contains(value)))
+			{
+				if (s_tables.ContainsKey(value))
+				{
+					UnloadCategory(value);
+				}
+				LoadCategory(value, native);
+			}
+		}
+		float realtimeSinceStartup2 = Time.realtimeSinceStartup;
+		AccessibilityUtils.LogDebug(string.Format("Reloading {0} GameStrings took {1}s)", native ? "Native" : "All", realtimeSinceStartup2 - realtimeSinceStartup));
+	}
+
+	public static void ReloadAll()
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.ReloadAll()");
+
+		ReloadAllInternal(native: false);
+	}
+
+	public static void LoadNative()
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.LoadNative()");
+
+		ReloadAllInternal(native: true);
+	}
+
+    public static bool HasKey(string key)
+	{
+		return Find(key) != null;
+	}
+
+	public static bool TryGet(string key, out string localized)
+	{
+		localized = null;
+		string text = Find(key);
+		if (text == null)
+		{
+			return false;
+		}
+		localized = ParseLanguageRules(text);
+		return true;
+	}
+
+	public static string Get(string key)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Get({key})");
+
+		if (!TryGet(key, out var localized))
+		{
+			return key;
+		}
+		return localized;
+	}
+
+	public static string Format(string key, params object[] args)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Format({key})");
+
+		string text = Find(key);
+		if (text == null)
+		{
+			return key;
+		}
+		return FormatLocalizedString(text, args);
+	}
+
+	public static string FormatLocalizedString(string text, params object[] args)
+	{
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		text = ParseLanguageRules(text);
+		return text;
+	}
+
+	public static string FormatLocalizedStringWithPlurals(string text, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+	{
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		text = ParseLanguageRules(text, pluralNumbers);
+		return text;
+	}
+
+	public static string FormatPlurals(string key, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.FormatPlurals({key})");
+
+		string text = Find(key);
+		if (text == null)
+		{
+			return key;
+		}
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		return ParseLanguageRules(text, pluralNumbers);
+	}
+
+	public static string FormatStringWithPlurals(List<LocalizedString> protoLocalized, string stringKey, params object[] optionalFormatArgs)
+	{
+		Locale[] loadOrder = Localization.GetLoadOrder(DEFAULT_LOCALE);
+		LocalizedString localizedString = protoLocalized.FirstOrDefault((LocalizedString s) => s.Key == stringKey);
+		LocalizedStringValue localizedStringValue = null;
+		int num = 0;
+		while (localizedString != null && num < loadOrder.Length)
+		{
+			Locale locale = loadOrder[num];
+			localizedStringValue = localizedString.Values.FirstOrDefault((LocalizedStringValue v) => v.Locale == (int)locale);
+			if (localizedStringValue != null)
+			{
+				break;
+			}
+			num++;
+		}
+		if (localizedStringValue == null || localizedStringValue.Value == null)
+		{
+			return null;
+		}
+		return ParseLanguageRules(string.Format(localizedStringValue.Value, optionalFormatArgs));
+	}
+
+	public static string ParseLanguageRules(string str)
+	{
+		str = ParseLanguageRule1(str);
+		str = ParseLanguageRule4(str);
+		return str;
+	}
+
+	public static string ParseLanguageRules(string str, GameStrings.PluralNumber[] pluralNumbers)
+	{
+		str = ParseLanguageRule1(str);
+		str = ParseLanguageRule4(str, pluralNumbers);
+		return str;
+	}
+
+	private static bool LoadCategory(Global.GameStringCategory cat, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.LoadCategory({cat}, {native})");
+
+		if (s_tables.ContainsKey(cat))
+		{
+			return false;
+		}
+		GameStringTable gameStringTable = new GameStringTable();
+		if (!gameStringTable.Load(cat, DEFAULT_LOCALE, native))
+		{
+			return false;
+		}
+		s_tables.Add(cat, gameStringTable);
+		return true;
+	}
+
+	private static bool UnloadCategory(Global.GameStringCategory cat)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.UnloadCategory({cat})");
+
+		if (!s_tables.Remove(cat))
+		{
+			AccessibilityUtils.LogDebug($"GameStrings.UnloadCategory() - {cat} was never loaded");
+			return false;
+		}
+		return true;
+	}
+
+	private static string Find(string key)
+	{
+		if (key == null)
+		{
+			return null;
+		}
+		foreach (GameStringTable value in s_tables.Values)
+		{
+			string text = value.Get(key);
+			if (text != null)
+			{
+				return text;
+			}
+		}
+		if (key.StartsWith("Assets/"))
+		{
+		}
+		return null;
+	}
+
+	private static string[] ParseLanguageRuleArgs(string str, int ruleIndex, out int argStartIndex, out int argEndIndex)
+	{
+		argStartIndex = -1;
+		argEndIndex = -1;
+		argStartIndex = str.IndexOf('(', ruleIndex + 2);
+		if (argStartIndex < 0)
+		{
+			return null;
+		}
+		argEndIndex = str.IndexOf(')', argStartIndex + 1);
+		if (argEndIndex < 0)
+		{
+			return null;
+		}
+		StringBuilder stringBuilder = new StringBuilder();
+		stringBuilder.Append(str, argStartIndex + 1, argEndIndex - argStartIndex - 1);
+		string text = stringBuilder.ToString();
+		MatchCollection matchCollection = Regex.Matches(text, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (matchCollection.Count == 0)
+		{
+			matchCollection = Regex.Matches(text, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (matchCollection.Count > 0)
+		{
+			stringBuilder.Remove(0, stringBuilder.Length);
+			int num = 0;
+			foreach (Match item in matchCollection)
+			{
+				stringBuilder.Append(text, num, item.Index - num);
+				stringBuilder.Append('0', item.Length);
+				num = item.Index + item.Length;
+			}
+			stringBuilder.Append(text, num, text.Length - num);
+			text = stringBuilder.ToString();
+		}
+		string[] array = text.Split(LANGUAGE_RULE_ARG_DELIMITERS);
+		int num2 = 0;
+		for (int i = 0; i < array.Length; i++)
+		{
+			string text2 = array[i];
+			if (matchCollection.Count > 0)
+			{
+				stringBuilder.Remove(0, stringBuilder.Length);
+				int num3 = 0;
+				foreach (Match item2 in matchCollection)
+				{
+					if (item2.Index >= num2 && item2.Index < num2 + text2.Length)
+					{
+						int num4 = item2.Index - num2;
+						stringBuilder.Append(text2, num3, num4 - num3);
+						stringBuilder.Append(item2.Value);
+						num3 = num4 + item2.Length;
+					}
+				}
+				stringBuilder.Append(text2, num3, text2.Length - num3);
+				text2 = stringBuilder.ToString();
+				num2 += text2.Length + 1;
+			}
+			text2 = (array[i] = text2.Trim());
+		}
+		return array;
+	}
+
+	private static string ParseLanguageRule1(string str)
+	{
+		int num = str.IndexOf("|1");
+		if (num < 0)
+		{
+			return str;
+		}
+		StringBuilder stringBuilder;
+		string text;
+		int num3;
+		string[] array;
+		int num4;
+		for (stringBuilder = new StringBuilder(); num >= 0; stringBuilder.Append(text), stringBuilder.Append(array[num4]), str = str.Substring(num3 + 1), num = str.IndexOf("|1"))
+		{
+			text = str.Substring(0, num);
+			if (text.Length == 0)
+			{
+				break;
+			}
+			int num2 = str.IndexOf('(', num);
+			if (num2 < 0)
+			{
+				break;
+			}
+			num3 = str.IndexOf(')', num2);
+			if (num3 < 0)
+			{
+				break;
+			}
+			string text2 = str.Substring(num2 + 1, num3 - num2 - 1);
+			array = text2.Split(',');
+			if (array.Length != 2)
+			{
+				break;
+			}
+			char c = text[text.Length - 1];
+			num4 = 0;
+			switch (c)
+			{
+			case '0':
+			case '1':
+			case '3':
+			case '6':
+			case '7':
+			case '8':
+				num4 = 0;
+				continue;
+			case '2':
+			case '4':
+			case '5':
+			case '9':
+				num4 = 1;
+				continue;
+			default:
+				if (c >= '가' && c <= '힣')
+				{
+					num4 = (((c - 44032) % 28 == 0) ? 1 : 0);
+					continue;
+				}
+				break;
+			}
+			break;
+		}
+		stringBuilder.Append(str);
+		return stringBuilder.ToString();
+	}
+
+	private static string ParseLanguageRule4(string str, GameStrings.PluralNumber[] pluralNumbers = null)
+	{
+		StringBuilder stringBuilder = null;
+		int? num = null;
+		int num2 = 0;
+		int num3 = 0;
+		for (int num4 = str.IndexOf("|4"); num4 >= 0; num4 = str.IndexOf("|4", num4 + 2))
+		{
+			num3++;
+			int argStartIndex;
+			int argEndIndex;
+			string[] array = ParseLanguageRuleArgs(str, num4, out argStartIndex, out argEndIndex);
+			if (array == null)
+			{
+				continue;
+			}
+			int num5 = num2;
+			int num6 = num4 - num2;
+			string text = str.Substring(num5, num6);
+			GameStrings.PluralNumber pluralNumber = null;
+			if (pluralNumbers != null)
+			{
+				int pluralArgIndex = num3 - 1;
+				pluralNumber = Array.Find(pluralNumbers, (GameStrings.PluralNumber currPluralNumber) => currPluralNumber.m_index == pluralArgIndex);
+			}
+			int number;
+			if (pluralNumber != null)
+			{
+				num = pluralNumber.m_number;
+			}
+			else if (ParseLanguageRule4Number(array, text, out number))
+			{
+				num = number;
+			}
+			else if (!num.HasValue)
+			{
+				continue;
+			}
+			int pluralIndex = GetPluralIndex(num.Value);
+			if (pluralIndex >= array.Length)
+			{
+			}
+			else
+			{
+				string value = array[pluralIndex];
+				if (stringBuilder == null)
+				{
+					stringBuilder = new StringBuilder();
+				}
+				stringBuilder.Append(text);
+				stringBuilder.Append(value);
+				num2 = argEndIndex + 1;
+			}
+			if (pluralNumber != null && pluralNumber.m_useForOnlyThisIndex)
+			{
+				num = null;
+			}
+		}
+		if (stringBuilder == null)
+		{
+			return str;
+		}
+		stringBuilder.Append(str, num2, str.Length - num2);
+		return stringBuilder.ToString();
+	}
+
+	private static bool ParseLanguageRule4Number(string[] args, string betweenRulesStr, out int number)
+	{
+		if (ParseLanguageRule4Number_Foreward(args[0], out number))
+		{
+			return true;
+		}
+		if (ParseLanguageRule4Number_Backward(betweenRulesStr, out number))
+		{
+			return true;
+		}
+		number = 0;
+		return false;
+	}
+
+	private static bool ParseLanguageRule4Number_Foreward(string str, out int number)
+	{
+		number = 0;
+		Match match = Regex.Match(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (!match.Success)
+		{
+			match = Regex.Match(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (!match.Success)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(match.Value, out number))
+		{
+			return false;
+		}
+		return true;
+	}
+
+	private static bool ParseLanguageRule4Number_Backward(string str, out int number)
+	{
+		number = 0;
+		MatchCollection matchCollection = Regex.Matches(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (matchCollection.Count == 0)
+		{
+			matchCollection = Regex.Matches(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (matchCollection.Count == 0)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(matchCollection[matchCollection.Count - 1].Value, out number))
+		{
+			return false;
+		}
+		return true;
+	}
+
+	private static int GetPluralIndex(int number)
+	{
+		if (number == 1)
+        {
+			return 0;
+        }
+		return 1;
+	}
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs
new file mode 100644
index 0000000..0b6156c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs
@@ -0,0 +1,813 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+public class LocalizationKey
+{
+    public static LocalizationKey WELCOME_TO_HEARTHSTONE = CreateKey("ACCESSIBILITY_WELCOME_TO_HEARTHSTONE"); 
+
+    // Press key to
+    public static LocalizationKey PRESS_KEY_TO_START = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_START"); 
+    public static LocalizationKey PRESS_KEY_TO_CONTINUE = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_CONTINUE"); 
+    public static LocalizationKey PRESS_KEY_TO_FINISH = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_FINISH"); 
+    public static LocalizationKey PRESS_KEY_TO_GO_BACK = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_GO_BACK");
+    public static LocalizationKey PRESS_KEY_TO_EXIT = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_EXIT"); 
+    public static LocalizationKey PRESS_KEY_ONCE_DONE = CreateKey("ACCESSIBILITY_PRESS_KEY_ONCE_DONE"); 
+
+    // Menus
+    public static LocalizationKey MENU_HELP_NO_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HELP_NO_BACK_BUTTON");
+    public static LocalizationKey MENU_HELP_WITH_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HELP_WITH_BACK_BUTTON");
+    public static LocalizationKey MENU_HORIZONTAL_HELP_NO_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HORIZONTAL_HELP_NO_BACK_BUTTON");
+    public static LocalizationKey MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON");
+    public static LocalizationKey MENU_OPTION_FORMAT = CreateKey("ACCESSIBILITY_MENU_OPTION_FORMAT");
+    public static LocalizationKey MENU_NO_ITEMS = CreateKey("ACCESSIBILITY_LIST_NO_ITEMS");
+    public static LocalizationKey MENU_GAME_MENU_TITLE = CreateKey("GLOBAL_TOOLTIP_MENU_HEADER");
+    public static LocalizationKey OPTIONS_MENU_TITLE = CreateKey("ACCESSIBILITY_OPTIONS_MENU_TITLE");
+    public static LocalizationKey OPTIONS_MENU_GRAPHICS_QUALITY_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_GRAPHICS_QUALITY_OPTION");
+    public static LocalizationKey OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION");
+    public static LocalizationKey OPTIONS_MENU_MASTER_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_MASTER_VOLUME_LABEL");
+    public static LocalizationKey OPTIONS_MENU_MUSIC_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_MUSIC_VOLUME_LABEL");
+    public static LocalizationKey OPTIONS_MENU_FULLSCREEN_OPTION = CreateKey("GLOBAL_OPTIONS_GRAPHICS_FULLSCREEN_LABEL");
+    public static LocalizationKey OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_IN_BACKGROUND");
+    public static LocalizationKey OPTIONS_MENU_ALLOW_SPECTATORS_OPTION = CreateKey("GLOBAL_OPTIONS_SPECTATOR_OPEN_JOIN");
+    public static LocalizationKey OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION = CreateKey("GLOBAL_OPTIONS_SCREEN_SHAKE");
+    public static LocalizationKey OPTIONS_MENU_ADJUST_VOLUME = CreateKey("ACCESSIBILITY_OPTIONS_MENU_ADJUST_VOLUME");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_LABEL = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_LABEL");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_CHECKED = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_CHECKED");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_NOT_CHECKED = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_NOT_CHECKED");
+
+    // Hub
+    public static LocalizationKey HUB_MAIN_MENU_TITLE = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_TITLE");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_GAME_MENU = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_GAME_MENU");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_HELP = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_HELP");
+
+    // Global
+    public static LocalizationKey GLOBAL_SOLO_ADVENTURES = CreateKey("GLUE_ADVENTURE");
+    public static LocalizationKey GLOBAL_GAME_MODES = CreateKey("GLUE_GAME_MODES");
+    public static LocalizationKey GLOBAL_CHOOSE_MODE = CreateKey("GLUE_GAME_MODES_POPUP_HEADER");
+    public static LocalizationKey GLOBAL_MY_COLLECTION = CreateKey("GLUE_MY_COLLECTION");
+    public static LocalizationKey GLOBAL_OPEN_PACKS = CreateKey("GLUE_OPEN_PACKS");
+    public static LocalizationKey GLOBAL_HELP = CreateKey("GLOBAL_HELP");
+    public static LocalizationKey GLOBAL_LOADING_GAME = CreateKey("ACCESSIBILITY_GLOBAL_LOADING_GAME");
+    public static LocalizationKey GLOBAL_CLOSING_GAME = CreateKey("ACCESSIBILITY_GLOBAL_CLOSING_GAME");
+    public static LocalizationKey GLOBAL_GAME_LOADED = CreateKey("ACCESSIBILITY_GLOBAL_GAME_LOADED");
+    public static LocalizationKey GLOBAL_LOADING = CreateKey("ACCESSIBILITY_GLOBAL_LOADING");
+    public static LocalizationKey GLOBAL_PLEASE_WAIT = CreateKey("ACCESSIBILITY_GLOBAL_PLEASE_WAIT");
+    public static LocalizationKey GLOBAL_RECONNECTED = CreateKey("GLOBAL_RECONNECT_RECONNECTED_HEADER");
+    public static LocalizationKey GLOBAL_CARD = CreateKey("ACCESSIBILITY_GLOBAL_CARD");
+    public static LocalizationKey GLOBAL_CARD_PLURAL = CreateKey("ACCESSIBILITY_GLOBAL_CARD_PLURAL");
+    public static LocalizationKey GLOBAL_SECRET = CreateKey("ACCESSIBILITY_GLOBAL_SECRET");
+    public static LocalizationKey GLOBAL_GAME_SPEED = CreateKey("ACCESSIBILITY_GLOBAL_GAME_SPEED");
+    public static LocalizationKey GLOBAL_OPTIONS = CreateKey("GLOBAL_OPTIONS");
+    public static LocalizationKey GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE = CreateKey("ACCESSIBILITY_GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE");
+
+    // Global cont'd
+    public static LocalizationKey GLOBAL_ACCESSIBILITY_ON = CreateKey("ACCESSIBILITY_GLOBAL_ACCESSIBILITY_ON");
+    public static LocalizationKey GLOBAL_ACCESSIBILITY_OFF = CreateKey("ACCESSIBILITY_GLOBAL_ACCESSIBILITY_OFF");
+
+    // Formatting
+    public static LocalizationKey FORMATTING_PERIOD = CreateKey("ACCESSIBILITY_FORMATTING_PERIOD");
+    public static LocalizationKey FORMATTING_SENTENCE_ENDING_CHARACTERS = CreateKey("ACCESSIBILITY_FORMATTING_SENTENCE_ENDING_CHARACTERS");
+    public static LocalizationKey FORMATTING_LIST_SEPARATOR = CreateKey("ACCESSIBILITY_FORMATTING_LIST_SEPARATOR");
+    public static LocalizationKey FORMATTING_LIST_FINAL_SEPARATOR = CreateKey("ACCESSIBILITY_FORMATTING_LIST_FINAL_SEPARATOR");
+
+    // Orders
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_1 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_1");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_2 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_2");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_3 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_3");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_4 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_4");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_5 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_5");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_6 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_6");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_7 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_7");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_8 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_8");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_9 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_9");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_10 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_10");
+
+    // Input
+    public static LocalizationKey INPUT_COMMAND_WITH_MODIFIER_FORMAT = CreateKey("ACCESSIBILITY_INPUT_COMMAND_WITH_MODIFIER_FORMAT");
+    public static string INPUT_KEY_OVERRIDE_FORMAT = "ACCESSIBILITY_INPUT_KEY_OVERRIDE_{0}";
+
+    // Card reading
+    public static LocalizationKey READ_CARD_COST = CreateKey("ACCESSIBILITY_READ_CARD_COST");
+    public static LocalizationKey READ_CARD_ATK_HEALTH = CreateKey("ACCESSIBILITY_READ_CARD_ATK_HEALTH");
+    public static LocalizationKey READ_CARD_ATK_DURABILITY = CreateKey("ACCESSIBILITY_READ_CARD_ATK_DURABILITY");
+    public static LocalizationKey READ_HERO_CARD_ATK = CreateKey("ACCESSIBILITY_READ_HERO_CARD_ATK");
+    public static LocalizationKey READ_HERO_CARD_HEALTH = CreateKey("ACCESSIBILITY_READ_HERO_CARD_HEALTH");
+    public static LocalizationKey READ_HERO_CARD_ARMOR = CreateKey("ACCESSIBILITY_READ_HERO_CARD_ARMOR");
+    public static LocalizationKey READ_CARD_N_COPIES = CreateKey("ACCESSIBILITY_READ_CARD_N_COPIES");
+    public static LocalizationKey READ_COLLECTION_CARD_NAME_GOLDEN = CreateKey("ACCESSIBILITY_READ_COLLECTION_CARD_NAME_GOLDEN");
+    public static LocalizationKey READ_COLLECTION_CARD_NAME_DIAMOND = CreateKey("ACCESSIBILITY_READ_COLLECTION_CARD_NAME_DIAMOND");
+
+    // Global keywords
+    public static LocalizationKey GLOBAL_TAUNT = CreateKey("GLOBAL_KEYWORD_TAUNT");
+    public static LocalizationKey GLOBAL_DEATHRATTLE = CreateKey("GLOBAL_KEYWORD_DEATHRATTLE");
+    public static LocalizationKey GLOBAL_BATTLECRY = CreateKey("GLOBAL_KEYWORD_BATTLECRY");
+    public static LocalizationKey GLOBAL_CHARGE = CreateKey("GLOBAL_KEYWORD_CHARGE");
+    public static LocalizationKey GLOBAL_LIFESTEAL = CreateKey("GLOBAL_KEYWORD_LIFESTEAL");
+    public static LocalizationKey GLOBAL_RUSH = CreateKey("GLOBAL_KEYWORD_RUSH");
+    public static LocalizationKey GLOBAL_WINDFURY = CreateKey("GLOBAL_KEYWORD_WINDFURY");
+    public static LocalizationKey GLOBAL_DIVINE_SHIELD = CreateKey("GLOBAL_KEYWORD_DIVINE_SHIELD");
+    public static LocalizationKey GLOBAL_FREEZE = CreateKey("GLOBAL_KEYWORD_FREEZE");
+    public static LocalizationKey GLOBAL_FROZEN = CreateKey("GLOBAL_KEYWORD_FROZEN");
+    public static LocalizationKey GLOBAL_POISONOUS = CreateKey("GLOBAL_KEYWORD_POISONOUS");
+    public static LocalizationKey GLOBAL_STEALTH = CreateKey("GLOBAL_KEYWORD_STEALTH");
+    public static LocalizationKey GLOBAL_IMMUNE = CreateKey("GLOBAL_KEYWORD_IMMUNE");
+    public static LocalizationKey GLOBAL_DORMANT = CreateKey("GLOBAL_KEYWORD_DORMANT");
+    public static LocalizationKey GLOBAL_ENCHANTMENT = CreateKey("GLOBAL_CARDTYPE_ENCHANTMENT");
+
+    // Gameplay
+    public static LocalizationKey GAMEPLAY_YOUR_TURN = CreateKey("GAMEPLAY_YOUR_TURN");
+    public static LocalizationKey GAMEPLAY_OPPONENT_TURN = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_TURN");
+    public static LocalizationKey GAMEPLAY_TURN_ENDED = CreateKey("ACCESSIBILITY_GAMEPLAY_TURN_ENDED");
+    public static LocalizationKey GAMEPLAY_PLAYER_CARD_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CARD_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CARD_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CARD_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_CARD_IN_ZONE_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_CARD_IN_ZONE_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_PLAYER_PLAYED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_PLAYED_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_PLAYED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_PLAYED_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_SUMMONED_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_SUMMONED_MINION");
+    public static LocalizationKey GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_SUMMONED_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_SUMMONED_MINION");
+    public static LocalizationKey GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_TRADED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_TRADED_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_TRADED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_TRADED_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_USED_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_USED_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_USED_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_USED_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_CAST_SECRET = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CAST_SECRET");
+    public static LocalizationKey GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CAST_SECRET = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CAST_SECRET");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CAST_N_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CAST_N_SECRETS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED");
+    public static LocalizationKey GAMEPLAY_ENTITY_ATTACKED = CreateKey("ACCESSIBILITY_GAMEPLAY_ENTITY_ATTACKED");
+    public static LocalizationKey GAMEPLAY_ENTITY_ATTACKED_OTHER = CreateKey("ACCESSIBILITY_GAMEPLAY_ENTITY_ATTACKED_OTHER");
+    public static LocalizationKey GAMEPLAY_JOUST_PLAYER_REVEALED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_PLAYER_REVEALED_CARD");
+    public static LocalizationKey GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD");
+    public static LocalizationKey GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS");
+    public static LocalizationKey GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS");
+
+    // Gameplay
+    public static LocalizationKey GAMEPLAY_PLAYER_TURN_START_READ_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_TURN_START_READ_MANA");
+    public static LocalizationKey GAMEPLAY_YOU_GO_FIRST = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_GO_FIRST");
+    public static LocalizationKey GAMEPLAY_OPPONENT_GOES_FIRST = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_GOES_FIRST");
+    public static LocalizationKey GAMEPLAY_YOU_START_WITH_N_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_START_WITH_N_CARDS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARDS");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARDS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DISCARDED_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DISCARDED_CARDS");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DISCARDED_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DISCARDED_CARDS");
+    public static LocalizationKey GAMEPLAY_YOU_GET_THE_COIN = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_GET_THE_COIN");
+    public static LocalizationKey GAMEPLAY_WAITING_FOR_OPPONENT = CreateKey("ACCESSIBILITY_GAMEPLAY_WAITING_FOR_OPPONENT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN");
+    public static LocalizationKey GAMEPLAY_QUERY_PLAY_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_PLAY_CARD");
+    public static LocalizationKey GAMEPLAY_QUERY_TRADE_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_TRADE_CARD");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_NO_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_NO_MINIONS");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS");
+    public static LocalizationKey GAMEPLAY_CHOOSE_TARGET = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET");
+    public static LocalizationKey GAMEPLAY_CHOOSE_ONE = CreateKey("GAMEPLAY_CHOOSE_ONE");
+
+    // Gameplay read zones
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_COUNT = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_COUNT");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_NO_MORE_VALID_OPTIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_NO_MORE_VALID_OPTIONS");
+    public static LocalizationKey GAMEPLAY_NO_VALID_PLAYS = CreateKey("ACCESSIBILITY_GAMEPLAY_NO_VALID_PLAYS");
+
+    // Gameplay game over
+    public static LocalizationKey GAMEPLAY_GAME_OVER_WON = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_WON");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_LOST = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_LOST");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_TIED = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_TIED");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_GENERIC");
+
+    // Gameplay zones
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HERO = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HERO");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HERO = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HERO");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_WEAPON");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_WEAPON");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_MINIONS");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_SECRETS");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_SECRETS");
+
+    // Gameplay diff zones
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD");
+
+    // Gameplay entity diffs
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_DIED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_DIED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED");
+    public static LocalizationKey GAMEPLAY_DIFF_WEAPON_BROKE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_WEAPON_BROKE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_TRANSFORMED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_TRANSFORMED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_DURABILITY = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_DURABILITY");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_ATTACK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_ATTACK");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_ARMOR = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_ARMOR");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_GAINED_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_GAINED_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_LOST_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_LOST_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS");
+
+    // Speeches
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT");
+
+    // Gameplay entity naming
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES");
+
+    // Gameplay entity groups
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_EVERYONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_EVERYONE");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ALL_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ALL_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_BOTH_HEROES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_BOTH_HEROES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ENEMIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ENEMIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES");
+
+    // Gameplay movements
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC");
+
+    // Gameplay movements continued
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT");
+
+    // Gameplay spell damage
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE");
+
+    // Gameplay mana crystals
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_MANA");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_MANA");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS");
+
+    // Gameplay help
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARDS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARDS_HELP");
+    public static LocalizationKey GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_TO_ATTACK_TARGET");
+    public static LocalizationKey GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION");
+    public static LocalizationKey GAMEPLAY_CONFIRM_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_END_TURN_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_VALID_OPTIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_VALID_OPTIONS");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HAND_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_HAND_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_MINIONS_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_MINIONS_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_SECRETS_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_WEAPON_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_WEAPON_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_PLAYER_DECK_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_DECK_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_TOOLTIP_HELP");
+    public static LocalizationKey GAMEPLAY_PLAY_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAY_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_TRADE_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_TRADE_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_SUMMON_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMON_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_CHOICE_MODE_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOICE_MODE_HELP");
+    public static LocalizationKey GAMEPLAY_CHOOSE_TARGET_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET_HELP");
+    public static LocalizationKey GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_USE_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_USE_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_THROUGH_VALID_TARGETS");
+    public static LocalizationKey GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_THIS_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_CANCEL_ATTACK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_ATTACK_HELP");
+    public static LocalizationKey GAMEPLAY_CANCEL_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_HELP");
+    public static LocalizationKey GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP");
+    public static LocalizationKey GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_OPEN_HISTORY_LOG_HELP");
+    public static LocalizationKey GAMEPLAY_READ_HISTORY_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_HISTORY_HELP");
+    public static LocalizationKey GAMEPLAY_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_END_TURN_HELP");
+
+    // Gameplay History Log
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_EMPTY");
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT");
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_CLOSE = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_CLOSE");
+
+    // Gameplay special events
+    public static LocalizationKey GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD"); // See BoH Jaina 6
+    public static LocalizationKey GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD"); // See BoH Rexxar 3
+
+    // Mulligan
+    public static LocalizationKey GAMEPLAY_MULLIGAN_WILL_BE_REPLACED = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_WILL_BE_REPLACED");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED");
+    public static LocalizationKey GAMEPLAY_MULLIGAN = CreateKey("GAMEPLAY_MULLIGAN_STARTING_HAND");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS = CreateKey("GAMEPLAY_MULLIGAN_SUBTITLE");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_HELP");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START");
+
+    // UI
+    public static LocalizationKey UI_POPUP = CreateKey("ACCESSIBILITY_UI_POPUP");
+    public static LocalizationKey UI_REWARDS_TITLE = CreateKey("ACCESSIBILITY_UI_REWARDS_TITLE");
+    public static LocalizationKey UI_UNKNOWN_POPUP = CreateKey("ACCESSIBILITY_UI_UNKNOWN_POPUP");
+    public static LocalizationKey UI_UNKNOWN_DIALOG = CreateKey("ACCESSIBILITY_UI_UNKNOWN_DIALOG");
+
+    // Alert Popup
+    public static LocalizationKey UI_ALERT_POPUP_TITLE = CreateKey("ACCESSIBILITY_UI_ALERT_POPUP_TITLE");
+
+    // Core Set Popup
+    public static LocalizationKey UI_CORE_SET_POPUP_HEADER = CreateKey("GLUE_CORE_SET_POPUP_HEADER");
+    public static LocalizationKey UI_CORE_SET_POPUP_SUBHEADER = CreateKey("GLUE_CORE_SET_POPUP_SUBHEADER");
+
+    // Standard format Popup
+    public static LocalizationKey UI_STANDARD_FORMAT_POPUP_TEXT = CreateKey("GLUE_STANDARD_COMING_SOON_BODY");
+
+    // Reward scroll
+    public static LocalizationKey UI_REWARD_SCROLL_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_SCROLL_HELP");
+
+    // Quest notification popup
+    public static LocalizationKey UI_QUEST_NOTIFICATION_POPUP_TITLE = CreateKey("ACCESSIBILITY_UI_QUEST_NOTIFICATION_POPUP_TITLE");
+    public static LocalizationKey UI_QUEST_NOTIFICATION_POPUP_HELP = CreateKey("ACCESSIBILITY_UI_QUEST_NOTIFICATION_POPUP_HELP");
+
+    // Welcome quests
+    public static LocalizationKey UI_WELCOME_QUESTS_HELP = CreateKey("ACCESSIBILITY_UI_WELCOME_QUESTS_HELP");
+
+    // Reward
+    public static LocalizationKey UI_REWARD_TITLE = CreateKey("ACCESSIBILITY_UI_REWARD_TITLE");
+    public static LocalizationKey UI_REWARD_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_HELP");
+
+    // Ranked intro popup
+    public static LocalizationKey UI_RANKED_INTRO_POPUP = CreateKey("ACCESSIBILITY_UI_RANKED_INTRO_POPUP");
+
+    // Ranked bonus stars popup
+    public static LocalizationKey UI_RANKED_BONUS_STARS_POPUP = CreateKey("ACCESSIBILITY_UI_RANKED_BONUS_STARS_POPUP");
+
+    // Set rotation rotated boosters popup
+    public static LocalizationKey UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE = CreateKey("GLUE_ROTATED_SETS_DIALOG");
+
+    // Reconnect helper dialog
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECTING = CreateKey("GLOBAL_RECONNECT_RECONNECTING_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_TITLE = CreateKey("ACCESSIBILITY_UI_RECONNECT_HELPER_DIALOG_TITLE");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_OFFLINE = CreateKey("GLUE_RECONNECT_HELPER_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED = CreateKey("GLUE_RECONNECT_HELPER_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED = CreateKey("GLUE_RECONNECT_HELPER_FAILED_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_NO_INTERNET = CreateKey("GLUE_RECONNECT_HELPER_ACCESS_DISABLED_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER = CreateKey("GLUE_RECONNECT_HELPER_BAD_VERSION_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY = CreateKey("GLUE_RECONNECT_HELPER_BAD_VERSION_RESET_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT = CreateKey("GLUE_RECONNECT_HELPER_INACTIVE_TIMEOUT_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED = CreateKey("GLUE_RECONNECT_HELPER_RESET_REQUIRED_BODY");
+
+    // Season end dialog
+    public static LocalizationKey UI_SEASON_END_DIALOG_RANK_EARNED = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_RANK_EARNED");
+    public static LocalizationKey UI_SEASON_END_DIALOG_CHEST_EARNED = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_CHEST_EARNED");
+    public static LocalizationKey UI_SEASON_END_DIALOG_CHEST_EARNED_HELP = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_CHEST_EARNED_HELP");
+    public static LocalizationKey UI_SEASON_END_DIALOG_SEASON_WELCOME = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_SEASON_WELCOME");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REDUCED_WELCOME = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REDUCED_WELCOME");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REMINDER_CHEST = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REMINDER_CHEST");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REMINDER_CARDBACK = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REMINDER_CARDBACK");
+
+    // Card list popup
+    public static LocalizationKey UI_CARD_LIST_POPUP_HELP = CreateKey("ACCESSIBILITY_UI_CARD_LIST_POPUP_HELP");
+
+    // Chest reward display
+    public static LocalizationKey UI_CHEST_REWARD_DISPLAY_TITLE = CreateKey("ACCESSIBILITY_UI_CHEST_REWARD_DISPLAY_TITLE");
+    public static LocalizationKey UI_CHEST_REWARD_DISPLAY_HELP = CreateKey("ACCESSIBILITY_UI_CHEST_REWARD_DISPLAY_HELP");
+
+    // Ranked reward display
+    public static LocalizationKey UI_RANKED_REWARD_DISPLAY = CreateKey("ACCESSIBILITY_UI_RANKED_REWARD_DISPLAY");
+
+    // Reward boxes display
+    public static LocalizationKey UI_REWARD_BOXES_DISPLAY_TITLE = CreateKey("ACCESSIBILITY_UI_REWARD_BOXES_DISPLAY_TITLE");
+    public static LocalizationKey UI_REWARD_BOXES_DISPLAY_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_BOXES_DISPLAY_HELP");
+
+    // Quests (via AccessibleQuest)
+    public static LocalizationKey UI_QUEST_NO_NAME_XP_ONLY = CreateKey("ACCESSIBILITY_UI_QUEST_NO_NAME_XP_ONLY");
+    public static LocalizationKey UI_QUEST_REWARD_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_QUEST_REWARD_DESCRIPTION");
+    public static LocalizationKey UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION");
+
+    // Rewards
+    public static LocalizationKey UI_REWARD_TYPE_REWARD_PACKAGE = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_REWARD_PACKAGE");
+    public static LocalizationKey UI_REWARD_TYPE_ARCANE_DUST = CreateKey("GLUE_CRAFTING_ARCANEDUST");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD_PACK = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD_PACK");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD_BACK = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD_BACK");
+    public static LocalizationKey UI_REWARD_TYPE_GOLD = CreateKey("GLUE_TOOLTIP_GOLD_HEADER");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_MOUNT = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_MOUNT");
+    public static LocalizationKey UI_REWARD_TYPE_ARCANE_ORBS = CreateKey("GLUE_TOOLTIP_BOOSTER_CURRENCY_HEADER");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_MINI_SET = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_MINI_SET");
+    public static LocalizationKey UI_REWARD_TYPE_UNKNOWN = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_UNKNOWN");
+    public static LocalizationKey UI_REWARD_N_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_TICKETS");
+    public static LocalizationKey UI_REWARD_MINI_SET_WITH_N_CARDS = CreateKey("ACCESSIBILITY_UI_REWARD_MINI_SET_WITH_N_CARDS");
+    public static LocalizationKey UI_REWARD_N_ARCANE_ORBS = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARCANE_ORBS");
+    public static LocalizationKey UI_REWARD_N_ARCANE_DUST = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARCANE_DUST");
+    public static LocalizationKey UI_REWARD_N_CARD_PACKS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CARD_PACKS");
+    public static LocalizationKey UI_REWARD_N_GOLD = CreateKey("ACCESSIBILITY_UI_REWARD_N_GOLD");
+    public static LocalizationKey UI_REWARD_CARD_FROM_CLASS = CreateKey("ACCESSIBILITY_UI_REWARD_CARD_FROM_CLASS");
+    public static LocalizationKey UI_REWARD_CORE_CARD_FROM_CLASS = CreateKey("ACCESSIBILITY_UI_REWARD_CORE_CARD_FROM_CLASS");
+    public static LocalizationKey UI_REWARD_GOLDEN_HERO = CreateKey("ACCESSIBILITY_UI_REWARD_GOLDEN_HERO");
+    public static LocalizationKey UI_REWARD_CLASS_HERO = CreateKey("ACCESSIBILITY_UI_REWARD_CLASS_HERO");
+    public static LocalizationKey UI_REWARD_CLASS_UNLOCK_PROGRESS = CreateKey("ACCESSIBILITY_UI_REWARD_CLASS_UNLOCK_PROGRESS");
+    public static LocalizationKey UI_REWARD_NEW_CLASS_UNLOCKED = CreateKey("GLUE_CLASS_UNLOCKED_CLASS");
+    public static LocalizationKey UI_REWARD_CARD = CreateKey("ACCESSIBILITY_UI_REWARD_CARD");
+    public static LocalizationKey UI_REWARD_N_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_HERO_SKINS");
+    public static LocalizationKey UI_REWARD_N_CARD_BACKS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CARD_BACKS");
+    public static LocalizationKey UI_REWARD_N_ARENA_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARENA_TICKETS");
+    public static LocalizationKey UI_REWARD_N_RUNESTONES = CreateKey("ACCESSIBILITY_UI_REWARD_N_RUNESTONES");
+    public static LocalizationKey UI_REWARD_N_ADVENTURES = CreateKey("ACCESSIBILITY_UI_REWARD_N_ADVENTURES");
+    public static LocalizationKey UI_REWARD_N_TAVERN_BRAWL_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_TAVERN_BRAWL_TICKETS");
+    public static LocalizationKey UI_REWARD_N_CUSTOM_COINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CUSTOM_COINS");
+    public static LocalizationKey UI_REWARD_XP_BOOST = CreateKey("ACCESSIBILITY_UI_REWARD_XP_BOOST");
+    public static LocalizationKey UI_REWARD_N_MINI_SETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_MINI_SETS");
+    public static LocalizationKey UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS");
+    public static LocalizationKey UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS");
+
+    // Choose free deck UI
+    public static LocalizationKey UI_CHOOSE_FREE_DECK_TITLE = CreateKey("GLUE_FREE_DECK_POPUP_TITLE");
+
+    // Screens
+    public static LocalizationKey SCREEN_GO_BACK = CreateKey("ACCESSIBILITY_SCREEN_GO_BACK");
+
+    // Fatal error screen
+    public static LocalizationKey SCREEN_FATAL_ERROR_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_FATAL_ERROR_SCREEN_TITLE");
+
+    // End game screen
+    public static LocalizationKey SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP = CreateKey("ACCESSIBILITY_SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP");
+
+    // Coose adventurer screen
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP");
+
+    // Adventure screen
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE = CreateKey("GLUE_CHOOSE_YOUR_HERO");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE");
+
+    // Choose adventure screen
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION = CreateKey("GLUE_PRACTICE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED");
+
+    // Choose opponent menu
+    public static LocalizationKey SCREEN_CHOOSE_OPPONENT_MENU_TITLE = CreateKey("GLUE_CHOOSE_OPPONENT");
+    public static LocalizationKey SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL");
+
+    // Choose deck screen
+    public static LocalizationKey SCREEN_CHOOSE_DECK_TITLE = CreateKey("GLUE_CHOOSE_YOUR_DECK");
+    public static LocalizationKey SCREEN_CHOOSE_DECK_HERO_LEVEL = CreateKey("GLOBAL_PROGRESSION_TOOLTIP_CLASS_DEFAULT_DESC");
+
+    // My collection screen
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_MY_DECKS = CreateKey("GLUE_COLLECTION_MY_DECKS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_NEW_DECK = CreateKey("GLUE_COLLECTION_NEW_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_DELETE_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_DELETE_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION = CreateKey("GLUE_COLLECTION_DECK_RENAME");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM = CreateKey("GLUE_COLLECTION_PAGE_NUM");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT");
+
+    // Pack opening screen
+    public static LocalizationKey SCREEN_PACK_OPENING_OPEN_CARDS_HELP = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_OPEN_CARDS_HELP");
+    public static LocalizationKey SCREEN_PACK_OPENING_NO_CARD_PACKS = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_NO_CARD_PACKS");
+
+    // Quest progress toast
+    public static LocalizationKey TOAST_QUEST_PROGRESS_TOAST_TITLE = CreateKey("ACCESSIBILITY_TOAST_QUEST_PROGRESS_TOAST_TITLE");
+    public static LocalizationKey TOAST_QUEST_PROGRESS_TOAST_PROGRESS = CreateKey("ACCESSIBILITY_TOAST_QUEST_PROGRESS_TOAST_PROGRESS");
+
+    // Quest toast
+    public static LocalizationKey TOAST_QUEST_TOAST_TITLE = CreateKey("ACCESSIBILITY_TOAST_QUEST_TOAST_TITLE");
+
+    // Collectible cards
+    public static LocalizationKey COLLECTION_CARD_NEW = CreateKey("GLUE_COLLECTION_CARD_NEW");
+
+    // Tutorial
+    public static LocalizationKey TUTORIAL_LOADING_TUTORIAL = CreateKey("ACCESSIBILITY_TUTORIAL_LOADING_TUTORIAL");
+    public static LocalizationKey TUTORIAL_WELCOME_BACK = CreateKey("ACCESSIBILITY_TUTORIAL_WELCOME_BACK");
+    public static LocalizationKey TUTORIAL_DEFEATED_HOGGER = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_HOGGER");
+    public static LocalizationKey TUTORIAL_DEFEATED_MILLHOUSE = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_MILLHOUSE");
+    public static LocalizationKey TUTORIAL_DEFEATED_CHO = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_CHO");
+    public static LocalizationKey TUTORIAL_DEFEATED_MUKLA = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_MUKLA");
+    public static LocalizationKey TUTORIAL_DEFEATED_NESINGWARY = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_NESINGWARY");
+    public static LocalizationKey TUTORIAL_DEFEATED_ILLIDAN = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_ILLIDAN");
+    public static LocalizationKey TUTORIAL_NEXT_HOGGER = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_HOGGER");
+    public static LocalizationKey TUTORIAL_NEXT_MILLHOUSE = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_MILLHOUSE");
+    public static LocalizationKey TUTORIAL_NEXT_CHO = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_CHO");
+    public static LocalizationKey TUTORIAL_NEXT_MUKLA = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_MUKLA");
+    public static LocalizationKey TUTORIAL_NEXT_NESINGWARY = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_NESINGWARY");
+    public static LocalizationKey TUTORIAL_NEXT_ILLIDAN = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_ILLIDAN");
+
+    // Tutorial generic narrator speeches
+    public static LocalizationKey TUTORIAL_NARRATOR_INTRO = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO");
+    public static LocalizationKey TUTORIAL_NARRATOR_HELP_KEYS = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_HELP_KEYS");
+    public static LocalizationKey TUTORIAL_NARRATOR_INTRO_END = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO_END");
+    public static LocalizationKey TUTORIAL_FREE_STARTING_PACK = CreateKey("ACCESSIBILITY_TUTORIAL_FREE_STARTING_PACK");
+    public static LocalizationKey TUTORIAL_NICE_WORK = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_WORK");
+    public static LocalizationKey TUTORIAL_NICE_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_JOB");
+    public static LocalizationKey TUTORIAL_NICE_ONE = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_ONE");
+    public static LocalizationKey TUTORIAL_GOOD_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_GOOD_JOB");
+    public static LocalizationKey TUTORIAL_YOU_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_YOU_GOT_IT");
+    public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_IT");
+    public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_THAT");
+    public static LocalizationKey TUTORIAL_TRY_IT_OUT = CreateKey("ACCESSIBILITY_TUTORIAL_TRY_IT_OUT");
+    public static LocalizationKey TUTORIAL_ALL_RIGHT = CreateKey("ACCESSIBILITY_TUTORIAL_ALL_RIGHT");
+    public static LocalizationKey TUTORIAL_LETS_LEARN_HOW = CreateKey("ACCESSIBILITY_TUTORIAL_LETS_LEARN_HOW");
+    public static LocalizationKey TUTORIAL_CAN_YOU_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_CAN_YOU_DO_IT");
+    public static LocalizationKey TUTORIAL_THINK_YOU_CAN_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_THINK_YOU_CAN_DO_IT");
+    public static LocalizationKey TUTORIAL_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_GOT_IT");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN_ATK = CreateKey("TUTORIAL_NO_ENDTURN_ATK");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN = CreateKey("TUTORIAL_NO_ENDTURN");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN_HP = CreateKey("ACCESSIBILITY_TUTORIAL_NO_ENDTURN_HP");
+
+    // Tutorial Hogger
+    public static LocalizationKey TUTORIAL_HOGGER_START = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_START");
+    public static LocalizationKey TUTORIAL01_HELP_07 = CreateKey("TUTORIAL01_HELP_07");
+    public static LocalizationKey TUTORIAL01_HELP_08 = CreateKey("TUTORIAL01_HELP_08");
+    public static LocalizationKey TUTORIAL_HOGGER_FORCE_CARD_READ = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_CARD_READ");
+    public static LocalizationKey TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_SUMMON_MINION_FIRST");
+    public static LocalizationKey TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST");
+    public static LocalizationKey TUTORIAL_HOGGER_2_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_0");
+    public static LocalizationKey TUTORIAL_HOGGER_2_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_1");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2B = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2B");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2D = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2D");
+    public static LocalizationKey TUTORIAL_HOGGER_2_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_3");
+    public static LocalizationKey TUTORIAL_HOGGER_2_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_4");
+    public static LocalizationKey TUTORIAL_HOGGER_2_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_5");
+    public static LocalizationKey TUTORIAL_HOGGER_2_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_6");
+    public static LocalizationKey TUTORIAL_HOGGER_3_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_0");
+    public static LocalizationKey TUTORIAL_HOGGER_3_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_1");
+    public static LocalizationKey TUTORIAL_HOGGER_3_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2");
+    public static LocalizationKey TUTORIAL_HOGGER_3_2_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_3_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_3");
+    public static LocalizationKey TUTORIAL_HOGGER_3_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_4");
+    public static LocalizationKey TUTORIAL_HOGGER_3_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5");
+    public static LocalizationKey TUTORIAL_HOGGER_3_5_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_3_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_6");
+    public static LocalizationKey TUTORIAL_HOGGER_3_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_7");
+    public static LocalizationKey TUTORIAL_HOGGER_4_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1");
+    public static LocalizationKey TUTORIAL_HOGGER_4_1_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_2");
+    public static LocalizationKey TUTORIAL_HOGGER_4_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_4");
+    public static LocalizationKey TUTORIAL_HOGGER_4_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_5");
+    public static LocalizationKey TUTORIAL_HOGGER_4_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6");
+    public static LocalizationKey TUTORIAL_HOGGER_4_6_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_8");
+    public static LocalizationKey TUTORIAL_HOGGER_4_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9");
+    public static LocalizationKey TUTORIAL_HOGGER_4_9_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_10");
+    public static LocalizationKey TUTORIAL_HOGGER_4_11 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11");
+    public static LocalizationKey TUTORIAL_HOGGER_4_11_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_12");
+    public static LocalizationKey TUTORIAL_HOGGER_4_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13");
+    public static LocalizationKey TUTORIAL_HOGGER_4_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_16");
+    public static LocalizationKey TUTORIAL_HOGGER_4_17 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_17");
+    public static LocalizationKey TUTORIAL_HOGGER_6_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_1");
+    public static LocalizationKey TUTORIAL_HOGGER_6_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_2");
+    public static LocalizationKey TUTORIAL_HOGGER_6_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_3");
+    public static LocalizationKey TUTORIAL_HOGGER_6_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_4");
+    public static LocalizationKey TUTORIAL_HOGGER_6_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_5");
+    public static LocalizationKey TUTORIAL_HOGGER_6_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_6");
+    public static LocalizationKey TUTORIAL_HOGGER_6_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_7");
+    public static LocalizationKey TUTORIAL_HOGGER_6_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_8");
+    public static LocalizationKey TUTORIAL_HOGGER_6_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_9");
+    public static LocalizationKey TUTORIAL_HOGGER_6_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_10");
+    public static LocalizationKey TUTORIAL_HOGGER_6_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12");
+    public static LocalizationKey TUTORIAL_HOGGER_6_12_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13");
+    public static LocalizationKey TUTORIAL_HOGGER_6_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_14 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_14");
+    public static LocalizationKey TUTORIAL_HOGGER_6_15 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_15");
+    public static LocalizationKey TUTORIAL_HOGGER_6_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16");
+    public static LocalizationKey TUTORIAL_HOGGER_6_16_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_21 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_21");
+    public static LocalizationKey TUTORIAL_HOGGER_8_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_8_1");
+
+    // Tutorial Millhouse Manastorm
+    public static LocalizationKey TUTORIAL02_HELP_01 = CreateKey("TUTORIAL02_HELP_01");
+    public static LocalizationKey TUTORIAL02_HELP_03 = CreateKey("TUTORIAL02_HELP_03");
+    public static LocalizationKey TUTORIAL02_HELP_06 = CreateKey("TUTORIAL02_HELP_06");
+    public static LocalizationKey TUTORIAL02_HELP_07 = CreateKey("TUTORIAL02_HELP_07");
+    public static LocalizationKey TUTORIAL_RAID_LEADER_DESCRIPTION = CreateKey("TUTORIAL_RAID_LEADER_DESCRIPTION");
+    public static LocalizationKey TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateKey("TUTORIAL_ARCANE_INTELLECT_DESCRIPTION");
+    public static LocalizationKey TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MILLHOUSE_SEE_MANA_HELP");
+    public static LocalizationKey TUTORIAL06_HELP_03 = CreateKey("TUTORIAL06_HELP_03");
+
+    // Tutorial Lorewalker Cho
+    public static LocalizationKey TUTORIAL_CHO_1 = CreateKey("ACCESSIBILITY_TUTORIAL_CHO_1");
+    public static LocalizationKey TUTORIAL06_HELP_02 = CreateKey("ACCESSIBILITY_TUTORIAL06_HELP_02");
+    public static LocalizationKey TUTORIAL06_HELP_04 = CreateKey("TUTORIAL06_HELP_04");
+
+    // Tutorial King Mukla
+    public static LocalizationKey TUTORIAL_MUKLA_START = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START");
+    public static LocalizationKey TUTORIAL_MUKLA_START_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_B");
+    public static LocalizationKey TUTORIAL_MUKLA_START_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_C");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_B");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_C");
+    public static LocalizationKey TUTORIAL04_HELP_14 = CreateKey("TUTORIAL04_HELP_14");
+    public static LocalizationKey TUTORIAL04_HELP_15 = CreateKey("TUTORIAL04_HELP_15");
+    public static LocalizationKey TUTORIAL04_HELP_16 = CreateKey("TUTORIAL04_HELP_16");
+    public static LocalizationKey TUTORIAL04_HELP_02 = CreateKey("TUTORIAL04_HELP_02");
+    public static LocalizationKey TUTORIAL04_HELP_03 = CreateKey("TUTORIAL04_HELP_03");
+
+    // Tutorial Hemet Nesingwary
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP");
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_B");
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_C");
+
+    // Tutorial Illidan Stormrage
+    public static LocalizationKey TUTORIAL05_HELP_03 = CreateKey("TUTORIAL05_HELP_03");
+    public static LocalizationKey TUTORIAL05_HELP_04 = CreateKey("TUTORIAL05_HELP_04");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B");
+
+    // In-game tutorial first time mulligan
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E");
+
+    public string Key { get; private set; }
+
+    private LocalizationKey(string key)
+    {
+        Key = key;
+    }
+
+    private static List<LocalizationKey> s_keys;
+    private static Dictionary<string, LocalizationKey> s_keyDict;
+
+    private static LocalizationKey CreateKey(string key)
+    {
+        if (key == null)
+        {
+            throw new ArgumentException($"Invoked CreateKey in an invalid context");
+        }
+
+        var newKey = new LocalizationKey(key);
+        if (s_keys == null)
+        {
+            s_keys = new List<LocalizationKey>();
+        }
+
+        if (s_keyDict == null)
+        {
+            s_keyDict = new Dictionary<string, LocalizationKey>();
+        }
+
+        if (s_keyDict.ContainsKey(key))
+        {
+            throw new ArgumentException($"Fatal error initializing localization keys. Found duplicate key: {key}");
+        }
+
+        s_keys.Add(newKey);
+        s_keyDict.Add(key, newKey);
+
+        return newKey;
+    }
+
+    public static List<LocalizationKey> GetAllKeys()
+    {
+        return s_keys;
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs
new file mode 100644
index 0000000..e367eeb
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs
@@ -0,0 +1,134 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+public class LocalizationUtils
+{
+    private static Dictionary<int, LocalizationKey> ORDERS = new Dictionary<int, LocalizationKey>
+    {
+        [1] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_1,
+        [2] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_2,
+        [3] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_3,
+        [4] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_4,
+        [5] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_5,
+        [6] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_6,
+        [7] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_7,
+        [8] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_8,
+        [9] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_9,
+        [10] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_10,
+    };
+
+    internal static bool HasKey(LocalizationKey key)
+    {
+        // Used to enable/disable narration in the tutorial
+        // The narrator will only disappear if a particular key hasn't been localized
+        // Note that we cannot default here
+        return GameStrings.HasKey(key.Key);
+    }
+
+    public static string Get(LocalizationKey key)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.Get(key.Key);
+        }
+        else
+        {
+            return DefaultGameStrings.Get(key.Key);
+        }
+    }
+
+    public static string Format(LocalizationKey key, params object[] args)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.Format(key.Key, args);
+        }
+        else
+        {
+            return DefaultGameStrings.Format(key.Key, args);
+        }
+    }
+
+    public static string FormatPlurals(LocalizationKey key, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.FormatPlurals(key.Key, pluralNumbers, args);
+        }
+        else
+        {
+            return DefaultGameStrings.FormatPlurals(key.Key, pluralNumbers, args);
+        }
+    }
+
+    public static bool HasOverrideForKey(KeyCode keyCode)
+    {
+        var stringsKey = GetKeyOverrideLocalizationKey(keyCode);
+        return GameStrings.HasKey(stringsKey);
+    }
+
+    public static string GetOverrideForKey(KeyCode keyCode)
+    {
+        var stringsKey = GetKeyOverrideLocalizationKey(keyCode);
+
+        if (GameStrings.HasKey(stringsKey))
+        {
+            return GameStrings.Get(stringsKey);
+        }
+        else
+        {
+            return DefaultGameStrings.Get(stringsKey);
+        }
+    }
+
+    private static string GetKeyOverrideLocalizationKey(KeyCode keyCode)
+    {
+        var keyCodeStr = keyCode.ToString();
+        return String.Format(LocalizationKey.INPUT_KEY_OVERRIDE_FORMAT, keyCodeStr);
+    }
+
+    public static string GetPeriod()
+    {
+        return Get(LocalizationKey.FORMATTING_PERIOD);
+    }
+
+    public static string GetSentenceEndingCharacters()
+    {
+        return Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+    }
+
+    public static string GetOrdinalNumber(int num)
+    {
+        if (num >= 1 && num <= 10 && GameStrings.HasKey(ORDERS[num].Key)) // Simply default to a normal digit representation for non-translated locales
+        {
+            return Get(ORDERS[num]);
+        }
+
+        return $"{num}";
+    }
+
+    public static bool IsOrdinalNumber(string text)
+    {
+        return GetOrdinalNumbers().Contains(text);
+    }
+    private static List<string> GetOrdinalNumbers()
+    {
+        var ret = new List<string>();
+
+        foreach (var entry in ORDERS)
+        {
+            ret.Add(GetOrdinalNumber(entry.Key));
+        }
+
+        return ret;
+    }
+
+    internal static string Get(LocalizationKey sCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION, object onBrowseCollection)
+    {
+        throw new NotImplementedException();
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs
new file mode 100644
index 0000000..4f3c2d3
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs
@@ -0,0 +1,66 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+class LocalizedText
+{
+    // Menus
+    public static string GAME_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.MENU_GAME_MENU_TITLE);
+    public static string OPTIONS_MENU_ADJUST_VOLUME => LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ADJUST_VOLUME);
+    public static string MENU_NO_ITEMS => LocalizationUtils.Get(LocalizationKey.MENU_NO_ITEMS);
+
+    // Hub
+    public static string HUB_MAIN_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.HUB_MAIN_MENU_TITLE);
+    public static string HUB_GAME_MODES_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_MODES);
+    public static string HUB_MY_COLLECTION_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION);
+    public static string HUB_HELP_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_HELP);
+
+    // Modes
+    public static string MODES_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE);
+    public static string MODES_SOLO_ADVENTURES_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_SOLO_ADVENTURES);
+
+    // Global
+    public static string GLOBAL_GAME_LOADED => LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_LOADED);
+    public static string GLOBAL_LOADING => LocalizationUtils.Get(LocalizationKey.GLOBAL_LOADING);
+    public static string GLOBAL_PLEASE_WAIT => LocalizationUtils.Get(LocalizationKey.GLOBAL_PLEASE_WAIT);
+    public static string GLOBAL_CARD => LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+    public static string GLOBAL_RECONNECTED => LocalizationUtils.Get(LocalizationKey.GLOBAL_RECONNECTED);
+    public static string GLOBAL_OPTIONS => LocalizationUtils.Get(LocalizationKey.GLOBAL_OPTIONS);
+
+    // Global keywords
+    public static string GLOBAL_TAUNT => LocalizationUtils.Get(LocalizationKey.GLOBAL_TAUNT);
+    public static string GLOBAL_DEATHRATTLE => LocalizationUtils.Get(LocalizationKey.GLOBAL_DEATHRATTLE);
+    public static string GLOBAL_BATTLECRY => LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLECRY);
+    public static string GLOBAL_CHARGE => LocalizationUtils.Get(LocalizationKey.GLOBAL_CHARGE);
+    public static string GLOBAL_LIFESTEAL => LocalizationUtils.Get(LocalizationKey.GLOBAL_LIFESTEAL);
+    public static string GLOBAL_RUSH => LocalizationUtils.Get(LocalizationKey.GLOBAL_RUSH);
+    public static string GLOBAL_WINDFURY => LocalizationUtils.Get(LocalizationKey.GLOBAL_WINDFURY);
+    public static string GLOBAL_DIVINE_SHIELD => LocalizationUtils.Get(LocalizationKey.GLOBAL_DIVINE_SHIELD);
+    public static string GLOBAL_FREEZE => LocalizationUtils.Get(LocalizationKey.GLOBAL_FREEZE);
+    public static string GLOBAL_FROZEN => LocalizationUtils.Get(LocalizationKey.GLOBAL_FROZEN);
+    public static string GLOBAL_POISONOUS => LocalizationUtils.Get(LocalizationKey.GLOBAL_POISONOUS);
+    public static string GLOBAL_STEALTH => LocalizationUtils.Get(LocalizationKey.GLOBAL_STEALTH);
+    public static string GLOBAL_IMMUNE => LocalizationUtils.Get(LocalizationKey.GLOBAL_IMMUNE);
+    public static string GLOBAL_DORMANT => LocalizationUtils.Get(LocalizationKey.GLOBAL_DORMANT);
+    public static string GLOBAL_ENCHANTMENT => LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT);
+
+    // Gameplay
+    public static string GAMEPLAY_YOUR_TURN => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOUR_TURN);
+    public static string GAMEPLAY_OPPONENT_TURN => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_TURN);
+    public static string GAMEPLAY_TURN_ENDED => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_TURN_ENDED);
+
+    // UI
+    public static string UI_POPUP => LocalizationUtils.Get(LocalizationKey.UI_POPUP);
+    public static string UI_REWARDS_TITLE => LocalizationUtils.Get(LocalizationKey.UI_REWARDS_TITLE);
+
+    // Screens
+    public static string SCREEN_GO_BACK => LocalizationUtils.Get(LocalizationKey.SCREEN_GO_BACK);
+
+    // Collectible cards
+    public static string COLLECTION_CARD_NEW => LocalizationUtils.Get(LocalizationKey.COLLECTION_CARD_NEW).ToLower();
+
+    // Tutorial
+    public static string TUTORIAL_LOADING_TUTORIAL => LocalizationUtils.Get(LocalizationKey.TUTORIAL_LOADING_TUTORIAL);
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs
new file mode 100644
index 0000000..6833ca0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs
@@ -0,0 +1,55 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessiblePackOpeningCard : AccessibleItem
+    {
+        private readonly PackOpeningCard m_card;
+
+        internal AccessiblePackOpeningCard(AccessibleComponent parent, PackOpeningCard card) : base(parent)
+        {
+            m_card = card;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_card.IsRevealed())
+            {
+                return GetLinesForRevealedCard();
+            }
+            else
+            {
+                return GetLinesForHiddenCard();
+            }
+        }
+
+        private List<string> GetLinesForRevealedCard()
+        {
+            var ret = new List<string>();
+
+            ret.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_card.GetEntityDef(), m_card.m_premium, m_card.GetClassName()));
+
+            if (m_card.m_isNew)
+            {
+                ret.Add(LocalizedText.COLLECTION_CARD_NEW);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForHiddenCard()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD));
+
+            return ret;
+        }
+
+        public PackOpeningCard GetPackOpeningCard()
+        {
+            return m_card;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs
new file mode 100644
index 0000000..fae3038
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs
@@ -0,0 +1,52 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleUnopenedPack : AccessibleItem
+    {
+        private readonly UnopenedPack m_pack;
+
+        internal AccessibleUnopenedPack(AccessibleComponent parent, UnopenedPack pack) : base(parent)
+        {
+            m_pack = pack;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, m_pack.GetBoosterStack().Count));
+
+            AccessibleCardUtils.AddLineIfExists(GetLockedRibbonText(), ret);
+            AccessibleCardUtils.AddLineIfExists(GetPackName(), ret);
+
+            return ret;
+        }
+
+        public string GetLockedRibbonText()
+        {
+            if (m_pack.CanOpenPack())
+            {
+                return null;
+            }
+
+            return m_pack.m_LockedRibbonText?.Text;
+        }
+
+        private string GetPackName()
+        {
+            return AccessibleCardUtils.GetCardPackName(m_pack.GetBoosterStack().Id);
+        }
+
+        public bool IsLocked()
+        {
+            return !m_pack.CanOpenPack();
+        }
+
+        public UnopenedPack GetUnopenedPack()
+        {
+            return m_pack;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs b/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs
new file mode 100644
index 0000000..0f96e9c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs
@@ -0,0 +1,152 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class QueuedText
+    {
+        private string m_text;
+
+        private bool m_playing;
+
+        private Stopwatch m_stopwatch;
+
+        private float m_playTimeMs;
+
+        private Action m_onStart, m_onEnd;
+
+        private bool m_interrupt;
+        private bool m_wait;
+
+        private bool m_narration;
+
+        public QueuedText(string text, Action onStart, Action onEnd, bool interrupt=false, bool wait=true, bool narration=false)
+        {
+            m_wait = wait; // Needs to be set first so we handle all text updates properly
+
+            UpdateText(text);
+            m_stopwatch = new Stopwatch();
+
+            m_onStart = onStart;
+            m_onEnd = onEnd;
+
+            m_interrupt = interrupt;
+
+            m_narration = narration;
+
+            //Log.Accessibility.Print($"SPS New QueuedText({text}) / PlayTime={m_playTimeMs}");
+        }
+
+        internal void UpdateText(string text)
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_text = text;
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        internal void UpdateSpeed()
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        private float EstimatePlayTimeMs()
+        {
+            // Was like this when testing initially vv
+            // Normal english speaking person rate = somewhere between 140~160. 150 seems like a good baseline
+            // Normal characters per word in english is ~4.5/wordl 5 seems like a good rate
+            // So 150WPM * 5Chars = 12.5CPS -> seems like a good baseline
+            // <100WPM is slow. JFK's speech was ~95WPM
+            // 100WPM is 8CPS
+            //int cps = 15; // This assumes 5/word + random spaces/punctuation = 1/word = 150WPM*6/60 = 15 CPS
+
+            //float safetyNet = 500;
+            //float safetyNet = 0;
+
+            if (!m_wait)
+            {
+                // Used for menus, popups, etc
+                return 0;
+            }
+
+            return (m_text.Length) / AccessibilityMgr.GetCPS() * 1000;
+        }
+
+        internal bool IsNarration()
+        {
+            return m_narration;
+        }
+
+        internal void Play()
+        {
+            if (!ScreenReader.Output(m_text, m_interrupt))
+            {
+                // e.g. optimized text which became empty
+                OnStartPlaying();
+                OnEndPlaying();
+            }
+            else
+            {
+                OnStartPlaying();
+            }
+        }
+
+        private void OnStartPlaying()
+        {
+            m_playing = true;
+            m_stopwatch.Start();
+
+            if (m_onStart != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnStartPlaying {m_text}");
+                m_onStart();
+            }
+        }
+
+        internal void Interrupt()
+        {
+            OnEndPlaying();
+        }
+
+        private void OnEndPlaying()
+        {
+            m_playing = false;
+            m_stopwatch.Stop();
+
+            if (m_onEnd != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnEndPlaying {m_text}");
+                m_onEnd();
+            }
+        }
+
+        internal bool IsPlaying()
+        {
+            if (m_stopwatch.ElapsedMilliseconds >= m_playTimeMs)
+            {
+                OnEndPlaying();
+            }
+
+            return m_playing;
+        }
+
+        public string GetText()
+        {
+            return m_text;
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs b/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs
new file mode 100644
index 0000000..7422d75
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs
@@ -0,0 +1,51 @@
+﻿using DavyKager;
+using System;
+using System.IO;
+
+namespace Accessibility
+{
+    class ScreenReader
+    {
+        internal static bool Output(string text, bool interrupt=false)
+        {
+            if (text.Length == 0)
+            {
+                return false;
+            }
+
+            bool success = Tolk.Output(text, interrupt);
+
+            AccessibilityUtils.LogDebug($"Output to screen reader (success={success}): {text}");
+
+            return success;
+        }
+
+        internal static void Load()
+        {
+            // Append accessibility deps (e.g. Tolk, NVDA drivers, etc.) to PATH
+            string path = System.Environment.GetEnvironmentVariable("PATH", System.EnvironmentVariableTarget.Process);
+            string accessibilityAssembliesDir = Path.Combine(Directory.GetCurrentDirectory(), "Hearthstone_Data", "Managed", "Accessibility");
+            path += $";{accessibilityAssembliesDir}";
+            System.Environment.SetEnvironmentVariable("PATH", path, System.EnvironmentVariableTarget.Process);
+
+            // Load Tolk
+            Tolk.TrySAPI(true);
+            Tolk.Load();
+        }
+
+        internal static void Unload()
+        {
+            Tolk.Unload();
+        }
+
+        internal static bool IsUsingSAPI()
+        {
+            return Tolk.DetectScreenReader().Equals("SAPI");
+        }
+
+        internal static void Interrupt()
+        {
+            Tolk.Output("", true);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs
new file mode 100644
index 0000000..4f62bdf
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs
@@ -0,0 +1,1296 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_01 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification handBounceArrow;
+
+    private Notification handFadeArrow;
+
+    private TooltipPanel attackHelpPanel;
+
+    private TooltipPanel healthHelpPanel;
+
+    private Card mousedOverCard;
+
+    private GameObject costLabel;
+
+    private GameObject attackLabel;
+
+    private GameObject healthLabel;
+
+    private Card firstMurlocCard;
+
+    private Card firstRaptorCard;
+
+    private GameObject startingPack;
+
+    private bool packOpened;
+
+    private bool announcerIsFinishedYapping;
+
+    private bool m_jainaSpeaking;
+
+    private bool m_isShowingAttackHelpPanel;
+
+    private bool m_fullyReadMurlocRaider;
+
+    private bool m_finishedReadingOpponentMinion;
+
+    private bool m_attackedOpponentMinion;
+
+    private bool m_attackedOpponentMinionOnTurn6;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool>
+        {
+            {
+                GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN,
+                true
+            },
+            {
+                GameEntityOption.SHOW_HERO_TOOLTIPS,
+                true
+            },
+            {
+                GameEntityOption.DISABLE_TOOLTIPS,
+                true
+            }
+        };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_01()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+        MulliganManager.Get().ForceMulliganActive(active: true);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8");
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41");
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada");
+        PreloadSound("VO_TUTORIAL_01_JAINA_13_10.prefab:b13670e36c248e141837c4eb0645a000");
+        PreloadSound("VO_TUTORIAL_01_JAINA_01_01.prefab:883391234efbde84eb99a16abd164d9d");
+        PreloadSound("VO_TUTORIAL_01_JAINA_02_02.prefab:cccdcb509085a974d922ac1d545d9bb6");
+        PreloadSound("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47");
+        PreloadSound("VO_TUTORIAL_01_JAINA_20_16.prefab:7980d02c581e4174991a8066e5785666");
+        PreloadSound("VO_TUTORIAL_01_JAINA_05_05.prefab:982193e53ab81f04ba562de4b32dd39c");
+        PreloadSound("VO_TUTORIAL_01_JAINA_06_06.prefab:ffe0ebdca06ca1d4c84cc28e4a1ed7cf");
+        PreloadSound("VO_TUTORIAL_01_JAINA_07_07.prefab:a8bf811494e94d742a3910fac9da906f");
+        PreloadSound("VO_TUTORIAL_01_JAINA_21_17.prefab:c1524bd0ef92bb845b5dab48cbd017f9");
+        PreloadSound("VO_TUTORIAL_01_JAINA_09_08.prefab:b7b739d9e31865a478275394ee57ad89");
+        PreloadSound("VO_TUTORIAL_01_JAINA_15_11.prefab:a644986d34ab8964582c6221cde54d45");
+        PreloadSound("VO_TUTORIAL_01_JAINA_16_12.prefab:e6b4ab6fc1f11634e88f013ce5351e46");
+        PreloadSound("VO_TUTORIAL_JAINA_02_55_ALT2.prefab:d049e67ad6c16db4da2c04be7a02a1ae");
+        PreloadSound("VO_TUTORIAL_01_JAINA_10_09.prefab:5bf553d532aca174083f48bf407b2b11");
+        PreloadSound("VO_TUTORIAL_01_JAINA_17_13.prefab:9b257c86e7c7f9045a2b819d35876aca");
+        PreloadSound("VO_TUTORIAL_01_JAINA_18_14.prefab:fedcdecb3346ec745b6fb4204f7dd4e0");
+        PreloadSound("VO_TUTORIAL_01_JAINA_19_15.prefab:659652a121ac01941a40c64c1c151f87");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_01_01.prefab:5833f4aeb72110741a2c9bc3a92f9bc8");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_02_02.prefab:7f321b26431a4974a82deefc368adf63");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_03_03.prefab:4ef21f71824b97842b33d8ebccb37ed2");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_04_04.prefab:3e16e42edb324e2469a25363ffd013a6");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_06_06_ALT.prefab:6c9ef3c501462474ab59a37b967cab6f");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_08_08_ALT.prefab:19ddb4ddaa4aee2468b17bae25da9419");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_09_09_ALT.prefab:70c4d2941509856448660f89d6c72b2b");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        base.NotifyOfGameOver(gameResult);
+        if (attackHelpPanel != null)
+        {
+            Object.Destroy(attackHelpPanel.gameObject);
+            attackHelpPanel = null;
+        }
+        if (healthHelpPanel != null)
+        {
+            Object.Destroy(healthHelpPanel.gameObject);
+            healthHelpPanel = null;
+        }
+        EnsureCardGemsAreOnTheCorrectLayer();
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.HOGGER_COMPLETE);
+                PlaySound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+                break;
+        }
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            InputManager.Get().RemovePhoneHandShownListener(OnPhoneHandShown);
+            InputManager.Get().RemovePhoneHandHiddenListener(OnPhoneHandHidden);
+        }
+    }
+
+    private void EnsureCardGemsAreOnTheCorrectLayer()
+    {
+        List<Card> list = new List<Card>();
+        list.AddRange(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+            .GetCards());
+        list.AddRange(GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+            .GetCards());
+        list.Add(GameState.Get().GetFriendlySidePlayer().GetHeroCard());
+        list.Add(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+        foreach (Card item in list)
+        {
+            if (!(item == null) && !(item.GetActor() == null))
+            {
+                if (item.GetActor().GetAttackObject() != null)
+                {
+                    SceneUtils.SetLayer(item.GetActor().GetAttackObject().gameObject, GameLayer.Default);
+                }
+                if (item.GetActor().GetHealthObject() != null)
+                {
+                    SceneUtils.SetLayer(item.GetActor().GetHealthObject().gameObject, GameLayer.Default);
+                }
+            }
+        }
+    }
+
+	public override bool ShouldAllowCardGrab(Entity entity)
+	{
+        if (GetTag(GAME_TAG.TURN) == 2 && !m_fullyReadMurlocRaider)
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_FORCE_CARD_READ);
+            return false;
+        }
+		return true;
+	}
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (GetTag(GAME_TAG.TURN) == 2 || entity.GetCardId() == "TU5_CS2_025")
+        {
+            BoardTutorial.Get().EnableHighlight(enable: true);
+        }
+        NukeNumberLabels();
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        if (GetTag(GAME_TAG.TURN) == 2 || entity.GetCardId() == "TU5_CS2_025")
+        {
+            BoardTutorial.Get().EnableHighlight(enable: false);
+        }
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN_ATK";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        if (!GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    public override bool NotifyOfPlayError(PlayErrors.ErrorType error, int? errorParam, Entity errorSource)
+    {
+        if (error == PlayErrors.ErrorType.REQ_ATTACK_GREATER_THAN_0 && errorSource.GetCardId() == "TU4a_006")
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public override void NotifyOfTargetModeCancelled()
+    {
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_11_HELP);
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 1)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_SUMMON_MINION_FIRST);
+                return false;
+            }
+            
+            if (!m_finishedReadingOpponentMinion)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST);
+                return false;
+            }
+
+            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_13_HELP);
+        }
+        if (GetTag(GAME_TAG.TURN) == 6 && clickedEntity.GetZone() == TAG_ZONE.PLAY && GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() < 2)
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_SUMMON_MINION_FIRST);
+            return false;
+        }
+
+        if (GetTag(GAME_TAG.TURN) == 6 && clickedEntity.GetCardId() == "TU4a_001" && wasInTargetMode)
+        {
+            NotificationManager.Get().DestroyAllPopUps();
+        }
+        if (wasInTargetMode && InputManager.Get().GetHeldCard() != null && InputManager.Get().GetHeldCard().GetEntity()
+            .GetCardId() == "TU5_CS2_029")
+        {
+            if (clickedEntity.IsControlledByLocalUser())
+            {
+                ShowDontFireballYourselfPopup(clickedEntity.GetCard().transform.position);
+                return false;
+            }
+            if (clickedEntity.GetCardId() == "TU4a_003" && GetTag(GAME_TAG.TURN) >= 8)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_08);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public override bool NotifyOfCardTooltipDisplayShow(Card card)
+    {
+        if (GameState.Get().IsGameOver())
+        {
+            return false;
+        }
+        Entity entity = card.GetEntity();
+        if (entity.IsMinion())
+        {
+            if (attackHelpPanel == null)
+            {
+                m_isShowingAttackHelpPanel = true;
+            }
+            return false;
+        }
+        if (entity.IsHero())
+        {
+            return false;
+        }
+        return true;
+    }
+
+	public override void NotifyOfEntityAttacked(Entity attacker, Entity defender)
+	{
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            m_attackedOpponentMinion = true;
+        }
+        else if (GetTag(GAME_TAG.TURN) == 6)
+        {
+            m_attackedOpponentMinionOnTurn6 = true;
+        }
+	}
+
+    public override void NotifyOfCardTooltipDisplayHide(Card card)
+    {
+        if (attackHelpPanel != null)
+        {
+            if (card != null)
+            {
+                GemObject attackObject = card.GetActor().GetAttackObject();
+                SceneUtils.SetLayer(attackObject.gameObject, GameLayer.Default);
+                attackObject.Shrink();
+            }
+            Object.Destroy(attackHelpPanel.gameObject);
+            m_isShowingAttackHelpPanel = false;
+        }
+        if (healthHelpPanel != null)
+        {
+            if (card != null)
+            {
+                GemObject healthObject = card.GetActor().GetHealthObject();
+                SceneUtils.SetLayer(healthObject.gameObject, GameLayer.Default);
+                healthObject.Shrink();
+            }
+            Object.Destroy(healthHelpPanel.gameObject);
+        }
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+            if (costTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            costLabel = go;
+            go.transform.parent = costTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(-0.017f, 0.3512533f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+        }
+    }
+
+    private void AttackLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject attackTextObject = ((Card)callbackData).GetActor().GetAttackTextObject();
+            if (attackTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            attackLabel = go;
+            go.transform.parent = attackTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(-0.2f, -0.3039344f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_ATTACK");
+        }
+    }
+
+    private void HealthLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject healthTextObject = ((Card)callbackData).GetActor().GetHealthTextObject();
+            if (healthTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            healthLabel = go;
+            go.transform.parent = healthTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(0.21f, -0.31f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_HEALTH");
+        }
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOverEntity))
+        {
+            NotificationManager.Get().DestroyAllArrows();
+        }
+        if (mousedOverEntity.GetZone() == TAG_ZONE.HAND)
+        {
+            mousedOverCard = mousedOverEntity.GetCard();
+            IAssetLoader assetLoader = AssetLoader.Get();
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", AttackLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", HealthLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOffEntity))
+        {
+            Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+        }
+        NukeNumberLabels();
+    }
+
+    private void NukeNumberLabels()
+    {
+        mousedOverCard = null;
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+        if (attackLabel != null)
+        {
+            Object.Destroy(attackLabel);
+        }
+        if (healthLabel != null)
+        {
+            Object.Destroy(healthLabel);
+        }
+    }
+
+    private bool ShouldShowArrowOnCardInHand(Entity entity)
+    {
+        if (entity.GetZone() != TAG_ZONE.HAND)
+        {
+            return false;
+        }
+        switch (GetTag(GAME_TAG.TURN))
+        {
+            case 2:
+                return true;
+            case 4:
+                if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+                    .GetCards()
+                    .Count == 0)
+                {
+                    return true;
+                }
+                break;
+        }
+        return false;
+    }
+
+    private IEnumerator ShowArrowInSeconds(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count != 0)
+        {
+            Card cardInHand = cards[0];
+            while (iTween.Count(cardInHand.gameObject) > 0)
+            {
+                yield return null;
+            }
+            if (!cardInHand.IsMousedOver() && !(InputManager.Get().GetHeldCard() == cardInHand))
+            {
+                ShowHandBouncingArrow();
+            }
+        }
+    }
+
+    private void ShowHandBouncingArrow()
+    {
+        if (!(handBounceArrow != null))
+        {
+            List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                .GetCards();
+            if (cards.Count != 0)
+            {
+                Card card = cards[0];
+                Vector3 position = card.transform.position;
+                Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z + 2f) : new Vector3(position.x - 0.08f, position.y + 0.2f, position.z + 1.2f));
+                handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
+                handBounceArrow.transform.parent = card.transform;
+            }
+        }
+    }
+
+    private void ShowHandFadeArrow()
+    {
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count != 0)
+        {
+            ShowFadeArrow(cards[0]);
+        }
+    }
+
+    private void ShowFadeArrow(Card card, Card target = null)
+    {
+        if (!(handFadeArrow != null))
+        {
+            Vector3 position = card.transform.position;
+            Vector3 rotation = new Vector3(0f, 180f, 0f);
+            Vector3 vector2;
+            if (target != null)
+            {
+                Vector3 vector = target.transform.position - position;
+                vector2 = new Vector3(position.x, position.y + 0.47f, position.z + 0.27f);
+                float num = Vector3.Angle(target.transform.position - vector2, new Vector3(0f, 0f, -1f));
+                rotation = new Vector3(0f, (0f - Mathf.Sign(vector.x)) * num, 0f);
+                vector2 += 0.3f * vector;
+            }
+            else
+            {
+                vector2 = new Vector3(position.x, position.y + 0.047f, position.z + 0.95f);
+            }
+            handFadeArrow = NotificationManager.Get().CreateFadeArrow(vector2, rotation);
+            if (target != null)
+            {
+                handFadeArrow.transform.localScale = 1.25f * Vector3.one;
+            }
+            handFadeArrow.transform.parent = card.transform;
+        }
+    }
+
+    private void HideFadeArrow()
+    {
+        if (handFadeArrow != null)
+        {
+            NotificationManager.Get().DestroyNotification(handFadeArrow, 0f);
+            handFadeArrow = null;
+        }
+    }
+
+    private void OnPhoneHandShown(object userData)
+    {
+        if (handBounceArrow != null)
+        {
+            NotificationManager.Get().DestroyNotification(handBounceArrow, 0f);
+            handBounceArrow = null;
+        }
+        ShowHandFadeArrow();
+    }
+
+    private void OnPhoneHandHidden(object userData)
+    {
+        HideFadeArrow();
+        ShowHandBouncingArrow();
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 1:
+                {
+                    List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetDeckZone()
+                        .GetCards();
+                    firstMurlocCard = cards[cards.Count - 1];
+                    firstRaptorCard = cards[cards.Count - 2];
+                    GameState.Get().SetBusy(busy: true);
+                    Board.Get().FindCollider("DragPlane").enabled = false;
+                    yield return new WaitForSeconds(1.25f);
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL01_HELP_14", "TUTORIAL01_HELP_15", "TUTORIAL01_HELP_16", Vector2.zero);
+                    tutorialStartDialog.SetWantedText(GameStrings.Get("MISSION_PRE_TUTORIAL_WANTED"));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_START);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE, AccessibleKey.CONFIRM);
+                    break;
+                }
+            case 2:
+                {
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        InputManager.Get().RegisterPhoneHandShownListener(OnPhoneHandShown);
+                        InputManager.Get().RegisterPhoneHandHiddenListener(OnPhoneHandHidden);
+                    }
+                    yield return new WaitForSeconds(1f);
+                    yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_02_02.prefab:cccdcb509085a974d922ac1d545d9bb6", "TUTORIAL01_JAINA_02", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                    List<Card> cards2 = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                        .GetCards();
+
+                    var onlyCard = cards2[0];
+                    var cardSelected = false;
+                    AccessibleCard cardBeingRead = null;
+                    if (GetTag(GAME_TAG.TURN) == 2 && cards2.Count == 1 && InputManager.Get().GetHeldCard() == null && !onlyCard.IsMousedOver())
+                    {
+                        AccessibleGameplay.Get().RegisterCardSelectedListener(onlyCard, (ac) =>
+                        {
+                            cardSelected = true;
+                            cardBeingRead = ac;
+                        });
+                        Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0f));
+                        AccessibilityMgr.BlockAllInput(false, true);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_0);;
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_1);;
+                        AccessibilityMgr.UnblockAllInput();
+                        AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_2_1);
+                        yield return new WaitUntil(() => cardSelected);
+                        AccessibilityMgr.ResetHelpSpeech();
+                        AccessibilityMgr.BlockAllInput(false, true);
+                    }
+
+                    var cardRead = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        cardRead = true;
+                        m_fullyReadMurlocRaider = true;
+                    });
+                    yield return new WaitForSeconds(2);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_READ_CARD_HELP);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.GAMEPLAY_READ_CARDS_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_NEXT_LINE, AccessibleKey.READ_PREV_LINE);
+                    yield return new WaitUntil(() => cardRead);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2D);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_3);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_4);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION);
+                    var cardGrabbed = false;
+                    AccessibleGameplay.Get().RegisterSummoningCardListener(onlyCard, () =>
+                    {
+                        cardGrabbed = true;
+                    });
+                    yield return new WaitUntil(() => cardGrabbed);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    AccessibilityMgr.ResetHelpSpeech();
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_5);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION);
+                    yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 1);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    break;
+                }
+            case 3:
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    InputManager.Get().RemovePhoneHandShownListener(OnPhoneHandShown);
+                    InputManager.Get().RemovePhoneHandHiddenListener(OnPhoneHandHidden);
+                }
+                break;
+            case 4:
+                AccessibilityMgr.BlockAllInput(false, true);
+                actor.SetActorState(ActorStateType.CARD_IDLE);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_06_06.prefab:ffe0ebdca06ca1d4c84cc28e4a1ed7cf", "TUTORIAL01_JAINA_06", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+
+                // 1
+                var summoningMinion = false;
+                AccessibleGameplay.Get().RegisterSummoningCardListener(firstRaptorCard, () =>
+                {
+                    summoningMinion = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_1);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_1_HELP);
+                yield return new WaitUntil(() => summoningMinion);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 2
+                yield return new WaitForSeconds(1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_TRY_IT_OUT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_1_HELP);
+                yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 2);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 4
+                yield return new WaitForSeconds(7);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_4);
+                var seenBattlefield = false;
+                AccessibleGameplay.Get().RegisterZoneSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone(), () =>
+                {
+                    seenBattlefield = true;
+                });
+                yield return new WaitForSeconds(0.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+                yield return new WaitUntil(() => seenBattlefield);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 6
+                var minionsRemaining = 2;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1), (_) =>
+                {
+                    minionsRemaining--;
+                });
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(2), (_) =>
+                {
+                    minionsRemaining--;
+                });
+                yield return new WaitForSeconds(2.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_6);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_6_HELP);
+                yield return new WaitUntil(() => minionsRemaining == 0);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 8
+                seenBattlefield = false;
+                AccessibleCard accessibleCard = null; 
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardAtPos(1), (opponentMinion) =>
+                {
+                    seenBattlefield = true;
+                    accessibleCard = opponentMinion;
+                });
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_8);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP);
+                yield return new WaitUntil(() => seenBattlefield);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 9
+                var readOpponentCard = false;
+                accessibleCard.RegisterFinishReadListener(() =>
+                {
+                    readOpponentCard = true;
+                    m_finishedReadingOpponentMinion = true; // Prevent an attack until this happens
+                });
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_9);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_4_9_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                yield return new WaitUntil(() => readOpponentCard);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 10
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_YOU_GOT_IT);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_10);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_11);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_11_HELP);
+                yield return new WaitUntil(() => GameState.Get().IsInTargetMode());
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return new WaitForSeconds(1.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_13);
+
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_13_HELP);
+                yield return new WaitUntil(() => m_attackedOpponentMinion);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 16
+                yield return new WaitForSeconds(5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_ONE);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_16);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_17);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+
+                if (firstMurlocCard != null)
+                {
+                    firstMurlocCard.GetActor().ToggleForceIdle(bOn: true);
+                    firstMurlocCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
+                }
+                break;
+            case 6:
+                var minionInBattlefieldAtTurn6 = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1);
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_17_13.prefab:9b257c86e7c7f9045a2b819d35876aca", "TUTORIAL01_JAINA_17", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_4);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_LETS_LEARN_HOW);
+                var firstCardInHandSelected = false;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCardAtPos(1), (_) =>
+                {
+                    firstCardInHandSelected = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_6);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_6_6, AccessibleKey.READ_NEXT_VALID_ITEM);
+                yield return new WaitUntil(() => firstCardInHandSelected);
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.READ_NEXT_VALID_ITEM);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_7);
+                var firstMinionInBattlefieldSelected = false;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1), (_) =>
+                {
+                    firstMinionInBattlefieldSelected = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_8);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_6_8, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.READ_PREV_VALID_ITEM);
+                yield return new WaitUntil(() => firstMinionInBattlefieldSelected);
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.READ_PREV_VALID_ITEM);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_9);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_10);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_12);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_CAN_YOU_DO_IT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_12_HELP);
+                yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 2);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_JOB);
+
+                yield return new WaitForSeconds(1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_13);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_THINK_YOU_CAN_DO_IT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_13_HELP);
+
+                yield return new WaitUntil(() => GameState.Get().IsInTargetMode());
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_14);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_15);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_16);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_16_HELP);
+
+                // Wait for atk
+                yield return new WaitUntil(() => m_attackedOpponentMinionOnTurn6);
+                yield return new WaitForSeconds(4);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_WORK);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_21);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                break;
+            case 8:
+                AccessibilityMgr.BlockAllInput(false, false);
+                m_jainaSpeaking = true;
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_18_14.prefab:fedcdecb3346ec745b6fb4204f7dd4e0", "TUTORIAL01_JAINA_18", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                m_jainaSpeaking = false;
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_8_1);
+                AccessibilityMgr.UnblockAllInput();
+                yield return new WaitForSeconds(1f);
+                Gameplay.Get().StartCoroutine(FlashMinionUntilAttackBegins(firstRaptorCard));
+                break;
+            case 10:
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_19_15.prefab:659652a121ac01941a40c64c1c151f87", "TUTORIAL01_JAINA_19", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                AccessibilityMgr.UnblockAllInput();
+
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor hoggerActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                GameState.Get().SetBusy(busy: true);
+                HistoryManager.Get().DisableHistory();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_01_01.prefab:883391234efbde84eb99a16abd164d9d", "TUTORIAL01_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                Gameplay.Get().SetGameStateBusy(busy: false, 2.2f);
+                break;
+            case 3:
+                {
+                    int turn = GameState.Get().GetTurn();
+                    yield return new WaitForSeconds(1.5f);
+                    if (turn == GameState.Get().GetTurn())
+                    {
+                        yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47", "TUTORIAL01_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+
+                        if (GetTag(GAME_TAG.TURN) == 2 && !EndTurnButton.Get().IsInWaitingState())
+                        {
+                            ShowEndTurnBouncingArrow();
+                            yield return new WaitForSeconds(0.5f);
+                            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_6);
+                            yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                            AccessibilityMgr.UnblockAllInput();
+                            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                            yield return new WaitUntil(() => GameState.Get().GetTurn() > turn);
+                            AccessibilityMgr.ResetHelpSpeech();
+                            AccessibilityMgr.BlockAllInput(false, true);
+                        }
+                    }
+                    break;
+                }
+            case 4:
+                {
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource prevLine = GetPreloadedSound("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47");
+                    while (SoundManager.Get().IsPlaying(prevLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_20_16.prefab:7980d02c581e4174991a8066e5785666", "TUTORIAL01_JAINA_20", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_06_06_ALT.prefab:6c9ef3c501462474ab59a37b967cab6f", "TUTORIAL01_HOGGER_07", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    Vector3 position6 = jainaActor.transform.position;
+                    Vector3 position7 = new Vector3(position6.x + 3.3f, position6.y + 0.5f, position6.z - 0.85f);
+                    Notification.PopUpArrowDirection direction2 = Notification.PopUpArrowDirection.Left;
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        position7 = new Vector3(position6.x + 3f, position6.y + 0.5f, position6.z + 0.85f);
+                        direction2 = Notification.PopUpArrowDirection.LeftDown;
+                    }
+
+                    var seenHero = false;
+                    AccessibleCard cardBeingRead = null;
+                    AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), (accessibleCard) =>
+                    {
+                        seenHero = true;
+                        cardBeingRead = accessibleCard;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_0);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+                    yield return new WaitUntil(() => seenHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    // Hero has been selected at this point
+
+                    yield return new WaitForSeconds(1);
+                    var readHero = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        readHero = true;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_2);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_3_2, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                    yield return new WaitUntil(() => readHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1.5f);
+                    var seenOpponentHero = false;
+                    AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), (accessibleCard) =>
+                    {
+                        seenOpponentHero = true;
+                        cardBeingRead = accessibleCard;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_3);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_4);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_HERO_HELP);
+                    yield return new WaitUntil(() => seenOpponentHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(2);
+                    var readOpponentHero = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        readOpponentHero = true;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_5);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_3_5_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                    yield return new WaitUntil(() => readOpponentHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_JOB);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_6);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_7);
+
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 5:
+                HideFadeArrow();
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_05_05.prefab:982193e53ab81f04ba562de4b32dd39c", "TUTORIAL01_JAINA_05", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 7:
+                NotificationManager.Get().DestroyAllPopUps();
+                yield return new WaitForSeconds(1.2f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_07_07.prefab:a8bf811494e94d742a3910fac9da906f", "TUTORIAL01_JAINA_07", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                yield return new WaitForSeconds(4f);
+                if (GetTag(GAME_TAG.TURN) == 4 && EndTurnButton.Get().IsInNMPState())
+                {
+                    yield return new WaitForSeconds(1f);
+                    ShowEndTurnBouncingArrow();
+                }
+                break;
+            case 8:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_03_03.prefab:4ef21f71824b97842b33d8ebccb37ed2", "TUTORIAL01_HOGGER_05", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_21_17.prefab:c1524bd0ef92bb845b5dab48cbd017f9", "TUTORIAL01_JAINA_21", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 12:
+                yield return new WaitForSeconds(1f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_15_11.prefab:a644986d34ab8964582c6221cde54d45", "TUTORIAL01_JAINA_15", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 13:
+                while (m_jainaSpeaking)
+                {
+                    yield return null;
+                }
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_16_12.prefab:e6b4ab6fc1f11634e88f013ce5351e46", "TUTORIAL01_JAINA_16", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 14:
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_08_08_ALT.prefab:19ddb4ddaa4aee2468b17bae25da9419", "TUTORIAL01_HOGGER_08", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    Vector3 position2 = hoggerActor.transform.position;
+                    Vector3 position3 = new Vector3(position2.x + 3.3f, position2.y + 0.5f, position2.z - 1f);
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        position3 = new Vector3(position2.x + 3f, position2.y + 0.5f, position2.z - 0.75f);
+                    }
+                    Notification.PopUpArrowDirection direction = Notification.PopUpArrowDirection.Left;
+                    if (GetTag(GAME_TAG.TURN) == 6 && EndTurnButton.Get().IsInNMPState())
+                    {
+                        yield return new WaitForSeconds(9f);
+                        ShowEndTurnBouncingArrow();
+                    }
+                    break;
+                }
+            case 15:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_JAINA_02_55_ALT2.prefab:d049e67ad6c16db4da2c04be7a02a1ae", "", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 20:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_10_09.prefab:5bf553d532aca174083f48bf407b2b11", "TUTORIAL01_JAINA_10", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    yield return new WaitForSeconds(1.5f);
+                    GameState.Get().SetBusy(busy: false);
+                    List<Card> cards = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+                        .GetCards();
+                    cards[cards.Count - 1].GetActor().GetAttackObject().Jiggle();
+                    break;
+                }
+            case 22:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_09_09_ALT.prefab:70c4d2941509856448660f89d6c72b2b", "TUTORIAL01_HOGGER_02", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                Gameplay.Get().SetGameStateBusy(busy: false, 2f);
+                break;
+            case 55:
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.CONFIRM);
+                GetGameOptions().SetBooleanOption(GameEntityOption.DISABLE_TOOLTIPS, value: false);
+                Board.Get().FindCollider("DragPlane").enabled = true;
+                while (!announcerIsFinishedYapping)
+                {
+                    yield return null;
+                }
+                if (!SoundUtils.CanDetectVolume())
+                {
+                    Notification battlebegin = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 84.8f), GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_05"), "", 15f);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada", "", Notification.SpeechBubbleDirection.None, null));
+                    NotificationManager.Get().DestroyNotification(battlebegin, 0f);
+                }
+                else
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada", "", Notification.SpeechBubbleDirection.None, null));
+                }
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_01_01.prefab:5833f4aeb72110741a2c9bc3a92f9bc8", "TUTORIAL01_HOGGER_01", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                GameState.Get().SetBusy(busy: false);
+                yield return new WaitForSeconds(4f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_04_04.prefab:3e16e42edb324e2469a25363ffd013a6", "TUTORIAL01_HOGGER_06", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                break;
+            case 66:
+                {
+                    Vector3 position = new Vector3(136f, NotificationManager.DEPTH, 131f);
+                    Vector3 middleSpot = new Vector3(136f, NotificationManager.DEPTH, 80f);
+                    if (!SoundUtils.CanDetectVolume())
+                    {
+                        Notification innkeeperLine3 = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, position, GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_01"), "", 15f);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8", "", Notification.SpeechBubbleDirection.None, null));
+                        NotificationManager.Get().DestroyNotification(innkeeperLine3, 0f);
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8", "", Notification.SpeechBubbleDirection.None, null));
+                    }
+                    yield return new WaitForSeconds(0.5f);
+                    if (!SoundUtils.CanDetectVolume())
+                    {
+                        Notification innkeeperLine3 = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, middleSpot, GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_02"), "", 15f);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41", "", Notification.SpeechBubbleDirection.None, null));
+                        NotificationManager.Get().DestroyNotification(innkeeperLine3, 0f);
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41", "", Notification.SpeechBubbleDirection.None, null));
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_02_02.prefab:7f321b26431a4974a82deefc368adf63", "TUTORIAL01_HOGGER_04", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        Gameplay.Get().AddGamePlayNameBannerPhone();
+                    }
+                    announcerIsFinishedYapping = true;
+                    break;
+                }
+            default:
+                Debug.LogWarning("WARNING - Mission fired an event that we are not listening for.");
+                break;
+            case 6:
+                break;
+        }
+    }
+
+    private IEnumerator FlashMinionUntilAttackBegins(Card minionToFlash)
+    {
+        yield return new WaitForSeconds(8f);
+        Gameplay.Get().StartCoroutine(BeginFlashingMinionLoop(minionToFlash));
+    }
+
+    private IEnumerator BeginFlashingMinionLoop(Card minionToFlash)
+    {
+        if (!(minionToFlash == null) && !minionToFlash.GetEntity().IsExhausted() && minionToFlash.GetActor().GetActorStateType() != ActorStateType.CARD_IDLE && minionToFlash.GetActor().GetActorStateType() != ActorStateType.CARD_MOUSE_OVER)
+        {
+            minionToFlash.GetActorSpell(SpellType.WIGGLE).Activate();
+            yield return new WaitForSeconds(1.5f);
+            Gameplay.Get().StartCoroutine(BeginFlashingMinionLoop(minionToFlash));
+        }
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    private void ShowDontFireballYourselfPopup(Vector3 origin)
+    {
+        AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_07);
+    }
+
+    public override bool ShouldDoAlternateMulliganIntro()
+    {
+        return true;
+    }
+
+    public override bool DoAlternateMulliganIntro()
+    {
+        AssetLoader.Get().InstantiatePrefab("GameOpen_Pack.prefab:fca6ae094e9a74644b00fc9029f304c3", PackLoadedCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
+        return true;
+    }
+
+    private void PackLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        MusicManager.Get().StartPlaylist(MusicPlaylistType.Misc_Tutorial01);
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        Card heroCard2 = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
+        startingPack = go;
+        Transform transform = SceneUtils.FindChildBySubstring(startingPack, "Hero_Dummy").transform;
+        heroCard.transform.parent = transform;
+        heroCard.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        heroCard.transform.localPosition = new Vector3(0f, 0f, 0f);
+        SceneUtils.SetLayer(heroCard.GetActor().GetRootObject(), GameLayer.IgnoreFullScreenEffects);
+        Transform transform2 = SceneUtils.FindChildBySubstring(startingPack, "HeroEnemy_Dummy").transform;
+        heroCard2.transform.parent = transform2;
+        heroCard2.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        heroCard2.transform.localPosition = new Vector3(0f, 0f, 0f);
+        heroCard.SetDoNotSort(on: true);
+        Transform transform3 = Board.Get().FindBone("Tutorial1HeroStart");
+        go.transform.position = transform3.position;
+        heroCard.GetActor().GetHealthObject().Hide();
+        heroCard2.GetActor().GetHealthObject().Hide();
+        heroCard2.GetActor().Hide();
+        heroCard.GetActor().Hide();
+        SceneMgr.Get().NotifySceneLoaded();
+        Gameplay.Get().StartCoroutine(UpdatePresence());
+        Gameplay.Get().StartCoroutine(ShowPackOpeningArrow(transform3.position));
+    }
+
+    private IEnumerator UpdatePresence()
+    {
+        while (LoadingScreen.Get().IsPreviousSceneActive() || LoadingScreen.Get().IsFadingOut())
+        {
+            yield return null;
+        }
+        GameMgr.Get().UpdatePresence();
+    }
+
+    private IEnumerator ShowPackOpeningArrow(Vector3 packSpot)
+    {
+        yield return new WaitForSeconds(4f);
+        if (!packOpened)
+        {
+            AccessibleGameplay.Get().StopHidingMouse();
+            var packHovered = false;
+            AccessibilityMgr.WaitForForcedKey(AccessibleKey.CONFIRM, () => {
+                AccessibleInputMgr.MoveMouseToWorldPosition(packSpot);
+                packHovered = true;
+            });
+
+            AccessibilityMgr.BlockAllInput(false, true);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.WELCOME_TO_HEARTHSTONE);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_INTRO);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_HELP_KEYS);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_INTRO_END);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_FREE_STARTING_PACK);
+            AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_FREE_STARTING_PACK, AccessibleKey.CONFIRM);
+            yield return new WaitUntil(() => packHovered);
+            yield return new WaitForSeconds(2);
+            AccessibleInputMgr.ClickLeftMouseButton();
+            AccessibleGameplay.Get().StartHidingMouse();
+            AccessibilityMgr.BlacklistKeys(AccessibleKey.CONFIRM);
+        }
+    }
+
+    public override void NotifyOfGamePackOpened()
+    {
+        packOpened = true;
+    }
+
+    public override void NotifyOfCustomIntroFinished()
+    {
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        Card heroCard2 = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
+        heroCard.SetDoNotSort(on: false);
+        heroCard2.GetActor().TurnOnCollider();
+        heroCard.GetActor().TurnOnCollider();
+        heroCard.transform.parent = null;
+        heroCard2.transform.parent = null;
+        SceneUtils.SetLayer(heroCard.GetActor().GetRootObject(), GameLayer.CardRaycast);
+        Gameplay.Get().StartCoroutine(ContinueFinishingCustomIntro());
+    }
+
+    private IEnumerator ContinueFinishingCustomIntro()
+    {
+        yield return new WaitForSeconds(3f);
+        Object.Destroy(startingPack);
+        GameState.Get().SetBusy(busy: false);
+        MulliganManager.Get().SkipMulligan();
+    }
+
+    public override bool ShouldShowBigCard()
+    {
+        return GetTag(GAME_TAG.TURN) > 8;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        PlaySound("VO_TUTORIAL_01_JAINA_13_10.prefab:b13670e36c248e141837c4eb0645a000");
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_023", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs
new file mode 100644
index 0000000..4df1957
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs
@@ -0,0 +1,495 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_02 : TutorialEntity
+{
+    private Notification endTurnNotifier;
+
+    private Notification manaNotifier;
+
+    private Notification manaNotifier2;
+
+    private GameObject costLabel;
+
+    private int numManaThisTurn = 1;
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_02_05.prefab:d1334881818e67d4c85216afa56226d6");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_01_04.prefab:5b48a6d28da46464ea99c7b278f63226");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_04_07.prefab:a804332a9a314af49b35d1c6d4a1f306");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_05_08.prefab:946dc71f989978844af5222d4342df4c");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_07_10.prefab:ffdc387467735484390ee8545698c57e");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_11_14.prefab:ada9c4aef7cd8dc418005c0a4c5f578d");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_13_16.prefab:80757414dc5a3b54b9cfc328ce2b7f6c");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_15_17.prefab:973e26c00c354b24595965035e8efba7");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_06_09.prefab:04bd4efe66a93bb438327216a4254560");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_03_06.prefab:c509f7e0eca4fb84dbf9be77a7ed5823");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_10_13.prefab:a22defa2f9b5ec242a1f4e502d9349eb");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+        PreloadSound("VO_TUTORIAL_02_JAINA_08_22.prefab:52cd86a7a20daeb4b8d1f3fd2647e9ea");
+        PreloadSound("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_19_21.prefab:bc8b4236bf74f1244afa49a8195c7f74");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.MILLHOUSE_COMPLETE);
+                PlaySound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        if (GameState.Get().IsFriendlySidePlayerTurn())
+        {
+            numManaThisTurn++;
+        }
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 1:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_02_HELP_01);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MILLHOUSE_SEE_MANA_HELP);
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return new WaitForSeconds(0.5f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_04_07.prefab:a804332a9a314af49b35d1c6d4a1f306", "TUTORIAL02_MILLHOUSE_04", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                yield return new WaitForSeconds(0.3f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_05_08.prefab:946dc71f989978844af5222d4342df4c", "TUTORIAL02_MILLHOUSE_05", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 3:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_03);
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 4:
+                {
+                    if (manaNotifier2 != null)
+                    {
+                        NotificationManager.Get().DestroyNotification(manaNotifier2, 0f);
+                    }
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource previousLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00");
+                    while (SoundManager.Get().IsPlaying(previousLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_07_10.prefab:ffdc387467735484390ee8545698c57e", "TUTORIAL02_MILLHOUSE_07", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 6:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_11_14.prefab:ada9c4aef7cd8dc418005c0a4c5f578d", "TUTORIAL02_MILLHOUSE_11", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 8:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_13_16.prefab:80757414dc5a3b54b9cfc328ce2b7f6c", "TUTORIAL02_MILLHOUSE_13", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 9:
+                yield return new WaitForSeconds(0.5f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_15_17.prefab:973e26c00c354b24595965035e8efba7", "TUTORIAL02_MILLHOUSE_15", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 10:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource comeOnLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8");
+                    while (SoundManager.Get().IsPlaying(comeOnLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_06_09.prefab:04bd4efe66a93bb438327216a4254560", "TUTORIAL02_MILLHOUSE_06", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return new WaitForSeconds(1.5f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_03_06.prefab:c509f7e0eca4fb84dbf9be77a7ed5823", "TUTORIAL02_MILLHOUSE_03", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                yield return new WaitForSeconds(4f);
+                if (GetTag(GAME_TAG.TURN) == 1 && !EndTurnButton.Get().IsInWaitingState())
+                {
+                    ShowEndTurnBouncingArrow();
+                }
+                break;
+            case 3:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00", "TUTORIAL02_MILLHOUSE_17", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 4:
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7", "TUTORIAL02_MILLHOUSE_08", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2", "TUTORIAL02_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac", "TUTORIAL02_MILLHOUSE_09", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 5:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource feelslikeLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7");
+                    while (SoundManager.Get().IsPlaying(feelslikeLine))
+                    {
+                        yield return null;
+                    }
+                    AudioSource whatLine = GetPreloadedSound("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2");
+                    while (SoundManager.Get().IsPlaying(whatLine))
+                    {
+                        yield return null;
+                    }
+                    AudioSource winngingLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac");
+                    while (SoundManager.Get().IsPlaying(winngingLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_10_13.prefab:a22defa2f9b5ec242a1f4e502d9349eb", "TUTORIAL02_MILLHOUSE_10", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 6:
+                if (EndTurnButton.Get().IsInNMPState())
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8", "TUTORIAL02_MILLHOUSE_16", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                }
+                break;
+            case 54:
+                yield return new WaitForSeconds(2f);
+                var tutorialStartDialog = ShowTutorialDialog("TUTORIAL02_HELP_06", "TUTORIAL02_HELP_07", "TUTORIAL01_HELP_16", new Vector2(0.5f, 0f));
+                tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_06);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_07);
+                tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                break;
+            case 55:
+                FadeInHeroActor(millhouseActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_02_05.prefab:d1334881818e67d4c85216afa56226d6", "TUTORIAL02_MILLHOUSE_02", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                HistoryManager.Get().DisableHistory();
+                MulliganManager.Get().BeginMulligan();
+                yield return new WaitForSeconds(1.1f);
+                FadeOutHeroActor(millhouseActor);
+                break;
+        }
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (mousedOverEntity.GetZone() == TAG_ZONE.HAND && GetTag(GAME_TAG.TURN) <= 7)
+        {
+            AssetLoader.Get().InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, mousedOverEntity.GetCard(), AssetLoadingOptions.IgnorePrefabPosition);
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+    }
+
+    public override void NotifyOfCoinFlipResult()
+    {
+        Gameplay.Get().StartCoroutine(HandleCoinFlip());
+    }
+
+    private IEnumerator HandleCoinFlip()
+    {
+        GameState.Get().SetBusy(busy: true);
+        yield return new WaitForSeconds(3.5f);
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        FadeInHeroActor(millhouseActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_01_04.prefab:5b48a6d28da46464ea99c7b278f63226", "TUTORIAL02_MILLHOUSE_01", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+        GameState.Get().SetBusy(busy: false);
+        yield return new WaitForSeconds(0.175f);
+        FadeOutHeroActor(millhouseActor);
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null)
+        {
+            if (!optionsPacket.HasValidOption())
+            {
+                NotificationManager.Get().DestroyAllArrows();
+                return true;
+            }
+            bool flag = false;
+            for (int i = 0; i < optionsPacket.List.Count; i++)
+            {
+                Network.Options.Option option = optionsPacket.List[i];
+                if (option.Main.PlayErrorInfo.IsValid() && option.Type == Network.Options.Option.OptionType.POWER && !(GameState.Get().GetEntity(option.Main.ID).GetCardId() == "TU5_CS2_025"))
+                {
+                    flag = true;
+                    break;
+                }
+            }
+            if (!flag)
+            {
+                return true;
+            }
+        }
+        if (endTurnNotifier != null)
+        {
+            NotificationManager.Get().DestroyNotificationNowWithNoAnim(endTurnNotifier);
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN_ATK";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    public override string[] NotifyOfKeywordHelpPanelDisplay(Entity entity)
+    {
+        if (entity.GetCardId() == "CS2_122")
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_RAID_LEADER_DESCRIPTION);
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL_RAID_LEADER_HEADLINE"),
+                GameStrings.Get("TUTORIAL_RAID_LEADER_DESCRIPTION")
+            };
+        }
+        if (entity.GetCardId() == "TU5_CS2_023")
+        {
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL_ARCANE_INTELLECT_HEADLINE"),
+                GameStrings.Get("TUTORIAL_ARCANE_INTELLECT_DESCRIPTION")
+            };
+        }
+        return null;
+    }
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (entity.GetCardId() == "TU5_CS2_023" && GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources() >= entity.GetCost())
+        {
+            BoardTutorial.Get().EnableFullHighlight(enable: true);
+        }
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        if (entity.GetCardId() == "TU5_CS2_023")
+        {
+            BoardTutorial.Get().EnableFullHighlight(enable: false);
+        }
+    }
+
+    public override void NotifyOfManaCrystalSpawned()
+    {
+        AssetLoader.Get().InstantiatePrefab("plus1.prefab:7427d28c07eea8645a3308e04398ee30", Plus1ActorLoadedCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
+        if (GetTag(GAME_TAG.TURN) == 3)
+        {
+            Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+                .GetCard()
+                .GetActor();
+            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_02_JAINA_08_22.prefab:52cd86a7a20daeb4b8d1f3fd2647e9ea", "TUTORIAL02_JAINA_08", Notification.SpeechBubbleDirection.BottomLeft, actor));
+        }
+        FadeInManaSpotlight();
+    }
+
+    private void FadeInManaSpotlight()
+    {
+        Gameplay.Get().StartCoroutine(StartManaSpotFade());
+    }
+
+    private IEnumerator StartManaSpotFade()
+    {
+        Light manaSpot = BoardTutorial.Get().m_ManaSpotlight;
+        manaSpot.enabled = true;
+        manaSpot.spotAngle = 179f;
+        manaSpot.intensity = 0f;
+        float TARGET_INTENSITY = 0.6f;
+        while (manaSpot.intensity < TARGET_INTENSITY * 0.95f)
+        {
+            manaSpot.intensity = Mathf.Lerp(manaSpot.intensity, TARGET_INTENSITY, Time.deltaTime * 5f);
+            manaSpot.spotAngle = Mathf.Lerp(manaSpot.spotAngle, 80f, Time.deltaTime * 5f);
+            yield return null;
+        }
+        yield return new WaitForSeconds(2f);
+        while (manaSpot.intensity > 0.05f)
+        {
+            manaSpot.intensity = Mathf.Lerp(manaSpot.intensity, 0f, Time.deltaTime * 10f);
+            yield return null;
+        }
+        manaSpot.enabled = false;
+    }
+
+    private void Plus1ActorLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        Vector3 position = SceneUtils.FindChildBySubstring(Board.Get().gameObject, "ManaCounter_Friendly").transform.position;
+        Vector3 position2 = new Vector3(position.x - 0.02f, position.y + 0.2f, position.z);
+        go.transform.position = position2;
+        go.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
+        Vector3 localScale = go.transform.localScale;
+        go.transform.localScale = new Vector3(1f, 1f, 1f);
+        iTween.MoveTo(go, new Vector3(position2.x, position2.y, position2.z + 2f), 3f);
+        float num = 2.5f;
+        iTween.ScaleTo(go, new Vector3(localScale.x * num, localScale.y * num, localScale.z * num), 3f);
+        iTween.RotateTo(go, new Vector3(0f, 170f, 0f), 3f);
+        iTween.FadeTo(go, 0f, 2.75f);
+    }
+
+    public override void NotifyOfEnemyManaCrystalSpawned()
+    {
+        AssetLoader.Get().InstantiatePrefab("plus1.prefab:7427d28c07eea8645a3308e04398ee30", Plus1ActorLoadedCallbackEnemy, null, AssetLoadingOptions.IgnorePrefabPosition);
+    }
+
+    private void Plus1ActorLoadedCallbackEnemy(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        Vector3 position = SceneUtils.FindChildBySubstring(Board.Get().gameObject, "ManaCounter_Opposing").transform.position;
+        Vector3 position2 = new Vector3(position.x, position.y + 0.2f, position.z);
+        go.transform.position = position2;
+        go.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
+        Vector3 localScale = go.transform.localScale;
+        go.transform.localScale = new Vector3(1f, 1f, 1f);
+        iTween.MoveTo(go, new Vector3(position2.x, position2.y, position2.z - 2f), 3f);
+        float num = 2.5f;
+        iTween.ScaleTo(go, new Vector3(localScale.x * num, localScale.y * num, localScale.z * num), 3f);
+        iTween.RotateTo(go, new Vector3(0f, 170f, 0f), 3f);
+        iTween.FadeTo(go, 0f, 2.75f);
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+        if (costTextObject == null)
+        {
+            Object.Destroy(go);
+            return;
+        }
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+        costLabel = go;
+        go.transform.parent = costTextObject.transform;
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localPosition = new Vector3(-0.025f, 0.28f, 0f);
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+    }
+
+    public override void NotifyOfTooltipZoneMouseOver(TooltipZone tooltip)
+    {
+        if (tooltip.targetObject.GetComponent<ManaCrystalMgr>() != null)
+        {
+            if (manaNotifier != null)
+            {
+                Object.Destroy(manaNotifier.gameObject);
+            }
+            if (manaNotifier2 != null)
+            {
+                Object.Destroy(manaNotifier2.gameObject);
+            }
+        }
+    }
+
+    public override string GetTurnStartReminderText()
+    {
+        return GameStrings.Format("TUTORIAL02_HELP_04", numManaThisTurn);
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        Gameplay.Get().StartCoroutine(PlayGoingOutSound());
+    }
+
+    private IEnumerator PlayGoingOutSound()
+    {
+        AudioSource deathLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+        while (deathLine != null && deathLine.isPlaying)
+        {
+            yield return null;
+        }
+        PlaySound("VO_TUTORIAL02_MILLHOUSE_19_21.prefab:bc8b4236bf74f1244afa49a8195c7f74");
+    }
+
+    protected override void NotifyOfManaError()
+    {
+        NotificationManager.Get().DestroyNotificationNowWithNoAnim(manaNotifier);
+        NotificationManager.Get().DestroyNotificationNowWithNoAnim(manaNotifier2);
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("EX1_015", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs
new file mode 100644
index 0000000..f4bd683
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs
@@ -0,0 +1,389 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_03 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private int numTauntGorillasPlayed;
+
+    private bool enemyPlayedBigBrother;
+
+    private bool needATaunterVOPlayed;
+
+    private bool monkeyLinePlayedOnce;
+
+    private bool defenselessVoPlayed;
+
+    private bool seenTheBrother;
+
+    private bool warnedAgainstAttackingGorilla;
+
+    private bool victory;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool>
+        {
+            {
+                GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN,
+                false
+            },
+            {
+                GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+                true
+            },
+            {
+                GameEntityOption.SHOW_CRAZY_KEYWORD_TOOLTIP,
+                true
+            }
+        };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_03()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_03_JAINA_17_33.prefab:b96f78fff7ab94a42894930d51bd45bd");
+        PreloadSound("VO_TUTORIAL_03_JAINA_18_34.prefab:b9a2a99d30893804790829b3ceabc9b8");
+        PreloadSound("VO_TUTORIAL_03_JAINA_01_24.prefab:b9515cf173f876a458202c6092055709");
+        PreloadSound("VO_TUTORIAL_03_JAINA_05_25.prefab:38e2d64610e757245877b8f8e2f68584");
+        PreloadSound("VO_TUTORIAL_03_JAINA_07_26.prefab:e93d67263c3d99740aaa4acc4b7d87a4");
+        PreloadSound("VO_TUTORIAL_03_JAINA_12_28.prefab:d30f0c732643aa74aba9ec4cf2c2e6dd");
+        PreloadSound("VO_TUTORIAL_03_JAINA_13_29.prefab:efca9c5305a101e4d968d08e58061cda");
+        PreloadSound("VO_TUTORIAL_03_JAINA_16_32.prefab:b05bea699e2f897478c81a485a7d1a1a");
+        PreloadSound("VO_TUTORIAL_03_JAINA_14_30.prefab:0787881bd0a25a342ba06f566f16051b");
+        PreloadSound("VO_TUTORIAL_03_JAINA_15_31.prefab:4e0f1eaa19e283a4cac77219e1f10fe3");
+        PreloadSound("VO_TUTORIAL_03_JAINA_20_36.prefab:79671f155307aa24a89b0581e4c5c4b2");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_01_01.prefab:3f6638f7f0d96da4ca422a290035c97a");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_03_03.prefab:5018131495f68c247bac073424fab700");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_04_04.prefab:0e4a4c87ac994c845b06230a34b168f9");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_05_05.prefab:8c12c75976cdfe044ad8ff3dd14ae5b8");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_06_06.prefab:8ed0c9ff5d18314469821d5be3d62dc7");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.MUKLA_COMPLETE);
+                PlaySound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.MUKLA_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (enemyPlayedBigBrother)
+        {
+            if (GameState.Get().IsFriendlySidePlayerTurn())
+            {
+                if (GameState.Get().GetNumEnemyMinionsInPlay(includeUntouchables: false) > 0)
+                {
+                    if (!needATaunterVOPlayed)
+                    {
+                        if (!GameState.Get().GetFriendlySidePlayer().HasATauntMinion())
+                        {
+                            needATaunterVOPlayed = true;
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_17_33.prefab:b96f78fff7ab94a42894930d51bd45bd", "TUTORIAL03_JAINA_17", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                        }
+                        yield break;
+                    }
+                    if (!defenselessVoPlayed)
+                    {
+                        bool flag = true;
+                        foreach (Card card in GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+                            .GetCards())
+                        {
+                            if (card.GetEntity().HasTaunt())
+                            {
+                                flag = false;
+                            }
+                        }
+                        if (flag)
+                        {
+                            defenselessVoPlayed = true;
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_18_34.prefab:b9a2a99d30893804790829b3ceabc9b8", "TUTORIAL03_JAINA_18", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                        }
+                    }
+                }
+            }
+            else if (!seenTheBrother)
+            {
+                Gameplay.Get().StartCoroutine(GetReadyForBro());
+            }
+        }
+        switch (turn)
+        {
+            case 1:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_01_24.prefab:b9515cf173f876a458202c6092055709", "TUTORIAL03_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                break;
+            case 5:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_05_25.prefab:38e2d64610e757245877b8f8e2f68584", "TUTORIAL03_JAINA_05", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_03_03.prefab:5018131495f68c247bac073424fab700", "TUTORIAL03_MUKLA_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 6:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_04_04.prefab:0e4a4c87ac994c845b06230a34b168f9", "TUTORIAL03_MUKLA_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 9:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_07_26.prefab:e93d67263c3d99740aaa4acc4b7d87a4", "TUTORIAL03_JAINA_07", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                break;
+            case 14:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_05_05.prefab:8c12c75976cdfe044ad8ff3dd14ae5b8", "TUTORIAL03_MUKLA_05", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    private IEnumerator GetReadyForBro()
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        seenTheBrother = true;
+        GameState.Get().SetBusy(busy: true);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_12_28.prefab:d30f0c732643aa74aba9ec4cf2c2e6dd", "TUTORIAL03_JAINA_12", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+        GameState.Get().SetBusy(busy: false);
+        yield return new WaitForSeconds(3.2f);
+        Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_13_29.prefab:efca9c5305a101e4d968d08e58061cda", "TUTORIAL03_JAINA_13", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                AssetLoader.Get().InstantiatePrefab("TutorialKeywordManager.prefab:c1276fda3e1df594990295731f80c9c2", AssetLoadingOptions.IgnorePrefabPosition);
+                break;
+            case 4:
+                numTauntGorillasPlayed++;
+                if (numTauntGorillasPlayed == 1)
+                {
+                    Gameplay.Get().StartCoroutine(ShowTauntPopup());
+                }
+                else if (numTauntGorillasPlayed == 2 && !DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_06_06.prefab:8ed0c9ff5d18314469821d5be3d62dc7", "TUTORIAL03_MUKLA_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 10:
+                enemyPlayedBigBrother = true;
+                Gameplay.Get().StartCoroutine(AdjustBigBrotherTransform());
+                if (!GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    Gameplay.Get().StartCoroutine(GetReadyForBro());
+                }
+                break;
+            case 11:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_16_32.prefab:b05bea699e2f897478c81a485a7d1a1a", "TUTORIAL03_JAINA_16", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                break;
+            case 12:
+                if (!monkeyLinePlayedOnce)
+                {
+                    monkeyLinePlayedOnce = true;
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_14_30.prefab:0787881bd0a25a342ba06f566f16051b", "TUTORIAL03_JAINA_14", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                else if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_15_31.prefab:4e0f1eaa19e283a4cac77219e1f10fe3", "TUTORIAL03_JAINA_15", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                break;
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    string bodyTextGameString = "TUTORIAL03_HELP_03";
+                    if (UniversalInputManager.Get().IsTouchMode())
+                    {
+                        bodyTextGameString = "TUTORIAL03_HELP_03_TOUCH";
+                    }
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL03_HELP_02", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0.5f, 0.5f));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START_B);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START_C);
+                    break;
+                }
+            case 55:
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_01_01.prefab:3f6638f7f0d96da4ca422a290035c97a", "TUTORIAL03_MUKLA_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                MulliganManager.Get().BeginMulligan();
+                FadeOutHeroActor(enemyActor);
+                break;
+        }
+    }
+
+    private IEnumerator ShowTauntPopup()
+    {
+        Card gorillaCard = null;
+        while (gorillaCard == null)
+        {
+            gorillaCard = FindCardInEnemyBattlefield("TU5_CS2_127");
+            if (gorillaCard != null)
+            {
+                break;
+            }
+            yield return null;
+        }
+        while (!gorillaCard.IsActorReady())
+        {
+            yield return null;
+        }
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP);
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP_B);
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP_C);
+    }
+
+    private IEnumerator AdjustBigBrotherTransform()
+    {
+        ZonePlay enemyBattlefield = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+        Vector3 prevBattlefieldScale = enemyBattlefield.transform.localScale;
+        enemyBattlefield.transform.localScale = 1.6f * enemyBattlefield.transform.localScale;
+        Vector3 position = enemyBattlefield.transform.position;
+        enemyBattlefield.transform.position = new Vector3(position.x + 2.3931637f, position.y, position.z + 0.7f);
+        Card bigBrotherCard = null;
+        while (bigBrotherCard == null)
+        {
+            bigBrotherCard = FindCardInEnemyBattlefield("TU4c_007");
+            if (bigBrotherCard != null)
+            {
+                break;
+            }
+            yield return null;
+        }
+        while (!bigBrotherCard.IsActorReady())
+        {
+            yield return null;
+        }
+        Actor actor = bigBrotherCard.GetActor();
+        Transform parent = actor.transform.parent;
+        Vector3 localScale = actor.transform.localScale;
+        actor.transform.parent = null;
+        bigBrotherCard.transform.localScale = prevBattlefieldScale;
+        GameObject gameObject = new GameObject();
+        gameObject.transform.parent = parent;
+        gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
+        gameObject.transform.localScale = new Vector3(1.6f, 1.6f, 1.6f);
+        actor.transform.parent = gameObject.transform;
+        actor.transform.localScale = localScale;
+        enemyBattlefield.transform.localScale = prevBattlefieldScale;
+    }
+
+    private Card FindCardInEnemyBattlefield(string cardId)
+    {
+        ZonePlay battlefieldZone = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+        for (int i = 0; i < battlefieldZone.GetCardCount(); i++)
+        {
+            Card cardAtIndex = battlefieldZone.GetCardAtIndex(i);
+            if (!(cardAtIndex.GetEntity().GetCardId() != cardId))
+            {
+                return cardAtIndex;
+            }
+        }
+        return null;
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        GetGameOptions().SetBooleanOption(GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN, value: false);
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (mousedOverEntity.HasTaunt())
+        {
+            GetGameOptions().SetBooleanOption(GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN, value: true);
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (!base.NotifyOfBattlefieldCardClicked(clickedEntity, wasInTargetMode))
+        {
+            return false;
+        }
+        if (wasInTargetMode && clickedEntity.GetCardId() == "TU4c_007" && !warnedAgainstAttackingGorilla)
+        {
+            warnedAgainstAttackingGorilla = true;
+            HandleMissionEvent(11);
+            return false;
+        }
+        return true;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (victory)
+        {
+            PlaySound("VO_TUTORIAL_03_JAINA_20_36.prefab:79671f155307aa24a89b0581e4c5c4b2");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_022", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs
new file mode 100644
index 0000000..e129991
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs
@@ -0,0 +1,641 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_04 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification endTurnNotifier;
+
+    private Notification handBounceArrow;
+
+    private Notification sheepTheBog;
+
+    private Notification noSheepPopup;
+
+    private int numBeastsPlayed;
+
+    private GameObject m_heroPowerCostLabel;
+
+    private Notification heroPowerHelp;
+
+    private bool victory;
+
+    private bool m_hemetSpeaking;
+
+    private int numComplaintsMade;
+
+    private bool m_shouldSignalPolymorph;
+
+    private bool m_isPolymorphGrabbed;
+
+    private bool m_isBogSheeped;
+
+    private bool m_playOneHealthCommentNextTurn;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_04()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+        PreloadSound("VO_TUTORIAL04_HEMET_15_13.prefab:c0da1267215708947a954e9c0ea1b061");
+        PreloadSound("VO_TUTORIAL04_HEMET_20_18.prefab:5d49a0bac4c03b94e9e13945624a581b");
+        PreloadSound("VO_TUTORIAL04_HEMET_16_14.prefab:df368c7075e4a2649803729f7b86601e");
+        PreloadSound("VO_TUTORIAL04_HEMET_13_12.prefab:fe14ab273aa4b7e4491f30310a7d0eca");
+        PreloadSound("VO_TUTORIAL04_HEMET_19_17.prefab:b9d5bd30659aae84b8a1380cbdba0398");
+        PreloadSound("VO_TUTORIAL_04_JAINA_09_43.prefab:1ee05d74948aba04ebd7065e44813921");
+        PreloadSound("VO_TUTORIAL_04_JAINA_10_44.prefab:6f5921db1071ead4585c8cc9689d22ea");
+        PreloadSound("VO_TUTORIAL04_HEMET_06_05.prefab:2527939914db3e543941a13266e88a01");
+        PreloadSound("VO_TUTORIAL04_HEMET_07_06_ALT.prefab:c19475ec3c3b0e648a97f423e0e86143");
+        PreloadSound("VO_TUTORIAL_04_JAINA_04_40.prefab:5bfc80c6184279140878a51eb1fa3469");
+        PreloadSound("VO_TUTORIAL04_HEMET_08_07.prefab:68207d2681a60c84d840d37c4b90740f");
+        PreloadSound("VO_TUTORIAL04_HEMET_09_08.prefab:2994b6b35f2e5f54782b6100ea92f40e");
+        PreloadSound("VO_TUTORIAL04_HEMET_10_09.prefab:3282099b41c7ab94aa99e84c20dd7db7");
+        PreloadSound("VO_TUTORIAL04_HEMET_11_10.prefab:db8c8cea0db51d14fbd5d4c782b8b160");
+        PreloadSound("VO_TUTORIAL04_HEMET_12_11.prefab:b0ea652d6f1ec6845845226680ade252");
+        PreloadSound("VO_TUTORIAL04_HEMET_12_11_ALT.prefab:b59f55e14876bee43a0d9ab4b7317f84");
+        PreloadSound("VO_TUTORIAL_04_JAINA_08_42.prefab:36763b11766e2b64198719d44b0fa8bf");
+        PreloadSound("VO_TUTORIAL04_HEMET_01_01.prefab:89be0839b16c1244a9221b373fd8fb61");
+        PreloadSound("VO_TUTORIAL_04_JAINA_01_37.prefab:c7fc40d1595ca3c49b524b9929264477");
+        PreloadSound("VO_TUTORIAL04_HEMET_02_02.prefab:c3ca1337cb01efe4194899d42918f80c");
+        PreloadSound("VO_TUTORIAL04_HEMET_03_03.prefab:b014c684c85f1c440bed5560c6b6dbf5");
+        PreloadSound("VO_TUTORIAL_04_JAINA_02_38.prefab:83b64d5eeb884db43b9fa5f20316da2c");
+        PreloadSound("VO_TUTORIAL04_HEMET_04_04_ALT.prefab:bb3fadd78adce274993862115f3c5137");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        if (m_heroPowerCostLabel != null)
+        {
+            Object.Destroy(m_heroPowerCostLabel);
+        }
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.NESINGWARY_COMPLETE);
+                PlaySound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.NESINGWARY_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        m_shouldSignalPolymorph = false;
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (m_playOneHealthCommentNextTurn)
+        {
+            m_playOneHealthCommentNextTurn = false;
+            GameState.Get().SetBusy(busy: true);
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_08_42.prefab:36763b11766e2b64198719d44b0fa8bf", "TUTORIAL04_JAINA_08", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+            GameState.Get().SetBusy(busy: false);
+        }
+        switch (turn)
+        {
+            case 1:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_15_13.prefab:c0da1267215708947a954e9c0ea1b061", "TUTORIAL04_HEMET_15", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 4:
+                {
+                    yield return new WaitForSeconds(1f);
+                    GameState.Get().SetBusy(busy: true);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return new WaitForSeconds(1f);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP_B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP_C);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_TRY_IT_OUT);
+                    AccessibilityMgr.UnblockAllInput();
+                    GameState.Get().SetBusy(busy: false);
+
+                    AssetLoader.Get().InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard(), AssetLoadingOptions.IgnorePrefabPosition);
+                    break;
+                }
+            case 5:
+                NotificationManager.Get().DestroyNotification(heroPowerHelp, 0f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_20_18.prefab:5d49a0bac4c03b94e9e13945624a581b", "TUTORIAL04_HEMET_20", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+            case 7:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_16_14.prefab:df368c7075e4a2649803729f7b86601e", "TUTORIAL04_HEMET_16", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 9:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_13_12.prefab:fe14ab273aa4b7e4491f30310a7d0eca", "TUTORIAL04_HEMET_13", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 11:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().SetGameStateBusy(busy: false, 3f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_19_17.prefab:b9d5bd30659aae84b8a1380cbdba0398", "TUTORIAL04_HEMET_19", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                yield return new WaitForSeconds(0.7f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_09_43.prefab:1ee05d74948aba04ebd7065e44813921", "TUTORIAL04_JAINA_09", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 12:
+                {
+                    if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                    {
+                        break;
+                    }
+                    m_shouldSignalPolymorph = true;
+                    List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                        .GetCards();
+                    if (!(InputManager.Get().GetHeldCard() == null))
+                    {
+                        break;
+                    }
+                    Card card = null;
+                    foreach (Card item in cards)
+                    {
+                        if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+                        {
+                            card = item;
+                        }
+                    }
+                    if (!(card == null) && !card.IsMousedOver())
+                    {
+                        Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0f));
+                    }
+                    break;
+                }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_06_05.prefab:2527939914db3e543941a13266e88a01", "TUTORIAL04_HEMET_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_07_06_ALT.prefab:c19475ec3c3b0e648a97f423e0e86143", "TUTORIAL04_HEMET_07", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                yield return Gameplay.Get().StartCoroutine(Wait(1f));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 3:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(Wait(2f));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 4:
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    InputManager.Get().GetFriendlyHand().SetHandEnlarged(enlarged: false);
+                }
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_04_40.prefab:5bfc80c6184279140878a51eb1fa3469", "TUTORIAL04_JAINA_04", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 5:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    switch (numBeastsPlayed)
+                    {
+                        case 0:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_08_07.prefab:68207d2681a60c84d840d37c4b90740f", "TUTORIAL04_HEMET_08", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 1:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_09_08.prefab:2994b6b35f2e5f54782b6100ea92f40e", "TUTORIAL04_HEMET_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 2:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_10_09.prefab:3282099b41c7ab94aa99e84c20dd7db7", "TUTORIAL04_HEMET_10", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 3:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_11_10.prefab:db8c8cea0db51d14fbd5d4c782b8b160", "TUTORIAL04_HEMET_11", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                    }
+                    numBeastsPlayed++;
+                }
+                break;
+            case 6:
+                if (numComplaintsMade == 0)
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_12_11.prefab:b0ea652d6f1ec6845845226680ade252", "TUTORIAL04_HEMET_12a", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    numComplaintsMade++;
+                }
+                else
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_12_11_ALT.prefab:b59f55e14876bee43a0d9ab4b7317f84", "TUTORIAL04_HEMET_12b", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 7:
+                m_playOneHealthCommentNextTurn = true;
+                break;
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE));
+                    string bodyTextGameString = flag? "TUTORIAL04_HELP_15" : "TUTORIAL04_HELP_16";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL04_HELP_14", bodyTextGameString, "TUTORIAL01_HELP_16", Vector2.zero, swapMaterial: true);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL04_HELP_14);
+                    yield return AccessibilityMgr.Narrate(flag? AccessibleSpeech.TUTORIAL04_HELP_15 : AccessibleSpeech.TUTORIAL04_HELP_16);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_01_01.prefab:89be0839b16c1244a9221b373fd8fb61", "TUTORIAL04_HEMET_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    FadeInHeroActor(jainaActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_01_37.prefab:c7fc40d1595ca3c49b524b9929264477", "TUTORIAL04_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    FadeOutHeroActor(jainaActor);
+                    yield return new WaitForSeconds(0.5f);
+                }
+                MulliganManager.Get().BeginMulligan();
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    m_hemetSpeaking = true;
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_02_02.prefab:c3ca1337cb01efe4194899d42918f80c", "TUTORIAL04_HEMET_02", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    m_hemetSpeaking = false;
+                }
+                break;
+        }
+    }
+
+    public override void NotifyOfCoinFlipResult()
+    {
+        Gameplay.Get().StartCoroutine(HandleCoinFlip());
+    }
+
+    private IEnumerator HandleCoinFlip()
+    {
+        GameState.Get().SetBusy(busy: true);
+        yield return Gameplay.Get().StartCoroutine(Wait(1f));
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        while (m_hemetSpeaking)
+        {
+            yield return null;
+        }
+        FadeInHeroActor(enemyActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_03_03.prefab:b014c684c85f1c440bed5560c6b6dbf5", "TUTORIAL04_HEMET_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+        FadeOutHeroActor(enemyActor);
+        yield return new WaitForSeconds(0.3f);
+        FadeInHeroActor(jainaActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_02_38.prefab:83b64d5eeb884db43b9fa5f20316da2c", "TUTORIAL04_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+        FadeOutHeroActor(jainaActor);
+        yield return new WaitForSeconds(0.25f);
+        if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+        {
+            FadeInHeroActor(enemyActor);
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_04_04_ALT.prefab:bb3fadd78adce274993862115f3c5137", "TUTORIAL04_HEMET_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+            FadeOutHeroActor(enemyActor);
+            yield return new WaitForSeconds(0.4f);
+        }
+        GameState.Get().SetBusy(busy: false);
+    }
+
+    private IEnumerator Wait(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+    }
+
+    private bool AllowEndTurn()
+    {
+        if (!m_shouldSignalPolymorph || (m_shouldSignalPolymorph && m_isBogSheeped))
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        if (GetTag(GAME_TAG.TURN) != 4 && AllowEndTurn())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        if (endTurnNotifier != null)
+        {
+            NotificationManager.Get().DestroyNotificationNowWithNoAnim(endTurnNotifier);
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN_HP";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_HP;
+        if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN_ATK";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        }
+        if (m_shouldSignalPolymorph && !m_isBogSheeped)
+        {
+            key = "TUTORIAL_NO_ENDTURN";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    public override void NotifyOfTargetModeCancelled()
+    {
+        if (!(sheepTheBog == null))
+        {
+            NotificationManager.Get().DestroyAllPopUps();
+        }
+    }
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (!m_shouldSignalPolymorph)
+        {
+            return;
+        }
+        if (entity.GetCardId() == "TU5_CS2_022")
+        {
+            m_isPolymorphGrabbed = true;
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            if (handBounceArrow != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(handBounceArrow);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            Vector3 position = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+                .GetFirstCard()
+                .transform.position;
+            Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL04_HELP_02);
+        }
+        else
+        {
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            if ((bool)UniversalInputManager.UsePhoneUI)
+            {
+                InputManager.Get().ReturnHeldCardToHand();
+            }
+            else
+            {
+                InputManager.Get().DropHeldCard();
+            }
+        }
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        m_isPolymorphGrabbed = false;
+        if (m_shouldSignalPolymorph)
+        {
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            if (ShouldShowArrowOnCardInHand(entity))
+            {
+                Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+            }
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (m_shouldSignalPolymorph)
+        {
+            if (!(clickedEntity.GetCardId() == "TU5_CS1_069" && wasInTargetMode))
+            {
+                if (m_isPolymorphGrabbed && wasInTargetMode)
+                {
+                    if (noSheepPopup != null)
+                    {
+                        NotificationManager.Get().DestroyNotificationNowWithNoAnim(noSheepPopup);
+                    }
+                    Vector3 position = clickedEntity.GetCard().transform.position;
+                    Vector3 position2 = new Vector3(position.x + 2.5f, position.y, position.z);
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL04_HELP_03);
+                    return false;
+                }
+                return false;
+            }
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            m_shouldSignalPolymorph = false;
+            m_isBogSheeped = true;
+        }
+        return true;
+    }
+
+    public override bool ShouldAllowCardGrab(Entity entity)
+    {
+        if (m_shouldSignalPolymorph && entity.GetCardId() != "TU5_CS2_022")
+        {
+            return false;
+        }
+        return true;
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+        if (costTextObject == null)
+        {
+            Object.Destroy(go);
+            return;
+        }
+        m_heroPowerCostLabel = go;
+        SceneUtils.SetLayer(go, GameLayer.Default);
+        go.transform.parent = costTextObject.transform;
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localPosition = new Vector3(-0.02f, 0.38f, 0f);
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localScale = new Vector3(go.transform.localScale.x, go.transform.localScale.x, go.transform.localScale.x);
+        go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOverEntity))
+        {
+            NotificationManager.Get().DestroyAllArrows();
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOffEntity))
+        {
+            Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+        }
+    }
+
+    private bool ShouldShowArrowOnCardInHand(Entity entity)
+    {
+        if (entity.GetZone() != TAG_ZONE.HAND)
+        {
+            return false;
+        }
+        if (m_shouldSignalPolymorph && entity.GetCardId() == "TU5_CS2_022")
+        {
+            return true;
+        }
+        return false;
+    }
+
+    private IEnumerator ShowArrowInSeconds(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count == 0 || m_isPolymorphGrabbed)
+        {
+            yield break;
+        }
+        Card polyMorph = null;
+        foreach (Card item in cards)
+        {
+            if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+            {
+                polyMorph = item;
+            }
+        }
+        if (!(polyMorph == null))
+        {
+            while (iTween.Count(polyMorph.gameObject) > 0)
+            {
+                yield return null;
+            }
+            if (!polyMorph.IsMousedOver() && !(InputManager.Get().GetHeldCard() == polyMorph))
+            {
+                ShowHandBouncingArrow();
+            }
+        }
+    }
+
+    private void ShowHandBouncingArrow()
+    {
+        if (handBounceArrow != null)
+        {
+            return;
+        }
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count == 0)
+        {
+            return;
+        }
+        Card card = null;
+        foreach (Card item in cards)
+        {
+            if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+            {
+                card = item;
+            }
+        }
+        if (!(card == null) && !m_isPolymorphGrabbed)
+        {
+            Vector3 position = card.transform.position;
+            Vector3 position2 = new Vector3(position.x, position.y, position.z + 2f);
+            handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
+            handBounceArrow.transform.parent = card.transform;
+        }
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (victory)
+        {
+            PlaySound("VO_TUTORIAL_04_JAINA_10_44.prefab:6f5921db1071ead4585c8cc9689d22ea");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_213", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs
new file mode 100644
index 0000000..09a1272
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs
@@ -0,0 +1,302 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_05 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private int weaponsPlayed;
+
+    private int numTimesRemindedAboutGoal;
+
+    private bool heroPowerHasNotBeenUsed = true;
+
+    private bool victory;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_05()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+        PreloadSound("VO_TUTORIAL_04_JAINA_03_39.prefab:ef84060011610064abeee5d2d526bf85");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_11_11.prefab:8cd68956e13f8ee43bb816a92c56ab7e");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_02_03.prefab:00cdf773e524ae548a31d82db5bb35c2");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_04_05.prefab:eb68b53ffa7195841a18d4c50516ce35");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_08_08.prefab:32281bee676aa6d4e9c590dfb9e03cb6");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_03_04.prefab:38739c8e8bb7eba42a94afe8bce981f3");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_05_06.prefab:30bf89624d8c3df4b9f776218c7300ad");
+        PreloadSound("VO_TUTORIAL_05_JAINA_02_46.prefab:4daa9f9fc9fc730429c198b9a7212521");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_06_07.prefab:f8e57e165a11de047a2fcaa95e22457b");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_09_09.prefab:1ca9806eebcb0e841be971e486199833");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_10_10.prefab:30c0266100fcd714e804006040c241ad");
+        PreloadSound("VO_TUTORIAL_05_JAINA_05_47.prefab:8caf0051fc3c91c48852eed53e886e4b");
+        PreloadSound("VO_TUTORIAL_05_JAINA_06_48.prefab:fbfba7282a8cb334ba40699cab0524fd");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_01_02.prefab:d4b65ea6366e7a64d8833321001590f1");
+        PreloadSound("VO_TUTORIAL_05_JAINA_01_45.prefab:d5b645ea8a95c0e44a90838ab77b2564");
+        PreloadSound("VO_INNKEEPER_TUT_COMPLETE_05.prefab:c8d19a552e18c7c429946f62102c9460");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.ILLIDAN_COMPLETE);
+                if (Network.ShouldBeConnectedToAurora() && Network.IsLoggedIn() && !GameMgr.Get().IsSpectator())
+                {
+                    BnetPresenceMgr.Get().SetGameField(15u, 1);
+                }
+                ResetTutorialLostProgress();
+                PlaySound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.ILLIDAN_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (GameState.Get().GetOpposingSidePlayer().HasWeapon())
+        {
+            GameState.Get().GetOpposingSidePlayer().GetWeaponCard()
+                .GetActorSpell(SpellType.DEATH)
+                .m_BlockServerEvents = true;
+        }
+        if (turn == 2)
+        {
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_03_39.prefab:ef84060011610064abeee5d2d526bf85", "TUTORIAL04_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, actor));
+            if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+            {
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_11_11.prefab:8cd68956e13f8ee43bb816a92c56ab7e", "TUTORIAL05_ILLIDAN_11", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                GameState.Get().SetBusy(busy: false);
+            }
+            if (GetTag(GAME_TAG.TURN) == 2 && EndTurnButton.Get().IsInNMPState())
+            {
+                ShowEndTurnBouncingArrow();
+            }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    weaponsPlayed++;
+                    if (weaponsPlayed == 1)
+                    {
+                        AccessibilityMgr.BlockAllInput(false, true);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_02_03.prefab:00cdf773e524ae548a31d82db5bb35c2", "TUTORIAL05_ILLIDAN_02", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H);
+                        AccessibilityMgr.UnblockAllInput();
+                    }
+                    else if (weaponsPlayed == 2)
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_04_05.prefab:eb68b53ffa7195841a18d4c50516ce35", "TUTORIAL05_ILLIDAN_04", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_08_08.prefab:32281bee676aa6d4e9c590dfb9e03cb6", "TUTORIAL05_ILLIDAN_08", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    }
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 3:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_03_04.prefab:38739c8e8bb7eba42a94afe8bce981f3", "TUTORIAL05_ILLIDAN_03", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                }
+                break;
+            case 4:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_05_06.prefab:30bf89624d8c3df4b9f776218c7300ad", "TUTORIAL05_ILLIDAN_05", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 5:
+                if (heroPowerHasNotBeenUsed)
+                {
+                    heroPowerHasNotBeenUsed = false;
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(2f);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_02_46.prefab:4daa9f9fc9fc730429c198b9a7212521", "TUTORIAL05_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_06_07.prefab:f8e57e165a11de047a2fcaa95e22457b", "TUTORIAL05_ILLIDAN_06", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 8:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_09_09.prefab:1ca9806eebcb0e841be971e486199833", "TUTORIAL05_ILLIDAN_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 9:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_10_10.prefab:30c0266100fcd714e804006040c241ad", "TUTORIAL05_ILLIDAN_10", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                }
+                break;
+            case 10:
+                if (numTimesRemindedAboutGoal == 0)
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_05_47.prefab:8caf0051fc3c91c48852eed53e886e4b", "TUTORIAL05_JAINA_05", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                else if (numTimesRemindedAboutGoal == 1)
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_06_48.prefab:fbfba7282a8cb334ba40699cab0524fd", "TUTORIAL05_JAINA_06", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                numTimesRemindedAboutGoal++;
+                break;
+            case 12:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return new WaitForSeconds(2f);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B);
+                    AccessibilityMgr.UnblockAllInput();
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE));
+                    string bodyTextGameString = flag ? "TUTORIAL05_HELP_03" : "TUTORIAL05_HELP_04";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL05_HELP_02", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0.5f, 0f), swapMaterial: true);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(flag ? AccessibleSpeech.TUTORIAL05_HELP_03 : AccessibleSpeech.TUTORIAL05_HELP_03);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_01_02.prefab:d4b65ea6366e7a64d8833321001590f1", "TUTORIAL05_ILLIDAN_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    yield return new WaitForSeconds(0.5f);
+                    FadeInHeroActor(jainaActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_01_45.prefab:d5b645ea8a95c0e44a90838ab77b2564", "TUTORIAL05_JAINA_01", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                MulliganManager.Get().BeginMulligan();
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    yield return new WaitForSeconds(2.3f);
+                    FadeOutHeroActor(jainaActor);
+                }
+                break;
+        }
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        NotificationManager.Get().DestroyAllArrows();
+        return true;
+    }
+
+    public override bool NotifyOfTooltipDisplay(TooltipZone specificZone)
+    {
+        return false;
+    }
+
+    public override string[] NotifyOfKeywordHelpPanelDisplay(Entity entity)
+    {
+        if (entity.GetCardId() == "TU4e_004" || entity.GetCardId() == "TU4e_007")
+        {
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL05_WEAPON_HEADLINE"),
+                GameStrings.Get("TUTORIAL05_WEAPON_DESC")
+            };
+        }
+        return null;
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("EX1_277", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs
new file mode 100644
index 0000000..4f2f06e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs
@@ -0,0 +1,328 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_06 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification m_endTurnNotifier;
+
+    private bool m_victory;
+
+    private bool m_choSpeaking;
+
+    private Spell m_choFloatSpell;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_06()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_06_CHO_15_15.prefab:5f0d0a2d3c6884a47aeadcf29b3d802d");
+        PreloadSound("VO_TUTORIAL_06_CHO_09_13.prefab:99a983ceaa6615848a8bea922e428a2d");
+        PreloadSound("VO_TUTORIAL_06_CHO_17_16.prefab:d337628cbe1422e4ca21dbe174ddef2e");
+        PreloadSound("VO_TUTORIAL_06_CHO_05_09.prefab:ef06af76837b9ff4c8ac27ee18516291");
+        PreloadSound("VO_TUTORIAL_06_JAINA_03_51.prefab:06bd40a237dd0674e8d377240de40e65");
+        PreloadSound("VO_TUTORIAL_06_CHO_06_10.prefab:cd28a9685f46936409d5300001540558");
+        PreloadSound("VO_TUTORIAL_06_CHO_21_18.prefab:48c935e7ec96a104ab04d185382898a4");
+        PreloadSound("VO_TUTORIAL_06_CHO_20_17.prefab:dfc795a107caddb42b3d131d6a627fd8");
+        PreloadSound("VO_TUTORIAL_06_CHO_07_11.prefab:b691c4acfee6c5342a727189de686b6d");
+        PreloadSound("VO_TUTORIAL_06_JAINA_04_52.prefab:5d75f42502bc99b4c84704bedf553ba5");
+        PreloadSound("VO_TUTORIAL_06_CHO_04_08.prefab:8164c968ccb1be44d9dfc01c1668b014");
+        PreloadSound("VO_TUTORIAL_06_CHO_12_14.prefab:13ee98fef9d3e6746a69c385c889dc3a");
+        PreloadSound("VO_TUTORIAL_06_CHO_01_05.prefab:10097a4886a24384d8e8f6dd668bb1c7");
+        PreloadSound("VO_TUTORIAL_06_JAINA_01_49.prefab:b9513645100911741b9bda379bc27a75");
+        PreloadSound("VO_TUTORIAL_06_CHO_02_06.prefab:a9c29883676f21d4e932dccc0f92feca");
+        PreloadSound("VO_TUTORIAL_06_JAINA_02_50.prefab:b97fe840305cae04f8486ac1770b126f");
+        PreloadSound("VO_TUTORIAL_06_CHO_03_07.prefab:c71aaff381cdbd346a9bcf54fa5d7db9");
+        PreloadSound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+        PreloadSound("VO_TUTORIAL_06_JAINA_05_53.prefab:6fb71de610db1234887f6d6c948f5174");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        CancelChoFloating();
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            m_victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.CHO_COMPLETE);
+                PlaySound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.CHO_COMPLETE);
+                break;
+        }
+    }
+
+    protected override Spell BlowUpHero(Card card, SpellType spellType)
+    {
+        if (card.GetEntity().GetCardId() != "TU4f_001")
+        {
+            return base.BlowUpHero(card, spellType);
+        }
+        Spell result = card.ActivateActorSpell(SpellType.CHODEATH);
+        Gameplay.Get().StartCoroutine(HideOtherElements(card));
+        return result;
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 2:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_15_15.prefab:5f0d0a2d3c6884a47aeadcf29b3d802d", "TUTORIAL06_CHO_15", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 4:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_09_13.prefab:99a983ceaa6615848a8bea922e428a2d", "TUTORIAL06_CHO_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 15:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    while (m_choSpeaking)
+                    {
+                        yield return null;
+                    }
+                    yield return new WaitForSeconds(0.5f);
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_05_09.prefab:ef06af76837b9ff4c8ac27ee18516291", "TUTORIAL06_CHO_05", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_03_51.prefab:06bd40a237dd0674e8d377240de40e65", "TUTORIAL06_JAINA_03", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_06_10.prefab:cd28a9685f46936409d5300001540558", "TUTORIAL06_CHO_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                }
+                break;
+            case 14:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    while (m_choSpeaking)
+                    {
+                        yield return null;
+                    }
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_21_18.prefab:48c935e7ec96a104ab04d185382898a4", "TUTORIAL06_CHO_21", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                }
+                break;
+            case 16:
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_20_17.prefab:dfc795a107caddb42b3d131d6a627fd8", "TUTORIAL06_CHO_20", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                while (m_choSpeaking)
+                {
+                    yield return null;
+                }
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_17_16.prefab:d337628cbe1422e4ca21dbe174ddef2e", "TUTORIAL06_CHO_17", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 6:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    Card card = GameState.Get().GetOpposingSidePlayer().GetHero()
+                        .GetCard();
+                    m_choFloatSpell = card.GetActorSpell(SpellType.CHOFLOAT);
+                    m_choFloatSpell.ActivateState(SpellStateType.BIRTH);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_07_11.prefab:b691c4acfee6c5342a727189de686b6d", "TUTORIAL06_CHO_07", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_04_52.prefab:5d75f42502bc99b4c84704bedf553ba5", "TUTORIAL06_JAINA_04", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    break;
+                }
+            case 8:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_04_08.prefab:8164c968ccb1be44d9dfc01c1668b014", "TUTORIAL06_CHO_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+            case 9:
+                CancelChoFloating();
+                m_choSpeaking = true;
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_12_14.prefab:13ee98fef9d3e6746a69c385c889dc3a", "TUTORIAL06_CHO_12", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                m_choSpeaking = false;
+                break;
+            case 10:
+                {
+                    Card card2 = FindVoodooDoctorInOpposingSide();
+                    if (!(card2 == null))
+                    {
+                        GameState.Get().SetBusy(busy: true);
+                        yield return new WaitForSeconds(2f);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL06_HELP_03);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_CHO_1);
+                        GameState.Get().SetBusy(busy: false);
+                    }
+                    break;
+                }
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE));
+                    string bodyTextGameString = flag? "TUTORIAL06_HELP_02" : "TUTORIAL06_HELP_04";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL06_HELP_01", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0f, 0.5f));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(flag? AccessibleSpeech.TUTORIAL06_HELP_02 : AccessibleSpeech.TUTORIAL06_HELP_04);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                MulliganManager.Get().BeginMulligan();
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_01_05.prefab:10097a4886a24384d8e8f6dd668bb1c7", "TUTORIAL06_CHO_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                FadeOutHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.5f));
+                FadeInHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_01_49.prefab:b9513645100911741b9bda379bc27a75", "TUTORIAL06_JAINA_01", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                FadeOutHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.5f));
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_02_06.prefab:a9c29883676f21d4e932dccc0f92feca", "TUTORIAL06_CHO_02", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                FadeOutHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.25f));
+                FadeInHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_02_50.prefab:b97fe840305cae04f8486ac1770b126f", "TUTORIAL06_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                FadeOutHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.25f));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_03_07.prefab:c71aaff381cdbd346a9bcf54fa5d7db9", "TUTORIAL06_CHO_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    private void CancelChoFloating()
+    {
+        if (!(m_choFloatSpell == null) && m_choFloatSpell.GetActiveState() != 0)
+        {
+            m_choFloatSpell.ActivateState(SpellStateType.CANCEL);
+        }
+    }
+
+    private Card FindVoodooDoctorInOpposingSide()
+    {
+        foreach (Card card in GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+            .GetCards())
+        {
+            if (card.GetEntity().GetCardId() == "EX1_011")
+            {
+                return card;
+            }
+        }
+        return null;
+    }
+
+    private IEnumerator Wait(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+    }
+
+    public override float GetAdditionalTimeToWaitForSpells()
+    {
+        return 1.5f;
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        for (int i = 0; i < optionsPacket.List.Count; i++)
+        {
+            Network.Options.Option option = optionsPacket.List[i];
+            if (option.Main.PlayErrorInfo.IsValid() && option.Type == Network.Options.Option.OptionType.POWER && GameState.Get().GetEntity(option.Main.ID).GetZone() == TAG_ZONE.PLAY)
+            {
+                if (m_endTurnNotifier != null)
+                {
+                    NotificationManager.Get().DestroyNotificationNowWithNoAnim(m_endTurnNotifier);
+                }
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (m_victory)
+        {
+            PlaySound("VO_TUTORIAL_06_JAINA_05_53.prefab:6fb71de610db1234887f6d6c948f5174");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!m_victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_124", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/AchieveManager.cs b/Decompiled/Assembly-CSharp/AchieveManager.cs
index 0b30ea3..8b41055 100644
--- a/Decompiled/Assembly-CSharp/AchieveManager.cs
+++ b/Decompiled/Assembly-CSharp/AchieveManager.cs
@@ -362,17 +362,26 @@ public class AchieveManager : IService, IHasUpdate
 		return value.IsCompleted();
 	}
 
-	public bool HasUnlockedDefaultHeroes()
-	{
+	public int NumDefaultHeroesUnlocked()
+    {
+		int ret = 0;
+
 		foreach (TAG_CLASS oRDERED_HERO_CLASS in GameUtils.ORDERED_HERO_CLASSES)
-		{
+        {
 			NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(oRDERED_HERO_CLASS);
-			if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
-			{
-				return false;
-			}
-		}
-		return true;
+			if (heroLevel != null && heroLevel.CurrentLevel.Level != 0)
+            {
+                ret++;
+            }
+        }
+
+		return ret;
+    }
+
+	public bool HasUnlockedDefaultHeroes()
+	{
+		// 21.0.0.88998 broke a bunch of stuff around this such as the quest markers
+		return NumDefaultHeroesUnlocked() == GameUtils.ORDERED_HERO_CLASSES.Count();
 	}
 
 	public bool HasUnlockedArena()
@@ -382,7 +391,7 @@ public class AchieveManager : IService, IHasUpdate
 
 	public Achievement GetAchievement(int achieveID)
 	{
-		if (!m_achievements.ContainsKey(achieveID))
+        if (!m_achievements.ContainsKey(achieveID))
 		{
 			return null;
 		}
diff --git a/Decompiled/Assembly-CSharp/Achievement.cs b/Decompiled/Assembly-CSharp/Achievement.cs
index e72e427..76ca010 100644
--- a/Decompiled/Assembly-CSharp/Achievement.cs
+++ b/Decompiled/Assembly-CSharp/Achievement.cs
@@ -646,7 +646,7 @@ public class Achievement
 		}
 	}
 
-	private void SetRewards(List<RewardData> rewardDataList)
+	internal void SetRewards(List<RewardData> rewardDataList)
 	{
 		m_rewards = new List<RewardData>(rewardDataList);
 		FixUpRewardOrigins(m_rewards);
diff --git a/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs b/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
index f63bd61..50c2dc0 100644
--- a/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
@@ -1145,7 +1145,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 			yield return null;
 		}
 		m_adventureBookPageContentsWidget.RemoveEventListener(AdventureNewlyCompletedEventListener);
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateAdventureComplete"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateAdventureComplete"))
 		{
 			bool allPopupsShown = false;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
@@ -1184,7 +1184,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 				yield return null;
 			}
 			m_adventureBookPageContentsWidget.RemoveEventListener(RewardChestAnimEventListener);
-			if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
+			if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
 			{
 				bool allPopupsShown = false;
 				if (AdventureScene.Get().IsDevMode)
diff --git a/Decompiled/Assembly-CSharp/AdventureChooserTray.cs b/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
index 056d0ca..f0bb156 100644
--- a/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
+++ b/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
@@ -50,6 +50,7 @@ public class AdventureChooserTray : AccordionMenuTray
 		AdventureProgressMgr.Get().RegisterProgressUpdatedListener(OnAdventureProgressUpdated);
 		Box.Get().AddTransitionFinishedListener(OnBoxTransitionFinished);
 		StartCoroutine(InitTrayWhenReady());
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureChooserTrayAwake(this);
 	}
 
 	private void Start()
diff --git a/Decompiled/Assembly-CSharp/AdventureConfig.cs b/Decompiled/Assembly-CSharp/AdventureConfig.cs
index c8b0a47..24a4021 100644
--- a/Decompiled/Assembly-CSharp/AdventureConfig.cs
+++ b/Decompiled/Assembly-CSharp/AdventureConfig.cs
@@ -5,6 +5,7 @@ using Hearthstone.DataModels;
 using Hearthstone.DungeonCrawl;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureConfig : MonoBehaviour
@@ -71,7 +72,7 @@ public class AdventureConfig : MonoBehaviour
 
 	private Map<AdventureDbId, AdventureModeDbId> m_ClientChooserAdventureModes = new Map<AdventureDbId, AdventureModeDbId>();
 
-	private AdventureDbId SelectedAdventure
+	internal AdventureDbId SelectedAdventure
 	{
 		get
 		{
@@ -95,7 +96,7 @@ public class AdventureConfig : MonoBehaviour
 		}
 	}
 
-	private AdventureModeDbId SelectedMode
+	internal AdventureModeDbId SelectedMode
 	{
 		get
 		{
@@ -420,6 +421,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void SetSelectedAdventureMode(AdventureDbId adventureId, AdventureModeDbId modeId)
 	{
+		AccessibilityUtils.LogDebug($"SetSelectedAdventureMode({adventureId}, {modeId})");
 		SelectedAdventure = adventureId;
 		SelectedMode = modeId;
 		m_ClientChooserAdventureModes[adventureId] = modeId;
@@ -663,6 +665,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void ChangeSubScene(AdventureData.Adventuresubscene subscene, bool pushToBackStack = true)
 	{
+		AccessibilityUtils.LogDebug($"ChangeSubScene({subscene})");
 		if (subscene == m_CurrentSubScene)
 		{
 			Debug.Log($"Sub scene {subscene} is already set.");
@@ -999,9 +1002,10 @@ public class AdventureConfig : MonoBehaviour
 
 	public void OnAdventureSceneAwake()
 	{
-		SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
-		SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
-		if (!ShouldDisplayAdventure(SelectedAdventure))
+        SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
+        SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
+
+        if (!ShouldDisplayAdventure(SelectedAdventure))
 		{
 			SelectedAdventure = AdventureDbId.PRACTICE;
 			SelectedMode = AdventureModeDbId.LINEAR;
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
index 2c68893..5c62a57 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
@@ -5,7 +5,7 @@ public class AdventureDungeonCrawlDeckTray : BasePhoneDeckTray
 {
 	public PlayMakerFSM DeckTrayGlow;
 
-	private CollectionDeck m_deck;
+	internal CollectionDeck m_deck;
 
 	protected override void Awake()
 	{
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
index 26376ac..d1b1d03 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
@@ -9,9 +9,10 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class AdventureDungeonCrawlDisplay : MonoBehaviour
+public class AdventureDungeonCrawlDisplay : MonoBehaviour, AccessibleScreen
 {
 	[Serializable]
 	public class DungeonCrawlDisplayStyleOverride
@@ -294,15 +295,15 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		m_subsceneController.TransitionComplete += OnSubSceneTransitionComplete;
 		AdventureDbId selectedAdv = m_dungeonCrawlData.GetSelectedAdventure();
 		AdventureModeDbId selectedMode = m_dungeonCrawlData.GetSelectedMode();
-		AdventureDataDbfRecord adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
+		m_adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
 		m_playerHeroData = new PlayerHeroData(m_dungeonCrawlData);
 		m_playerHeroData.OnHeroDataChanged += delegate
 		{
 			m_playMat.SetPlayerHeroDbId(m_playerHeroData.HeroDbId);
 		};
-		m_AdventureTitle.Text = adventureDataRecord.Name;
-		m_gameSaveDataServerKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataServerKey;
-		m_gameSaveDataClientKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataClientKey;
+		m_AdventureTitle.Text = m_adventureDataRecord.Name;
+		m_gameSaveDataServerKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataServerKey;
+		m_gameSaveDataClientKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataClientKey;
 		if (m_gameSaveDataServerKey <= (GameSaveKeyId)0)
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has no GameSaveDataKey set! This mode does not work without defining GAME_SAVE_DATA_SERVER_KEY in ADVENTURE.dbi!", selectedAdv, selectedMode);
@@ -315,7 +316,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has an equal GameSaveDataKey for Client and Server. These keys are not allowed to be equal!", selectedAdv, selectedMode);
 		}
-		m_bossCardBackId = adventureDataRecord.BossCardBack;
+		m_bossCardBackId = m_adventureDataRecord.BossCardBack;
 		if (m_bossCardBackId == 0)
 		{
 			m_bossCardBackId = 0;
@@ -347,13 +348,13 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 				Log.Adventures.Print("Owns wing for this Dungeon Run? {0}", AdventureProgressMgr.Get().OwnsWing(scenarioDbfRecord2.WingId));
 			}
 		}
-		m_shouldSkipHeroSelect = adventureDataRecord.DungeonCrawlSkipHeroSelect;
-		m_mustPickShrine = adventureDataRecord.DungeonCrawlMustPickShrine;
-		m_mustSelectChapter = adventureDataRecord.DungeonCrawlSelectChapter;
-		m_anomalyModeCardDbId = adventureDataRecord.AnomalyModeDefaultCardId;
+		m_shouldSkipHeroSelect = m_adventureDataRecord.DungeonCrawlSkipHeroSelect;
+		m_mustPickShrine = m_adventureDataRecord.DungeonCrawlMustPickShrine;
+		m_mustSelectChapter = m_adventureDataRecord.DungeonCrawlSelectChapter;
+		m_anomalyModeCardDbId = m_adventureDataRecord.AnomalyModeDefaultCardId;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_dungeonCrawlPlayMatReference.RegisterReadyListener<AdventureDungeonCrawlPlayMat>(OnPlayMatReady);
-		bool retireButtonSupported = adventureDataRecord.DungeonCrawlIsRetireSupported;
+		bool retireButtonSupported = m_adventureDataRecord.DungeonCrawlIsRetireSupported;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_retireButtonReference.RegisterReadyListener(delegate(Widget w)
 		{
@@ -361,24 +362,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			{
 				if (eventName == "Button_Framed_Clicked" && retireButtonSupported)
 				{
-					m_retireButton.SetActive(value: false);
-					AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
-					{
-						m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
-						m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
-						m_showAlertIcon = true,
-						m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
-						m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
-					};
-					if (m_isPVPDR)
-					{
-						popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
-					}
-					else
-					{
-						popupInfo.m_responseCallback = OnRetirePopupResponse;
-					}
-					DialogManager.Get().ShowPopup(popupInfo);
+					RetireFromAdventure();
 				}
 			});
 			m_retireButton = w.gameObject;
@@ -415,7 +399,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		SetDungeonCrawlDisplayVisualStyle();
 	}
 
-	public void EnablePlayButton()
+    public void EnablePlayButton()
 	{
 		if (m_playMat != null)
 		{
@@ -1098,6 +1082,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			m_retireButton.SetActive(adventureDataRecord.DungeonCrawlIsRetireSupported);
 		}
 		m_assetLoadingHelper.AssetLoadCompleted();
+		ReadScreen();
 	}
 
 	private void OnPlayMatPaperControllerReady(VisualController paperController)
@@ -3129,4 +3114,228 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		Navigation.PopBlockBackingOut();
 		Navigation.GoBack();
 	}
+
+	#region Accessibility
+
+	private enum AccessibleState { WAITING, IS_VO_PLAYING, READING_PLAY_MENU, READING_DECK, RUN_COMPLETED };
+
+	private AccessibleState m_curAccessibleState;
+
+	private AccessibleState m_stateAfterVO;
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleDeckTray;
+
+	private AdventureDataDbfRecord m_adventureDataRecord;
+
+	private void ReadScreen()
+    {
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+		AccessibilityMgr.SetScreen(this);
+
+		if (ShouldShowRunCompletedScreen())
+        {
+			ReadCompletedScreen();
+        }
+		else
+        {
+            ReadPlayMenu(); // TODO: Figure out a cleanway to delay this until VO plays that doesn't require refactoring playMat..
+        }
+    }
+
+    private void ReadCompletedScreen()
+    {
+		m_curAccessibleState = AccessibleState.RUN_COMPLETED;
+		m_stateAfterVO = AccessibleState.RUN_COMPLETED;
+
+		AccessibilityMgr.Output(this, GetAdventureCompleteSpeech());
+    }
+
+	private string GetAdventureCompleteSpeech()
+    {
+		var text = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE);
+		return AccessibleSpeechUtils.CombineSentences(text, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_FINISH, AccessibleKey.CONFIRM));
+    }
+
+    private void ReadPlayMenu()
+    {
+		m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+		m_stateAfterVO = AccessibleState.READING_PLAY_MENU;
+
+		var numDefeatedBosses = m_playMat.m_numBossesDefeated;
+		var numBossesInRun = m_playMat.m_bossesPerRun;
+
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE, numDefeatedBosses + 1, numBossesInRun));
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE), () => m_BackButton.TriggerRelease());
+
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION), () => m_playMat.ClickPlayButton());
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION), ReadDeck);
+
+        if (m_adventureDataRecord.DungeonCrawlIsRetireSupported)
+        {
+			m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION), () => RetireFromAdventure());
+        }
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void ReadDeck()
+	{
+		if (m_dungeonCrawlDeckTray == null || m_dungeonCrawlDeckTray.m_deck == null || m_dungeonCrawlDeckTray.m_deck.GetCards().Count == 0)
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK));
+			return;
+		}
+
+		m_curAccessibleState = AccessibleState.READING_DECK;
+
+		var cards = m_dungeonCrawlDeck.GetDeckContents();
+
+		var accessibleCards = new List<AccessibleCollectibleCard>(cards.Cards.Count);
+
+		foreach (var card in cards.Cards)
+        {
+			var cardDbId = card.Def.Asset;
+			var cardId = GameUtils.TranslateDbIdToCardId(cardDbId);
+			var cardQty = card.Qty;
+			var entityDef = DefLoader.Get().GetEntityDef(cardId);
+			var cardRecord = GameUtils.GetCardRecord(cardId);
+			var collectibleCard = new CollectibleCard(cardRecord, entityDef, TAG_PREMIUM.NORMAL);
+			collectibleCard.OwnedCount = cardQty;
+			var accessibleCollectibleCard = new AccessibleCollectibleCard(this, collectibleCard, true);
+
+			accessibleCards.Add(accessibleCollectibleCard);
+        }
+
+		m_accessibleDeckTray = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+		m_accessibleDeckTray.StartReading();
+    }
+
+    private bool SupportedAdventure()
+    {
+		return m_dungeonCrawlData.GetSelectedAdventure() == AdventureDbId.BOH;
+    }
+
+    public void HandleInput()
+    {
+		// Wait for VO to finish
+		if (NotificationManager.Get().IsQuotePlaying)
+        {
+			m_curAccessibleState = AccessibleState.IS_VO_PLAYING;
+
+			if (AccessibleKey.SKIP_NOTIFICATION.IsPressed())
+            {
+				NotificationManager.Get().m_quote.clickOff?.TriggerPress();
+            }
+			return;
+        }
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+        {
+			if (m_stateAfterVO == AccessibleState.RUN_COMPLETED)
+            {
+				ReadCompletedScreen();
+            }
+			else
+            {
+                // Repeat menu
+                ReadPlayMenu();
+            }
+
+            return;
+        }
+
+		// Normal flow
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+            m_accessibleMenu.HandleAccessibleInput();
+        }
+		else if (m_curAccessibleState == AccessibleState.READING_DECK)
+        {
+			if (AccessibleKey.BACK.IsPressed())
+            {
+				m_accessibleMenu.StartReading();
+				m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+            }
+			else
+            {
+				m_accessibleDeckTray.HandleAccessibleInput();
+
+				var curCardIdx = m_accessibleDeckTray.GetItemBeingReadIndex();
+				var cardTiles = m_dungeonCrawlDeckTray.GetCardsContent().GetCardTiles();
+				AccessibleInputMgr.MoveMouseTo(cardTiles[curCardIdx]);
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_BackButton.TriggerRelease();
+            }
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+			return m_accessibleMenu.GetHelp();
+        }
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+        {
+			return GetAdventureCompleteSpeech();
+        }
+        else if (m_curAccessibleState == AccessibleState.READING_DECK)
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP);
+			return AccessibleSpeechUtils.CombineSentences(helpText, AccessibleSpeech.PRESS_BACK_ONCE_DONE);
+        }
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+        {
+			return LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP);
+        }
+
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+			m_accessibleMenu.StartReading();
+        }
+		else
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_TITLE));
+        }
+    }
+
+    private void RetireFromAdventure()
+    {
+        m_retireButton.SetActive(value: false);
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
+        {
+            m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
+            m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
+            m_showAlertIcon = true,
+            m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
+            m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
+        };
+        if (m_isPVPDR)
+        {
+            popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
+        }
+        else
+        {
+            popupInfo.m_responseCallback = OnRetirePopupResponse;
+        }
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
index ae331d3..3ed71b5 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
@@ -7,6 +7,7 @@ using Hearthstone.DungeonCrawl;
 using Hearthstone.Progression;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureDungeonCrawlPlayMat : MonoBehaviour
@@ -266,9 +267,9 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 
 	private OptionType m_currentOptionType;
 
-	private int m_numBossesDefeated;
+	internal int m_numBossesDefeated;
 
-	private int m_bossesPerRun;
+	internal int m_bossesPerRun;
 
 	private bool m_allowPlayButtonAnimation;
 
@@ -1112,10 +1113,13 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 		}
 		if ((!(m_bossHeroPowerTooltip != null) || m_bossHeroPowerTooltip.IsDying()) && m_shouldShowBossHeroPowerTooltip)
 		{
-			m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
-			m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
-			m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
-		}
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
+                m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
+                m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
+            }
+        }
 	}
 
 	public void HideBossHeroPowerTooltip(bool immediate = false)
@@ -1890,4 +1894,13 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 			}
 		}
 	}
+
+    #region Accessibility
+
+    internal void ClickPlayButton()
+    {
+		m_playButton.TriggerRelease();
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs b/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
index 080cec8..419b3fb 100644
--- a/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
@@ -885,7 +885,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 				wingIds.Add((int)item2.GetWingId());
 			}
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			m_WaitingForClassChallengeUnlocks = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
diff --git a/Decompiled/Assembly-CSharp/AdventureScene.cs b/Decompiled/Assembly-CSharp/AdventureScene.cs
index 4c21e7c..ce52a6c 100644
--- a/Decompiled/Assembly-CSharp/AdventureScene.cs
+++ b/Decompiled/Assembly-CSharp/AdventureScene.cs
@@ -133,6 +133,7 @@ public class AdventureScene : PegasusScene
 		adventureConfig.AddSelectedModeChangeListener(OnSelectedModeChanged);
 		adventureConfig.AddAdventureModeChangeListener(OnAdventureModeChanged);
 		adventureConfig.AddAdventureMissionSetListener(OnAdventureMissionChanged);
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureSceneShown();
 		m_StartupAssetLoads++;
 		SetCurrentTransitionDirection();
 		if (HearthstoneApplication.IsInternal())
@@ -318,7 +319,7 @@ public class AdventureScene : PegasusScene
 					runCallback((string)subSceneDef.m_Prefab, widgetInstance.Widget.gameObject, callbackData);
 				}
 				UpdateAdventureModeMusic();
-				m_isLoading = false;
+				DoneLoading(subscene);
 			});
 			return;
 		}
@@ -330,11 +331,12 @@ public class AdventureScene : PegasusScene
 				runCallback(assetRef, go, data);
 			}
 			UpdateAdventureModeMusic();
-			m_isLoading = false;
+			DoneLoading(subscene);
 		}, callbackData, AssetLoadingOptions.IgnorePrefabPosition);
 	}
 
-	private void OnSubSceneChange(AdventureData.Adventuresubscene newscene, bool forward)
+
+    private void OnSubSceneChange(AdventureData.Adventuresubscene newscene, bool forward)
 	{
 		m_transitionIsGoingBack = !forward;
 		LoadSubScene(newscene);
@@ -599,7 +601,9 @@ public class AdventureScene : PegasusScene
 
 	private void ShowExpertAIUnlockTip()
 	{
-		if (AchieveManager.Get().HasUnlockedDefaultHeroes() && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("AdventureScene.ShowExpertAIUnlockTip"))
+		// vvv This is broken since Blizzard's 21.0.0.88998 patch
+		//if (NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>().Levels.Count <= 0 && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "AdventureScene.ShowExpertAIUnlockTip"))
+		if (AchieveManager.Get().HasUnlockedDefaultHeroes() && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "AdventureScene.ShowExpertAIUnlockTip"))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_EXPERT_AI_10"), "VO_INNKEEPER_EXPERT_AI_10.prefab:7979b1ca6d60f7b448686a248246542d");
 			Options.Get().SetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, val: true);
@@ -668,4 +672,12 @@ public class AdventureScene : PegasusScene
 			m_CurrentTransitionDirection = m_TransitionDirection;
 		}
 	}
+
+    #region Accessibility
+    private void DoneLoading(AdventureData.Adventuresubscene subscene)
+    {
+        m_isLoading = false;
+		Accessibility.AccessibleAdventureScene.Get().OnSubSceneLoaded(subscene);
+    }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs b/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
index f673f12..8eff520 100644
--- a/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
+++ b/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
@@ -348,7 +348,7 @@ public class AdventureWingFrozenThroneHelper : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			waitingForNextStep = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
diff --git a/Decompiled/Assembly-CSharp/AlertPopup.cs b/Decompiled/Assembly-CSharp/AlertPopup.cs
index 3654f34..7bb2e0a 100644
--- a/Decompiled/Assembly-CSharp/AlertPopup.cs
+++ b/Decompiled/Assembly-CSharp/AlertPopup.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using Blizzard.T5.AssetManager;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AlertPopup : DialogBase
@@ -29,7 +30,8 @@ public class AlertPopup : DialogBase
 		OK,
 		CONFIRM,
 		CANCEL,
-		CONFIRM_CANCEL
+		CONFIRM_CANCEL,
+		EOE
 	}
 
 	public delegate void ResponseCallback(Response response, object userData);
@@ -236,6 +238,8 @@ public class AlertPopup : DialogBase
 		DoShowAnimation();
 		bool systemDialogActive = m_popupInfo == null || !m_popupInfo.m_layerToUse.HasValue || m_popupInfo.m_layerToUse.Value == GameLayer.UI || m_popupInfo.m_layerToUse.Value == GameLayer.HighPriorityUI;
 		UniversalInputManager.Get().SetSystemDialogActive(systemDialogActive);
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -467,4 +471,59 @@ public class AlertPopup : DialogBase
 			m_header.m_container.UpdateSlices();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadPopup()
+    {
+        AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_ALERT_POPUP_TITLE), true);
+
+		m_accessibleMenu = new AccessibleMenu(this, m_alertText.Text, null);
+
+		switch (m_popupInfo.m_responseDisplay)
+		{
+            case ResponseDisplay.OK:
+				AddAccessibleOption(m_accessibleMenu, m_okayButton);
+                break;
+            case ResponseDisplay.CONFIRM:
+				AddAccessibleOption(m_accessibleMenu, m_confirmButton);
+                break;
+            case ResponseDisplay.CANCEL:
+				AddAccessibleOption(m_accessibleMenu, m_cancelButton);
+                break;
+            case ResponseDisplay.CONFIRM_CANCEL:
+				AddAccessibleOption(m_accessibleMenu, m_confirmButton);
+				AddAccessibleOption(m_accessibleMenu, m_cancelButton);
+                break;
+			default:
+				break;
+        }
+
+		if (m_header?.m_text?.Text != null)
+        {
+			AccessibilityMgr.Output(this, m_header.m_text.Text);
+        }
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void AddAccessibleOption(AccessibleMenu menu, UIBButton button)
+    {
+        menu.AddOption(button.GetText(), () => button.TriggerRelease());
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs b/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
index b81211e..3f68585 100644
--- a/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
+++ b/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.Streaming;
 
-public class AssetDownloadDialog : DialogBase
+public class AssetDownloadDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/Assets/AdventureData.cs b/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
index 0680bff..42d9a16 100644
--- a/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
+++ b/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
@@ -25,7 +25,9 @@ namespace Assets
 			[Description("Bonus_Challenge")]
 			BONUS_CHALLENGE,
 			[Description("Location_Select")]
-			LOCATION_SELECT
+			LOCATION_SELECT,
+			[Description("EOE")]
+			EOE
 		}
 
 		public enum Adventurebooklocation
diff --git a/Decompiled/Assembly-CSharp/Assets/Global.cs b/Decompiled/Assembly-CSharp/Assets/Global.cs
index 6d280b8..3123bbe 100644
--- a/Decompiled/Assembly-CSharp/Assets/Global.cs
+++ b/Decompiled/Assembly-CSharp/Assets/Global.cs
@@ -299,7 +299,8 @@ namespace Assets
 			GAMEPLAY,
 			TUTORIAL,
 			PRESENCE,
-			MISSION
+			MISSION,
+			ACCESSIBILITY
 		}
 
 		public enum MercenariesPremium
diff --git a/Decompiled/Assembly-CSharp/Assets/QuestPool.cs b/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
index 004674a..4a545a2 100644
--- a/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
+++ b/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
@@ -11,7 +11,9 @@ namespace Assets
 			[Description("daily")]
 			DAILY,
 			[Description("weekly")]
-			WEEKLY
+			WEEKLY,
+			[Description("eoe")]
+			EOE
 		}
 
 		public static QuestPoolType ParseQuestPoolTypeValue(string value)
diff --git a/Decompiled/Assembly-CSharp/AttackSpellController.cs b/Decompiled/Assembly-CSharp/AttackSpellController.cs
index 0f2eb12..6d400a0 100644
--- a/Decompiled/Assembly-CSharp/AttackSpellController.cs
+++ b/Decompiled/Assembly-CSharp/AttackSpellController.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class AttackSpellController : SpellController
 {
@@ -31,6 +32,8 @@ public class AttackSpellController : SpellController
 
 	private bool m_repeatProposed;
 
+	private AccessibleAttackSpellController m_accController;
+
 	protected override bool AddPowerSourceAndTargets(PowerTaskList taskList)
 	{
 		m_attackType = taskList.GetAttackType();
@@ -49,6 +52,7 @@ public class AttackSpellController : SpellController
 		{
 			AddTarget(defender.GetCard());
 		}
+		m_accController = new AccessibleAttackSpellController(taskList);
 		return true;
 	}
 
@@ -144,6 +148,7 @@ public class AttackSpellController : SpellController
 
 	private void LaunchAttack()
 	{
+		m_accController.OnLaunchAttack();
 		Card source = GetSource();
 		Entity entity = source.GetEntity();
 		Card target = GetTarget();
diff --git a/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs b/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
index f83ef84..5caa31d 100644
--- a/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
+++ b/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
@@ -85,7 +85,7 @@ public class BaconCollectionDisplay : CollectibleDisplay
 
 	protected override void OnDestroy()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/BannerPopup.cs b/Decompiled/Assembly-CSharp/BannerPopup.cs
index a8610a3..12f16e7 100644
--- a/Decompiled/Assembly-CSharp/BannerPopup.cs
+++ b/Decompiled/Assembly-CSharp/BannerPopup.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class BannerPopup : MonoBehaviour
+public class BannerPopup : MonoBehaviour, AccessibleUI
 {
 	public GameObject m_root;
 
@@ -55,6 +56,8 @@ public class BannerPopup : MonoBehaviour
 				m_onCloseBannerPopup();
 			}
 		}
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public void Show(string headerText, string bannerText, BannerManager.DelOnCloseBanner onCloseCallback = null)
@@ -89,6 +92,8 @@ public class BannerPopup : MonoBehaviour
 			m_dismissButton.AddEventListener(UIEventType.RELEASE, CloseBannerPopup);
 		}
 		m_showSpellComplete = false;
+
+		ReadPopup();
 	}
 
 	private void FadeEffectsIn()
@@ -185,4 +190,46 @@ public class BannerPopup : MonoBehaviour
 			m_HideSpell.Activate();
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+		if (m_header != null && m_header.Text != null)
+		{
+			AccessibilityMgr.Output(this, m_header.Text);
+		}
+
+		if (m_text != null && m_text.Text != null)
+		{
+			AccessibilityMgr.Output(this, m_text.Text);
+		}
+
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (m_dismissButton != null)
+            {
+                m_dismissButton?.TriggerRelease();
+            }
+			else
+            {
+				AccessibleInputMgr.ClickCenterOfScreen();
+            }
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BasicPopup.cs b/Decompiled/Assembly-CSharp/BasicPopup.cs
index 8a8d3a7..6a89030 100644
--- a/Decompiled/Assembly-CSharp/BasicPopup.cs
+++ b/Decompiled/Assembly-CSharp/BasicPopup.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections.Generic;
 using UnityEngine;
 
@@ -27,6 +28,13 @@ public class BasicPopup : DialogBase
 		public bool m_disableBnetBar;
 
 		public bool m_blurWhenShown;
+
+		public string m_accessibleText;
+
+		public PopupInfo(string accessibleText)
+        {
+			m_accessibleText = accessibleText;
+        }
 	}
 
 	public UIBButton m_cancelButton;
@@ -45,6 +53,10 @@ public class BasicPopup : DialogBase
 
 	protected PopupInfo m_popupInfo;
 
+	#region Accessibility
+	private string m_accessibleText;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -101,6 +113,8 @@ public class BasicPopup : DialogBase
 		{
 			SoundManager.Get().LoadAndPlay(m_showAnimationSound);
 		}
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -126,7 +140,7 @@ public class BasicPopup : DialogBase
 	{
 		if (m_popupInfo == null)
 		{
-			m_popupInfo = new PopupInfo();
+			m_popupInfo = new PopupInfo(LocalizationUtils.Get(LocalizationKey.UI_UNKNOWN_POPUP));
 		}
 		if (m_headerText != null && m_popupInfo.m_headerText != null)
 		{
@@ -136,6 +150,8 @@ public class BasicPopup : DialogBase
 		{
 			m_bodyText.Text = m_popupInfo.m_bodyText;
 		}
+
+		m_accessibleText = m_popupInfo.m_accessibleText;
 	}
 
 	private void ButtonPress(Response response)
@@ -146,4 +162,41 @@ public class BasicPopup : DialogBase
 		}
 		Hide();
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    protected void ReadPopup()
+    {
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_customButton != null)
+        {
+			m_accessibleMenu.AddOption(m_customButton.GetText(), () => m_customButton.TriggerRelease());
+        }
+
+		if (m_cancelButton != null)
+        {
+			m_accessibleMenu.AddOption(m_cancelButton.GetText(), () => m_cancelButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, m_accessibleText);
+
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BigCard.cs b/Decompiled/Assembly-CSharp/BigCard.cs
index b7889e1..74e0b46 100644
--- a/Decompiled/Assembly-CSharp/BigCard.cs
+++ b/Decompiled/Assembly-CSharp/BigCard.cs
@@ -106,7 +106,7 @@ public class BigCard : MonoBehaviour
 
 	private Vector3 m_initialBannerTextScale;
 
-	private Pool<BigCardEnchantmentPanel> m_enchantmentPool = new Pool<BigCardEnchantmentPanel>();
+	internal Pool<BigCardEnchantmentPanel> m_enchantmentPool = new Pool<BigCardEnchantmentPanel>();
 
 	private Map<string, BigCardEnchantmentPanel> m_uniqueEnchantmentLookup = new Map<string, BigCardEnchantmentPanel>();
 
diff --git a/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs b/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs
index bebf08d..f8fd035 100644
--- a/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Guldan_01.cs
@@ -52,8 +52,6 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -259,46 +257,13 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals();
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -307,31 +272,4 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_GULDAN_01", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs b/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs
index c6026b4..6417ac0 100644
--- a/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Guldan_06.cs
@@ -56,8 +56,6 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -266,46 +264,13 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals();
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -314,31 +279,4 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_GULDAN_01", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs b/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs
index 0efae65..2c4f170 100644
--- a/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Illidan_08.cs
@@ -80,8 +80,6 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -196,7 +194,7 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 			yield return MissionPlayVOOnce(enemyActor, m_InGame_BossUsesHeroPowerLines);
 			break;
 		case 105:
-			InitVisuals();
+			InitTurnCounterVisuals();
 			GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 			Gameplay.Get().GetNameBannerForSide(Player.Side.OPPOSING).UpdateHeroNameBanner();
 			break;
@@ -344,43 +342,10 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 		}
 	}
 
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
-	}
-
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = false;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = true;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -389,31 +354,4 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_ILLIDAN_08", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs b/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
index 6dc59e8..b863557 100644
--- a/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 {
@@ -296,7 +297,7 @@ public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 		switch (turn)
 		{
 		case 1:
-			yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
+            yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
 			yield return PlayLineAlways(enemyActor, VO_Story_Hero_Garrosh_Male_Orc_Story_Jaina_Mission6ExchangeA_01);
 			break;
 		case 5:
diff --git a/Decompiled/Assembly-CSharp/BoH_Uther_08.cs b/Decompiled/Assembly-CSharp/BoH_Uther_08.cs
index 03a8744..5656764 100644
--- a/Decompiled/Assembly-CSharp/BoH_Uther_08.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Uther_08.cs
@@ -46,8 +46,6 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -228,46 +226,13 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals();
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		GAME_TAG tag = (GAME_TAG)change.tag;
-		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -277,33 +242,6 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
 
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_UTHER_08", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
-
 	public override void StartGameplaySoundtracks()
 	{
 		MusicManager.Get().StartPlaylist(MusicPlaylistType.InGame_ICCLichKing);
diff --git a/Decompiled/Assembly-CSharp/Board.cs b/Decompiled/Assembly-CSharp/Board.cs
index 10baeb6..b93d040 100644
--- a/Decompiled/Assembly-CSharp/Board.cs
+++ b/Decompiled/Assembly-CSharp/Board.cs
@@ -256,6 +256,11 @@ public class Board : MonoBehaviour
 		return Gameplay.Get().GetBoardLayout().FindCollider(name);
 	}
 
+	public Collider GetTradeArea()
+	{
+		return FindCollider("TradeArea");
+	}
+
 	public GameObject GetMouseClickDustEffectPrefab()
 	{
 		return m_MouseClickDustEffect;
diff --git a/Decompiled/Assembly-CSharp/BookTab.cs b/Decompiled/Assembly-CSharp/BookTab.cs
index a39c1b9..8143436 100644
--- a/Decompiled/Assembly-CSharp/BookTab.cs
+++ b/Decompiled/Assembly-CSharp/BookTab.cs
@@ -92,6 +92,11 @@ public class BookTab : PegUIElement
 		return m_isVisible;
 	}
 
+	public bool IsSelected()
+	{
+		return m_selected;
+	}
+
 	public void SetTargetVisibility(bool visible)
 	{
 		m_shouldBeVisible = visible;
diff --git a/Decompiled/Assembly-CSharp/Box.cs b/Decompiled/Assembly-CSharp/Box.cs
index a0e79fa..8480e29 100644
--- a/Decompiled/Assembly-CSharp/Box.cs
+++ b/Decompiled/Assembly-CSharp/Box.cs
@@ -6,6 +6,7 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class Box : MonoBehaviour
@@ -1100,7 +1101,7 @@ public class Box : MonoBehaviour
 		else if (mode == SceneMgr.Mode.TOURNAMENT && flag)
 		{
 			ChangeState(State.SET_ROTATION_OPEN);
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 			m_transitioningToSceneMode = true;
 		}
 		else if (!SceneMgr.Get().IsDoingSceneDrivenTransition() && ChangeState(state))
@@ -1850,7 +1851,8 @@ public class Box : MonoBehaviour
 			m_setRotationDisk.SetActive(value: true);
 			return;
 		}
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var popupText = AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_HEADER), LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_SUBHEADER));
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_prefabAssetRefs.Add("CoreSetIntroPopup.prefab:32fcd0d9c45bc9449af825460fac647b");
 		DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
@@ -1914,7 +1916,7 @@ public class Box : MonoBehaviour
 	private IEnumerator SetRotation_StartSetRotationIntro()
 	{
 		ResetSetRotationPopupProgress();
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.SET_ROTATION_INTRO);
 		NotificationManager.Get().DestroyAllPopUps();
 		PopupDisplayManager.Get().ReadyToShowPopups();
 		yield return StartCoroutine(PopupDisplayManager.Get().WaitForAllPopups());
diff --git a/Decompiled/Assembly-CSharp/ButtonListMenu.cs b/Decompiled/Assembly-CSharp/ButtonListMenu.cs
index 802a573..e462f80 100644
--- a/Decompiled/Assembly-CSharp/ButtonListMenu.cs
+++ b/Decompiled/Assembly-CSharp/ButtonListMenu.cs
@@ -9,7 +9,7 @@ public abstract class ButtonListMenu : MonoBehaviour
 
 	private bool m_isShown;
 
-	private List<UIBButton> m_allButtons = new List<UIBButton>();
+	protected List<UIBButton> m_allButtons = new List<UIBButton>();
 
 	private List<GameObject> m_horizontalDividers = new List<GameObject>();
 
diff --git a/Decompiled/Assembly-CSharp/Card.cs b/Decompiled/Assembly-CSharp/Card.cs
index e0e7f5e..1866655 100644
--- a/Decompiled/Assembly-CSharp/Card.cs
+++ b/Decompiled/Assembly-CSharp/Card.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Hearthstone;
 using PegasusGame;
 using UnityEngine;
@@ -5211,6 +5212,7 @@ public class Card : MonoBehaviour
 		m_actor.TurnOffCollider();
 		GameState.Get().GetFriendlySidePlayer().GetDeckZone()
 			.UpdateLayout();
+		AccessibleGameplay.Get().OnDrawCard(this);
 		while (iTween.Count(base.gameObject) > 0)
 		{
 			yield return null;
@@ -5288,6 +5290,7 @@ public class Card : MonoBehaviour
 	private IEnumerator DrawUnknownOpponentCard(ZoneHand handZone)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_and_add_to_hand_opp_1.prefab:5a05fbb2c5833a94182e1b454647d5c8", base.gameObject);
+		AccessibleGameplay.Get().OnDrawUnknownOpponentCard(this);
 		base.gameObject.transform.rotation = IN_DECK_HIDDEN_ROTATION;
 		DetermineIfOverrideDrawTimeScale();
 		Transform transform = Board.Get().FindBone("OpponentDrawCard");
@@ -5365,6 +5368,7 @@ public class Card : MonoBehaviour
 	private IEnumerator RevealDrawnOpponentCard(string handActorPath, Actor handActor, ZoneHand handZone)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_1.prefab:19dd221ebfed9754e85ef1f104e0fddb", base.gameObject);
+		AccessibleGameplay.Get().OnRevealDrawnOpponentCard(this);
 		handActor.transform.parent = m_actor.transform.parent;
 		TransformUtil.CopyLocal(handActor, m_actor);
 		m_actor.Hide();
@@ -6079,6 +6083,7 @@ public class Card : MonoBehaviour
 	public IEnumerator AnimatePlayToDeck(GameObject mover, ZoneDeck deckZone, bool hideBackSide = false, float timeScale = 1f)
 	{
 		SoundManager.Get().LoadAndPlay("MinionToDeck_transition.prefab:8063f1b133f28e34aaeade8fcabe250c");
+		AccessibleGameplay.Get().OnCardToDeck(this);
 		Vector3 vector = deckZone.GetThicknessForLayout().GetMeshRenderer().bounds.center + IN_DECK_OFFSET;
 		Vector3 vector2 = vector + ABOVE_DECK_OFFSET;
 		Vector3 vector3 = new Vector3(0f, IN_DECK_ANGLES.y, 0f);
@@ -6776,7 +6781,7 @@ public class Card : MonoBehaviour
 		{
 			return false;
 		}
-		Collider collider = Board.Get().FindCollider("TradeArea");
+		Collider collider = Board.Get().GetTradeArea();
 		if (collider == null)
 		{
 			return false;
diff --git a/Decompiled/Assembly-CSharp/CardListPanel.cs b/Decompiled/Assembly-CSharp/CardListPanel.cs
index 2670877..b20f23f 100644
--- a/Decompiled/Assembly-CSharp/CardListPanel.cs
+++ b/Decompiled/Assembly-CSharp/CardListPanel.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CardListPanel : MonoBehaviour
@@ -18,11 +19,11 @@ public class CardListPanel : MonoBehaviour
 
 	private UIBButton m_rightArrow;
 
-	private const int MAX_CARDS_PER_PAGE = 3;
+	internal const int MAX_CARDS_PER_PAGE = 3;
 
 	private int m_numPages = 1;
 
-	private int m_pageNum;
+	internal int m_pageNum;
 
 	private List<CollectibleCard> m_cards = new List<CollectibleCard>();
 
@@ -55,7 +56,7 @@ public class CardListPanel : MonoBehaviour
 			m_cards = cards;
 		}
 		SetupPagingArrows();
-		m_numPages = (m_cards.Count + 3 - 1) / 3;
+		m_numPages = (m_cards.Count + MAX_CARDS_PER_PAGE - 1) / MAX_CARDS_PER_PAGE;
 		ShowPage(0);
 	}
 
@@ -90,8 +91,8 @@ public class CardListPanel : MonoBehaviour
 		}
 		m_cardActors.Clear();
 		list.Clear();
-		int num = m_pageNum * 3;
-		int num2 = Mathf.Min(3, m_cards.Count - num);
+		int num = m_pageNum * MAX_CARDS_PER_PAGE;
+		int num2 = Mathf.Min(MAX_CARDS_PER_PAGE, m_cards.Count - num);
 		for (int i = 0; i < num2; i++)
 		{
 			CollectibleCard collectibleCard = m_cards[num + i];
@@ -154,7 +155,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void UpdateCardPositions()
+    private void UpdateCardPositions()
 	{
 		int count = m_cardActors.Count;
 		for (int i = 0; i < count; i++)
@@ -169,7 +170,7 @@ public class CardListPanel : MonoBehaviour
 
 	private void SetupPagingArrows()
 	{
-		if (m_cards.Count > 3)
+		if (m_cards.Count > MAX_CARDS_PER_PAGE)
 		{
 			m_leftArrowNested.gameObject.SetActive(value: true);
 			m_rightArrowNested.gameObject.SetActive(value: true);
@@ -200,7 +201,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void TurnPage(bool right)
+	internal void TurnPage(bool right)
 	{
 		HighlightState componentInChildren = m_rightArrow.GetComponentInChildren<HighlightState>();
 		if ((bool)componentInChildren)
diff --git a/Decompiled/Assembly-CSharp/CardListPopup.cs b/Decompiled/Assembly-CSharp/CardListPopup.cs
index 7a9ad4a..d502718 100644
--- a/Decompiled/Assembly-CSharp/CardListPopup.cs
+++ b/Decompiled/Assembly-CSharp/CardListPopup.cs
@@ -1,4 +1,7 @@
+using System;
 using System.Collections.Generic;
+using Accessibility;
+using UnityEngine;
 
 [CustomEditClass]
 public class CardListPopup : DialogBase
@@ -31,7 +34,12 @@ public class CardListPopup : DialogBase
 
 	private Info m_info = new Info();
 
-	protected override void Awake()
+    #region Accessibility
+    private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleCards;
+	private CardListPanel m_curCardsContainer;
+    #endregion
+
+    protected override void Awake()
 	{
 		base.Awake();
 		m_okayButton.AddEventListener(UIEventType.RELEASE, delegate
@@ -66,18 +74,81 @@ public class CardListPopup : DialogBase
 		{
 			m_CardsContainer_MultiLineDescription.Show(m_info.m_cards);
 			m_descriptionMultiLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_MultiLineDescription;
 		}
 		else
 		{
 			m_CardsContainer_SingleLineDescription.Show(m_info.m_cards);
 			m_descriptionSingleLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_SingleLineDescription;
 		}
 		UniversalInputManager.Get().SetSystemDialogActive(active: true);
-	}
 
-	public override void Hide()
+		ReadPopup();
+    }
+
+    public override void Hide()
 	{
 		base.Hide();
 		DialogBase.EndBlur();
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+        var accessibleCards = new List<AccessibleCollectibleCard>();
+        foreach (var card in m_info.m_cards)
+        {
+            accessibleCards.Add(new AccessibleCollectibleCard(this, card, false));
+        }
+
+        m_accessibleCards = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, m_info.m_description);
+		m_accessibleCards.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+            m_okayButton.TriggerRelease();
+        }
+        else
+        {
+			if (m_accessibleCards.HandleAccessibleInput())
+			{
+				ChangePageIfNeeded();
+			}
+        }
+    }
+
+    private void ChangePageIfNeeded()
+    {
+		int curCardIndex = m_accessibleCards.GetItemBeingReadIndex();
+		int cardsPerPage = CardListPanel.MAX_CARDS_PER_PAGE;
+		int curPage = m_curCardsContainer.m_pageNum;
+
+		int realPage = curCardIndex / cardsPerPage;
+
+		if (curPage < realPage)
+        {
+            m_curCardsContainer.TurnPage(true);
+        }
+		else if (curPage > realPage)
+        {
+			m_curCardsContainer.TurnPage(false);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		var helpText = LocalizationUtils.Get(LocalizationKey.UI_CARD_LIST_POPUP_HELP);
+		return AccessibleSpeechUtils.CombineSentences(helpText, AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs b/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
index 745be4f..a04faea 100644
--- a/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
+++ b/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
@@ -70,7 +70,7 @@ public class CastSpellCardFromHandSepll : Spell
 		targetCard.HideCard();
 		Entity entity = targetCard.GetEntity();
 		UpdateTags(entity);
-		HistoryManager.Get().CreatePlayedBigCard(entity, delegate
+		HistoryManager.Get().CreatePlayedBigCard(m_taskList, entity, delegate
 		{
 		}, delegate
 		{
@@ -126,7 +126,7 @@ public class CastSpellCardFromHandSepll : Spell
 		iTween.RotateTo(targetCard.gameObject, transform.rotation.eulerAngles, m_BigCardDisplayTime);
 		iTween.ScaleTo(targetCard.gameObject, new Vector3(1f, 1f, 1f), m_BigCardDisplayTime);
 		SoundManager.Get().LoadAndPlay("play_card_from_hand_1.prefab:ac4be75e319a97947a68308a08e54e88");
-		yield return new WaitForSeconds(m_BigCardDisplayTime);
+        yield return new WaitForSeconds(m_BigCardDisplayTime);
 	}
 
 	private IEnumerator PlayPowerUpSpell()
diff --git a/Decompiled/Assembly-CSharp/ChatMgr.cs b/Decompiled/Assembly-CSharp/ChatMgr.cs
index e573a4d..eb0d7d5 100644
--- a/Decompiled/Assembly-CSharp/ChatMgr.cs
+++ b/Decompiled/Assembly-CSharp/ChatMgr.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using bgs;
 using Hearthstone;
 using UnityEngine;
@@ -689,6 +690,15 @@ public class ChatMgr : MonoBehaviour
 
 	public void HandleGUIInput()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Chat is not implemented yet
+			return;
+        }
+
+		// Players were running into issues due to pressing Enter while using OCR so we'll disable this for now and rethink it later
+		return;
+
 		if (!m_fatalErrorMgr.HasError() && !IsMobilePlatform())
 		{
 			HandleGUIInputForQuickChat();
diff --git a/Decompiled/Assembly-CSharp/CheatMgr.cs b/Decompiled/Assembly-CSharp/CheatMgr.cs
index be1e317..a18cdf1 100644
--- a/Decompiled/Assembly-CSharp/CheatMgr.cs
+++ b/Decompiled/Assembly-CSharp/CheatMgr.cs
@@ -7,6 +7,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class CheatMgr : IService
 {
@@ -121,7 +122,7 @@ public class CheatMgr : IService
 		{
 			return false;
 		}
-		if (!InputCollection.GetKeyUp(KeyCode.BackQuote))
+		if (!InputCollection.GetKeyUp(KeyCode.Backslash))
 		{
 			return false;
 		}
@@ -151,9 +152,10 @@ public class CheatMgr : IService
 			m_completedCallback = OnInputComplete
 		};
 		UniversalInputManager.Get().UseTextInput(parms);
-	}
+        AccessibilityMgr.AllowTextInput();
+    }
 
-	public void HideConsole()
+    public void HideConsole()
 	{
 		UniversalInputManager.Get().CancelTextInput(SceneObject);
 		m_inputActive = false;
@@ -472,6 +474,8 @@ public class CheatMgr : IService
 
 	private void OnInputComplete(string inputCommand)
 	{
+        AccessibilityMgr.DisallowTextInput();
+
 		m_inputActive = false;
 		inputCommand = inputCommand.TrimStart();
 		if (!string.IsNullOrEmpty(inputCommand))
@@ -568,6 +572,7 @@ public class CheatMgr : IService
 		{
 			return "\"" + text + "\" cheat command executed, but failed!";
 		}
+		AccessibilityUtils.LogDebug($"Processed cheat: {text}");
 		return null;
 	}
 
diff --git a/Decompiled/Assembly-CSharp/Cheats.cs b/Decompiled/Assembly-CSharp/Cheats.cs
index b04fb6e..78b8bc3 100644
--- a/Decompiled/Assembly-CSharp/Cheats.cs
+++ b/Decompiled/Assembly-CSharp/Cheats.cs
@@ -36,6 +36,7 @@ using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
 using UnityEngine.SceneManagement;
+using Accessibility;
 
 public class Cheats : IService
 {
@@ -384,6 +385,29 @@ public class Cheats : IService
 		CheatMgr cheatMgr = serviceLocator.Get<CheatMgr>();
 		if (HearthstoneApplication.IsInternal())
 		{
+			cheatMgr.RegisterCategory("HSA changed cards");
+			cheatMgr.RegisterCheatHandler("hsashowchangedcardspopup", OnProcessCheat_hsashowchangedcardspopup, "Show 'these cards have changed' popup", "<command name>", "");
+			cheatMgr.RegisterCheatHandler("hsashowaddedcardspopup", OnProcessCheat_hsashowaddedcardspopup, "Show 'these cards were added' popup", "<command name>", "");
+			cheatMgr.RegisterCategory("HSA reconnect");
+			cheatMgr.RegisterCheatHandler("hsashowreconnecthelperdialog", OnProcessCheat_hsashowreconnecthelperdialog, "Show the recconect helper dialog", "<command> [fullResetRequired] [wasKickedForInactivity] [updateRequired]", "");
+			cheatMgr.RegisterCategory("HSA Quests");
+			cheatMgr.RegisterCheatHandler("hsashowquesttoastmount", OnProcessCheat_hsashowquesttoastmount, "Show a quest toast which rewards a mount", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowquesttoastminiset", OnProcessCheat_hsashowquesttoastminiset, "Show a quest toast which rewards a mini set", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowwelcomequests", OnProcessCheat_hsashowwelcomequests, "Show welcome quests", "<command>", "");
+			cheatMgr.RegisterCategory("HSA Returning player");
+			cheatMgr.RegisterCheatHandler("hsashowreturningplayerbanner", OnProcessCheat_hsashowreturningplayerbanner, "Show returning player banner", "<command>", "");
+			cheatMgr.RegisterCategory("HSA Basic popups");
+			cheatMgr.RegisterCheatHandler("hsashowstandardcomingsoonpopup", OnProcessCheat_hsashowstandardcomingsoonpopup, "Show Standard coming soon popup", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowcoresetavailablepopup", OnProcessCheat_hsashowcoresetavailablepopup, "Show core set available popup", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowwhizbangpopup", OnProcessCheat_hsashowwhizbangpopup, "Show Whizbang popup", "<command>", "");
+			cheatMgr.RegisterCategory("HSA others");
+			cheatMgr.RegisterCheatHandler("hsashowleaguepromotionrewards", OnProcessCheat_hsashowleaguepromotionrewards, "Show (legacy?) league promotion rewards", "<command> [rank]", "bronze10");
+			cheatMgr.RegisterCheatHandler("hsashowquestchestreward", OnProcessCheat_hsashowquestchestreward, "Show (legacy?) quest chest reward", "<command>", "");
+			cheatMgr.RegisterCategory("HSA pack opening");
+			cheatMgr.RegisterCheatHandler("hsasettestpacks1", OnProcessCheat_hsasettestpacks1, "Set test packs 1", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasettestpacks2", OnProcessCheat_hsasettestpacks2, "Set test packs 2", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsasettestpacks3", OnProcessCheat_hsasettestpacks3, "Set test packs 3", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsaresettestpacks", OnProcessCheat_hsaresettestpacks, "Reset test packs", "<command>", "");
 			cheatMgr.RegisterCategory("help");
 			cheatMgr.RegisterCheatHandler("help", OnProcessCheat_help, "Get help for a specific command or list of commands", "<command name>", "");
 			cheatMgr.RegisterCheatHandler("example", OnProcessCheat_example, "Run an example of this command if one exists", "<command name>");
@@ -474,7 +498,7 @@ public class Cheats : IService
 			cheatMgr.RegisterCheatHandler("iksaction", OnProcessCheat_iksgameaction, "Execute a game action as if IKS was clicked.");
 			cheatMgr.RegisterCheatHandler("iksseen", OnProcessCheat_iksseen, "Determine if an IKS message should be seen by its game action.");
 			cheatMgr.RegisterCategory("rank");
-			cheatMgr.RegisterCheatHandler("seasondialog", OnProcessCheat_seasondialog, "Open the season end dialog", "<rank> [standard|wild|classic]", "bronze5 wild");
+			cheatMgr.RegisterCheatHandler("seasondialog", OnProcessCheat_seasondialog, "Open the season end dialog", "<rank> [standard|wild|classic]", "bronze5 wild"); // BUG
 			cheatMgr.RegisterCheatHandler("rankrefresh", OnProcessCheat_rankrefresh, "Request medalinfo from server and show rankchange twoscoop after receiving it");
 			cheatMgr.RegisterCheatHandler("rankchange", OnProcessCheat_rankchange, "Show a fake rankchange twoscoop", "[rank] [up|down|win|loss] [wild] [winstreak] [chest]", "bronze5 up chest");
 			cheatMgr.RegisterCheatHandler("rankreward", OnProcessCheat_rankreward, "Show a fake RankedRewardDisplay for rank (or all ranks up to a rank)", "<rank> [standard|wild|classic|all]", "bronze5 all");
@@ -671,7 +695,7 @@ public class Cheats : IService
 		yield break;
 	}
 
-	public Type[] GetDependencies()
+    public Type[] GetDependencies()
 	{
 		return new Type[2]
 		{
@@ -3071,8 +3095,10 @@ public class Cheats : IService
 		}
 		if (flag)
 		{
-			achievement.SetDescription("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "");
-			achievement.SetName("Title Text", "");
+			//achievement.SetDescription("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "");
+			achievement.SetName("Example quest", "");
+			achievement.SetDescription("Kill 5 minions", "");
+			achievement.SetRewards(list);
 			QuestToast.ShowQuestToast(UserAttentionBlocker.ALL, null, updateCacheValues: false, achievement);
 		}
 		else
@@ -3463,7 +3489,7 @@ public class Cheats : IService
 
 	private bool OnProcessCheat_setRotationRotatedBoostersPopup(string func, string[] args, string rawArgs)
 	{
-		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo("");
 		DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, info);
 		return true;
 	}
@@ -10270,7 +10296,7 @@ public class Cheats : IService
 
 	private bool OnProcessCheat_showtrackreward(string func, string[] args, string rawArgs)
 	{
-		string message = "showtrackreward <level> <forPaidTrack>";
+		string message = "showtrackreward <level> <forPaidTrack> <tracklevelOverrideForAccessibilityTesting>";
 		if (!int.TryParse(args[0], out var level))
 		{
 			UIStatus.Get().AddInfo(message);
@@ -10281,6 +10307,7 @@ public class Cheats : IService
 		{
 			bool.TryParse(args[1], out result);
 		}
+
 		RewardTrackLevelDbfRecord rewardTrackLevelDbfRecord = RewardTrackManager.Get().RewardTrackAsset.Levels.Where((RewardTrackLevelDbfRecord r) => r.Level == level).FirstOrDefault();
 		if (rewardTrackLevelDbfRecord == null)
 		{
@@ -10300,6 +10327,10 @@ public class Cheats : IService
 			}
 			return true;
 		}
+		if (args.Length > 2)
+        {
+			int.TryParse(args[2], out num);
+        }
 		RewardScroll.DebugShowFake(RewardTrackFactory.CreateRewardScrollDataModel(num, level));
 		return true;
 	}
@@ -10433,4 +10464,234 @@ public class Cheats : IService
 		}
 		return true;
 	}
+
+	#region Accessibility
+	private bool OnProcessCheat_hsashowchangedcardspopup(string func, string[] args, string rawArgs)
+	{
+        CheatMgr.Get().ProcessCheat("cardresetchange");
+        Vars.Key("Cheats.ShowFakeNerfedCards").Set(true.ToString(), false);
+        CheatMgr.Get().ProcessCheat("cardchangepopup false true 5");
+        return true;
+	}
+
+	private bool OnProcessCheat_hsashowaddedcardspopup(string func, string[] args, string rawArgs)
+	{
+        CheatMgr.Get().ProcessCheat("cardresetchange");
+        Vars.Key("Cheats.ShowFakeAddedCards").Set(true.ToString(), false);
+        CheatMgr.Get().ProcessCheat("cardchangepopup true true 5");
+        return true;
+	}
+	
+	private bool OnProcessCheat_hsashowreconnecthelperdialog(string func, string[] args, string rawArgs)
+	{
+		bool fullResetRequired = false;
+		bool wasKickedForInactivity = false;
+		bool updateRequired = false;
+
+		if (args.Length < 3)
+		{
+			UIStatus.Get().AddInfo("Usage: hsashowreconnecthelperdialog [fullResetRequired] [wasKickedForInactivity] [updateRequired] \nExample: hsashowreconnecthelperdialog true false true");
+			return false;
+		}
+
+		if (!bool.TryParse(args[0], out fullResetRequired))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[0]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (!bool.TryParse(args[1], out wasKickedForInactivity))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[1]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (!bool.TryParse(args[2], out updateRequired))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[2]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (fullResetRequired)
+        {
+			ReconnectMgr.Get().FullResetRequired = true;
+        }
+
+		if (wasKickedForInactivity)
+        {
+			InactivePlayerKicker.Get().WasKickedForInactivity = true;
+        }
+
+		if (updateRequired)
+        {
+			ReconnectMgr.Get().UpdateRequired = true;
+        }
+
+        DialogManager.Get().ShowReconnectHelperDialog();
+        return true;
+	}
+
+    private bool OnProcessCheat_hsashowquesttoastmount(string func, string[] args, string rawArgs)
+    {
+        RewardData rwd = new MountRewardData(MountRewardData.MountType.WOW_HEARTHSTEED);
+        ShowQuestToast(rwd);
+		return true;
+    }
+
+    private bool OnProcessCheat_hsashowquesttoastminiset(string func, string[] args, string rawArgs)
+    {
+        RewardData rwd = new MiniSetRewardData(1);
+        ShowQuestToast(rwd);
+		return true;
+    }
+
+    private void ShowQuestToast(RewardData rwd)
+    {
+        QuestToast.ShowGenericRewardQuestToast(UserAttentionBlocker.NONE, null, rwd, "Example quest", "Kill 5 minions");
+    }
+
+    private bool OnProcessCheat_hsashowwelcomequests(string func, string[] args, string rawArgs)
+    {
+        Achievement achievement = AchieveManager.Get().GetAchievement(58);
+        WelcomeQuests.ShowSpecialQuest(UserAttentionBlocker.ALL, achievement);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowreturningplayerbanner(string func, string[] args, string rawArgs)
+    {
+        BannerManager.Get().ShowBanner("WoodenSign_Paint_Welcome_Back.prefab:4cb64d2b8c67feb45b4e17042d58f1ba", null, GameStrings.Get("GLUE_RETURNING_PLAYER_WELCOME_DESC"), delegate
+        {
+        });
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowstandardcomingsoonpopup(string func, string[] args, string rawArgs)
+    {
+        var popupText = LocalizationUtils.Get(LocalizationKey.UI_STANDARD_FORMAT_POPUP_TEXT);
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
+        popupInfo.m_prefabAssetRefs.Add("RotationPopUp_ComingSoon.prefab:afff670e4001e11429c04d2e0c27dd76");
+        DialogManager.Get().ShowStandardComingSoonPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowcoresetavailablepopup(string func, string[] args, string rawArgs)
+    {
+		var popupText = AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_HEADER), LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_SUBHEADER));
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
+        popupInfo.m_blurWhenShown = true;
+        popupInfo.m_prefabAssetRefs.Add("CoreSetIntroPopup.prefab:32fcd0d9c45bc9449af825460fac647b");
+        DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowwhizbangpopup(string func, string[] args, string rawArgs)
+    {
+        var headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
+        var bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", "Mage", "My whizbang deck");
+        var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
+        popupInfo.m_prefabAssetRefs.Add("WhizbangDialog_notification.prefab:89912cf72b2d5cf47820d2328de40f3f");
+        popupInfo.m_headerText = headerText;
+        popupInfo.m_bodyText = bodyText;
+        popupInfo.m_disableBnetBar = true;
+        DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.NONE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowleaguepromotionrewards(string func, string[] args, string rawArgs)
+    {
+		string cheatName = "bronze10";
+		if (args.Length != 0 && !string.IsNullOrEmpty(args[0]))
+		{
+			cheatName = args[0];
+		}
+
+        var leagueRecord = RankMgr.Get().GetLeagueRankRecordByCheatName(cheatName);
+		var leagueId = leagueRecord.LeagueId;
+
+		var rewards = GenerateFakeRewards();
+
+		var rewardBone = PopupDisplayManager.Get().GetChestRewardBoneForScene();
+
+        RewardUtils.ShowLeaguePromotionRewards(leagueId, rewards, rewardBone, () => DialogManager.Get().ShowRankedIntroPopUp(null));
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowquestchestreward(string func, string[] args, string rawArgs)
+    {
+		string questName = "Quest name";
+		string questDesc = "Kill 5 Murlocs";
+
+		var rewards = GenerateFakeRewards();
+
+		var rewardBone = PopupDisplayManager.Get().GetChestRewardBoneForScene(PopupDisplayManager.Get().QuestChestBones);
+
+        RewardUtils.ShowQuestChestReward(questName, questDesc, rewards, rewardBone, () => { });
+        return true;
+    }
+
+    private List<RewardData> GenerateFakeRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        GoldRewardData goldRewardData = new GoldRewardData();
+        goldRewardData.Amount = 327;
+        list.Add(goldRewardData);
+        list.Add(RewardUtils.CreateArcaneOrbRewardData(327));
+        ArcaneDustRewardData arcaneDustRewardData = new ArcaneDustRewardData();
+        arcaneDustRewardData.Amount = 327;
+        list.Add(arcaneDustRewardData);
+
+		return list;
+    }
+
+    #region Test Pack Opening
+
+    private bool OnProcessCheat_hsasettestpacks1(string func, string[] args, string rawArgs)
+    {
+        NetCache.NetCacheBoosters netCacheBoosters = new NetCache.NetCacheBoosters();
+        AddTestPack(netCacheBoosters.BoosterStacks, 1, 1);
+        AddTestPack(netCacheBoosters.BoosterStacks, 23, 1);
+        NetCache.Get().SetTestDataNetCacheBoosters(netCacheBoosters);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasettestpacks2(string func, string[] args, string rawArgs)
+    {
+        NetCache.NetCacheBoosters netCacheBoosters = new NetCache.NetCacheBoosters();
+        AddTestPack(netCacheBoosters.BoosterStacks, 616, 2);
+        AddTestPack(netCacheBoosters.BoosterStacks, 633, 1);
+        NetCache.Get().SetTestDataNetCacheBoosters(netCacheBoosters);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsasettestpacks3(string func, string[] args, string rawArgs)
+    {
+        NetCache.NetCacheBoosters netCacheBoosters = new NetCache.NetCacheBoosters();
+        NetCache.Get().SetTestDataNetCacheBoosters(netCacheBoosters);
+
+		return true;
+    }
+
+    private bool OnProcessCheat_hsaresettestpacks(string func, string[] args, string rawArgs)
+    {
+        NetCache.Get().SetTestDataNetCacheBoosters(null);
+
+		return true;
+    }
+
+    private void AddTestPack(List<NetCache.BoosterStack> boosterStacks, int packId, int packCount)
+    {
+		NetCache.BoosterStack item = new NetCache.BoosterStack
+		{
+			Id = packId,
+			Count = packCount
+		};
+		boosterStacks.Add(item);
+    }
+
+	#endregion
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs b/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
index 43da71c..95a890f 100644
--- a/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
+++ b/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
@@ -1,8 +1,9 @@
 using System;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class ChestRewardDisplay : MonoBehaviour
+public class ChestRewardDisplay : MonoBehaviour, AccessibleUI
 {
 	public const string DEFAULT_PREFAB = "RewardChest_Lock.prefab:06ffa33e82036694e8cacb96aa7b48e8";
 
@@ -76,7 +77,13 @@ public class ChestRewardDisplay : MonoBehaviour
 		m_bannerUberText.Text = title;
 		m_descText.SetActive(value: true);
 		m_descText.GetComponent<UberText>().Text = desc;
-		ShowRewardChest();
+		ShowRewardChest(true);
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+		AccessibilityMgr.Output(this, title);
+		AccessibilityMgr.Output(this, desc);
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 		return true;
 	}
 
@@ -85,7 +92,7 @@ public class ChestRewardDisplay : MonoBehaviour
 		m_doneCallbacks.Add(action);
 	}
 
-	private void ShowRewardChest()
+	private void ShowRewardChest(bool accessible)
 	{
 		if (FullScreenFXMgr.Get() != null)
 		{
@@ -98,17 +105,29 @@ public class ChestRewardDisplay : MonoBehaviour
 
 	private void ShowRewardChest_TavernBrawl()
 	{
-		ShowRewardChest();
+		ShowRewardChest(true);
 		string text = ((m_wins != 0) ? GameStrings.Format("GLUE_BRAWLISEUM_REWARDS_WIN_BANNER_TEXT", m_wins, m_wins) : GameStrings.Get("GLUE_BRAWLISEUM_NO_WINS_REWARD_PACK_TEXT"));
 		m_bannerUberText.Text = text;
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+		AccessibilityMgr.Output(this, text);
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 	}
 
 	private void ShowRewardChest_LeaguePromotion()
 	{
-		ShowRewardChest();
+		ShowRewardChest(true);
 		LeagueRankDbfRecord record = GameDbf.LeagueRank.GetRecord((LeagueRankDbfRecord r) => r.LeagueId == m_leagueId && r.StarLevel == 1);
 		m_bannerUberText.Text = record.RankName.GetString();
-		m_descText.GetComponent<UberText>().Text = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
+		var desc = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
+		m_descText.GetComponent<UberText>().Text = desc;
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+		AccessibilityMgr.Output(this, m_bannerUberText.Text);
+		AccessibilityMgr.Output(this, desc);
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 	}
 
 	private void ShowRewardBags(UIEvent e)
@@ -157,6 +176,8 @@ public class ChestRewardDisplay : MonoBehaviour
 
 	public void OnSummonOutAnimationDone()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		foreach (Action doneCallback in m_doneCallbacks)
 		{
 			doneCallback?.Invoke();
@@ -173,4 +194,21 @@ public class ChestRewardDisplay : MonoBehaviour
 		}
 		return m_rewardBoxBone;
 	}
+
+    #region Accessibility
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_rewardChest.TriggerRelease();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return LocalizationUtils.Format(LocalizationKey.UI_CHEST_REWARD_DISPLAY_HELP, AccessibleKey.CONFIRM);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs b/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
index a26503b..89953c5 100644
--- a/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
+++ b/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
@@ -1351,6 +1351,7 @@ public class ChoiceCardMgr : MonoBehaviour
 		ShowChoiceBanner(choiceState.m_cards);
 		ShowChoiceButtons();
 		HideEnlargedHand();
+		Accessibility.AccessibleGameplay.Get().OnChoice(choiceState.m_cards, m_choiceBanner, m_confirmChoiceButton);
 	}
 
 	private void HideChoiceUI()
@@ -1625,6 +1626,7 @@ public class ChoiceCardMgr : MonoBehaviour
 			}
 		}
 		HideEnlargedHand();
+		Accessibility.AccessibleGameplay.Get().OnSubOption(m_subOptionState.m_cards);
 	}
 
 	private void HideSubOptions(Entity chosenEntity = null)
diff --git a/Decompiled/Assembly-CSharp/ChooseDeckReward.cs b/Decompiled/Assembly-CSharp/ChooseDeckReward.cs
index 7034f2a..80b163d 100644
--- a/Decompiled/Assembly-CSharp/ChooseDeckReward.cs
+++ b/Decompiled/Assembly-CSharp/ChooseDeckReward.cs
@@ -2,8 +2,9 @@ using System;
 using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
+using Accessibility;
 
-public class ChooseDeckReward : CustomVisualReward
+public class ChooseDeckReward : CustomVisualReward, AccessibleUI
 {
 	public AsyncReference m_chooseDeckReference;
 
@@ -29,6 +30,10 @@ public class ChooseDeckReward : CustomVisualReward
 
 	private long m_noticeId;
 
+	#region Accessibility
+	private int m_numButtonsLoading;
+	#endregion
+
 	private TAG_CLASS[] m_classByButtonIndex = new TAG_CLASS[10]
 	{
 		TAG_CLASS.DRUID,
@@ -47,6 +52,7 @@ public class ChooseDeckReward : CustomVisualReward
 	{
 		m_classButtonWidgets = new Widget[m_classButtonReferences.Length];
 		m_buttonDataModels = new DeckChoiceDataModel[m_classButtonReferences.Length];
+		m_numButtonsLoading = m_classButtonReferences.Length;
 		for (int i = 0; i < m_classButtonReferences.Length; i++)
 		{
 			int classIndex = i;
@@ -118,5 +124,65 @@ public class ChooseDeckReward : CustomVisualReward
 		m_classButtonWidgets[index] = w;
 		m_buttonDataModels[index] = deckChoiceDataModel;
 		w.BindDataModel(deckChoiceDataModel);
+
+		// Accessibility
+		m_numButtonsLoading--;
+
+		if (m_numButtonsLoading == 0)
+        {
+			ReadChooseDeckUI();
+        }
 	}
+
+	#region Accessibility
+
+	private enum State { LOADING, CHOOSING };
+
+	private AccessibleMenu m_chooseDeckMenu;
+	private State m_curState = State.LOADING;
+
+	private void ReadChooseDeckUI()
+    {
+		m_curState = State.LOADING;
+
+		m_chooseDeckMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.UI_CHOOSE_FREE_DECK_TITLE), null);
+
+		for (int i = 0; i < m_buttonDataModels.Length; i++)
+        {
+			var classIndex = i;
+			m_chooseDeckMenu.AddOption(GameStrings.GetClassName(m_classByButtonIndex[i]), () => ChooseDeck(classIndex));
+        }
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		m_chooseDeckMenu.StartReading();
+		m_curState = State.CHOOSING;
+    }
+
+    private void ChooseDeck(int index)
+    {
+		SetSelectedButtonIndex(index);
+		ChoiceConfirmed();
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == State.LOADING)
+        {
+			return;
+        }
+		m_chooseDeckMenu?.HandleAccessibleInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_curState == State.CHOOSING)
+        {
+			return m_chooseDeckMenu?.GetHelp();
+        }
+
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ClientOption.cs b/Decompiled/Assembly-CSharp/ClientOption.cs
index 5325aa4..40463cc 100644
--- a/Decompiled/Assembly-CSharp/ClientOption.cs
+++ b/Decompiled/Assembly-CSharp/ClientOption.cs
@@ -123,5 +123,9 @@ public enum ClientOption
 	DEBUG_SHOW_PRODUCT_IDS,
 	APKINSTALL_START,
 	APKINSTALL_FAILURE_REPORTED,
-	INTERNET_UNREACHABLE
+	INTERNET_UNREACHABLE,
+
+	#region Accessibility
+	ACCESSIBILITY_GAME_SPEED
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs b/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs
index d39f308..3939614 100644
--- a/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs
+++ b/Decompiled/Assembly-CSharp/CollectionDeckBoxVisual.cs
@@ -5,6 +5,7 @@ using System.Linq;
 using Assets;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionDeckBoxVisual : PegUIElement
@@ -1012,6 +1013,10 @@ public class CollectionDeckBoxVisual : PegUIElement
 			SetEnabled(enabled: false);
 			DecksContent.DeleteDeck(GetDeckID());
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void PlayPopAnimation(string animationName)
diff --git a/Decompiled/Assembly-CSharp/CollectionDeckTray.cs b/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
index 0779108..f6b6d52 100644
--- a/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
+++ b/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using System.Linq;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionDeckTray : EditableDeckTray
@@ -634,7 +635,7 @@ public class CollectionDeckTray : EditableDeckTray
 		}
 		else
 		{
-			if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
+			if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
 			{
 				Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
 				Options.Get().SetLong(Option.LAST_CUSTOM_DECK_CHOSEN, editedDeck.ID);
@@ -643,7 +644,7 @@ public class CollectionDeckTray : EditableDeckTray
 				Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, relativePosition, NotificationManager.NOTIFICATITON_WORLD_SCALE, GameStrings.Get("GLUE_COLLECTION_TUTORIAL16"), convertLegacyPosition: false);
 				notification.ShowPopUpArrow(Notification.PopUpArrowDirection.RightDown);
 				notification.PulseReminderEveryXSeconds(3f);
-				UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+				UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 				m_doneButton.GetComponentInChildren<HighlightState>().ChangeState(ActorStateType.HIGHLIGHT_PRIMARY_ACTIVE);
 			}
 			SaveCurrentDeckAndEnterDeckListMode();
@@ -750,6 +751,7 @@ public class CollectionDeckTray : EditableDeckTray
 					}
 					else
 					{
+						AccessibleCollectionManager.Get().OnFinishingDeckAutoFill();
 						FinishMyDeck(backOutWhenComplete: true);
 					}
 				}
@@ -941,6 +943,7 @@ public class CollectionDeckTray : EditableDeckTray
 		CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: true);
 		AllowInput(allowed: true);
 		completedCallback?.Invoke(addedCards, removedCards);
+		AccessibleCollectionManager.Get().OnFinishAutoAddCardsWithTiming();
 	}
 
 	public override void UpdateDoneButtonText()
diff --git a/Decompiled/Assembly-CSharp/CollectionManager.cs b/Decompiled/Assembly-CSharp/CollectionManager.cs
index 314a963..1a2323d 100644
--- a/Decompiled/Assembly-CSharp/CollectionManager.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManager.cs
@@ -3083,6 +3083,9 @@ public class CollectionManager
 
 	public bool ShouldShowWildToStandardTutorial(bool checkPrevSceneIsPlayMode = true)
 	{
+		// Prevent problems when using OCR
+		return false;
+
 		if (!ShouldAccountSeeStandardWild())
 		{
 			return false;
@@ -3959,4 +3962,13 @@ public class CollectionManager
 		}
 		return collectionDeck.GetShareableDeck();
 	}
+
+    #region Accessibility
+
+    public bool IsDeleteDeckPending()
+    {
+		return m_pendingDeckDeleteList?.Count > 0;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs b/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
index 4332800..e125e5a 100644
--- a/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
@@ -10,6 +10,7 @@ using Hearthstone;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerDisplay : CollectibleDisplay
@@ -198,7 +199,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		}
 		if (CollectionManager.Get().ShouldShowWildToStandardTutorial())
 		{
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
 		SetTavernBrawlTexturesIfNecessary();
 		SetDuelsTexturesIfNecessary();
@@ -236,7 +237,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			UnityEngine.Object.Destroy(m_deckTemplatePickerPhone.gameObject);
 			m_deckTemplatePickerPhone = null;
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
@@ -411,6 +412,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 					m_cardActors.Add(new CollectionCardActors(component));
 				}
 			}
+			AccessibleCollectionManager.Get().OnPageChanged(m_pageManager.CurrentPageNum, cardsToDisplay, m_cardActors);
 			callback?.Invoke(m_cardActors, callbackData);
 		}
 	}
@@ -1666,7 +1668,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void ShowCraftingTipIfNeeded()
 	{
-		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
+		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_DISENCHANT_31"), "VO_INNKEEPER_DISENCHANT_31.prefab:4a0246488dc2d8146b1db88de5c603ff");
 			Options.Get().SetBool(Option.TIP_CRAFTING_UNLOCKED, val: true);
@@ -1749,7 +1751,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			yield return null;
 		}
 		int deckCount = CollectionManager.Get().GetDecks(DeckType.NORMAL_DECK).Count;
-		if (CollectionManager.Get().ShouldShowWildToStandardTutorial() && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial"))
+		if (CollectionManager.Get().ShouldShowWildToStandardTutorial() && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial"))
 		{
 			CollectionDeckTray deckTray = CollectionDeckTray.Get();
 			while (deckTray.IsUpdatingTrayMode() || !deckTray.GetDecksContent().IsDoneEntering())
@@ -1775,7 +1777,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER_AFTER_PRACTICE, val: true);
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_WELCOME"), "VO_INNKEEPER_Male_Dwarf_CM_WELCOME_23.prefab:c8afdeaaf2189eb42aad9d29f6a97994");
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER, val: true);
@@ -1785,18 +1787,28 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			yield return new WaitForSeconds(1f);
 		}
-		bool num = UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK);
+		bool num = UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK);
 		bool @bool = Options.Get().GetBool(Option.HAS_STARTED_A_DECK, defaultVal: false);
 		if (num && !@bool && deckCount > 0)
 		{
-			m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_editDeckTutorialBone.position, m_editDeckTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL07"));
-			m_deckHelpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
-			m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+			{
+				// Visual notif - ignore
+				m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_editDeckTutorialBone.position, m_editDeckTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL07"));
+				m_deckHelpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
+				m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+			}
 		}
 	}
 
 	private void ShowDeckTemplateTipsIfNeeded()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// All of these tips are very visual which is just confusing
+			return;
+        }
+
 		bool flag = m_deckHelpPopup != null && m_deckHelpPopup.gameObject != null;
 		Notification deckHelpPopup = CollectionDeckTray.Get().GetCardsContent().GetDeckHelpPopup();
 		bool flag2 = deckHelpPopup != null && deckHelpPopup.gameObject != null;
@@ -1820,7 +1832,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			}
 			else
 			{
-				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
+				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
 				{
 					return;
 				}
@@ -2006,7 +2018,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowConvertTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
 		{
 			m_showConvertTutorialCoroutine = ShowConvertTutorialCoroutine(blocker);
 			StartCoroutine(m_showConvertTutorialCoroutine);
@@ -2052,7 +2064,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowSetFilterTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
 		{
 			m_showSetFilterTutorialCoroutine = ShowSetFilterTutorialCoroutine(blocker);
 			StartCoroutine(m_showSetFilterTutorialCoroutine);
@@ -2276,6 +2288,8 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void CreateDeckFromClipboard(ShareableDeck shareableDeck)
 	{
+		AccessibleCollectionManager.Get().OnCreateDeckFromClipboard();
+
 		bool num = SceneMgr.Get().GetMode() == SceneMgr.Mode.COLLECTIONMANAGER;
 		TAG_CLASS @class = DefLoader.Get().GetEntityDef(shareableDeck.HeroCardDbId).GetClass();
 		NetCache.CardDefinition favoriteHero = CollectionManager.Get().GetFavoriteHero(@class);
diff --git a/Decompiled/Assembly-CSharp/CollectionManagerScene.cs b/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
index 8af3e11..e6fa7fb 100644
--- a/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerScene : PegasusScene
@@ -13,6 +14,7 @@ public class CollectionManagerScene : PegasusScene
 	{
 		base.Awake();
 		AssetLoader.Get().InstantiatePrefab((string)m_CollectionManagerPrefab, OnUIScreenLoaded);
+		AccessibleCollectionManager.Get().OnCollectionManagerOpened();
 	}
 
 	private void Update()
@@ -27,6 +29,7 @@ public class CollectionManagerScene : PegasusScene
 
 	public override void Unload()
 	{
+		AccessibleCollectionManager.Get().OnCollectionManagerClosed();
 		if ((bool)UniversalInputManager.UsePhoneUI)
 		{
 			BnetBar.Get().ToggleActive(active: true);
@@ -55,6 +58,7 @@ public class CollectionManagerScene : PegasusScene
 		{
 			yield return null;
 		}
+		AccessibleCollectionManager.Get().OnCollectibleDisplayReady();
 		SceneMgr.Get().NotifySceneLoaded();
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionPageManager.cs b/Decompiled/Assembly-CSharp/CollectionPageManager.cs
index fa06b83..09010a6 100644
--- a/Decompiled/Assembly-CSharp/CollectionPageManager.cs
+++ b/Decompiled/Assembly-CSharp/CollectionPageManager.cs
@@ -152,7 +152,7 @@ public class CollectionPageManager : CollectiblePageManager
 
 	private static Map<TAG_CLASS, int> CLASS_TO_TAB_IDX = null;
 
-	private List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
+	internal List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
 
 	private MassDisenchant m_massDisenchant;
 
@@ -170,7 +170,7 @@ public class CollectionPageManager : CollectiblePageManager
 
 	private int m_numPageFlipsThisSession;
 
-	protected TAG_CLASS m_currentClassContext;
+	internal TAG_CLASS m_currentClassContext;
 
 	private CollectibleCard m_lastCardAnchor;
 
diff --git a/Decompiled/Assembly-CSharp/CraftingUI.cs b/Decompiled/Assembly-CSharp/CraftingUI.cs
index 3b6362e..229cecc 100644
--- a/Decompiled/Assembly-CSharp/CraftingUI.cs
+++ b/Decompiled/Assembly-CSharp/CraftingUI.cs
@@ -330,7 +330,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void ShowFirstTimeTips()
 	{
-		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber("CraftingUI.ShowFirstTimeTips"))
+		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.ShowFirstTimeTips"))
 		{
 			CreateDisenchantNotification();
 			CreateCraftNotification();
@@ -371,7 +371,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void UpdateTips()
 	{
-		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber("CraftingUI.UpdateTips"))
+		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.UpdateTips"))
 		{
 			HideTips();
 		}
diff --git a/Decompiled/Assembly-CSharp/CreateButton.cs b/Decompiled/Assembly-CSharp/CreateButton.cs
index 480d173..a8d8205 100644
--- a/Decompiled/Assembly-CSharp/CreateButton.cs
+++ b/Decompiled/Assembly-CSharp/CreateButton.cs
@@ -94,7 +94,7 @@ public class CreateButton : CraftingButton
 					Options.Get().SetBool(Option.HAS_SEEN_STANDARD_MODE_TUTORIAL, val: true);
 					Options.Get().SetInt(Option.SET_ROTATION_INTRO_PROGRESS, 6);
 					Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
-					UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+					UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 					Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_PLAY_SCREEN, val: true);
 					Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_CREATE_DECK, val: true);
 				}
diff --git a/Decompiled/Assembly-CSharp/CustomDeckPage.cs b/Decompiled/Assembly-CSharp/CustomDeckPage.cs
index d0d5d81..309a51b 100644
--- a/Decompiled/Assembly-CSharp/CustomDeckPage.cs
+++ b/Decompiled/Assembly-CSharp/CustomDeckPage.cs
@@ -34,7 +34,7 @@ public class CustomDeckPage : MonoBehaviour
 
 	protected int m_numCustomDecks;
 
-	protected List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
+	public List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
 
 	protected DeckButtonCallback m_deckButtonCallback;
 
diff --git a/Decompiled/Assembly-CSharp/DeckHelper.cs b/Decompiled/Assembly-CSharp/DeckHelper.cs
index 280f6a5..51f972c 100644
--- a/Decompiled/Assembly-CSharp/DeckHelper.cs
+++ b/Decompiled/Assembly-CSharp/DeckHelper.cs
@@ -345,7 +345,7 @@ public class DeckHelper : MonoBehaviour
 			Navigation.PushUnique(OnNavigateBack);
 			m_shown = true;
 			m_rootObject.SetActive(value: true);
-			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
+			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_ANNOUNCER_CM_HELP_DECK_50"), "VO_ANNOUNCER_CM_HELP_DECK_50.prefab:450881875d33d094e9a27f6260fb06d9");
 				Options.Get().SetBool(Option.HAS_SEEN_DECK_HELPER, val: true);
diff --git a/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs b/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs
index 5498c61..40aa890 100644
--- a/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs
+++ b/Decompiled/Assembly-CSharp/DeckOptionsMenu.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class DeckOptionsMenu : MonoBehaviour
 {
@@ -176,6 +177,10 @@ public class DeckOptionsMenu : MonoBehaviour
 				collectionManagerDisplay.OnDoneEditingDeck();
 			}
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void OnRetireButtonReleased(UIEvent e)
diff --git a/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
index 52feed4..4a4c587 100644
--- a/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
@@ -8,6 +8,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
@@ -564,6 +565,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 				SetHeaderText("UNSUPPORTED DECK TEXT " + formatType);
 				return;
 			}
+
+			m_creatingDeck = true;
 		}
 		SetHeaderText(GameStrings.Get(key));
 	}
@@ -746,7 +749,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 
 	public void ShowSwitchToWildTutorialIfNecessary()
 	{
-		if (!(m_switchFormatPopup != null) && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
+		if (!(m_switchFormatPopup != null) && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
 		{
 			if (Options.GetFormatType() == PegasusShared.FormatType.FT_WILD)
 			{
@@ -885,6 +888,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		InitDeckPages();
 		SetPageDecks(decks);
 		UpdateDeckVisuals();
+		AccessibleAdventureScene.Get().OnDeckPickerTrayDisplayReady(m_customPages);
 	}
 
 	private void UpdateDeckVisuals()
@@ -1008,13 +1012,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			if (SceneMgr.Get().GetMode() == SceneMgr.Mode.TOURNAMENT && SetRotationManager.HasSeenStandardModeTutorial())
 			{
-				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_WILD_GAME"), "VO_INNKEEPER_Male_Dwarf_SetRotation_35.prefab:db2f6e3818fa49b4d8423121eba762f6");
 					Options.Get().SetBool(Option.HAS_SEEN_WILD_MODE_VO, val: true);
 				}
-				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_CLASSIC_TAKES_YOU_BACK_ORIGINAL_HEARTHSTONE"), "VO_Innkeeper_Male_Dwarf_ClassicMode_06.prefab:f91da6f7e66fd754fb4e568d15d49116");
@@ -1679,7 +1683,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		if (m_showStandardComingSoonNotice)
 		{
-			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+			var popupText = LocalizationUtils.Get(LocalizationKey.UI_STANDARD_FORMAT_POPUP_TEXT);
+			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 			popupInfo.m_responseCallback = OnStandardComingSoonResponse;
 			popupInfo.m_prefabAssetRefs.Add(STANDARD_COMING_SOON_POPUP_NAME);
 			DialogManager.Get().ShowStandardComingSoonPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
@@ -1871,7 +1876,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		ShowPage(m_currentPageIndex - 1, skipTraySlidingAnimation);
 	}
 
-	private void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
+	internal void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
 	{
 		if (iTween.Count(m_randomDeckPickerTray) > 0 || pageNum < 0 || pageNum >= m_customPages.Count)
 		{
@@ -2145,6 +2150,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			m_slidingTray.ToggleTraySlider(show: true);
 		}
+		AccessibleAdventureScene.Get().OnSelectedDeck(deckbox);
 	}
 
 	private bool HandleClickToFixDeck(CollectionDeck deck, HeroPickerButton button, bool isClickToConvertCase, bool IsMissingCards)
@@ -2372,7 +2378,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_heroActor.SetUnlit();
 		NetCache.HeroLevel heroLevel = ((!locked) ? GameUtils.GetHeroLevel(fullDef.EntityDef.GetClass()) : null);
 		int totalLevel = GameUtils.GetTotalHeroLevel() ?? 0;
-		m_xpBar.UpdateDisplay(heroLevel, totalLevel);
+		m_xpBar.UpdateDisplay(null, heroLevel, totalLevel, false);
 		string heroPowerCardIdFromHero = GameUtils.GetHeroPowerCardIdFromHero(fullDef.EntityDef.GetCardId());
 		if (!locked && ShouldShowHeroPower() && !string.IsNullOrEmpty(heroPowerCardIdFromHero))
 		{
@@ -3240,7 +3246,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		return GetDeckboxWithDeckID(deckId) != null;
 	}
 
-	private long GetLastChosenDeckId()
+	internal long GetLastChosenDeckId()
 	{
 		if (SceneMgr.Get().GetMode() != SceneMgr.Mode.FRIENDLY)
 		{
@@ -3444,7 +3450,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		bool result = false;
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
-		if (mode == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber("DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
+		if (mode == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, NotificationManager.DEFAULT_CHARACTER_POS, GameStrings.Get("VO_INNKEEPER_PLAY_STANDARD_TO_WILD"), "VO_INNKEEPER_Male_Dwarf_SetRotation_43.prefab:4b4ce858139927946905ec0d40d5b3c1");
 			Options.Get().SetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK, val: false);
@@ -3477,7 +3483,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		bool result = false;
 		if (num == 0 || num == 2 || num == 6)
 		{
-			if (UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
+			if (UserAttentionManager.CanShowAttentionGrabber(false, "DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
 			{
 				StartCoroutine(ShowWhizbangPopup(templateDeck));
 				num++;
@@ -3497,10 +3503,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		if (whizbangDeck != null)
 		{
 			yield return new WaitForSeconds(1f);
-			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+			var headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
+			var bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 			popupInfo.m_prefabAssetRefs.Add("WhizbangDialog_notification.prefab:89912cf72b2d5cf47820d2328de40f3f");
-			popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
-			popupInfo.m_bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			popupInfo.m_headerText = headerText;
+			popupInfo.m_bodyText = bodyText;
 			popupInfo.m_disableBnetBar = true;
 			DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.NONE, popupInfo);
 		}
@@ -3771,9 +3780,9 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	private IEnumerator ShowRotatedBoostersPopup(Action callbackOnHide = null)
 	{
 		yield return new WaitForSeconds(1f);
-		if (UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
 		{
-			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo("");
 			setRotationRotatedBoostersPopupInfo.m_onHiddenCallback = callbackOnHide;
 			DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, setRotationRotatedBoostersPopupInfo);
 			GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
@@ -3889,7 +3898,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			m_switchFormatButton.Enable();
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 	}
 
 	private bool ShouldShowStandardDeckVO(VisualsFormatType newVisualsFormatType)
@@ -3932,4 +3941,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			gameSaveDataManager.SaveSubkeys(list);
 		}
 	}
+
+    #region Accessibility
+
+    internal int GetCurrentPageIndex()
+    {
+		return m_currentPageIndex;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs b/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
index c663fd9..20a9eeb 100644
--- a/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
+++ b/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
@@ -5,8 +5,9 @@ using Blizzard.T5.Core;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class DeckTemplatePicker : MonoBehaviour
+public class DeckTemplatePicker : MonoBehaviour, AccessibleScreen
 {
 	public delegate void OnTemplateDeckChosen();
 
@@ -233,6 +234,8 @@ public class DeckTemplatePicker : MonoBehaviour
 					yield return null;
 				}
 			}
+
+			ReadDeckTemplatePicker();
 		}
 		else if (m_root.activeSelf)
 		{
@@ -243,7 +246,7 @@ public class DeckTemplatePicker : MonoBehaviour
 		}
 	}
 
-	private void SetupTemplateButtons(CollectionManager.TemplateDeck refDeck)
+    private void SetupTemplateButtons(CollectionManager.TemplateDeck refDeck)
 	{
 		List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
 		if (nonStarterTemplateDecks == null)
@@ -369,7 +372,7 @@ public class DeckTemplatePicker : MonoBehaviour
 	{
 		yield return new WaitForSeconds(0.5f);
 		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
+		if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
 		{
 			Transform deckTemplateTutorialWelcomeBone = collectionManagerDisplay.m_deckTemplateTutorialWelcomeBone;
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, deckTemplateTutorialWelcomeBone.localPosition, GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_WELCOME"), "VO_INNKEEPER_Male_Dwarf_RECIPE1_01.prefab:0261ef622a5e2b945a8f89e87cbe01a7", 3f);
@@ -484,6 +487,8 @@ public class DeckTemplatePicker : MonoBehaviour
 		{
 			action();
 		}
+
+		OnAccessibleDeckTemplateChosen(false);
 	}
 
 	public IEnumerator ShowTips()
@@ -578,6 +583,8 @@ public class DeckTemplatePicker : MonoBehaviour
 		{
 			collectionManagerDisplay.ShowStandardInfoTutorial(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
+
+		AccessibleCollectionManager.Get().OnEditDeckScreen();
 	}
 
 	private void ShowLowCardsPopup(Action confirmAction, Action cancelAction = null)
@@ -595,12 +602,14 @@ public class DeckTemplatePicker : MonoBehaviour
 				{
 				case AlertPopup.Response.CONFIRM:
 					confirmAction();
+						SetupTemplateChosen();
 					break;
 				case AlertPopup.Response.CANCEL:
 					if (cancelAction != null)
 					{
 						cancelAction();
 					}
+						m_curState = State.CHOOSING_TEMPLATE;
 					break;
 				}
 			}
@@ -637,6 +646,8 @@ public class DeckTemplatePicker : MonoBehaviour
 		{
 			ChooseRecipeAndFillInCards();
 		}
+
+		OnAccessibleDeckTemplateChosen(true);
 	}
 
 	public IEnumerator EnterDeckPhone()
@@ -644,4 +655,130 @@ public class DeckTemplatePicker : MonoBehaviour
 		yield return StartCoroutine(ShowPacks(show: false));
 		yield return StartCoroutine(HideTrays());
 	}
+
+	#region Accessibility
+
+	private enum State { LOADING, CHOOSING_TEMPLATE, TEMPLATE_CHOSEN, CUSTOM_DECK_CHOSEN };
+
+	private State m_curState;
+
+	private AccessibleHorizontalMenu<AccessibleDeckTemplatePickerButton> m_accessibleButtons;
+
+	private void ReadDeckTemplatePicker()
+    {
+		m_curState = State.LOADING;
+
+		AccessibilityMgr.SetScreen(this);
+
+		SetupChooseTemplateMenu();
+    }
+
+	private void SetupChooseTemplateMenu()
+    {
+		m_accessibleButtons = new AccessibleHorizontalMenu<AccessibleDeckTemplatePickerButton>(this, m_pageHeaderText.Text, () => AccessibilityUtils.GoBackToHub());
+
+		foreach (var deck in m_pickerButtons)
+        {
+			m_accessibleButtons.AddOption(new AccessibleDeckTemplatePickerButton(this, deck), () => deck.TriggerRelease());
+        }
+
+		m_accessibleButtons.AddOption(new AccessibleDeckTemplatePickerButton(this, m_customDeckButton, true), () => m_customDeckButton.TriggerRelease());
+
+		m_accessibleButtons.StartReading();
+
+		m_curState = State.CHOOSING_TEMPLATE;
+    }
+
+	private void OnAccessibleDeckTemplateChosen(bool isCustomDeck)
+    {
+		if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+			// Race conditions on preselect. It doesn't make sense to say this out loud unless we're choosing though
+			if (isCustomDeck)
+            {
+				SetupCustomDeckChosen();
+            }
+			else
+            {
+                SetupTemplateChosen();
+            }
+        }
+    }
+
+	private void SetupCustomDeckChosen()
+    {
+        AccessibilityMgr.Output(this, GetCustomDeckChooseHelpMessage());
+        m_curState = State.CUSTOM_DECK_CHOSEN;
+    }
+
+	private void SetupTemplateChosen()
+    {
+        AccessibilityMgr.Output(this, GetTemplateChooseHelpMessage());
+        m_curState = State.TEMPLATE_CHOSEN;
+    }
+
+    public void HandleInput()
+    {
+		if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            m_accessibleButtons?.HandleAccessibleInput();
+        }
+		else if (m_curState == State.TEMPLATE_CHOSEN || m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_chooseButton?.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				SetupChooseTemplateMenu();
+            }
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curState == State.TEMPLATE_CHOSEN)
+        {
+			return GetTemplateChooseHelpMessage();
+        }
+		else if (m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+			return GetCustomDeckChooseHelpMessage();
+        }
+		else if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            return m_accessibleButtons?.GetHelp();
+        }
+
+		return "";
+    }
+
+	private string GetCustomDeckChooseHelpMessage()
+    {
+        return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+    }
+
+	private string GetTemplateChooseHelpMessage()
+    {
+        return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+    }
+
+    public void OnGainedFocus()
+    {
+		if (m_curState == State.TEMPLATE_CHOSEN)
+        {
+            AccessibilityMgr.Output(this, GetTemplateChooseHelpMessage());
+        }
+		else if (m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+            AccessibilityMgr.Output(this, GetCustomDeckChooseHelpMessage());
+        }
+		else if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+			m_accessibleButtons.StartReading();
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs b/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
index e9c4c5b..55c2ee2 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class DeckTrayCardListContent : DeckTrayContent
@@ -543,10 +544,13 @@ public class DeckTrayCardListContent : DeckTrayContent
 			CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks(playSound: true);
 		}
 		DeckHelper.Get().OnCardAdded(editingDeck);
-		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber("DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
+		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber(false, "DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
 		{
-			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_PAGEFLIP_28"), "VO_INNKEEPER_CM_PAGEFLIP_28.prefab:47bb7bdb89ad93443ab7d031bbe666fb");
-			Options.Get().SetBool(Option.HAS_ADDED_CARDS_TO_DECK, val: true);
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_PAGEFLIP_28"), "VO_INNKEEPER_CM_PAGEFLIP_28.prefab:47bb7bdb89ad93443ab7d031bbe666fb");
+            }
+            Options.Get().SetBool(Option.HAS_ADDED_CARDS_TO_DECK, val: true);
 		}
 		return true;
 	}
@@ -897,12 +901,16 @@ public class DeckTrayCardListContent : DeckTrayContent
 		Transform removeCardTutorialBone = CollectionDeckTray.Get().m_removeCardTutorialBone;
 		if (m_deckHelpPopup == null)
 		{
-			m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, removeCardTutorialBone.position, removeCardTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL08"));
-			if (m_deckHelpPopup != null)
-			{
-				m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
-			}
-		}
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                // Visual notification
+                m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, removeCardTutorialBone.position, removeCardTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL08"));
+                if (m_deckHelpPopup != null)
+                {
+                    m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+                }
+            }
+        }
 	}
 
 	private void ShowDeckHelpButtonIfNeeded()
diff --git a/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs b/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
index f5ff7f0..038a3ed 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
@@ -46,9 +46,9 @@ public abstract class DeckTrayDeckListContent : DeckTrayContent
 
 	protected CollectionDeckInfo m_deckInfoTooltip;
 
-	protected List<TraySection> m_traySections = new List<TraySection>();
+	internal List<TraySection> m_traySections = new List<TraySection>();
 
-	protected TraySection m_editingTraySection;
+	internal TraySection m_editingTraySection;
 
 	protected int m_centeringDeckList = -1;
 
diff --git a/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs b/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs
index 4fd9e77..12e15fe 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayDeckTileVisual.cs
@@ -156,7 +156,7 @@ public class DeckTrayDeckTileVisual : PegUIElement
 		m_actor.UpdateGhostTileEffect();
 	}
 
-	private CollectionDeckTileActor.GhostedState GetGhostedState()
+	public CollectionDeckTileActor.GhostedState GetGhostedState()
 	{
 		if (m_deck != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/DialogBase.cs b/Decompiled/Assembly-CSharp/DialogBase.cs
index 73d74f2..33bf5a8 100644
--- a/Decompiled/Assembly-CSharp/DialogBase.cs
+++ b/Decompiled/Assembly-CSharp/DialogBase.cs
@@ -1,8 +1,10 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
+using System;
 
-public class DialogBase : MonoBehaviour
+public abstract class DialogBase : MonoBehaviour, AccessibleUI
 {
 	public delegate void HideCallback(DialogBase dialog, object userData);
 
@@ -88,6 +90,7 @@ public class DialogBase : MonoBehaviour
 
 	public virtual void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
 		m_shown = false;
 		StartCoroutine(HideWhenAble());
 	}
@@ -217,4 +220,8 @@ public class DialogBase : MonoBehaviour
 		fullScreenFXMgr.StopVignette();
 		fullScreenFXMgr.StopBlur();
 	}
+
+    public abstract void HandleAccessibleInput();
+
+    public abstract string GetAccessibleHelp();
 }
diff --git a/Decompiled/Assembly-CSharp/DialogManager.cs b/Decompiled/Assembly-CSharp/DialogManager.cs
index 879637e..8e9f094 100644
--- a/Decompiled/Assembly-CSharp/DialogManager.cs
+++ b/Decompiled/Assembly-CSharp/DialogManager.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using bgs;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
@@ -46,7 +47,8 @@ public class DialogManager : MonoBehaviour
 		BACON_CHALLENGE,
 		PRIVACY_POLICY,
 		GENERIC_BASIC_POPUP,
-		EXISTING_ACCOUNT_CN
+		EXISTING_ACCOUNT_CN,
+		EOE
 	}
 
 	public class DialogRequest
@@ -207,7 +209,7 @@ public class DialogManager : MonoBehaviour
 	public bool AddToQueue(DialogRequest request)
 	{
 		UserAttentionBlocker attentionCategory = request?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
 		{
 			return false;
 		}
@@ -216,14 +218,14 @@ public class DialogManager : MonoBehaviour
 		return true;
 	}
 
-	private void UpdateQueue()
+    private void UpdateQueue()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
 		{
 			return;
 		}
 		DialogRequest dialogRequest = m_dialogRequests.Peek();
-		if (!UserAttentionManager.CanShowAttentionGrabber(dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
 		{
 			Processor.ScheduleCallback(0.5f, realTime: false, delegate
 			{
@@ -239,7 +241,7 @@ public class DialogManager : MonoBehaviour
 	public void ShowPopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (!UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (!UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			DialogRequest dialogRequest = new DialogRequest();
 			dialogRequest.m_type = DialogType.ALERT;
@@ -264,7 +266,7 @@ public class DialogManager : MonoBehaviour
 	public bool ShowUniquePopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			return false;
 		}
@@ -599,7 +601,7 @@ public class DialogManager : MonoBehaviour
 		AddToQueue(dialogRequest);
 	}
 
-	public void ShowClassUpcomingPopup()
+    public void ShowClassUpcomingPopup()
 	{
 		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 		popupInfo.m_showAlertIcon = false;
@@ -612,7 +614,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowBonusStarsPopup(RankedPlayDataModel dataModel, Action onHiddenCallback)
 	{
-		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo
+		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -629,7 +631,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowRankedIntroPopUp(Action onHiddenCallback)
 	{
-		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo
+		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -696,7 +698,7 @@ public class DialogManager : MonoBehaviour
 			return;
 		}
 		NetCache.ProfileNoticeMedal profileNoticeMedal = profileNotice as NetCache.ProfileNoticeMedal;
-		if (profileNoticeMedal == null || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("DialogManager.MaybeShowSeasonEndDialog"))
+		if (profileNoticeMedal == null || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "DialogManager.MaybeShowSeasonEndDialog"))
 		{
 			return;
 		}
@@ -823,7 +825,7 @@ public class DialogManager : MonoBehaviour
 	{
 		DialogRequest dialogRequest = ((m_dialogRequests.Count == 0) ? null : m_dialogRequests.Peek());
 		UserAttentionBlocker attentionCategory = dialogRequest?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
+		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
 		{
 			m_loadingDialog = false;
 			UnityEngine.Object.DestroyImmediate(go);
@@ -1107,7 +1109,7 @@ public class DialogManager : MonoBehaviour
 		loginPopupSequencePopup.LoadAssetsAndShowWhenReady();
 	}
 
-	private void ProcessPrivacyPolicyRequest(DialogRequest request, PrivacyPolicyPopup privacyPolicyPopup)
+    private void ProcessPrivacyPolicyRequest(DialogRequest request, PrivacyPolicyPopup privacyPolicyPopup)
 	{
 		privacyPolicyPopup.SetInfo((PrivacyPolicyPopup.Info)request.m_info);
 		privacyPolicyPopup.Show();
@@ -1161,4 +1163,16 @@ public class DialogManager : MonoBehaviour
 		AddToQueue(request);
 		m_waitingToShowSeasonEndDialog = false;
 	}
+
+    #region Accessibility
+    internal AccessibleUI GetCurrentDialog()
+    {
+		return m_currentDialog;
+    }
+
+	internal int GetNumQueuedDialogs()
+    {
+		return m_dialogRequests.Count;
+    }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DraftDisplay.cs b/Decompiled/Assembly-CSharp/DraftDisplay.cs
index 846d55b..649565c 100644
--- a/Decompiled/Assembly-CSharp/DraftDisplay.cs
+++ b/Decompiled/Assembly-CSharp/DraftDisplay.cs
@@ -805,7 +805,7 @@ public class DraftDisplay : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
+		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
 		{
 			while (SceneMgr.Get().IsTransitioning())
 			{
@@ -1237,7 +1237,7 @@ public class DraftDisplay : MonoBehaviour
 
 	public void ShowInnkeeperInstructions()
 	{
-		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
+		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
 		{
 			if (!m_draftManager.HasSlotType(DraftSlotType.DRAFT_SLOT_HERO_POWER))
 			{
@@ -1245,13 +1245,13 @@ public class DraftDisplay : MonoBehaviour
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			}
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST2_20"), "VO_INNKEEPER_FORGE_INST2_20.prefab:242b6a30031534e47b1f8ddd69370eac", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, val: true);
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST3_21"), "VO_INNKEEPER_FORGE_INST3_21.prefab:06182dd3360965d4ea48952a6dd4a720", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, val: true);
@@ -1461,7 +1461,7 @@ public class DraftDisplay : MonoBehaviour
 			yield return new WaitForSeconds(0.3f);
 		}
 		ArenaTrayDisplay.Get().UpdateTray();
-		if (!UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowActiveDraftScreen"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowActiveDraftScreen"))
 		{
 			yield break;
 		}
@@ -1506,7 +1506,7 @@ public class DraftDisplay : MonoBehaviour
 		if (m_draftManager.ShouldActivateKey())
 		{
 			int maxWins = m_draftManager.GetMaxWins();
-			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
+			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_MAX_ARENA_WINS_04"), "VO_INNKEEPER_MAX_ARENA_WINS_04.prefab:cdf8e488f2d17604499f2cc358cb35f6");
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_MAX_WIN, val: true);
diff --git a/Decompiled/Assembly-CSharp/DraftManager.cs b/Decompiled/Assembly-CSharp/DraftManager.cs
index 8704e7d..578ecb8 100644
--- a/Decompiled/Assembly-CSharp/DraftManager.cs
+++ b/Decompiled/Assembly-CSharp/DraftManager.cs
@@ -8,6 +8,7 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class DraftManager : IService
 {
@@ -434,11 +435,14 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_responseUserData = CurrentSeasonId;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseCallback = delegate
@@ -468,11 +472,14 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseUserData = m_currentSeason.NextSeasonId;
 		popupInfo.m_responseCallback = delegate
@@ -618,7 +625,7 @@ public class DraftManager : IService
 		sessionRecord.RunFinished = true;
 		sessionRecord.SessionRecordType = SessionRecordType.ARENA;
 		BnetPresenceMgr.Get().SetGameFieldBlob(22u, sessionRecord);
-		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
+		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_1ST_REWARD"), "VO_INNKEEPER_ARENA_1ST_REWARD.prefab:660e915849550ae4085735866647d529");
 			Options.Get().SetBool(Option.HAS_ACKED_ARENA_REWARDS, val: true);
@@ -681,7 +688,7 @@ public class DraftManager : IService
 		{
 			DemoMgr.Get().CreateDemoText(GameStrings.Get("GLUE_BLIZZCON2013_ARENA_5_WINS"), unclickable: false, shouldDoArenaInstruction: false);
 		}
-		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
+		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_3RD_LOSS"), "VO_INNKEEPER_ARENA_3RD_LOSS.prefab:6b2af024c9980d344a087295afb5e3df");
 			Options.Get().SetBool(Option.HAS_LOST_IN_ARENA, val: true);
diff --git a/Decompiled/Assembly-CSharp/DropdownControl.cs b/Decompiled/Assembly-CSharp/DropdownControl.cs
index 4169bba..50003bd 100644
--- a/Decompiled/Assembly-CSharp/DropdownControl.cs
+++ b/Decompiled/Assembly-CSharp/DropdownControl.cs
@@ -43,7 +43,7 @@ public class DropdownControl : PegUIElement
 	{
 	};
 
-	private List<DropdownMenuItem> m_items = new List<DropdownMenuItem>();
+	internal List<DropdownMenuItem> m_items = new List<DropdownMenuItem>();
 
 	private Font m_overrideFont;
 
diff --git a/Decompiled/Assembly-CSharp/EditableDeckTrayDeckListContent.cs b/Decompiled/Assembly-CSharp/EditableDeckTrayDeckListContent.cs
index 2ad22aa..edd0916 100644
--- a/Decompiled/Assembly-CSharp/EditableDeckTrayDeckListContent.cs
+++ b/Decompiled/Assembly-CSharp/EditableDeckTrayDeckListContent.cs
@@ -5,6 +5,7 @@ using Hearthstone;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public abstract class EditableDeckTrayDeckListContent : DeckTrayDeckListContent
 {
@@ -469,6 +470,7 @@ public abstract class EditableDeckTrayDeckListContent : DeckTrayDeckListContent
 				UniversalInputManager.Get().CancelTextInput(base.gameObject);
 			}
 			deckBox.ShowDeckName();
+			AccessibleCollectionManager.Get().OnFinishRenamingDeck();
 		}
 	}
 
diff --git a/Decompiled/Assembly-CSharp/EndGameScreen.cs b/Decompiled/Assembly-CSharp/EndGameScreen.cs
index da9f003..861bdb2 100644
--- a/Decompiled/Assembly-CSharp/EndGameScreen.cs
+++ b/Decompiled/Assembly-CSharp/EndGameScreen.cs
@@ -8,6 +8,7 @@ using Hearthstone.UI;
 using PegasusShared;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class EndGameScreen : MonoBehaviour
@@ -173,6 +174,8 @@ public class EndGameScreen : MonoBehaviour
 	{
 		if (GameState.Get() == null || !GameState.Get().WasRestartRequested())
 		{
+			AccessibleEndGameScreen.Get().OnShow();
+
 			m_shown = true;
 			m_endGameScreenStartTime = Time.time;
 			Network.Get().DisconnectFromGameServer();
@@ -187,6 +190,8 @@ public class EndGameScreen : MonoBehaviour
 			}
 			ShowScoreScreen();
 			ShowStandardFlowIfReady();
+
+			AccessibleEndGameScreen.Get().OnShown(m_hitbox);
 		}
 	}
 
@@ -304,7 +309,7 @@ public class EndGameScreen : MonoBehaviour
 		{
 			return true;
 		}
-		if (ShowNextRewardTrackAutoClaimedReward())
+		if (ShowNextRewardTrackAutoClaimedReward()) // TODO
 		{
 			return true;
 		}
@@ -316,19 +321,19 @@ public class EndGameScreen : MonoBehaviour
 		{
 			return true;
 		}
-		if (ShowRankedCardBackProgress())
+		if (ShowRankedCardBackProgress()) // TODO Ranked only
 		{
 			return true;
 		}
-		if (ShowRankChange())
+		if (ShowRankChange()) // TODO Ranked only
 		{
 			return true;
 		}
-		if (ShowRankedRewards())
+		if (ShowRankedRewards()) // TODO Ranked only
 		{
 			return true;
 		}
-		if (ShowNextProgressionQuestReward())
+		if (ShowNextProgressionQuestReward()) // TODO
 		{
 			return true;
 		}
@@ -684,7 +689,7 @@ public class EndGameScreen : MonoBehaviour
 		{
 			yield return null;
 		}
-		m_twoScoop.Show();
+		m_twoScoop.Show(AccessibleEndGameScreen.Get());
 		if (!SpectatorManager.Get().IsSpectatingOrWatching && ShouldMakeUtilRequests())
 		{
 			InitGoldRewardUI();
diff --git a/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs b/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
index 75596b8..7fc934b 100644
--- a/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
+++ b/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class EndGameTwoScoop : MonoBehaviour
 {
@@ -54,7 +55,7 @@ public class EndGameTwoScoop : MonoBehaviour
 		return m_isShown;
 	}
 
-	public void Show(bool showXPBar = true)
+	public void Show(AccessibleComponent parent, bool showXPBar = true)
 	{
 		m_isShown = true;
 		base.gameObject.SetActive(value: true);
@@ -67,8 +68,9 @@ public class EndGameTwoScoop : MonoBehaviour
 			if (heroLevel == null)
 			{
 				HideXpBar();
-			}
-			else if (m_xpBarPrefab != null)
+                AccessibilityMgr.Output(parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+            }
+            else if (m_xpBarPrefab != null)
 			{
 				m_xpBar = Object.Instantiate(m_xpBarPrefab);
 				m_xpBar.transform.parent = m_heroActor.transform;
@@ -79,9 +81,13 @@ public class EndGameTwoScoop : MonoBehaviour
 				m_xpBar.m_isAnimated = true;
 				m_xpBar.m_delay = BAR_ANIMATION_DELAY;
 				m_xpBar.m_levelUpCallback = PlayLevelUpEffect;
-				m_xpBar.UpdateDisplay(heroLevel, totalLevel);
+				m_xpBar.UpdateDisplay(AccessibleEndGameScreen.Get(), heroLevel, totalLevel, true);
 			}
 		}
+		else
+        {
+			AccessibilityMgr.Output(parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
 	}
 
 	public void Hide()
diff --git a/Decompiled/Assembly-CSharp/Entity.cs b/Decompiled/Assembly-CSharp/Entity.cs
index 575cb2e..c644e5d 100644
--- a/Decompiled/Assembly-CSharp/Entity.cs
+++ b/Decompiled/Assembly-CSharp/Entity.cs
@@ -1578,6 +1578,22 @@ public class Entity : EntityBase
 		return entity;
 	}
 
+	public Entity CloneForAccessibility()
+	{
+		Entity entity = new Entity();
+		entity.m_duplicateForHistory = true;
+		entity.m_staticEntityDef = GetEntityDef();
+		entity.m_dynamicEntityDef = null;
+		entity.m_card = m_card;
+		entity.m_cardId = base.m_cardId;
+		entity.ReplaceTags(m_tags);
+		entity.m_subCardIDs = m_subCardIDs;
+		entity.m_loadState = m_loadState;
+		entity.m_displayedCreatorName = m_displayedCreatorName;
+		entity.m_enchantmentCreatorCardIDForPortrait = m_enchantmentCreatorCardIDForPortrait;
+		return entity;
+	}
+
 	public bool IsHistoryDupe()
 	{
 		return m_duplicateForHistory;
diff --git a/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs b/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
index 711b7e1..6aa4892 100644
--- a/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
+++ b/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using UnityEngine;
 
-public class ExistingAccountPopup : DialogBase
+public class ExistingAccountPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool hasAccount);
 
diff --git a/Decompiled/Assembly-CSharp/FatalErrorScene.cs b/Decompiled/Assembly-CSharp/FatalErrorScene.cs
index bf13053..b90b717 100644
--- a/Decompiled/Assembly-CSharp/FatalErrorScene.cs
+++ b/Decompiled/Assembly-CSharp/FatalErrorScene.cs
@@ -11,7 +11,7 @@ public class FatalErrorScene : PegasusScene
 		{
 			service.AppAbort();
 		}
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 		if (DialogManager.Get() != null)
 		{
 			DialogManager.Get().ClearAllImmediately();
@@ -34,7 +34,7 @@ public class FatalErrorScene : PegasusScene
 
 	public override void Unload()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StopBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 	}
 
 	private void OnFatalErrorScreenLoaded(AssetReference assetRef, GameObject go, object callbackData)
diff --git a/Decompiled/Assembly-CSharp/FatalErrorScreen.cs b/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
index 1fd2a6d..6dabcf6 100644
--- a/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
+++ b/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
@@ -4,8 +4,9 @@ using System.Collections.Generic;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
-public class FatalErrorScreen : MonoBehaviour
+public class FatalErrorScreen : MonoBehaviour, AccessibleScreen
 {
 	public UberText m_closedSignText;
 
@@ -126,6 +127,8 @@ public class FatalErrorScreen : MonoBehaviour
 		{
 			Processor.TerminateAllProcessing();
 		}
+
+		ReadScreen();
 	}
 
 	private void OnClick(UIEvent e)
@@ -165,4 +168,43 @@ public class FatalErrorScreen : MonoBehaviour
 		yield return new WaitForSeconds(waitDuration);
 		HearthstoneApplication.Get().Reset();
 	}
+
+    #region Accessibility
+
+	private void ReadScreen()
+    {
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_FATAL_ERROR_SCREEN_TITLE));
+
+		if (m_closedSignTitle != null && m_closedSignTitle.Text != null)
+        {
+			AccessibilityMgr.Output(this, m_closedSignTitle.Text);
+        }
+
+		if (m_closedSignText != null && m_closedSignText.Text != null)
+        {
+			AccessibilityMgr.Output(this, m_closedSignText.Text);
+        }
+
+        AccessibilityMgr.Output(this, GetHelp());
+    }
+
+    public void HandleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			HearthstoneApplication.Get().Exit();
+        }
+    }
+
+    public string GetHelp()
+    {
+		return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_EXIT, AccessibleKey.CONFIRM);
+    }
+
+    public void OnGainedFocus()
+    {
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs b/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
index 1fd1226..d4b8178 100644
--- a/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using PegasusShared;
 
-public class FiresideBrawlChoiceDialog : DialogBase
+public class FiresideBrawlChoiceDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(BrawlType choice);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs b/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
index e0b7eee..62167a6 100644
--- a/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideBrawlOkDialog : DialogBase
+using Accessibility;
+
+public class FiresideBrawlOkDialog : InaccessibleDialogBase
 {
 	public UIBButton m_okBrawlButton;
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
index e92d6c0..e693e45 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringFindEventDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringFindEventDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool search);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
index 213822a..4cdf1f6 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringInnkeeperSetupDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringInnkeeperSetupDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool search);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
index 5cad85e..4312358 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringJoinDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringJoinDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool joinFSG);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
index 8aab063..1dbaa12 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using System;
 using System.Collections.Generic;
 using UnityEngine;
 
-public class FiresideGatheringLocationHelperDialog : DialogBase
+public class FiresideGatheringLocationHelperDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs b/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
index dc1d0a9..3aec415 100644
--- a/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
+++ b/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
@@ -122,7 +122,7 @@ public class FixedRewardsMgr : IService
 
 	public bool ShowFixedRewards(UserAttentionBlocker blocker, HashSet<Achieve.RewardTiming> rewardVisualTimings, DelOnAllFixedRewardsShown allRewardsShownCallback, DelPositionNonToastReward positionNonToastRewardCallback)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs b/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
index 869b7b1..9adbc09 100644
--- a/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
+++ b/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
@@ -1,7 +1,8 @@
+using Accessibility;
 using System.Collections;
 using UnityEngine;
 
-public class FreeArenaWinDialog : DialogBase
+public class FreeArenaWinDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs b/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
index 798f7fc..7c79804 100644
--- a/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
+++ b/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
@@ -2239,7 +2239,7 @@ public class FriendChallengeMgr
 
 	private bool CanPromptReceivedChallenge()
 	{
-		bool flag = !UserAttentionManager.CanShowAttentionGrabber("FriendlyChallengeMgr.CanPromptReceivedChallenge");
+        bool flag = !UserAttentionManager.CanShowAttentionGrabber(false, "FriendlyChallengeMgr.CanPromptReceivedChallenge");
 		if (!flag)
 		{
 			if (GameMgr.Get().IsFindingGame())
@@ -2658,7 +2658,7 @@ public class FriendChallengeMgr
 		}
 		if (availabilityBlockerReasons == AvailabilityBlockerReasons.NONE)
 		{
-			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: true);
+			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: true);
 		}
 		if (availabilityBlockerReasons != 0)
 		{
diff --git a/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs b/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
index 022dbc0..acb78fe 100644
--- a/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
+++ b/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
@@ -147,7 +147,7 @@ public class FriendListFSGFrame : FriendListUIElement
 	private bool ShouldEnableEnterButton()
 	{
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
-		if (UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: false) != 0 || mode == SceneMgr.Mode.FIRESIDE_GATHERING)
+		if (UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: false) != 0 || mode == SceneMgr.Mode.FIRESIDE_GATHERING)
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs b/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
index f080666..7765b04 100644
--- a/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
+++ b/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
@@ -1,5 +1,6 @@
 using System;
 using System.Collections;
+using Accessibility;
 using bgs;
 using Hearthstone.Core;
 using Hearthstone.DataModels;
@@ -9,7 +10,7 @@ using PegasusShared;
 using SpectatorProto;
 using UnityEngine;
 
-public class FriendlyChallengeDialog : DialogBase
+public class FriendlyChallengeDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool accept);
 
diff --git a/Decompiled/Assembly-CSharp/GAME_TAG.cs b/Decompiled/Assembly-CSharp/GAME_TAG.cs
index f999768..9465a6c 100644
--- a/Decompiled/Assembly-CSharp/GAME_TAG.cs
+++ b/Decompiled/Assembly-CSharp/GAME_TAG.cs
@@ -560,5 +560,6 @@ public enum GAME_TAG
 	BACON_VERDANTSPHERES = 1598,
 	METAMORPHOSIS = 1644,
 	BACON_AVALANCHE = 1744,
-	BACON_COMEONECOMEALL = 1789
+	BACON_COMEONECOMEALL = 1789,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/GameEntity.cs b/Decompiled/Assembly-CSharp/GameEntity.cs
index 5c1cf15..0ede2f8 100644
--- a/Decompiled/Assembly-CSharp/GameEntity.cs
+++ b/Decompiled/Assembly-CSharp/GameEntity.cs
@@ -1347,4 +1347,13 @@ public class GameEntity : Entity
 	public virtual void OnTurnTimerEnded(bool isFriendlyPlayerTurnTimer)
 	{
 	}
+
+    #region Turn Counter missions
+
+    public virtual bool IsTurnCounterBasedMission()
+    {
+		return false;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMenu.cs b/Decompiled/Assembly-CSharp/GameMenu.cs
index d544e5f..2388568 100644
--- a/Decompiled/Assembly-CSharp/GameMenu.cs
+++ b/Decompiled/Assembly-CSharp/GameMenu.cs
@@ -3,9 +3,11 @@ using bgs;
 using Hearthstone;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class GameMenu : ButtonListMenu, GameMenuInterface
+public class GameMenu : ButtonListMenu, GameMenuInterface, AccessibleUI
 {
 	[CustomEditField(Sections = "Template Items")]
 	public Vector3 m_ratingsObjectMinPadding = new Vector3(0f, 0f, -0.06f);
@@ -72,22 +74,22 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		ButtonListMenu.MakeButtonRed(m_endGameButton, m_redButtonMaterial);
 		m_leaveButton = CreateMenuButton("LeaveButton", "GLOBAL_LEAVE_SPECTATOR_MODE", LeaveButtonPressed);
 		m_restartButton = CreateMenuButton("RestartButton", "GLOBAL_RESTART", RestartButtonPressed);
-		if ((bool)HearthstoneApplication.CanQuitGame)
-		{
-			m_quitButton = CreateMenuButton("QuitButton", "GLOBAL_QUIT", QuitButtonPressed);
-		}
 		if (PlatformSettings.IsMobile())
 		{
 			m_loginButton = CreateMenuButton("LogoutButton", Network.ShouldBeConnectedToAurora() ? "GLOBAL_SWITCH_ACCOUNT" : "GLOBAL_LOGIN", LogoutButtonPressed);
 		}
+		if (m_menu.m_templateSignUpButton != null)
+		{
+			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+		}
 		m_optionsButton = CreateMenuButton("OptionsButton", "GLOBAL_OPTIONS", OptionsButtonPressed);
 		if (m_menu.m_templateDownloadButton != null)
 		{
 			m_downloadButton = CreateMenuButton("AssetDownloadButton", "GLOBAL_ASSET_DOWNLOAD", AssetDownloadButtonPressed, m_menu.m_templateDownloadButton);
 		}
-		if (m_menu.m_templateSignUpButton != null)
+		if ((bool)HearthstoneApplication.CanQuitGame)
 		{
-			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+			m_quitButton = CreateMenuButton("QuitButton", "GLOBAL_QUIT", QuitButtonPressed);
 		}
 		m_menu.m_headerText.Text = GameStrings.Get("GLOBAL_GAME_MENU");
 	}
@@ -160,6 +162,8 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		}
 		ShowLoginTooltipIfNeeded();
 		BnetBar.Get().m_menuButton.SetSelected(enable: true);
+
+		ReadMenu();
 	}
 
 	public override void Hide()
@@ -167,7 +171,13 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		base.Hide();
 		HideLoginTooltip();
 		BnetBar.Get().m_menuButton.SetSelected(enable: false);
-	}
+
+		if (!m_gameMenuBase.TransitioningToOptionsMenu)
+        {
+			// Don't hide when transitioning as we would just regain + lose focus on the main menu screen instantly (causing us to start reading it)
+            AccessibilityMgr.HideUI(this);
+        }
+    }
 
 	public void ShowLoginTooltipIfNeeded()
 	{
@@ -433,4 +443,41 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 			}
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadMenu()
+    {
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GAME_MENU_TITLE, CloseMainMenu, true);
+
+		foreach (var btn in m_allButtons)
+        {
+			if (btn.gameObject.activeInHierarchy && btn.IsEnabled())
+            {
+                m_accessibleMenu.AddOption(btn.GetText(), () => btn.TriggerRelease());
+            }
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleMenu.StartReading();
+    }
+
+    public void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    private void CloseMainMenu()
+    {
+		BnetBar.Get().HideGameMenu();
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMenuBase.cs b/Decompiled/Assembly-CSharp/GameMenuBase.cs
index f436c1b..64fc087 100644
--- a/Decompiled/Assembly-CSharp/GameMenuBase.cs
+++ b/Decompiled/Assembly-CSharp/GameMenuBase.cs
@@ -18,7 +18,9 @@ public class GameMenuBase
 
 	public void ShowOptionsMenu()
 	{
-		if (m_hideCallback != null)
+        TransitioningToOptionsMenu = true;
+
+        if (m_hideCallback != null)
 		{
 			m_hideCallback();
 		}
@@ -35,9 +37,11 @@ public class GameMenuBase
 		{
 			SwitchToOptionsMenu();
 		}
-	}
 
-	public void DestroyOptionsMenu()
+        TransitioningToOptionsMenu = false;
+    }
+
+    public void DestroyOptionsMenu()
 	{
 		if (m_optionsMenu != null)
 		{
@@ -74,4 +78,8 @@ public class GameMenuBase
 			m_showCallback();
 		}
 	}
+
+	#region Accessibility
+	internal bool TransitioningToOptionsMenu { get; set; }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMgr.cs b/Decompiled/Assembly-CSharp/GameMgr.cs
index 5a9c106..904199a 100644
--- a/Decompiled/Assembly-CSharp/GameMgr.cs
+++ b/Decompiled/Assembly-CSharp/GameMgr.cs
@@ -13,6 +13,7 @@ using PegasusShared;
 using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 public class GameMgr : IService
 {
@@ -664,22 +665,64 @@ public class GameMgr : IService
 		switch (m_missionId)
 		{
 		case 3:
-			gameEntity = new Tutorial_01();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_01();
+            }
+            else
+            {
+                gameEntity = new Tutorial_01();
+            }
 			break;
 		case 4:
-			gameEntity = new Tutorial_02();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_02();
+            }
+            else
+            {
+                gameEntity = new Tutorial_02();
+            }
 			break;
 		case 181:
-			gameEntity = new Tutorial_03();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_03();
+            }
+            else
+            {
+                gameEntity = new Tutorial_03();
+            }
 			break;
 		case 201:
-			gameEntity = new Tutorial_04();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_04();
+            }
+            else
+            {
+                gameEntity = new Tutorial_04();
+            }
 			break;
 		case 248:
-			gameEntity = new Tutorial_05();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_05();
+            }
+            else
+            {
+                gameEntity = new Tutorial_05();
+            }
 			break;
 		case 249:
-			gameEntity = new Tutorial_06();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_06();
+            }
+            else
+            {
+                gameEntity = new Tutorial_06();
+            }
 			break;
 		case 273:
 		case 300:
diff --git a/Decompiled/Assembly-CSharp/GameModeDisplay.cs b/Decompiled/Assembly-CSharp/GameModeDisplay.cs
index 35d1811..8a5169d 100644
--- a/Decompiled/Assembly-CSharp/GameModeDisplay.cs
+++ b/Decompiled/Assembly-CSharp/GameModeDisplay.cs
@@ -4,6 +4,7 @@ using System.Linq;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class GameModeDisplay : MonoBehaviour
 {
@@ -29,9 +30,9 @@ public class GameModeDisplay : MonoBehaviour
 
 	public List<string> m_tavernBrawlEnterCrowdSounds;
 
-	private PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
-	private UIBButton m_backButton;
+	internal UIBButton m_backButton;
 
 	private bool m_playButtonFinishedLoading;
 
@@ -226,6 +227,8 @@ public class GameModeDisplay : MonoBehaviour
 				IsBeta = isBeta
 			});
 		}
+
+		AccessibleGameModeScene.Get().OnDisplayReady(gameModeSceneDataModel);
 	}
 
 	private bool ShouldShowNewBanner(GameModeDbfRecord gameModeRecord)
@@ -242,7 +245,7 @@ public class GameModeDisplay : MonoBehaviour
 		switch (EnumUtils.Parse<SceneMgr.Mode>(gameModeRecord.LinkedScene))
 		{
 		case SceneMgr.Mode.TAVERN_BRAWL:
-			if (UserAttentionManager.CanShowAttentionGrabber("Hub.TavernBrawl.IsFirstTimeSeeingCurrentSeason") && ShouldSeeNewTavernBrawlBanner())
+			if (UserAttentionManager.CanShowAttentionGrabber(false, "Hub.TavernBrawl.IsFirstTimeSeeingCurrentSeason") && ShouldSeeNewTavernBrawlBanner())
 			{
 				s_hasAlreadyShownTavernBrawlNewBanner = true;
 				return true;
@@ -403,6 +406,12 @@ public class GameModeDisplay : MonoBehaviour
 
 	public static bool ShouldSeeNewTavernBrawlBanner()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Not implemented yet
+			return false;
+		}
+
 		if (s_hasAlreadyShownTavernBrawlNewBanner)
 		{
 			return false;
@@ -446,26 +455,11 @@ public class GameModeDisplay : MonoBehaviour
 			return;
 		}
 		m_selectedGameModeButtonDataModel = (GameModeButtonDataModel)eventDataModel.Payload;
-		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.GAME_MODE_SCENE, GameSaveKeySubkeyId.GAME_MODE_SCENE_LAST_SELECTED_GAME_MODE, m_selectedGameModeButtonDataModel.GameModeRecordId));
-		GameModeSceneDataModel gameModeSceneDataModel = GetGameModeSceneDataModel();
-		if (gameModeSceneDataModel != null)
-		{
-			gameModeSceneDataModel.LastSelectedGameModeRecordId = m_selectedGameModeButtonDataModel.GameModeRecordId;
-		}
-		if (!CanEnterMode(out var reason))
-		{
-			m_playButton.Disable(keepLabelTextVisible: true);
-			m_lockedNameText.Text = GameStrings.Format(reason, m_selectedGameModeButtonDataModel.Name);
-			m_gameModeButtonController.SetState("GAME_MODE_LOCKED");
-		}
-		else
-		{
-			m_playButton.Enable();
-			m_gameModeButtonController.SetState("GAME_MODE_ACTIVE");
-		}
+
+		OnGameModeSelectedPart2();
 	}
 
-	private void ShowDisabledPopupForCurrentMode(string lockReason)
+    private void ShowDisabledPopupForCurrentMode(string lockReason)
 	{
 		if (!string.IsNullOrEmpty(lockReason))
 		{
@@ -489,4 +483,34 @@ public class GameModeDisplay : MonoBehaviour
 		};
 		DialogManager.Get().ShowPopup(info);
 	}
+
+	#region Accessibility
+	internal void SelectMode(GameModeButtonDataModel gameModeButtonDataModel)
+    {
+		m_selectedGameModeButtonDataModel = gameModeButtonDataModel;
+		OnGameModeSelectedPart2();
+    } 
+
+    private void OnGameModeSelectedPart2()
+    {
+		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.GAME_MODE_SCENE, GameSaveKeySubkeyId.GAME_MODE_SCENE_LAST_SELECTED_GAME_MODE, m_selectedGameModeButtonDataModel.GameModeRecordId));
+		GameModeSceneDataModel gameModeSceneDataModel = GetGameModeSceneDataModel();
+		if (gameModeSceneDataModel != null)
+		{
+			gameModeSceneDataModel.LastSelectedGameModeRecordId = m_selectedGameModeButtonDataModel.GameModeRecordId;
+		}
+		if (!CanEnterMode(out var reason))
+		{
+			m_playButton.Disable(keepLabelTextVisible: true);
+			m_lockedNameText.Text = GameStrings.Format(reason, m_selectedGameModeButtonDataModel.Name);
+			m_gameModeButtonController.SetState("GAME_MODE_LOCKED");
+		}
+		else
+		{
+			m_playButton.Enable();
+			m_gameModeButtonController.SetState("GAME_MODE_ACTIVE");
+		}
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameModeUtils.cs b/Decompiled/Assembly-CSharp/GameModeUtils.cs
index 494224c..27e4c00 100644
--- a/Decompiled/Assembly-CSharp/GameModeUtils.cs
+++ b/Decompiled/Assembly-CSharp/GameModeUtils.cs
@@ -4,6 +4,8 @@ public static class GameModeUtils
 {
 	public static bool CanAccessGameModes()
 	{
+		return true;
+
 		if (!AchieveManager.Get().HasUnlockedDefaultHeroes())
 		{
 			return TavernBrawlManager.Get().HasUnlockedTavernBrawl(BrawlType.BRAWL_TYPE_TAVERN_BRAWL);
@@ -13,6 +15,8 @@ public static class GameModeUtils
 
 	public static bool ShouldSeeSoloAdventuresMovedPopup()
 	{
+		return false;
+
 		GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.FTUE_SHOULD_SEE_SOLO_ADVENTURES_MOVED_POPUP, out long value);
 		return value > 0;
 	}
diff --git a/Decompiled/Assembly-CSharp/GameState.cs b/Decompiled/Assembly-CSharp/GameState.cs
index 4d0f248..1ccb464 100644
--- a/Decompiled/Assembly-CSharp/GameState.cs
+++ b/Decompiled/Assembly-CSharp/GameState.cs
@@ -7,6 +7,7 @@ using System.Text;
 using Assets;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class GameState
 {
@@ -16,14 +17,16 @@ public class GameState
 		OPTION,
 		SUB_OPTION,
 		OPTION_TARGET,
-		CHOICE
+		CHOICE,
+		EOE
 	}
 
 	public enum CreateGamePhase
 	{
 		INVALID,
 		CREATING,
-		CREATED
+		CREATED,
+		EOE
 	}
 
 	public delegate void GameStateInitializedCallback(GameState instance, object userData);
@@ -1403,6 +1406,12 @@ public class GameState
 
 	public bool CanShowScoreScreen()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            // The modes that use this screen are not implemented yet
+            return false;
+        }
+
 		if (HasScoreLabels(m_gameEntity))
 		{
 			return true;
@@ -1807,6 +1816,14 @@ public class GameState
 		{
 			return false;
 		}
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePowerTaskListDescriber.IsBusy())
+        {
+			return false;
+        }
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePlayDescriber.Get().IsBusy())
+        {
+			return false;
+        }
 		return true;
 	}
 
@@ -2458,6 +2475,7 @@ public class GameState
 
 	private void FireCreateGameEvent()
 	{
+		AccessiblePowerTaskListDescriber.OnGameStart();
 		CreateGameListener[] array = m_createGameListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
@@ -4158,6 +4176,7 @@ public class GameState
 				m_createGameListeners.Clear();
 			}
 		}
+		taskList.FireCompleteEvent();
 		RemoveQueuedEntitiesFromGame();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/GameStringTable.cs b/Decompiled/Assembly-CSharp/GameStringTable.cs
index 62cdfe4..f60e531 100644
--- a/Decompiled/Assembly-CSharp/GameStringTable.cs
+++ b/Decompiled/Assembly-CSharp/GameStringTable.cs
@@ -83,7 +83,7 @@ public class GameStringTable
 		return true;
 	}
 
-	public string Get(string key)
+    public string Get(string key)
 	{
 		m_table.TryGetValue(key, out var value);
 		return value;
diff --git a/Decompiled/Assembly-CSharp/GameStrings.cs b/Decompiled/Assembly-CSharp/GameStrings.cs
index de791dc..029993f 100644
--- a/Decompiled/Assembly-CSharp/GameStrings.cs
+++ b/Decompiled/Assembly-CSharp/GameStrings.cs
@@ -844,6 +844,8 @@ public class GameStrings
 		}
 		float realtimeSinceStartup2 = Time.realtimeSinceStartup;
 		Log.Performance.Print($"Loading All GameStrings took {realtimeSinceStartup2 - realtimeSinceStartup}s)");
+
+		DefaultGameStrings.LoadAll(); // Accessibility
 	}
 
 	public static IEnumerator<IAsyncJobResult> Job_LoadAll()
@@ -854,7 +856,12 @@ public class GameStrings
 			if (value != 0)
 			{
 				jobResultCollection.Add(CreateLoadCategoryJob(value, native: false));
-			}
+
+				if (value == Global.GameStringCategory.ACCESSIBILITY)
+                {
+                    jobResultCollection.Add(DefaultGameStrings.CreateLoadCategoryJob(value, native: false));
+                }
+            }
 		}
 		yield return jobResultCollection;
 	}
@@ -900,6 +907,7 @@ public class GameStrings
 	public static void LoadNative()
 	{
 		ReloadAllInternal(native: true);
+		DefaultGameStrings.LoadNative();
 	}
 
 	public static string GetAssetPath(Locale locale, string fileName, bool native = false)
@@ -1862,4 +1870,26 @@ public class GameStrings
 			return 1;
 		}
 	}
+
+	#region Accessibility - Used for regression testing
+
+	public static List<string> FindKeysWithValue(string value)
+	{
+		var ret = new List<string>();
+		foreach (GameStringTable table in s_tables.Values)
+		{
+			var values = table.GetAll();
+
+			foreach (var entry in values)
+            {
+				if (entry.Value.Equals(value))
+                {
+					ret.Add(entry.Key);
+                }
+            }
+		}
+		return ret;
+	}
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameUtils.cs b/Decompiled/Assembly-CSharp/GameUtils.cs
index a79ae24..8f1de60 100644
--- a/Decompiled/Assembly-CSharp/GameUtils.cs
+++ b/Decompiled/Assembly-CSharp/GameUtils.cs
@@ -12,6 +12,7 @@ using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
 using UnityEngine.Events;
+using Accessibility;
 
 public class GameUtils
 {
@@ -1666,6 +1667,9 @@ public class GameUtils
 
 	public static bool ShouldUseLegacyTutorialFlow()
 	{
+		// New flow breaks accessibility
+		return true;
+
 		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
 		if (netObject == null)
 		{
@@ -2207,6 +2211,12 @@ public class GameUtils
 		{
 			return false;
 		}
+
+		if (HearthstoneAccessConstants.DEV_MODE)
+        {
+			return true;
+        }
+
 		return Options.Get().GetBool(Option.FAKE_PACK_OPENING);
 	}
 
@@ -2216,6 +2226,12 @@ public class GameUtils
 		{
 			return 0;
 		}
+
+		if (HearthstoneAccessConstants.DEV_MODE)
+        {
+			return 17;
+        }
+
 		return Options.Get().GetInt(Option.FAKE_PACK_COUNT);
 	}
 
diff --git a/Decompiled/Assembly-CSharp/Gameplay.cs b/Decompiled/Assembly-CSharp/Gameplay.cs
index aca5b0b..259abb3 100644
--- a/Decompiled/Assembly-CSharp/Gameplay.cs
+++ b/Decompiled/Assembly-CSharp/Gameplay.cs
@@ -107,6 +107,7 @@ public class Gameplay : PegasusScene
 
 	private void Start()
 	{
+		Accessibility.AccessibleGameplay.Get().OnGameplayScreenStart();
 		Log.LoadingScreen.Print("Gameplay.Start()");
 		CheckBattleNetConnection();
 		Network network = Network.Get();
diff --git a/Decompiled/Assembly-CSharp/GameplayErrorManager.cs b/Decompiled/Assembly-CSharp/GameplayErrorManager.cs
index e7e7462..6857df7 100644
--- a/Decompiled/Assembly-CSharp/GameplayErrorManager.cs
+++ b/Decompiled/Assembly-CSharp/GameplayErrorManager.cs
@@ -3,6 +3,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
 using UnityEngine;
+using Accessibility;
 
 public class GameplayErrorManager : IService
 {
@@ -79,6 +80,7 @@ public class GameplayErrorManager : IService
 		m_uberText.gameObject.transform.localPosition = Data.m_mobileTextAdjustment;
 		s_messageInstance.ShowMessage(m_message, m_displaySecsLeft);
 		SoundManager.Get().LoadAndPlay("UI_no_can_do.prefab:7b1a22774f818544387c0f2ca4fea02c");
+		AccessibilityMgr.Output(AccessibleGameplay.Get(), message);
 	}
 
 	private void HideMessage()
diff --git a/Decompiled/Assembly-CSharp/GeneralStore.cs b/Decompiled/Assembly-CSharp/GeneralStore.cs
index c4ef35a..9173904 100644
--- a/Decompiled/Assembly-CSharp/GeneralStore.cs
+++ b/Decompiled/Assembly-CSharp/GeneralStore.cs
@@ -495,7 +495,7 @@ public class GeneralStore : Store
 		FriendChallengeMgr.Get().OnStoreOpened();
 		PreRender();
 		PresenceMgr.Get().SetStatus(Global.PresenceStatus.STORE);
-		if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_SEEN_GOLD_QTY_INSTRUCTION, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("GeneralStore.Show:" + Option.HAS_SEEN_GOLD_QTY_INSTRUCTION) && NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().GetTotal() >= MIN_GOLD_FOR_CHANGE_QTY_TOOLTIP)
+		if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_SEEN_GOLD_QTY_INSTRUCTION, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "GeneralStore.Show:" + Option.HAS_SEEN_GOLD_QTY_INSTRUCTION) && NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().GetTotal() >= MIN_GOLD_FOR_CHANGE_QTY_TOOLTIP)
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 			popupInfo.m_attentionCategory = UserAttentionBlocker.NONE;
@@ -897,7 +897,7 @@ public class GeneralStore : Store
 			yield return null;
 		}
 		int currencyChangedVersion = StoreManager.Get().GetCurrencyChangedVersion();
-		if (currencyChangedVersion != 0 && currencyChangedVersion != Options.Get().GetInt(Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION) && UserAttentionManager.CanShowAttentionGrabber("GeneralStore.AnimateAndUpdateStoreMode:" + Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION))
+		if (currencyChangedVersion != 0 && currencyChangedVersion != Options.Get().GetInt(Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION) && UserAttentionManager.CanShowAttentionGrabber(false, "GeneralStore.AnimateAndUpdateStoreMode:" + Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION))
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 			popupInfo.m_attentionCategory = UserAttentionBlocker.NONE;
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs b/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
index cf437bb..c472fad 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
@@ -92,6 +92,37 @@ namespace Hearthstone
 			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
 		}
 
+		public void ExceptionReportInitializeDebug()
+		{
+			ExceptionReporter.Get().Initialize(FileUtils.PersistentDataPath, m_logger, HearthstoneApplication.Get());
+			ExceptionReporter.Get().IsInDebugMode = true;
+			ExceptionReporter.Get().SendExceptions = false;
+			ExceptionReporter.Get().SendAsserts = false;
+			ExceptionReporter.Get().SendErrors = false;
+			ExceptionSettings exceptionSettings = new ExceptionSettings();
+			exceptionSettings.m_projectID = 70;
+			exceptionSettings.m_moduleName = "Hearthstone Client";
+			exceptionSettings.m_version = "20.8";
+			exceptionSettings.m_branchName = Network.BranchName;
+			exceptionSettings.m_buildNumber = 86601;
+			exceptionSettings.m_locale = Localization.GetLocaleName();
+			exceptionSettings.m_jiraProjectName = "HSTN";
+			exceptionSettings.m_jiraComponent = "T5QA Confirmation";
+			exceptionSettings.m_jiraVersion = "20.8 Patch";
+			exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.BUG] = -1;
+			if (HearthstoneApplication.IsInternal())
+			{
+				exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.EXCEPTION] = 0;
+			}
+			exceptionSettings.m_logPathsCallback = GetLogPaths;
+			exceptionSettings.m_attachableFilesCallback = GetAttachableFiles;
+			exceptionSettings.m_additionalInfoCallback = GetAdditionalInfo;
+			exceptionSettings.m_readFileMethodCallback = ReadLogFileSharing;
+			ExceptionReporter.Get().BeforeZipping += FlushAllLogs;
+			ExceptionReporter.Get().SetSettings(exceptionSettings);
+			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
+		}
+
 		public void ControlANRMonitor(bool on)
 		{
 			if (PlatformSettings.IsMobileRuntimeOS && (on ^ m_ANRMonitorOn))
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs b/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
index acd6d24..13913e2 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
@@ -5,6 +5,7 @@ using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Threading;
+using Accessibility;
 using Blizzard.BlizzardErrorMobile;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
@@ -51,6 +52,10 @@ namespace Hearthstone
 		};
 
 		private static bool s_initializedMode = false;
+		//private static bool s_initializedMode = true; // Dev mode
+
+		private static ApplicationMode s_mode = ApplicationMode.PUBLIC;
+		//private static ApplicationMode s_mode = ApplicationMode.INTERNAL; // Dev mode
 
 		private static string[] s_cachedCmdLineArgs = null;
 
@@ -78,8 +83,6 @@ namespace Hearthstone
 
 		private float m_unloadUnusedAssetsDelay;
 
-		private static ApplicationMode s_mode = ApplicationMode.INVALID;
-
 		private static HearthstoneApplication s_instance = null;
 
 		private static int s_mainThreadId = -1;
@@ -164,8 +167,10 @@ namespace Hearthstone
 			UpdateWorkingDirectory();
 			LocalOptions.Get().Initialize();
 			Localization.Initialize();
+			AccessibilityMgr.Initialize(gameObject);
+			//AccessibleHearthstoneApplication.OnLoading();
 			LaunchArguments.ReadLaunchArgumentsFromDeeplink();
-			ApplyInitializationSettingsFromConfig();
+            ApplyInitializationSettingsFromConfig();
 			Processor.UseJobQueueAlerts = !IsPublic();
 			PreviousInstanceStatus.ReportAppStatus();
 			new JobQueueTelemetry(Processor.JobQueue, Processor.JobQueueAlerts, TestType);
@@ -193,7 +198,8 @@ namespace Hearthstone
 		{
 			HsAppsFlyer.Initialize(60);
 			TelemetryManager.Initialize();
-			ExceptionReporterControl.Get().ExceptionReportInitialize();
+			// ExceptionReporterControl.Get().ExceptionReportInitialize(); // Remove so we don't send Blizzard exceptions that may be caused by us
+			ExceptionReporterControl.Get().ExceptionReportInitializeDebug();
 			HearthstonePerformance.Initialize(TestType, 2307301.ToString());
 			HearthstonePerformance.Get()?.CaptureAppStartTime();
 			AppLaunchTracker.TrackAppLaunch();
@@ -207,6 +213,8 @@ namespace Hearthstone
 
 		private void OnApplicationQuit()
 		{
+			AccessibleHearthstoneApplication.OnClosing();
+			AccessibilityMgr.Shutdown();
 			IsHearthstoneClosing = true;
 			UberText.StoreCachedData();
 			if (this.OnShutdown != null)
@@ -452,6 +460,7 @@ namespace Hearthstone
 		{
 			WaitForGameDownloadManagerState waitForGameDownloadManagerState = new WaitForGameDownloadManagerState();
 			JobDefinition jobDefinition = new JobDefinition("GameStrings.LoadAll", GameStrings.Job_LoadAll(), waitForGameDownloadManagerState);
+			jobDefinition.AddJobFinishedEventListener(OnGameStringsLoaded);
 			Processor.QueueJob("HearthstoneApplication.CacheCommandLineArgs", Job_CacheCommandLineArgs());
 			Processor.QueueJob("HearthstoneApplication.InitializeMode", Job_InitializeMode());
 			Processor.QueueJob(jobDefinition);
@@ -466,7 +475,12 @@ namespace Hearthstone
 			Processor.QueueJob(HearthstoneJobs.CreateJobFromDependency("Load_CardColorSwitcher", new InstantiatePrefab("CardColorSwitcher.prefab:b30c8322821f1524d9e08a59e78e2c85"), waitForGameDownloadManagerState, typeof(GameDownloadManager), typeof(SceneMgr), typeof(IAssetLoader)));
 		}
 
-		private void InitializeGlobalDataContext()
+        private void OnGameStringsLoaded(JobDefinition job, bool success)
+        {
+			AccessibleHearthstoneApplication.OnLoading();
+        }
+
+        private void InitializeGlobalDataContext()
 		{
 			DataContext dataContext = GlobalDataContext.Get();
 			dataContext.BindDataModel(new DeviceDataModel
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs b/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
index 180e21a..6ffe488 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
@@ -7,10 +7,11 @@ using Blizzard.T5.Services;
 using Hearthstone.Core;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.InGameMessage.UI
 {
-	public class MessagePopupDisplay : IService
+	public class MessagePopupDisplay : IService, AccessibleUI
 	{
 		private static readonly AssetReference m_modalMessageReference = new AssetReference("MessageModal.prefab:7d258ca7826c5ba4c8e86d37eb6e909d");
 
@@ -127,6 +128,7 @@ namespace Hearthstone.InGameMessage.UI
 			{
 				m_messageModal.SetMessage(dataToDisplay);
 				m_modalWidget.Show();
+				ReadMessage(dataToDisplay);
 			}
 			catch (Exception ex)
 			{
@@ -143,7 +145,7 @@ namespace Hearthstone.InGameMessage.UI
 			}
 		}
 
-		private void OnModalWidgetReady(object _)
+        private void OnModalWidgetReady(object _)
 		{
 			if (m_modalWidget != null)
 			{
@@ -169,6 +171,7 @@ namespace Hearthstone.InGameMessage.UI
 
 		private void OnMessageClosed()
 		{
+			AccessibilityMgr.HideUI(this);
 			m_currentlyDisplayedMessage = null;
 			DeactivateFullscreenBlur();
 			DestroyModal();
@@ -196,5 +199,58 @@ namespace Hearthstone.InGameMessage.UI
 			BnetBar.Get()?.CancelRequestToDisableButtons();
 			FullScreenFXMgr.Get().EndStandardBlurVignette(1f);
 		}
-	}
+
+		#region Accessibility
+
+        private void ReadMessage(MessageUIData data)
+        {
+			List<IDataModel> list = MessageDataModelFactory.CreateDataModel(data);
+
+			if (list == null)
+            {
+				m_messageModal.OnClosePressed();
+				return;
+            }
+
+			foreach (var item in list)
+            {
+				switch (item)
+                {
+					case TextMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TextBody);
+						break;
+					case ShopMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TextBody);
+						break;
+					case TestDebugMessageUIData i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TestString);
+						break;
+					default:
+                        m_messageModal.OnClosePressed();
+						return;
+                }
+            }
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_messageModal.OnClosePressed();
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+
+        #endregion
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
index 72389a8..746bfe1 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
@@ -4,11 +4,13 @@ using Assets;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class QuestNotificationPopup : MonoBehaviour
+	public class QuestNotificationPopup : MonoBehaviour, AccessibleUI
 	{
 		public Widget m_questList;
 
@@ -28,12 +30,18 @@ namespace Hearthstone.Progression
 
 		private const int RETURNING_PLAYER_PROXY_QUEST_ID = 99;
 
+		#region Accessibility
+		private QuestListDataModel m_questListDataModel;
+
+		private AccessibleListOfItems<AccessibleQuest> m_accessibleQuests;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == CODE_HIDE)
 				{
 					Hide();
 				}
@@ -43,6 +51,8 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			m_callback?.Invoke();
 			if (m_IKSShown)
 			{
@@ -52,6 +62,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(RewardTrackDataModel rewardTrackDataModel, QuestListDataModel questListDataModel, Action callback, bool showIKS)
 		{
+			m_questListDataModel = questListDataModel;
 			m_callback = callback;
 			m_shouldShowIKS = showIKS;
 			if (rewardTrackDataModel != null)
@@ -60,6 +71,17 @@ namespace Hearthstone.Progression
 			}
 			if (questListDataModel != null)
 			{
+				// Accessiblity getting the pool type
+				foreach(var quest in questListDataModel.Quests)
+                {
+					if (m_questPoolType != null && quest.PoolType != m_questPoolType)
+                    {
+						m_questPoolType = QuestPool.QuestPoolType.NONE;
+						break;
+                    }
+					m_questPoolType = quest.PoolType;
+                }
+
 				m_widget.BindDataModel(new QuestListDataModel
 				{
 					Quests = questListDataModel.Quests.Take(m_maxQuestsPerRow).Aggregate(new DataModelList<QuestDataModel>(), delegate(DataModelList<QuestDataModel> acc, QuestDataModel dataModel)
@@ -85,10 +107,14 @@ namespace Hearthstone.Progression
 				}
 				m_widget.TriggerEvent("SHOW");
 			}, null, callImmediatelyIfSet: true, doOnce: true);
+
+			ReadPopup();
 		}
 
 		public void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			AckQuests();
 			SceneMgr.Get().UnregisterScenePreLoadEvent(OnPreLoadNextScene);
 			FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
@@ -145,5 +171,48 @@ namespace Hearthstone.Progression
 		{
 			Hide();
 		}
-	}
+
+        #region Accessibility
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(CODE_HIDE);
+            }
+			else
+            {
+				m_accessibleQuests.HandleAccessibleInput();
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.UI_QUEST_NOTIFICATION_POPUP_HELP);
+			var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+			return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+        }
+
+        private void ReadPopup()
+        {
+			AccessibilityMgr.ShowUI(this);
+			AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+			var accessibleQuests = new List<AccessibleQuest>();
+			foreach(var quest in m_questListDataModel.Quests)
+            {
+				accessibleQuests.Add(new AccessibleQuest(this, quest));
+            }
+
+			m_accessibleQuests = new AccessibleListOfItems<AccessibleQuest>(this, accessibleQuests);
+			int numQuests = accessibleQuests.Count;
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_QUEST_NOTIFICATION_POPUP_TITLE, numQuests));
+
+            m_accessibleQuests.StartReading();
+        }
+
+        #endregion
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
index 24cda7e..d39e39f 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
@@ -1,6 +1,7 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -17,6 +18,10 @@ namespace Hearthstone.Progression
 
 		private const string CODE_HIDE = "CODE_HIDE";
 
+		#region Accessibility
+		private QuestDataModel m_questDataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_toast = GetComponent<WidgetTemplate>();
@@ -31,6 +36,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(QuestDataModel questDataModel)
 		{
+			m_questDataModel = questDataModel;
 			m_toast.BindDataModel(questDataModel);
 		}
 
@@ -38,12 +44,13 @@ namespace Hearthstone.Progression
 		{
 			if (!(m_toast == null))
 			{
+				ReadToast();
 				OverlayUI.Get().AddGameObject(base.gameObject.transform.parent.gameObject);
 				m_toast.Show();
 			}
 		}
 
-		public void Hide()
+        public void Hide()
 		{
 			if (!(m_toast == null))
 			{
@@ -68,5 +75,22 @@ namespace Hearthstone.Progression
 				componentInChildren.Show();
 			});
 		}
+
+        #region Accessibility
+
+        private void ReadToast()
+        {
+			var quota = m_questDataModel.Quota;
+			var progress = m_questDataModel.Progress;
+
+			if (quota > 0)
+            {
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+				AccessibilityMgr.OutputNotification(m_questDataModel.Description);
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, progress, quota));
+            }
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
index e5c4896..486c97e 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
@@ -2,11 +2,13 @@ using System;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class RewardScroll : MonoBehaviour
+	public class RewardScroll : MonoBehaviour, AccessibleUI
 	{
 		private const string HIDE = "CODE_HIDE";
 
@@ -20,12 +22,16 @@ namespace Hearthstone.Progression
 
 		private event Action OnRewardScrollShown;
 
+        #region Accessibility
+        private RewardScrollDataModel m_dataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == HIDE)
 				{
 					Hide();
 				}
@@ -40,6 +46,8 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (FatalErrorMgr.IsInitialized())
 			{
 				FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
@@ -48,6 +56,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(RewardScrollDataModel dataModel, Action onHiddenCallback = null, Action onShownCallback = null)
 		{
+			m_dataModel = dataModel;
 			this.OnRewardScrollHidden = onHiddenCallback;
 			this.OnRewardScrollShown = onShownCallback;
 			m_widget.BindDataModel(dataModel);
@@ -55,6 +64,8 @@ namespace Hearthstone.Progression
 
 		public void Show()
 		{
+			ReadScroll();
+
 			OverlayUI.Get().AddGameObject(m_owner);
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
@@ -67,8 +78,10 @@ namespace Hearthstone.Progression
 			this.OnRewardScrollShown?.Invoke();
 		}
 
-		private void Hide()
+        private void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
 				UIContext.GetRoot().DismissPopup(base.gameObject);
@@ -94,5 +107,80 @@ namespace Hearthstone.Progression
 				widget.GetComponentInChildren<RewardScroll>().Show();
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 		}
+
+        #region Accessibility
+
+		private void ReadScroll()
+        {
+			AccessibilityMgr.ShowUI(this);
+
+            AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+            AccessibilityMgr.Output(this, m_dataModel.DisplayName);
+			AccessibilityMgr.Output(this, m_dataModel.Description);
+
+			ReadRewards();
+        }
+
+		private AccessibleListOfItems<AccessibleRewardItemDataModel> m_accessibleRewards;
+
+		private AccessibleRewardItemDataModel m_accessibleReward;
+
+        private void ReadRewards()
+        {
+            AccessibilityMgr.Output(this, LocalizedText.UI_REWARDS_TITLE);
+
+			m_accessibleRewards = null; // Reset in case of reuse
+			m_accessibleReward = null; // Reset in case of reuse
+
+			var rewards = m_dataModel.RewardList.Items;
+			var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+
+			foreach (var reward in rewards)
+            {
+				accessibleRewards.Add(new AccessibleRewardItemDataModel(this, reward));
+            }
+
+			m_accessibleRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(this, accessibleRewards);
+
+			if (m_accessibleRewards.Count == 1)
+            {
+				m_accessibleReward = m_accessibleRewards.Items[0];
+				m_accessibleReward.ReadAllLines();
+            }
+			else
+            {
+                m_accessibleRewards.StartReading();
+            }
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(HIDE);
+            }
+			else
+            {
+				if (m_accessibleReward != null)
+                {
+					m_accessibleReward.HandleAccessibleInput();
+                }
+				else
+                {
+                    m_accessibleRewards.HandleAccessibleInput();
+                }
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.UI_REWARD_SCROLL_HELP);
+			var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+			return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
index 39aefa2..c5525ea 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Text;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusUtil;
diff --git a/Decompiled/Assembly-CSharp/HeroDbId.cs b/Decompiled/Assembly-CSharp/HeroDbId.cs
index 79c6983..1bb1e15 100644
--- a/Decompiled/Assembly-CSharp/HeroDbId.cs
+++ b/Decompiled/Assembly-CSharp/HeroDbId.cs
@@ -14,5 +14,6 @@ public enum HeroDbId
 	ALLERIA,
 	MEDIVH,
 	LIADRIN,
-	KHADGAR
+	KHADGAR,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs b/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs
index 56ebc5e..2cc7a73 100644
--- a/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs
+++ b/Decompiled/Assembly-CSharp/HeroPickerDisplay.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class HeroPickerDisplay : MonoBehaviour
 {
diff --git a/Decompiled/Assembly-CSharp/HeroXPBar.cs b/Decompiled/Assembly-CSharp/HeroXPBar.cs
index e6dfd54..dafd6f0 100644
--- a/Decompiled/Assembly-CSharp/HeroXPBar.cs
+++ b/Decompiled/Assembly-CSharp/HeroXPBar.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class HeroXPBar : PegUIElement
 {
@@ -33,6 +34,12 @@ public class HeroXPBar : PegUIElement
 
 	private string m_rewardDesc;
 
+	#region Accessibility
+	private bool m_fromEndGameScreen;
+
+	private AccessibleComponent m_parent;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -44,12 +51,16 @@ public class HeroXPBar : PegUIElement
 	{
 	}
 
-	public void UpdateDisplay(NetCache.HeroLevel heroLevel, int totalLevel)
+	public void UpdateDisplay(AccessibleComponent parent, NetCache.HeroLevel heroLevel, int totalLevel, bool fromEndGameScreen)
 	{
+		m_fromEndGameScreen = fromEndGameScreen;
+		m_parent = parent;
+
 		if (heroLevel == null)
 		{
 			base.gameObject.SetActive(value: false);
-			return;
+            SignalEnterToContinue();
+            return;
 		}
 		m_heroLevel = heroLevel;
 		m_totalLevel = totalLevel;
@@ -72,6 +83,7 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.PrevLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
+				SignalEnterToContinue();
 				return;
 			}
 			SetBarValue((float)m_heroLevel.PrevLevel.XP / (float)m_heroLevel.PrevLevel.MaxXP);
@@ -83,12 +95,14 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.CurrentLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
-			}
-			else
+                SignalEnterToContinue();
+            }
+            else
 			{
 				SetBarValue((float)m_heroLevel.CurrentLevel.XP / (float)m_heroLevel.CurrentLevel.MaxXP);
-			}
-		}
+                SignalEnterToContinue();
+            }
+        }
 	}
 
 	public void AnimateBar(NetCache.HeroLevel.LevelInfo previousLevelInfo, NetCache.HeroLevel.LevelInfo currentLevelInfo)
@@ -110,9 +124,10 @@ public class HeroXPBar : PegUIElement
 			currVal2 = 1f;
 		}
 		m_progressBar.AnimateProgress(prevVal2, currVal2);
-	}
+        SignalEnterToContinue();
+    }
 
-	public void SetBarValue(float barValue)
+    public void SetBarValue(float barValue)
 	{
 		m_progressBar.SetProgressBar(barValue);
 	}
@@ -128,7 +143,7 @@ public class HeroXPBar : PegUIElement
 	private IEnumerator AnimatePostLevelUpXp(float delayTime, NetCache.HeroLevel.LevelInfo currentLevelInfo)
 	{
 		yield return new WaitForSeconds(delayTime);
-		if (currentLevelInfo.Level == 3 && !Options.Get().GetBool(Option.HAS_SEEN_LEVEL_3, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("HeroXPBar.AnimatePostLevelUpXp:" + Option.HAS_SEEN_LEVEL_3))
+		if (currentLevelInfo.Level == 3 && !Options.Get().GetBool(Option.HAS_SEEN_LEVEL_3, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "HeroXPBar.AnimatePostLevelUpXp:" + Option.HAS_SEEN_LEVEL_3))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_LEVEL3_TIP"), "VO_INNKEEPER_LEVEL3_TIP.prefab:0f82ce6c91fccf249b6abcc9f153ff1e");
 			Options.Get().SetBool(Option.HAS_SEEN_LEVEL_3, val: true);
@@ -140,6 +155,8 @@ public class HeroXPBar : PegUIElement
 		{
 			m_levelUpCallback();
 		}
+		AccessibilityMgr.Output(m_parent, LocalizationUtils.Format(LocalizationKey.SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP, currentLevelInfo.Level));
+		SignalEnterToContinue();
 	}
 
 	private IEnumerator DelayBarAnimation(NetCache.HeroLevel.LevelInfo prevInfo, NetCache.HeroLevel.LevelInfo currInfo)
@@ -171,4 +188,16 @@ public class HeroXPBar : PegUIElement
 	{
 		base.gameObject.GetComponent<TooltipZone>().HideTooltip();
 	}
+
+	#region Accessibility
+
+	private void SignalEnterToContinue()
+    {
+		if (m_fromEndGameScreen)
+        {
+            AccessibilityMgr.Output(m_parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/HistoryCard.cs b/Decompiled/Assembly-CSharp/HistoryCard.cs
index 88251ce..4d61301 100644
--- a/Decompiled/Assembly-CSharp/HistoryCard.cs
+++ b/Decompiled/Assembly-CSharp/HistoryCard.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
@@ -87,7 +88,9 @@ public class HistoryCard : HistoryItem
 
 	private int m_displayTimeMS;
 
-	private HistoryInfoType m_historyInfoType;
+	internal HistoryInfoType m_historyInfoType;
+
+	internal PowerTaskList OriginTaskList { get; private set; }
 
 	public void LoadMainCardActor()
 	{
@@ -609,8 +612,10 @@ public class HistoryCard : HistoryItem
 		return -1.404475f + num2 * (float)num3;
 	}
 
-	public void LoadBigCard(HistoryBigCardInitInfo info)
+	public void LoadBigCard(PowerTaskList origin, HistoryBigCardInitInfo info)
 	{
+		OriginTaskList = origin;
+
 		m_entity = info.m_entity;
 		m_historyInfoType = info.m_historyInfoType;
 		m_portraitTexture = info.m_portraitTexture;
@@ -690,7 +695,7 @@ public class HistoryCard : HistoryItem
 
 	public void ShowBigCard(Vector3[] pathToFollow)
 	{
-		float num = 1f;
+        float num = 1f;
 		if (m_displayTimeMS > 0)
 		{
 			float b = (float)m_displayTimeMS / 1000f;
@@ -716,10 +721,11 @@ public class HistoryCard : HistoryItem
 			{
 				ShowDisplayedCreator();
 			}
-		}
-	}
+            AccessibleGameplay.Get().OnShowBigCard(this);
+        }
+    }
 
-	private void OnBigCardPathComplete()
+    private void OnBigCardPathComplete()
 	{
 		ShowDisplayedCreator();
 	}
diff --git a/Decompiled/Assembly-CSharp/HistoryInfoType.cs b/Decompiled/Assembly-CSharp/HistoryInfoType.cs
index 23926a8..8ba672c 100644
--- a/Decompiled/Assembly-CSharp/HistoryInfoType.cs
+++ b/Decompiled/Assembly-CSharp/HistoryInfoType.cs
@@ -7,5 +7,6 @@ public enum HistoryInfoType
 	TRIGGER,
 	WEAPON_BREAK,
 	FATIGUE,
-	BURNED_CARDS
+	BURNED_CARDS,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/HistoryManager.cs b/Decompiled/Assembly-CSharp/HistoryManager.cs
index 49626a0..8b937e9 100644
--- a/Decompiled/Assembly-CSharp/HistoryManager.cs
+++ b/Decompiled/Assembly-CSharp/HistoryManager.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class HistoryManager : CardTileListDisplay
 {
@@ -24,6 +25,14 @@ public class HistoryManager : CardTileListDisplay
 		public bool m_waitForSecretSpell;
 
 		public int m_displayTimeMS;
+
+		public PowerTaskList m_origin;
+
+		public BigCardEntry(PowerTaskList origin)
+        {
+			// Required to arbitrate TTS between big cards and power list parsing
+			m_origin = origin;
+        }
 	}
 
 	private enum BigCardTransformState
@@ -1490,26 +1499,27 @@ public class HistoryManager : CardTileListDisplay
 		return m_pendingBigCardEntry.m_info.GetOriginalEntity();
 	}
 
-	public void CreateFastBigCardFromMetaData(Entity entity)
+	public void CreateFastBigCardFromMetaData(PowerTaskList origin, Entity entity)
 	{
 		int displayTimeMS = 1000;
-		CreatePlayedBigCard(entity, delegate
+		CreatePlayedBigCard(origin, entity, delegate
 		{
 		}, delegate
 		{
 		}, fromMetaData: true, countered: false, displayTimeMS);
 	}
 
-	public void CreatePlayedBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
+	public void CreatePlayedBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard())
-		{
-			finishedCallback();
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard())
+        {
+            // Some tutorials don't show big cards but we depend on it for accessibility atm
+            finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		if (entity.IsWeapon())
@@ -1528,16 +1538,17 @@ public class HistoryManager : CardTileListDisplay
 		StartCoroutine("WaitForCardLoadedAndCreateBigCard", bigCardEntry);
 	}
 
-	public void CreateTriggeredBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
+	public void CreateTriggeredBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard())
-		{
-			finishedCallback();
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard())
+        {
+            // Some tutorials don't show big cards but we depend on it for accessibility atm
+            finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		bigCardEntry.m_info.m_infoType = HistoryInfoType.TRIGGER;
@@ -1657,7 +1668,7 @@ public class HistoryManager : CardTileListDisplay
 			historyBigCardInitInfo.m_postTransformedEntity = postTransformedEntity;
 			historyBigCardInitInfo.m_displayTimeMS = bigCardEntry.m_displayTimeMS;
 			HistoryCard component = go.GetComponent<HistoryCard>();
-			component.LoadBigCard(historyBigCardInitInfo);
+			component.LoadBigCard(bigCardEntry.m_origin, historyBigCardInitInfo);
 			if ((bool)m_currentBigCard)
 			{
 				InterruptCurrentBigCard();
diff --git a/Decompiled/Assembly-CSharp/Hub.cs b/Decompiled/Assembly-CSharp/Hub.cs
index 47c7a5c..b47fdd2 100644
--- a/Decompiled/Assembly-CSharp/Hub.cs
+++ b/Decompiled/Assembly-CSharp/Hub.cs
@@ -7,6 +7,7 @@ using Hearthstone;
 using Hearthstone.Core;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class Hub : PegasusScene
 {
@@ -48,6 +49,10 @@ public class Hub : PegasusScene
 		{
 			Box.Get().DisableAllButtons();
 		}
+		else
+        {
+			AccessibleHub.Get().OnHubOpened();
+        }
 		yield break;
 	}
 
@@ -240,16 +245,18 @@ public class Hub : PegasusScene
 		{
 			return;
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_HUB))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_HUB))
 		{
 			StartCoroutine(DoFirstTimeHubWelcome());
 		}
-		else if (!Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_MODE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_PRACTICE_MODE))
+		else if (!Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_MODE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "Hub.Start:" + Option.HAS_SEEN_PRACTICE_MODE) && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
+			// This is visual and doesn't really help. Need to ask for translations to do this properly
 			ShowModesButtonNotification("GLUE_PRACTICE_HINT");
 		}
-		else if (GameModeUtils.ShouldSeeSoloAdventuresMovedPopup() && GameModeUtils.CanAccessGameModes() && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + GameSaveKeySubkeyId.FTUE_SHOULD_SEE_SOLO_ADVENTURES_MOVED_POPUP))
+		else if (GameModeUtils.ShouldSeeSoloAdventuresMovedPopup() && GameModeUtils.CanAccessGameModes() && UserAttentionManager.CanShowAttentionGrabber(false, "Hub.Start:" + GameSaveKeySubkeyId.FTUE_SHOULD_SEE_SOLO_ADVENTURES_MOVED_POPUP) && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
+			// This is visual and doesn't really help. Need to ask for translations to do this properly
 			ShowModesButtonNotification("GLUE_SOLO_ADVENTURES_MOVED_HINT");
 		}
 		else if (!Options.Get().GetBool(Option.HAS_SEEN_100g_REMINDER, defaultVal: false))
@@ -259,7 +266,7 @@ public class Hub : PegasusScene
 			{
 				Debug.LogError("Hub.Start Error - NetCache.NetCacheGoldBalance is null");
 			}
-			if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
+			if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FIRST_100_GOLD"), "VO_INNKEEPER_FIRST_100_GOLD.prefab:c6a50337099a454488acd96d2f37320f");
 				Options.Get().SetBool(Option.HAS_SEEN_100g_REMINDER, val: true);
@@ -417,6 +424,10 @@ public class Hub : PegasusScene
 		NotificationManager notificationManager = NotificationManager.Get();
 		if (notificationManager != null)
 		{
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+              yield return new WaitForSeconds(3f); // Allow menu to be read before jumping in
+            }
 			Notification innkeeperPopup = notificationManager.CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_1ST_HUB_06"), "VO_INNKEEPER_1ST_HUB_06.prefab:9774392944a21424788286f80d401d8c", 3f);
 			if ((bool)UniversalInputManager.UsePhoneUI)
 			{
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
index 6b58bab..a5724d5 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
@@ -1,4 +1,5 @@
 using System;
+using Accessibility;
 using HutongGames.PlayMaker.AnimationEnums;
 using UnityEngine;
 
@@ -335,7 +336,8 @@ namespace HutongGames.PlayMaker
 		{
 			if (!(Camera.main == null))
 			{
-				Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out mousePickInfo, distance, layerMask);
+				Physics.Raycast(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), out mousePickInfo, distance, layerMask);
+				//Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out mousePickInfo, distance, layerMask);
 				mousePickLayerMaskUsed = layerMask;
 				mousePickDistanceUsed = distance;
 				mousePickRaycastTime = Time.frameCount;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
index 8f7015a..0db1a61 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
@@ -32,7 +32,8 @@ namespace HutongGames.PlayMaker.Actions
 		{
 			if (storeResult != null)
 			{
-				float num = Input.mousePosition.x;
+				float num = AccessibleUnityInput.Get().GetMousePosition().x;
+				//float num = Input.mousePosition.x;
 				if (normalize)
 				{
 					num /= (float)Screen.width;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
index 30f3fbf..327bca0 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
@@ -32,7 +32,8 @@ namespace HutongGames.PlayMaker.Actions
 		{
 			if (storeResult != null)
 			{
-				float num = Input.mousePosition.y;
+				float num = AccessibleUnityInput.Get().GetMousePosition().y;
+				//float num = Input.mousePosition.y;
 				if (normalize)
 				{
 					num /= (float)Screen.height;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
index 44a1bbd..bf99203 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
@@ -54,7 +54,8 @@ namespace HutongGames.PlayMaker.Actions
 
 		private void DoMousePick2d()
 		{
-			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			//RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
 			bool flag = rayIntersection.collider != null;
 			storeDidPickObject.Value = flag;
 			if (flag)
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
index dcd9828..4f70c4f 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
@@ -84,7 +84,8 @@ namespace HutongGames.PlayMaker.Actions
 		private bool DoRaycast()
 		{
 			GameObject gameObject = ((GameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : GameObject.GameObject.Value);
-			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			//RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
 			Fsm.RecordLastRaycastHit2DInfo(base.Fsm, rayIntersection);
 			if (rayIntersection.transform != null && rayIntersection.transform.gameObject == gameObject)
 			{
diff --git a/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs b/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs
index 4f6d108..4af0340 100644
--- a/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs
+++ b/Decompiled/Assembly-CSharp/ICCPrologueFakeDeath.cs
@@ -175,7 +175,7 @@ public class ICCPrologueFakeDeath : Spell
 			}
 			FullScreenFXMgr.Get().SetBlurDesaturation(0.5f);
 			FullScreenFXMgr.Get().Blur(1f, 0.5f, iTween.EaseType.easeInCirc);
-			defeatTwoScoop.Show(showXPBar: false);
+			defeatTwoScoop.Show(null, showXPBar: false);
 			yield return new WaitForSeconds(m_FakeDefeatScreenShowTime);
 			FullScreenFXMgr.Get().StopBlur(0.25f, iTween.EaseType.linear);
 			FullScreenFXMgr.Get().SetBlurDesaturation(0f);
diff --git a/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs b/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
index 02b2985..f37d763 100644
--- a/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
+++ b/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
@@ -22,7 +22,7 @@ public class InactivePlayerKicker : IService, IHasUpdate
 
 	private GameMgr m_gameMgr;
 
-	public bool WasKickedForInactivity { get; private set; }
+	public bool WasKickedForInactivity { get; set; }
 
 	public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
 	{
diff --git a/Decompiled/Assembly-CSharp/InputCollection.cs b/Decompiled/Assembly-CSharp/InputCollection.cs
index 9fc8020..5568c6d 100644
--- a/Decompiled/Assembly-CSharp/InputCollection.cs
+++ b/Decompiled/Assembly-CSharp/InputCollection.cs
@@ -8,6 +8,7 @@ public static class InputCollection
 	static InputCollection()
 	{
 		m_Inputs = new List<IInput>();
+		m_Inputs.Add(AccessibleUnityInput.Get());
 		m_Inputs.Add(new UnityInput());
 	}
 
diff --git a/Decompiled/Assembly-CSharp/InputManager.cs b/Decompiled/Assembly-CSharp/InputManager.cs
index ccab8d5..c86277a 100644
--- a/Decompiled/Assembly-CSharp/InputManager.cs
+++ b/Decompiled/Assembly-CSharp/InputManager.cs
@@ -1575,7 +1575,7 @@ public class InputManager : MonoBehaviour
 			Entity entity = heldCard.GetEntity();
 			heldCard.NotifyLeftPlayfield();
 			GameState.Get().GetGameEntity().NotifyOfCardDropped(entity);
-			DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
+            DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
 			if ((bool)component)
 			{
 				component.Disable();
@@ -1628,7 +1628,7 @@ public class InputManager : MonoBehaviour
 		Entity entity = heldCard.GetEntity();
 		heldCard.NotifyLeftPlayfield();
 		GameState.Get().GetGameEntity().NotifyOfCardDropped(entity);
-		DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
+        DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
 		if ((bool)component)
 		{
 			component.Disable();
@@ -2287,7 +2287,7 @@ public class InputManager : MonoBehaviour
 				{
 					if (gameState.GetGameEntity().NotifyOfEndTurnButtonPushed())
 					{
-						gameState.SetSelectedOption(i);
+                                gameState.SetSelectedOption(i);
 						gameState.SendOption();
 						HidePhoneHand();
 						DoEndTurnButton_Option_OnEndTurnRequested();
diff --git a/Decompiled/Assembly-CSharp/JoustSpellController.cs b/Decompiled/Assembly-CSharp/JoustSpellController.cs
index d995418..e43b6e1 100644
--- a/Decompiled/Assembly-CSharp/JoustSpellController.cs
+++ b/Decompiled/Assembly-CSharp/JoustSpellController.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Core;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class JoustSpellController : SpellController
@@ -267,6 +268,7 @@ public class JoustSpellController : SpellController
 		{
 			PlayNoJousterSpell(GameState.Get().GetOpposingSidePlayer());
 		}
+
 		while (IsJousterBusy(m_friendlyJouster) || IsJousterBusy(m_opponentJouster))
 		{
 			yield return null;
@@ -311,9 +313,21 @@ public class JoustSpellController : SpellController
 			DriftJouster(jouster);
 		};
 		iTween.Timer(card.gameObject, iTween.Hash("delay", delaySec, "time", showSec, "oncomplete", action));
+
+		var jousterName = card.GetEntity().GetName();
+		var jousterCost = card.GetEntity().GetDefCost();
+
+		if (card.GetEntity().IsControlledByFriendlySidePlayer())
+        {
+			OutputSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_JOUST_PLAYER_REVEALED_CARD, jousterCost, jousterName));
+        }
+		else
+        {
+			OutputSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD, jousterCost, jousterName));
+        }
 	}
 
-	private void PlayNoJousterSpell(Player player)
+    private void PlayNoJousterSpell(Player player)
 	{
 		ZoneDeck deckZone = player.GetDeckZone();
 		Spell spell2 = UnityEngine.Object.Instantiate(m_NoJousterSpellPrefab);
@@ -326,6 +340,15 @@ public class JoustSpellController : SpellController
 			}
 		});
 		spell2.Activate();
+
+		if (player.IsFriendlySide())
+        {
+			OutputSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS));
+        }
+		else
+        {
+			OutputSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS));
+        }
 	}
 
 	private void DriftJouster(Jouster jouster)
@@ -534,4 +557,14 @@ public class JoustSpellController : SpellController
 		}
 		return jouster.m_effectsPendingFinish > 0;
 	}
+
+    #region Accessibility
+
+    private void OutputSpeech(string speech)
+    {
+        AccessibilityMgr.Output(AccessibleGameplay.Get(), speech);
+        AccessibleHistoryMgr.Get().AddEntry(speech);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs b/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
index d34aaf9..d6e5e18 100644
--- a/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
+++ b/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.UI;
 
-public class LeaguePromoteSelfManuallyDialog : DialogBase
+public class LeaguePromoteSelfManuallyDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback();
 
diff --git a/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs b/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
index a76eca7..70cd0e6 100644
--- a/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
@@ -2,8 +2,9 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class LoadingPopupDisplay : TransitionPopup
+public class LoadingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	[Serializable]
 	public class LoadingbarTexture
@@ -93,12 +94,23 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 	}
 
+	public override void Show()
+    {
+		base.Show();
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, m_title.Text, true);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+    }
+
 	public override void Hide()
 	{
 		if (m_shown)
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -408,4 +420,18 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 		m_progressBar.SetBarTexture(texture);
 	}
+
+	#region
+
+	public void HandleAccessibleInput()
+    {
+		// No-op
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Log.cs b/Decompiled/Assembly-CSharp/Log.cs
index 4223cdd..f965105 100644
--- a/Decompiled/Assembly-CSharp/Log.cs
+++ b/Decompiled/Assembly-CSharp/Log.cs
@@ -9,10 +9,10 @@ public class Log
 {
 	public enum LogLevel
 	{
-		[Description("None")]
-		None,
-		[Description("Debug")]
-		Debug,
+        [Description("None")]
+        None,
+        [Description("Debug")]
+        Debug,
 		[Description("Info")]
 		Info,
 		[Description("Warning")]
@@ -25,6 +25,8 @@ public class Log
 
 	public static Logger All = new Logger("All");
 
+	public static Logger Accessibility = new Logger("Accessibility");
+
 	public static Logger AchievementManager = new Logger("AchievementManager");
 
 	public static Logger Achievements = new Logger("Achievements");
@@ -205,7 +207,9 @@ public class Log
 
 	private const string CONFIG_FILE_NAME = "log.config";
 
-	private readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[5]
+	private const string ACCESSIBILITY_LOG_NAME = "Accessibility";
+
+	private static readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[]
 	{
 		new LogInfo
 		{
@@ -221,6 +225,14 @@ public class Log
 			m_minLevel = LogLevel.Info
 		},
 		new LogInfo
+		{
+			m_name = ACCESSIBILITY_LOG_NAME,
+			m_filePrinting = true,
+			m_consolePrinting = false,
+			m_minLevel = LogLevel.Info,
+			m_defaultLevel = LogLevel.Info
+		},
+		new LogInfo
 		{
 			m_name = "Login",
 			m_filePrinting = true,
@@ -412,6 +424,10 @@ public class Log
 				value2.m_verbose = GeneralUtils.ForceBool(value);
 			}
 		}
+
+		// Force Accessibility log for returning users (e.g. PCs shared with sighted people)
+		var accessibilityLog = Array.Find(DEFAULT_LOG_INFOS, x => x.m_name.Equals(ACCESSIBILITY_LOG_NAME));
+		map.Add(accessibilityLog.m_name, accessibilityLog);
 		return map;
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Login.cs b/Decompiled/Assembly-CSharp/Login.cs
index 36b4975..c1c928a 100644
--- a/Decompiled/Assembly-CSharp/Login.cs
+++ b/Decompiled/Assembly-CSharp/Login.cs
@@ -1,4 +1,5 @@
 using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.Jobs;
 using Hearthstone;
 using Hearthstone.Core;
@@ -86,6 +87,7 @@ public class Login : PegasusScene
 
 	private void ChangeMode()
 	{
+		HSADevTools.Init();
 		MusicManager.Get().StartPlaylist(MusicPlaylistType.UI_MainTitle);
 		m_nextMissionId = GameUtils.GetNextTutorial();
 		if (m_nextMissionId > 3)
@@ -98,11 +100,18 @@ public class Login : PegasusScene
 			if (!CreateSkipHelper.ShouldShowCreateSkip() || !CreateSkipHelper.ShowCreateSkipDialog(ChangeToAppropriateHubMode))
 			{
 				ChangeToAppropriateHubMode();
-				ChangeMode_SetRotation();
+				ChangeMode_SetRotation(false);
 			}
 			return;
 		}
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+
+		// Force old flow as the new one isn't accessible yet
+		if (m_nextMissionId == 3)
+        {
+			ChangeMode_TutorialWithStart();
+			return;
+        }
+		/*NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
 		if (netObject == null)
 		{
 			Debug.LogError(" Could not get NetCacheFeatures Object");
@@ -119,16 +128,17 @@ public class Login : PegasusScene
 				ChangeMode_TutorialWithStart();
 				return;
 			}
-		}
+		}*/
 		ChangeMode_Hub();
 	}
 
 	private void ChangeToAppropriateHubMode()
 	{
 		Log.Login.PrintInfo("Changing mode");
-		if (SetRotationManager.ShouldShowSetRotationIntro())
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && SetRotationManager.ShouldShowSetRotationIntro())
 		{
-			ChangeMode_SetRotation();
+            // None of this is implemented yet (nor needed until ranked etc)
+            ChangeMode_SetRotation(false);
 		}
 		else
 		{
@@ -237,6 +247,7 @@ public class Login : PegasusScene
 	{
 		Box.Get().AddButtonPressListener(OnStartButtonPressed);
 		Box.Get().ChangeState(Box.State.PRESS_START);
+		AccessibleLoginScreen.Get().OnGameLoaded(Box.Get().m_StartButton);
 	}
 
 	private void OnStartButtonPressed(Box.ButtonType buttonType, object userData)
@@ -274,6 +285,7 @@ public class Login : PegasusScene
 
 	private void StartTutorial()
 	{
+		AccessibleTutorialProgressScreen.Get().OnStartTutorial();
 		MusicManager.Get().StopPlaylist();
 		Box.Get().ChangeState(Box.State.CLOSED);
 		GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
@@ -287,9 +299,9 @@ public class Login : PegasusScene
 		return true;
 	}
 
-	private void ChangeMode_SetRotation()
+	private void ChangeMode_SetRotation(bool accessible)
 	{
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		Spell eventSpell = Box.Get().GetEventSpell(BoxEventType.STARTUP_SET_ROTATION);
 		Box.Get().m_StoreButton.gameObject.SetActive(value: false);
 		Box.Get().m_QuestLogButton.gameObject.SetActive(value: false);
diff --git a/Decompiled/Assembly-CSharp/LoginManager.cs b/Decompiled/Assembly-CSharp/LoginManager.cs
index a40239c..b8b5feb 100644
--- a/Decompiled/Assembly-CSharp/LoginManager.cs
+++ b/Decompiled/Assembly-CSharp/LoginManager.cs
@@ -253,7 +253,7 @@ public class LoginManager : IService
 	private void OnProfileProgressResponse()
 	{
 		HearthstoneApplication.SendStartupTimeTelemetry("LoginManager.OnProfileProgressResponse");
-		if (!Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
+		if (!Accessibility.AccessibilityMgr.IsAccessibilityEnabled() && !Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
 		{
 			HearthstoneServices.Get<Cinematic>().Play(delegate
 			{
@@ -500,7 +500,7 @@ public class LoginManager : IService
 
 	private void ShowGoldCapAlert(Action callback)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber("Login.ShowGoldCapAlert"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, "Login.ShowGoldCapAlert"))
 		{
 			callback();
 			return;
diff --git a/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs b/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
index 94e757f..9c674c4 100644
--- a/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
+++ b/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class LoginPopupSequencePopup : BasicPopup
 {
@@ -18,6 +19,8 @@ public class LoginPopupSequencePopup : BasicPopup
 		public AssetReference m_backgroundMaterialReference;
 
 		public HideCallback m_callbackOnHide;
+
+		public Info(bool markedForAccessibility) { } // If something new shows up we must ensure login popup sequence is still hidden
 	}
 
 	private struct CardActorLoadedData
@@ -129,14 +132,17 @@ public class LoginPopupSequencePopup : BasicPopup
 		if (m_headerText != null)
 		{
 			m_headerText.Text = info.m_headerText;
+			AccessibilityMgr.Output(this, info.m_headerText);
 		}
 		if (m_bodyText != null)
 		{
 			m_bodyText.Text = info.m_bodyText;
+			AccessibilityMgr.Output(this, info.m_bodyText);
 		}
 		if (m_cancelButton != null)
 		{
 			m_cancelButton.SetText(info.m_buttonText);
+			AccessibilityMgr.Output(this, info.m_buttonText);
 		}
 		if (m_backgroundMaterial != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs b/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
index 8d39aff..fdfb2ea 100644
--- a/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
+++ b/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
@@ -4,6 +4,8 @@ using UnityEngine;
 
 public class ManaFilterTabManager : MonoBehaviour
 {
+	internal static int NUM_MANA_FILTERS = 7;
+
 	public ManaFilterTab m_singleManaFilterPrefab;
 
 	public ManaFilterTab m_dynamicManaFilterPrefab;
@@ -12,7 +14,7 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	private bool m_tabsActive;
 
-	private List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
+	internal List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
 
 	private HashSet<int> m_currentFilterExactValues = new HashSet<int>();
 
@@ -169,11 +171,11 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	public void SetUpTabs()
 	{
-		for (int i = 0; i <= 6; i++)
+		for (int i = 0; i <= NUM_MANA_FILTERS - 1; i++)
 		{
 			CreateNewTab(m_singleManaFilterPrefab, i);
 		}
-		CreateNewTab(m_dynamicManaFilterPrefab, 7);
+		CreateNewTab(m_dynamicManaFilterPrefab, NUM_MANA_FILTERS);
 		m_manaCrystalContainer.UpdateSlices();
 	}
 
@@ -208,7 +210,7 @@ public class ManaFilterTabManager : MonoBehaviour
 		if (m_tabsActive)
 		{
 			ManaFilterTab manaFilterTab = (ManaFilterTab)e.GetElement();
-			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
+			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
 			{
 				Options.Get().SetBool(Option.HAS_CLICKED_MANA_TAB, val: true);
 				ShowManaTabHint(manaFilterTab);
diff --git a/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs b/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
index ce5fca1..e82104a 100644
--- a/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
@@ -3,8 +3,9 @@ using System.Collections.Generic;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class MatchingPopupDisplay : TransitionPopup
+public class MatchingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	public UberText m_tipOfTheDay;
 
@@ -37,6 +38,8 @@ public class MatchingPopupDisplay : TransitionPopup
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -46,6 +49,9 @@ public class MatchingPopupDisplay : TransitionPopup
 		UpdateTipOfTheDay();
 		GenerateRandomSpinnerTexts(IsMultiOpponentGame());
 		m_title.Text = GetTitleTextBasedOnScenario();
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, m_title.Text, true);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
 		base.Show();
 	}
 
@@ -274,4 +280,18 @@ public class MatchingPopupDisplay : TransitionPopup
 		}
 		return record.Players > 2;
 	}
+
+	#region
+
+	public void HandleAccessibleInput()
+    {
+		// No-op
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MissionEntity.cs b/Decompiled/Assembly-CSharp/MissionEntity.cs
index 7c21fc8..9ac7a11 100644
--- a/Decompiled/Assembly-CSharp/MissionEntity.cs
+++ b/Decompiled/Assembly-CSharp/MissionEntity.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class MissionEntity : GameEntity
 {
@@ -962,4 +963,93 @@ public class MissionEntity : GameEntity
 			responseGroup.m_responseIndex++;
 		}
 	}
+
+    #region Missions with Turn Counters
+
+	private Notification m_turnCounter;
+
+	private string m_turnCounterText = ""; // Used for reading # of remaining turns when focusing on opponent's Hero
+
+	private bool m_isTurnCounterBasedMission = false; // Used to avoid race conditions after the counter is destroyed
+
+    protected virtual void InitTurnCounterVisuals()
+	{
+		m_isTurnCounterBasedMission = true;
+		int cost = GetCost();
+		InitTurnCounter(cost);
+	}
+
+	private void InitTurnCounter(int cost)
+	{
+		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
+		m_turnCounter = gameObject.GetComponent<Notification>();
+		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
+		component.FsmVariables.GetFsmBool("RunningMan").Value = false;
+		component.FsmVariables.GetFsmBool("MineCart").Value = false;
+		component.FsmVariables.GetFsmBool("Airship").Value = false;
+		component.FsmVariables.GetFsmBool("Destroyer").Value = true;
+		component.SendEvent("Birth");
+		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
+			.GetActor();
+		m_turnCounter.transform.parent = actor.gameObject.transform;
+		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
+		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
+		UpdateTurnCounterText(cost);
+	}
+
+	protected virtual void UpdateTurnCounterVisualsIfNeeded(TagDelta change)
+    {
+		GAME_TAG tag = (GAME_TAG)change.tag;
+		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
+		{
+			UpdateTurnCounterVisuals(change.newValue);
+		}
+    }
+
+	private void UpdateTurnCounterVisuals(int cost)
+	{
+		UpdateTurnCounter(cost);
+	}
+
+	private void UpdateTurnCounter(int cost)
+	{
+		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
+		if (cost <= 0)
+		{
+			Object.Destroy(m_turnCounter.gameObject);
+		}
+		else
+		{
+			UpdateTurnCounterText(cost);
+		}
+	}
+
+	private void UpdateTurnCounterText(int cost)
+	{
+		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+		{
+			new GameStrings.PluralNumber
+			{
+				m_index = 0,
+				m_number = cost
+			}
+		};
+		string headlineString = GameStrings.FormatPlurals("BOH_GULDAN_01", pluralNumbers);
+		string costString = cost.ToString();
+		m_turnCounter.ChangeDialogText(headlineString, costString, "", "");
+		m_turnCounterText = $"{costString} {headlineString}";
+		AccessibilityMgr.Output(AccessibleGameplay.Get(), m_turnCounterText);
+	}
+
+	public string GetTurnCounterText()
+    {
+		return m_turnCounterText;
+    }
+
+    public override bool IsTurnCounterBasedMission()
+    {
+		return m_isTurnCounterBasedMission;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MountRewardData.cs b/Decompiled/Assembly-CSharp/MountRewardData.cs
index 98a724c..f40e67b 100644
--- a/Decompiled/Assembly-CSharp/MountRewardData.cs
+++ b/Decompiled/Assembly-CSharp/MountRewardData.cs
@@ -4,7 +4,8 @@ public class MountRewardData : RewardData
 	{
 		UNKNOWN,
 		WOW_HEARTHSTEED,
-		HEROES_MAGIC_CARPET_CARD
+		HEROES_MAGIC_CARPET_CARD,
+		EOE
 	}
 
 	public MountType Mount { get; set; }
diff --git a/Decompiled/Assembly-CSharp/MulliganManager.cs b/Decompiled/Assembly-CSharp/MulliganManager.cs
index 196c984..370d47e 100644
--- a/Decompiled/Assembly-CSharp/MulliganManager.cs
+++ b/Decompiled/Assembly-CSharp/MulliganManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using UnityEngine;
 
@@ -1535,13 +1536,25 @@ public class MulliganManager : MonoBehaviour
 			mulliganButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton();
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
-		}
+
+                if (AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+                }
+                else
+                {
+                    innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+                }
+            }
+        }
 		GameState.Get().GetGameEntity().StartMulliganSoundtracks(soft: true);
 		m_waitingForUserInput = true;
 		while (innkeeperMulliganDialog != null)
@@ -1568,7 +1581,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterIntroBeforeMulligan());
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.DO_OPENING_TAUNTS) && !Cheats.Get().ShouldSkipMulligan())
 		{
-			m_PlayStartingTaunts = PlayStartingTaunts();
+            m_PlayStartingTaunts = PlayStartingTaunts();
 			StartCoroutine(m_PlayStartingTaunts);
 		}
 		Player friendlySidePlayer = GameState.Get().GetFriendlySidePlayer();
@@ -1576,11 +1589,11 @@ public class MulliganManager : MonoBehaviour
 		GetStartingLists();
 		if (m_startingCards.Count == 0)
 		{
-			SkipCardChoosing();
+            SkipCardChoosing();
 		}
 		foreach (Card startingCard in m_startingCards)
 		{
-			startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
 			startingCard.GetActor().TurnOffCollider();
 			startingCard.GetActor().GetMeshRenderer().gameObject.layer = 8;
 			startingCard.GetActor().m_nameTextMesh.UpdateNow();
@@ -1599,15 +1612,15 @@ public class MulliganManager : MonoBehaviour
 		int numCardsToDealExcludingBonusCard = m_startingCards.Count;
 		if (!friendlyPlayerGoesFirst)
 		{
-			numCardsToDealExcludingBonusCard = m_bonusCardIndex;
+            numCardsToDealExcludingBonusCard = m_bonusCardIndex;
 			spacingToUse = spaceForEachCard;
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
 			if (m_coinCardIndex >= 0)
 			{
-				m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
+                m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
 			}
 		}
 		opposingSideHandZone.SetDoNotUpdateLayout(enable: false);
@@ -1624,9 +1637,10 @@ public class MulliganManager : MonoBehaviour
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeDealingBaseMulliganCards());
 		float xOffset2 = spacingToUse / 2f;
+		AccessibleGameplay.Get().OnStartingHand(m_startingCards);
 		for (int i = 0; i < numCardsToDealExcludingBonusCard; i++)
 		{
-			GameObject topCard = m_startingCards[i].gameObject;
+            GameObject topCard = m_startingCards[i].gameObject;
 			iTween.Stop(topCard);
 			Vector3[] array = new Vector3[3]
 			{
@@ -1660,11 +1674,12 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeCoinFlip());
 		if (coinObject != null)
 		{
-			Transform transform = Board.Get().FindBone("MulliganCoinPosition");
+            Transform transform = Board.Get().FindBone("MulliganCoinPosition");
 			coinObject.transform.position = transform.position;
 			coinObject.transform.localEulerAngles = transform.localEulerAngles;
 			coinObject.SetActive(value: true);
 			coinObject.GetComponent<CoinEffect>().DoAnim(friendlyPlayerGoesFirst);
+			AccessibleGameplay.Get().OnCoinResult(friendlyPlayerGoesFirst);
 			SoundManager.Get().LoadAndPlay("FX_MulliganCoin03_CoinFlip.prefab:07015cb3f02713a45aa03fc3aa798778", coinObject);
 			coinLocation = transform.position;
 			AssetLoader.Get().InstantiatePrefab("MulliganResultText.prefab:0369b435afd2e344db21e58648f8636c", CoinTossTextCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
@@ -1673,7 +1688,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterCoinFlip());
 		if (!friendlyPlayerGoesFirst)
 		{
-			GameObject topCard = m_startingCards[m_bonusCardIndex].gameObject;
+            GameObject topCard = m_startingCards[m_bonusCardIndex].gameObject;
 			Vector3[] array2 = new Vector3[3]
 			{
 				topCard.transform.position,
@@ -1688,7 +1703,7 @@ public class MulliganManager : MonoBehaviour
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
 			opposingSideHandZone.UpdateLayout(null, forced: true, 4);
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterDealingBonusCard());
@@ -1700,7 +1715,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeSpreadingMulliganCards());
 		if (friendlyPlayerGoesFirst)
 		{
-			xOffset2 = 0f;
+            xOffset2 = 0f;
 			for (int num3 = m_startingCards.Count - 1; num3 >= 0; num3--)
 			{
 				GameObject target = m_startingCards[num3].gameObject;
@@ -1710,22 +1725,23 @@ public class MulliganManager : MonoBehaviour
 			}
 		}
 		GameState.Get().GetGameEntity().OnMulliganCardsDealt(m_startingCards);
+		AccessibleGameplay.Get().OnMulliganCardsDealt(m_startingCards);
 		yield return new WaitForSeconds(0.6f);
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterSpreadingMulliganCards());
 		if (skipCardChoosing)
 		{
-			if (GameState.Get().IsMulliganPhase())
+            if (GameState.Get().IsMulliganPhase())
 			{
-				if (GameState.Get().IsFriendlySidePlayerTurn())
+                if (GameState.Get().IsFriendlySidePlayerTurn())
 				{
-					TurnStartManager.Get().BeginListeningForTurnEvents();
+                    TurnStartManager.Get().BeginListeningForTurnEvents();
 				}
 				m_WaitForOpponentToFinishMulligan = WaitForOpponentToFinishMulligan();
 				StartCoroutine(m_WaitForOpponentToFinishMulligan);
 			}
 			else
 			{
-				yield return new WaitForSeconds(2f);
+                yield return new WaitForSeconds(2f);
 				EndMulligan();
 			}
 			yield break;
@@ -1759,12 +1775,26 @@ public class MulliganManager : MonoBehaviour
 			mulliganButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton();
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
+
+				if (AccessibilityMgr.IsAccessibilityEnabled())
+				{
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+				}
+				else
+                {
+                    innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+                }
+            }
+
+			AccessibleGameplay.Get().OnMulliganChoiceStart(m_startingCards, mulliganButton);
 		}
 		GameState.Get().GetGameEntity().StartMulliganSoundtracks(soft: true);
 		m_waitingForUserInput = true;
@@ -2434,6 +2464,7 @@ public class MulliganManager : MonoBehaviour
 
 	private IEnumerator WaitForOpponentToFinishMulligan()
 	{
+		AccessibleGameplay.Get().WaitingForOpponentToFinishMulligan();
 		DestroyChooseBanner();
 		DestroyDetailLabel();
 		DestroyTagConditionalVFXs();
@@ -3005,6 +3036,7 @@ public class MulliganManager : MonoBehaviour
 
 	public void EndMulligan()
 	{
+		AccessibleGameplay.Get().EndMulligan();
 		m_waitingForUserInput = false;
 		if (m_replaceLabels != null)
 		{
@@ -3144,7 +3176,7 @@ public class MulliganManager : MonoBehaviour
 				coinObject.GetComponentInChildren<PlayMakerFSM>().SendEvent("Birth");
 				yield return new WaitForSeconds(0.1f);
 			}
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_COIN_INTRO"), "VO_INNKEEPER_COIN_INTRO.prefab:6fb1b3b124d474c4c84e392646caada4");
 				Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, val: true);
@@ -3202,6 +3234,7 @@ public class MulliganManager : MonoBehaviour
 
 	private void CoinCardSummonFinishedCallback(Spell spell, object userData)
 	{
+		AccessibleGameplay.Get().OnCoinCard();
 		Card card = SceneUtils.FindComponentInParents<Card>(spell);
 		card.RefreshActor();
 		card.UpdateActorComponents();
diff --git a/Decompiled/Assembly-CSharp/MultiPagePopup.cs b/Decompiled/Assembly-CSharp/MultiPagePopup.cs
index 86a5704..78f7da9 100644
--- a/Decompiled/Assembly-CSharp/MultiPagePopup.cs
+++ b/Decompiled/Assembly-CSharp/MultiPagePopup.cs
@@ -1,9 +1,10 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
 
 [CustomEditClass]
-public class MultiPagePopup : DialogBase
+public class MultiPagePopup : InaccessibleDialogBase
 {
 	public enum PageType
 	{
@@ -26,6 +27,8 @@ public class MultiPagePopup : DialogBase
 		public List<CollectibleCard> m_cardsToShow;
 
 		public int m_dustAmount;
+
+		public PageInfo(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	public class Info
@@ -35,6 +38,8 @@ public class MultiPagePopup : DialogBase
 		public bool m_blurWhenShown;
 
 		public List<PageInfo> m_pages = new List<PageInfo>();
+
+		public Info(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	private readonly Map<PageType, string> m_pagePrefabRefs = new Map<PageType, string>
@@ -55,7 +60,7 @@ public class MultiPagePopup : DialogBase
 	[CustomEditField(Sections = "Sounds", T = EditType.SOUND_PREFAB)]
 	public string m_hideAnimationSound = "Shrink_Down_Quicker.prefab:2fe963b171811ca4b8d544fa53e3330c";
 
-	private Info m_info = new Info();
+	private Info m_info = new Info(true);
 
 	private int m_currentPageIdx;
 
@@ -63,6 +68,11 @@ public class MultiPagePopup : DialogBase
 
 	private int m_numPagesLoaded;
 
+	private MultiPagePopup()
+    {
+		// Protect against constructors due to accessibility and the fact that this has a dangling m_info (Info subclass)
+    }
+
 	protected override void OnDestroy()
 	{
 		base.OnDestroy();
diff --git a/Decompiled/Assembly-CSharp/NarrativeManager.cs b/Decompiled/Assembly-CSharp/NarrativeManager.cs
index 283f3b8..868693e 100644
--- a/Decompiled/Assembly-CSharp/NarrativeManager.cs
+++ b/Decompiled/Assembly-CSharp/NarrativeManager.cs
@@ -837,7 +837,7 @@ public class NarrativeManager : MonoBehaviour
 		{
 			return false;
 		}
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/NetCache.cs b/Decompiled/Assembly-CSharp/NetCache.cs
index 83bbbbd..20bc008 100644
--- a/Decompiled/Assembly-CSharp/NetCache.cs
+++ b/Decompiled/Assembly-CSharp/NetCache.cs
@@ -2109,24 +2109,50 @@ public class NetCache : IService, IHasUpdate
 		return GetNetObject<T>() != null;
 	}
 
+	#region Accessibility
+	private NetCacheBoosters m_testNetCacheBoosters;
+
+    internal void SetTestDataNetCacheBoosters(NetCacheBoosters netCacheBoosters)
+    {
+		m_testNetCacheBoosters = netCacheBoosters;
+    }
+	#endregion
+
 	private object GetTestData(Type type)
 	{
+		if (type == typeof(NetCacheBoosters) && m_testNetCacheBoosters != null)
+        {
+			return m_testNetCacheBoosters;
+        }
+
 		if (type == typeof(NetCacheBoosters) && GameUtils.IsFakePackOpeningEnabled())
 		{
 			NetCacheBoosters netCacheBoosters = new NetCacheBoosters();
 			int fakePackCount = GameUtils.GetFakePackCount();
-			BoosterStack item = new BoosterStack
-			{
-				Id = 1,
-				Count = fakePackCount
-			};
-			netCacheBoosters.BoosterStacks.Add(item);
+			AddTestPack(netCacheBoosters.BoosterStacks, 1, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 23, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 468, 7);
+			AddTestPack(netCacheBoosters.BoosterStacks, 470, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 545, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 553, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 616, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 633, 1);
 			return netCacheBoosters;
 		}
 		return null;
 	}
 
-	public void UnloadNetObject<T>()
+    private void AddTestPack(List<BoosterStack> boosterStacks, int packId, int packCount)
+    {
+		BoosterStack item = new BoosterStack
+		{
+			Id = packId,
+			Count = packCount
+		};
+		boosterStacks.Add(item);
+    }
+
+    public void UnloadNetObject<T>()
 	{
 		Type typeFromHandle = typeof(T);
 		m_netCache[typeFromHandle] = null;
diff --git a/Decompiled/Assembly-CSharp/NotificationManager.cs b/Decompiled/Assembly-CSharp/NotificationManager.cs
index 79fd88b..4111cbe 100644
--- a/Decompiled/Assembly-CSharp/NotificationManager.cs
+++ b/Decompiled/Assembly-CSharp/NotificationManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -241,7 +242,7 @@ public class NotificationManager : MonoBehaviour
 
 	private Notification popUpDialog;
 
-	private Notification m_quote;
+	internal Notification m_quote;
 
 	private List<string> m_quotesThisSession;
 
@@ -289,28 +290,28 @@ public class NotificationManager : MonoBehaviour
 		return s_instance;
 	}
 
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
-	{
-		return CreatePopupDialog(headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
-	}
-
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
-	{
-		if (popUpDialog != null)
-		{
-			UnityEngine.Object.Destroy(popUpDialog.gameObject);
-		}
-		GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
-		Vector3 position = Camera.main.transform.position;
-		gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
-		popUpDialog = gameObject.GetComponent<Notification>();
-		popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
-		popUpDialog.PlayBirth();
-		UniversalInputManager.Get().SetGameDialogActive(active: true);
-		return popUpDialog;
-	}
-
-	public Notification CreateSpeechBubble(string speechText, Actor actor)
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
+    {
+        return CreatePopupDialog(accessible, headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
+    }
+
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
+    {
+        if (popUpDialog != null)
+        {
+            UnityEngine.Object.Destroy(popUpDialog.gameObject);
+        }
+        GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
+        Vector3 position = Camera.main.transform.position;
+        gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
+        popUpDialog = gameObject.GetComponent<Notification>();
+        popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
+        popUpDialog.PlayBirth();
+        UniversalInputManager.Get().SetGameDialogActive(active: true);
+        return popUpDialog;
+    }
+
+    public Notification CreateSpeechBubble(string speechText, Actor actor)
 	{
 		return CreateSpeechBubble(speechText, Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: false);
 	}
@@ -427,12 +428,13 @@ public class NotificationManager : MonoBehaviour
 			DestroyNotification(component, options.emoteDuration);
 		}
 		component.notificationGroup = options.speechBubbleGroup;
+		AccessibleNotificationMgr.OnCreateNotificationWithSound(component);
 		return component;
 	}
 
 	public Notification CreateBouncingArrow(UserAttentionBlocker blocker, bool addToList)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManger.CreateBouncingArrow"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManger.CreateBouncingArrow"))
 		{
 			return null;
 		}
@@ -452,7 +454,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreateBouncingArrow(UserAttentionBlocker blocker, Vector3 position, Vector3 rotation, bool addToList, float scaleFactor = 1f)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManger.CreateBouncingArrow"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManger.CreateBouncingArrow"))
 		{
 			return null;
 		}
@@ -498,7 +500,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreatePopupText(UserAttentionBlocker blocker, Vector3 position, Vector3 scale, string text, bool convertLegacyPosition = true, PopupTextType popupTextType = PopupTextType.BASIC)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreatePopupText"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreatePopupText"))
 		{
 			return null;
 		}
@@ -517,6 +519,7 @@ public class NotificationManager : MonoBehaviour
 		component.ChangeText(text);
 		component.PlayBirth();
 		popUpTexts.Add(component);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(component);
 		return component;
 	}
 
@@ -532,7 +535,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreateInnkeeperQuote(UserAttentionBlocker blocker, Vector3 position, string text, string soundPath, float durationSeconds = 0f, Action<int> finishCallback = null, bool clickToDismiss = false)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreateInnkeeperQuote"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreateInnkeeperQuote"))
 		{
 			finishCallback?.Invoke(0);
 			return null;
@@ -759,7 +762,8 @@ public class NotificationManager : MonoBehaviour
 			return;
 		}
 		m_quote.PlayBirthWithForcedScale(Vector3.one);
-		if (durationSeconds > 0f)
+        AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        if (durationSeconds > 0f)
 		{
 			if (persistCharacter)
 			{
@@ -789,8 +793,9 @@ public class NotificationManager : MonoBehaviour
 			quoteSoundCallbackData.m_quote = m_quote;
 			quoteSoundCallbackData.m_durationSeconds = durationSeconds;
 			SoundLoader.LoadSound(soundPath, OnQuoteSoundLoaded, quoteSoundCallbackData, SoundManager.Get().GetPlaceholderSound());
-		}
-		else
+            AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        }
+        else
 		{
 			PlayQuoteWithoutSound(durationSeconds, text);
 		}
@@ -799,6 +804,7 @@ public class NotificationManager : MonoBehaviour
 	private void PlayQuoteWithoutSound(float durationSeconds, string text = null)
 	{
 		m_quote.PlayBirthWithForcedScale(UniversalInputManager.UsePhoneUI ? NOTIFICATION_SCALE_PHONE : NOTIFICATION_SCALE);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(m_quote);
 		if (durationSeconds <= 0f && text != null)
 		{
 			durationSeconds = ClipLengthEstimator.StringToReadTime(text);
diff --git a/Decompiled/Assembly-CSharp/Option.cs b/Decompiled/Assembly-CSharp/Option.cs
index ef0c23a..8a37498 100644
--- a/Decompiled/Assembly-CSharp/Option.cs
+++ b/Decompiled/Assembly-CSharp/Option.cs
@@ -570,5 +570,10 @@ public enum Option
 	[Description("hasSeenClassicModeVO")]
 	HAS_SEEN_CLASSIC_MODE_VO,
 	[Description("hasAcceptedPrivacyPolicyAndEULA")]
-	HAS_ACCEPTED_PRIVACY_POLICY_AND_EULA
+	HAS_ACCEPTED_PRIVACY_POLICY_AND_EULA,
+
+	#region Accessibility
+	[Description("accessibilityGameSpeed")]
+	ACCESSIBILITY_GAME_SPEED
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/OptionDataTables.cs b/Decompiled/Assembly-CSharp/OptionDataTables.cs
index bc5a647..08b407d 100644
--- a/Decompiled/Assembly-CSharp/OptionDataTables.cs
+++ b/Decompiled/Assembly-CSharp/OptionDataTables.cs
@@ -659,7 +659,13 @@ public class OptionDataTables
 		{
 			Option.FORMAT_TYPE_LAST_PLAYED,
 			typeof(int)
-		}
+		},
+		#region Accessibility
+		{
+            Option.ACCESSIBILITY_GAME_SPEED,
+			typeof(int)
+        }
+		#endregion
 	};
 
 	public static readonly Map<Option, object> s_defaultsMap = new Map<Option, object>
@@ -686,7 +692,7 @@ public class OptionDataTables
 		},
 		{
 			Option.SOUND_VOLUME,
-			1f
+			0.5f // Start lower due to screen readers as it's easier for beginners
 		},
 		{
 			Option.MUSIC_VOLUME,
@@ -1127,6 +1133,12 @@ public class OptionDataTables
 		{
 			Option.HAS_SEEN_CLASSIC_MODE_VO,
 			false
-		}
+		},
+		#region Accessibility
+        {
+			Option.ACCESSIBILITY_GAME_SPEED,
+			3
+        }
+		#endregion
 	};
 }
diff --git a/Decompiled/Assembly-CSharp/OptionsMenu.cs b/Decompiled/Assembly-CSharp/OptionsMenu.cs
index 2ba5628..d3d54a2 100644
--- a/Decompiled/Assembly-CSharp/OptionsMenu.cs
+++ b/Decompiled/Assembly-CSharp/OptionsMenu.cs
@@ -3,9 +3,10 @@ using System.Collections.Generic;
 using Hearthstone;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class OptionsMenu : MonoBehaviour
+public class OptionsMenu : MonoBehaviour, AccessibleUI
 {
 	public delegate void hideHandler();
 
@@ -259,10 +260,13 @@ public class OptionsMenu : MonoBehaviour
 		UpdateOtherUI();
 		ShowOrHide(showOrHide: true);
 		AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
+
+		ReadMenu();
 	}
 
 	public void Hide(bool callHideHandler = true)
 	{
+		AccessibilityMgr.HideUI(this);
 		ShowOrHide(showOrHide: false);
 		if (m_hideHandler != null && callHideHandler)
 		{
@@ -354,7 +358,7 @@ public class OptionsMenu : MonoBehaviour
 
 	private bool CanShowOtherMenuOptions()
 	{
-		if (UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: false) != 0)
+		if (UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: false) != 0)
 		{
 			return false;
 		}
@@ -645,4 +649,132 @@ public class OptionsMenu : MonoBehaviour
 		m_privacyMenu.Show();
 		m_privacyMenuLoading = false;
 	}
+
+	#region
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleScrollbarControl m_accessibleScrollbar;
+
+	private AccessibleCheckBox m_accessibleCheckBox;
+
+	private AccessibleDropdownControl m_accessibleDropdown;
+
+	private enum AccessibleMenuState { MAIN_MENU, ADJUSTING_MASTER_VOLUME, ADJUSTING_MUSIC_VOLUME, ADJUSTING_GRAPHICS_QUALITY, ADJUSTING_GRAPHICS_RESOLUTION };
+
+	private AccessibleMenuState m_curState;
+
+	private void ReadMenu()
+    {
+        AccessibilityMgr.ShowUI(this);
+
+		SetupMainMenu();
+    }
+
+	private void SetupMainMenu()
+    {
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_TITLE), () => Hide(), true);
+
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MASTER_VOLUME_OPTION), OnClickMasterVolume);
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_MUSIC_VOLUME_OPTION), OnClickMusicVolume);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION)), OnToggleSoundInBackground);
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION), OnClickGraphicsResolutionDropdown);
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_GRAPHICS_QUALITY_OPTION), OnClickGraphicsQualityDropdown);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FULLSCREEN_OPTION)), OnToggleFullscreen);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ALLOW_SPECTATORS_OPTION)), OnToggleAllowSpectators);
+        m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION)), OnToggleScreenShake);
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void BackToMainMenu()
+    {
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu.ReadCurrentOption();
+    }
+
+    private void OnClickGraphicsQualityDropdown()
+    {
+		m_accessibleDropdown = new AccessibleDropdownControl(this, m_graphicsQuality, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_GRAPHICS_QUALITY;
+		m_accessibleDropdown.StartReading();
+    }
+
+    private void OnClickGraphicsResolutionDropdown()
+    {
+		m_accessibleDropdown = new AccessibleDropdownControl(this, m_graphicsRes, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_GRAPHICS_RESOLUTION;
+		m_accessibleDropdown.StartReading();
+    }
+
+    private void OnClickMasterVolume()
+    {
+		m_accessibleScrollbar = new AccessibleScrollbarControl(this, m_masterVolume, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_MASTER_VOLUME;
+		AccessibilityMgr.Output(this, LocalizedText.OPTIONS_MENU_ADJUST_VOLUME);
+    }
+
+    private void OnClickMusicVolume()
+    {
+		m_accessibleScrollbar = new AccessibleScrollbarControl(this, m_musicVolume, BackToMainMenu);
+		m_curState = AccessibleMenuState.ADJUSTING_MUSIC_VOLUME;
+		AccessibilityMgr.Output(this, LocalizedText.OPTIONS_MENU_ADJUST_VOLUME);
+    }
+
+    private void OnToggleFullscreen()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_fullScreenCheckbox);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    private void OnToggleSoundInBackground()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_backgroundSound);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    private void OnToggleAllowSpectators()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_spectatorOpenJoinCheckbox);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    private void OnToggleScreenShake()
+    {
+		m_accessibleCheckBox = new AccessibleCheckBox(this, m_screenShakeCheckbox);
+		m_accessibleCheckBox.Toggle();
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+        {
+            m_accessibleMenu?.HandleAccessibleInput();
+        }
+		else if (m_curState == AccessibleMenuState.ADJUSTING_MASTER_VOLUME || m_curState == AccessibleMenuState.ADJUSTING_MUSIC_VOLUME)
+        {
+			m_accessibleScrollbar?.HandleInput();
+        }
+		else if (m_curState == AccessibleMenuState.ADJUSTING_GRAPHICS_QUALITY || m_curState == AccessibleMenuState.ADJUSTING_GRAPHICS_RESOLUTION)
+        {
+			m_accessibleDropdown?.HandleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+        {
+            return m_accessibleMenu?.GetHelp();
+        }
+		else if (m_curState == AccessibleMenuState.ADJUSTING_MASTER_VOLUME || m_curState == AccessibleMenuState.ADJUSTING_MUSIC_VOLUME)
+        {
+			return LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ADJUST_VOLUME);
+        }
+
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs b/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
index f5bc7a8..88c2b04 100644
--- a/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
+++ b/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using System;
 using System.Collections;
 using UnityEngine;
 
-public class OutstandingDraftTicketDialog : DialogBase
+public class OutstandingDraftTicketDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/PackOpening.cs b/Decompiled/Assembly-CSharp/PackOpening.cs
index 9bf0d61..b64b864 100644
--- a/Decompiled/Assembly-CSharp/PackOpening.cs
+++ b/Decompiled/Assembly-CSharp/PackOpening.cs
@@ -6,8 +6,9 @@ using Hearthstone.Progression;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
-public class PackOpening : MonoBehaviour
+public class PackOpening : MonoBehaviour, AccessibleScreen
 {
 	public PackOpeningBones m_Bones;
 
@@ -394,12 +395,12 @@ public class PackOpening : MonoBehaviour
 		BnetBar.Get().HideCurrencyTemporarily();
 		if (GameUtils.IsFakePackOpeningEnabled())
 		{
-			StartCoroutine(OnFakeBoosterOpened());
+			StartCoroutine(OnFakeBoosterOpened(pack.GetBoosterStack().Id));
 		}
 		m_UnopenedPackScroller.Pause(pause: true);
 	}
 
-	private IEnumerator OnFakeBoosterOpened()
+	private IEnumerator OnFakeBoosterOpened(int boosterId)
 	{
 		float seconds = Random.Range(0f, 1f);
 		yield return new WaitForSeconds(seconds);
@@ -424,6 +425,10 @@ public class PackOpening : MonoBehaviour
 		boosterCard.Def.Name = "EX1_350";
 		boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
 		list.Add(boosterCard);
+
+		//
+		m_director.Play(boosterId);
+		m_autoOpenPending = false;
 		m_director.OnBoosterOpened(list);
 	}
 
@@ -605,6 +610,7 @@ public class PackOpening : MonoBehaviour
 			m_InputBlocker.SetActive(value: false);
 			CreateDirector();
 			LayoutPacks(animate: true);
+			ReadChoosePack();
 		}
 		BnetBar.Get().RefreshCurrency();
 	}
@@ -628,7 +634,7 @@ public class PackOpening : MonoBehaviour
 			return;
 		}
 		list[0].PlayAlert();
-		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnUnopenedPack") && m_hintArrow == null)
+		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "PackOpening.ShowHintOnUnopenedPack") && m_hintArrow == null)
 		{
 			Bounds bounds = list[0].GetComponent<Collider>().bounds;
 			Vector3 center = bounds.center;
@@ -657,7 +663,7 @@ public class PackOpening : MonoBehaviour
 
 	private void ShowHintOnSlot()
 	{
-		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnSlot"))
+		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "PackOpening.ShowHintOnSlot"))
 		{
 			if (m_hintArrow == null)
 			{
@@ -730,9 +736,11 @@ public class PackOpening : MonoBehaviour
 				unopenedPack.Value.SetEnabled(enabled: true);
 			}
 		}
+
+		AccessibilityOnUpdateUIEvents();
 	}
 
-	private void UnregisterUIEvents()
+    private void UnregisterUIEvents()
 	{
 		m_enableBackButton = false;
 		m_BackButton.SetEnabled(enabled: false);
@@ -802,21 +810,27 @@ public class PackOpening : MonoBehaviour
 		m_DragPlane.SetActive(value: false);
 	}
 
-	private void AutomaticallyOpenPack()
+	private void AutomaticallyOpenPack(UnopenedPack pack)
 	{
 		HideUnopenedPackTooltip();
-		UnopenedPack value = null;
-		if (!m_unopenedPacks.TryGetValue(m_lastOpenedBoosterId, out value) || value.GetBoosterStack().Count == 0)
+		UnopenedPack value = pack;
+
+		if (value == null)
 		{
-			foreach (KeyValuePair<int, UnopenedPack> unopenedPack in m_unopenedPacks)
+			// Normal HS flow
+			if (!m_unopenedPacks.TryGetValue(m_lastOpenedBoosterId, out value) || value.GetBoosterStack().Count == 0)
 			{
-				if (!(unopenedPack.Value == null) && unopenedPack.Value.GetBoosterStack().Count > 0)
+				foreach (KeyValuePair<int, UnopenedPack> unopenedPack in m_unopenedPacks)
 				{
-					value = unopenedPack.Value;
-					break;
+					if (!(unopenedPack.Value == null) && unopenedPack.Value.GetBoosterStack().Count > 0)
+					{
+						value = unopenedPack.Value;
+						break;
+					}
 				}
 			}
 		}
+
 		if (!(value == null) && value.CanOpenPack())
 		{
 			if (m_draggedPack != null || m_InputBlocker.activeSelf)
@@ -942,7 +956,7 @@ public class PackOpening : MonoBehaviour
 			yield return null;
 		}
 		yield return new WaitForSeconds(waitTime);
-		AutomaticallyOpenPack();
+		AutomaticallyOpenPack(null);
 	}
 
 	private void OnPackOpeningFXLoaded(AssetReference assetRef, GameObject go, object callbackData)
@@ -1003,4 +1017,161 @@ public class PackOpening : MonoBehaviour
 		DialogManager.Get().ShowReconnectHelperDialog();
 		Navigation.Clear();
 	}
+
+    #region Accessibility
+	private enum AccessibleState { LOADING, CHOOSING_PACK };
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleListOfItems<AccessibleUnopenedPack> m_accessiblePacks;
+
+    private void AccessibilityOnUpdateUIEvents()
+    {
+		AccessibilityMgr.SetScreen(this);
+    }
+
+    private void ReadChoosePack()
+    {
+		m_curAccessibleState = AccessibleState.CHOOSING_PACK;
+
+		if (GetNumUnopenedPacks() == 0)
+        {
+			// Players can't enter the screen if they don't have card packs. The screen sends them back to Hub if they've opened all
+			return;
+        }
+
+		if (m_accessiblePacks != null && m_accessiblePacks.Count == GetNumUnopenedPacks())
+        {
+			m_accessiblePacks.StartReading();
+			return;
+        }
+
+		var unopenedPacks = GetSortedUnopenedPacks();
+		var accessiblePacks = new List<AccessibleUnopenedPack>();
+
+        foreach (var pack in unopenedPacks)
+        {
+			if (pack.GetBoosterStack().Count > 0)
+            {
+                accessiblePacks.Add(new AccessibleUnopenedPack(this, pack));
+            }
+        }
+
+		m_accessiblePacks = new AccessibleListOfItems<AccessibleUnopenedPack>(this, accessiblePacks);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS));
+		m_accessiblePacks.StartReading();
+        AccessibilityUtils.CenterScrollbarAroundObject(m_UnopenedPackScroller, m_accessiblePacks.GetItemBeingRead().GetUnopenedPack().gameObject);
+    }
+
+    private List<UnopenedPack> GetSortedUnopenedPacks()
+    {
+		// Index by game object to compare
+		var gameObjectIndex = new Dictionary<GameObject, int>();
+		var spacedObjects = m_UnopenedPackContainer.m_Objects;
+		for (var i = 0; i < spacedObjects.Count; i++) 
+        {
+			var spacedObject = spacedObjects[i];
+			if (spacedObject != null && spacedObject.m_Object != null)
+            {
+                gameObjectIndex.Add(spacedObject.m_Object, i);
+            }
+        }
+
+		// Use index to sort
+		var ret = new List<UnopenedPack>();
+		ret.AddRange(m_unopenedPacks.Values);
+		ret.RemoveAll(p => p.GetBoosterStack().Count == 0);
+		ret.Sort((a, b) => gameObjectIndex[a.gameObject] - gameObjectIndex[b.gameObject]);
+
+		return ret;
+    }
+
+    private int GetNumUnopenedPacks()
+    {
+		int ret = 0;
+
+		foreach (var entry in m_unopenedPacks)
+        {
+			if (entry.Value.GetBoosterStack().Count > 0)
+            {
+				ret++;
+            }
+        }
+
+		return ret;
+    }
+
+    private bool FinishedLoadingPacks()
+    {
+        foreach (var pack in m_unopenedPacksLoading)
+        {
+			if (pack.Value)
+            {
+				return false;
+            }
+        }
+
+		return true;
+    }
+
+    public void HandleInput()
+    {
+		if (m_curAccessibleState == AccessibleState.LOADING)
+        {
+			if (FinishedLoadingPacks())
+            {
+				ReadChoosePack();
+				return;
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_PACK)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				// TODO: Locked, open, etc
+				TryOpenPack();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				m_BackButton.TriggerRelease();
+            }
+			else if (m_accessiblePacks.HandleAccessibleInput())
+			{
+				AccessibilityUtils.CenterScrollbarAroundObject(m_UnopenedPackScroller, m_accessiblePacks.GetItemBeingRead().GetUnopenedPack().gameObject);
+			}
+        }
+    }
+
+    private void TryOpenPack()
+    {
+		var curPack = m_accessiblePacks.GetItemBeingRead();
+
+		if (curPack.IsLocked())
+        {
+			AccessibilityMgr.Output(this, curPack.GetLockedRibbonText());
+        }
+		else
+        {
+			AutomaticallyOpenPack(curPack.GetUnopenedPack());
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.LOADING)
+        {
+			return LocalizedText.GLOBAL_LOADING;
+        }
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_PACK)
+        {
+			return m_accessiblePacks?.GetHelp(true);
+        }
+
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PackOpeningButton.cs b/Decompiled/Assembly-CSharp/PackOpeningButton.cs
index 6fbb2eb..7afa78b 100644
--- a/Decompiled/Assembly-CSharp/PackOpeningButton.cs
+++ b/Decompiled/Assembly-CSharp/PackOpeningButton.cs
@@ -6,6 +6,9 @@ public class PackOpeningButton : BoxMenuButton
 
 	public GameObject m_countFrame;
 
+	// Accessibility
+	public int m_numPacks;
+
 	public string GetGetPackCount()
 	{
 		return m_count.Text;
@@ -13,6 +16,8 @@ public class PackOpeningButton : BoxMenuButton
 
 	public void SetPackCount(int packs)
 	{
+		m_numPacks = packs;
+
 		if (packs < 0)
 		{
 			m_count.Text = "";
diff --git a/Decompiled/Assembly-CSharp/PackOpeningCard.cs b/Decompiled/Assembly-CSharp/PackOpeningCard.cs
index 149bfb2..70343c6 100644
--- a/Decompiled/Assembly-CSharp/PackOpeningCard.cs
+++ b/Decompiled/Assembly-CSharp/PackOpeningCard.cs
@@ -26,13 +26,13 @@ public class PackOpeningCard : MonoBehaviour
 
 	private NetCache.BoosterCard m_boosterCard;
 
-	private TAG_PREMIUM m_premium;
+	internal TAG_PREMIUM m_premium;
 
 	private DefLoader.DisposableFullDef m_fullDef;
 
 	private Actor m_actor;
 
-	private PackOpeningCardRarityInfo m_rarityInfo;
+	internal PackOpeningCardRarityInfo m_rarityInfo;
 
 	private Spell m_spell;
 
@@ -46,7 +46,7 @@ public class PackOpeningCard : MonoBehaviour
 
 	private bool m_revealed;
 
-	private bool m_isNew;
+	internal bool m_isNew;
 
 	private List<RevealedListener> m_revealedListeners = new List<RevealedListener>();
 
@@ -206,17 +206,17 @@ public class PackOpeningCard : MonoBehaviour
 	{
 		if (fullDef == null)
 		{
-			Debug.LogError($"PackOpeningCard.OnFullDefLoaded() - FAILED to load \"{cardId}\"");
+            Debug.LogError($"PackOpeningCard.OnFullDefLoaded() - FAILED to load \"{cardId}\"");
 			return;
 		}
 		DisposeFullDef();
 		m_fullDef = fullDef;
 		if (DetermineRarityInfo())
 		{
-			AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(m_fullDef.EntityDef, m_premium), OnActorLoaded, null, AssetLoadingOptions.IgnorePrefabPosition);
-			if (Cheats.Get().IsNewCardInPackOpeningEnabed())
+            AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(m_fullDef.EntityDef, m_premium), OnActorLoaded, null, AssetLoadingOptions.IgnorePrefabPosition);
+            if (Cheats.Get().IsNewCardInPackOpeningEnabed())
 			{
-				CollectibleCard card = CollectionManager.Get().GetCard(m_fullDef.EntityDef.GetCardId(), m_premium);
+                CollectibleCard card = CollectionManager.Get().GetCard(m_fullDef.EntityDef.GetCardId(), m_premium);
 				m_isNew = card.SeenCount < 1 && card.OwnedCount < 2;
 			}
 		}
@@ -232,10 +232,10 @@ public class PackOpeningCard : MonoBehaviour
 	{
 		if (go == null)
 		{
-			Debug.LogError($"PackOpeningCard.OnActorLoaded() - FAILED to load actor \"{assetRef}\"");
+            Debug.LogError($"PackOpeningCard.OnActorLoaded() - FAILED to load actor \"{assetRef}\"");
 			return;
 		}
-		Actor component = go.GetComponent<Actor>();
+        Actor component = go.GetComponent<Actor>();
 		if (component == null)
 		{
 			Debug.LogError($"PackOpeningCard.OnActorLoaded() - ERROR actor \"{base.name}\" has no Actor component");
@@ -468,7 +468,7 @@ public class PackOpeningCard : MonoBehaviour
 		}
 	}
 
-	private string GetClassName()
+	internal string GetClassName()
 	{
 		TAG_CLASS @class = m_fullDef.EntityDef.GetClass();
 		if (m_fullDef.EntityDef.IsMultiClass())
diff --git a/Decompiled/Assembly-CSharp/PackOpeningDirector.cs b/Decompiled/Assembly-CSharp/PackOpeningDirector.cs
index 061d9ad..8ca1073 100644
--- a/Decompiled/Assembly-CSharp/PackOpeningDirector.cs
+++ b/Decompiled/Assembly-CSharp/PackOpeningDirector.cs
@@ -4,9 +4,10 @@ using System.Collections.Generic;
 using System.Linq;
 using Hearthstone.Progression;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class PackOpeningDirector : MonoBehaviour
+public class PackOpeningDirector : MonoBehaviour, AccessibleUI
 {
 	public delegate void FinishedCallback(object userData);
 
@@ -199,6 +200,7 @@ public class PackOpeningDirector : MonoBehaviour
 			this.OnDoneOpeningPack();
 		}
 		HideKeywordTooltips();
+		AccessibilityMgr.HideUI(this);
 		return true;
 	}
 
@@ -282,6 +284,7 @@ public class PackOpeningDirector : MonoBehaviour
 			hiddenCard.EnableReveal(enable: true);
 		}
 		AttachCardsToCarousel();
+		ReadCards();
 	}
 
 	private void CameraBlurOn()
@@ -412,6 +415,8 @@ public class PackOpeningDirector : MonoBehaviour
 	private void OnDoneButtonShown(Spell spell, object userData)
 	{
 		m_doneButton.AddEventListener(UIEventType.RELEASE, OnDoneButtonPressed);
+
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 	}
 
 	private void HideDoneButton()
@@ -495,6 +500,11 @@ public class PackOpeningDirector : MonoBehaviour
 				BnetPresenceMgr.Get().SetGameField(4u, packOpeningCard.GetCardId() + ",0");
 			}
 		}
+
+		// a11y
+		AccessibilityOnRevealedCard(packOpeningCard);
+		// a11y
+
 		m_cardsPendingReveal--;
 		if (m_cardsPendingReveal <= 0)
 		{
@@ -503,7 +513,7 @@ public class PackOpeningDirector : MonoBehaviour
 		}
 	}
 
-	private void OnHiddenCardSpellFinished(Spell spell, object userData)
+    private void OnHiddenCardSpellFinished(Spell spell, object userData)
 	{
 		OnEffectFinished();
 	}
@@ -524,7 +534,7 @@ public class PackOpeningDirector : MonoBehaviour
 		{
 			yield return null;
 			NetCache.BoosterCard boosterCard = cards[i];
-			m_hiddenCards[i].AttachBoosterCard(boosterCard);
+            m_hiddenCards[i].AttachBoosterCard(boosterCard);
 			int num = i + 1;
 			i = num;
 		}
@@ -556,4 +566,89 @@ public class PackOpeningDirector : MonoBehaviour
 			array[i].Fire();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleListOfItems<AccessiblePackOpeningCard> m_accessiblePackOpeningCards;
+
+	private void ReadCards()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		var accessiblePackOpeningCards = new List<AccessiblePackOpeningCard>();
+		foreach(var card in m_hiddenCards)
+        {
+			accessiblePackOpeningCards.Add(new AccessiblePackOpeningCard(this, card));
+        }
+
+		m_accessiblePackOpeningCards = new AccessibleListOfItems<AccessiblePackOpeningCard>(this, accessiblePackOpeningCards);
+		m_accessiblePackOpeningCards.StartReading();
+		AccessibleInputMgr.MoveMouseTo(m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed() || AccessibleKey.SPACE.IsPressed())
+        {
+			if (m_doneButtonShown)
+            {
+				m_doneButton.TriggerRelease();
+            }
+			else
+            {
+                TryRevealCard();
+            }
+        }
+		else if (AccessibleKey.READ_TOOLTIP.IsPressed())
+        {
+            AccessibilityUtils.ReadTooltip(this);
+        }
+		else
+        {
+			if (m_accessiblePackOpeningCards?.HandleAccessibleInput() ?? false)
+            {
+				AccessibleInputMgr.MoveMouseTo(m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard());
+            }
+        }
+    }
+
+    private void TryRevealCard()
+    {
+		var curCard = m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard();
+
+		if (!curCard.IsRevealed())
+		{
+			curCard.ForceReveal();
+		}
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_doneButtonShown)
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+		else
+        {
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_PACK_OPENING_OPEN_CARDS_HELP, AccessibleKey.CONFIRM);
+        }
+    }
+
+	public List<PackOpeningCard> GetRevealedCards()
+    {
+		return m_hiddenCards;
+    }
+
+    private void AccessibilityOnRevealedCard(PackOpeningCard revealedCard)
+    {
+		foreach (var card in m_accessiblePackOpeningCards.Items)
+        {
+			if (card.GetPackOpeningCard() == revealedCard)
+            {
+				card.ReadLine();
+            }
+        }
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PopupDisplayManager.cs b/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
index fa53b17..551467b 100644
--- a/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
+++ b/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
@@ -12,6 +12,7 @@ using Hearthstone.Progression;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class PopupDisplayManager : IHasUpdate, IService
 {
@@ -74,7 +75,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool m_receivedPlayerData;
 
-	private static string CHOOSE_A_DECK_PREFAB = "ChooseADeck.prefab:de9efdb77e14b144ea84f333a1e78926";
+	internal static string CHOOSE_A_DECK_PREFAB = "ChooseADeck.prefab:de9efdb77e14b144ea84f333a1e78926";
 
 	private readonly Queue<NetCache.ProfileNotice> m_cardReplacementNotices = new Queue<NetCache.ProfileNotice>();
 
@@ -82,7 +83,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private PopupDisplayManagerBones ChestBones { get; set; }
 
-	private PopupDisplayManagerBones QuestChestBones { get; set; }
+	internal PopupDisplayManagerBones QuestChestBones { get; set; }
 
 	private static HashSet<Assets.Achieve.RewardTiming> CurrentRewardTimings
 	{
@@ -230,7 +231,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 			m_isShowing = true;
 			return;
 		}
-		if (FiresideGatheringManager.Get() != null && FiresideGatheringManager.Get().ShowSignIfNeeded(OnPopupClosed))
+		if (FiresideGatheringManager.Get() != null && FiresideGatheringManager.Get().ShowSignIfNeeded(OnPopupClosed)) // Safe to ignore as we can't enter FSG mode anyways
 		{
 			this.OnPopupShown();
 			m_isShowing = true;
@@ -246,7 +247,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 			m_isShowing = true;
 			return;
 		}
-		if (DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(OnPopupClosed))
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(OnPopupClosed)) // To be reviewed if we implement arena
 		{
 			this.OnPopupShown();
 			m_isShowing = true;
@@ -263,7 +264,28 @@ public class PopupDisplayManager : IHasUpdate, IService
 		{
 			m_hasShownMetaShakeupEventPopups = true;
 		}
-		else if (!ShowNextTavernBrawlReward() && !ShowNextLeaguePromotionReward() && !ShowNextRankedIntro() && !ShowNextFreeDeckReward() && !ShowNextSellableDeckReward() && !ShowNextQuestChestReward() && !ShowNextDuelsReward() && !ShowNextProgressionAchievementReward() && !ShowNextProgressionQuestReward() && !ShowNextProgressionTrackReward() && !ShowRewardTrackXpGains() && !ShowRewardTrackSeasonRoll() && ((m_completedAchieves.Count <= 0 && m_rewards.Count <= 0 && m_purchasedCardRewards.Count <= 0 && m_genericRewards.Count <= 0) || (!ShowNextCompletedQuest() && !ShowNextUnAckedReward() && !ShowNextUnAckedGenericReward() && !ShowNextUnAckedPurchasedCardReward())) && !ShowFixedRewards(CurrentRewardTimings) && !IsLoadingRewards && !ShowNextQuestNotification() && !ShowWelcomeQuests() && !ShowInGameMessagePopups())
+		// Original (commented as this is way too hard to read as a one-liner): else if (!ShowNextTavernBrawlReward() && !ShowNextLeaguePromotionReward() && !ShowNextRankedIntro() && !ShowNextFreeDeckReward() && !ShowNextSellableDeckReward() && !ShowNextQuestChestReward() && !ShowNextDuelsReward() && !ShowNextProgressionAchievementReward() && !ShowNextProgressionQuestReward() && !ShowNextProgressionTrackReward() && !ShowRewardTrackXpGains() && !ShowRewardTrackSeasonRoll() && ((m_completedAchieves.Count <= 0 && m_rewards.Count <= 0 && m_purchasedCardRewards.Count <= 0 && m_genericRewards.Count <= 0) || (!ShowNextCompletedQuest() && !ShowNextUnAckedReward() && !ShowNextUnAckedGenericReward() && !ShowNextUnAckedPurchasedCardReward())) && !ShowFixedRewards(CurrentRewardTimings) && !IsLoadingRewards && !ShowNextQuestNotification() && !ShowWelcomeQuests() && !ShowInGameMessagePopups())
+		else if (!ShowNextTavernBrawlReward() &&
+			!ShowNextLeaguePromotionReward() &&
+			!ShowNextRankedIntro() &&
+			!ShowNextFreeDeckReward() &&
+			!ShowNextSellableDeckReward() &&
+			!ShowNextQuestChestReward() &&
+			!ShowNextDuelsReward() &&
+			!ShowNextProgressionAchievementReward() &&
+			!ShowNextProgressionQuestReward() &&
+			!ShowNextProgressionTrackReward() &&
+			!ShowRewardTrackXpGains() &&
+			!ShowRewardTrackSeasonRoll() &&
+			(
+                (m_completedAchieves.Count <= 0 && m_rewards.Count <= 0 && m_purchasedCardRewards.Count <= 0 && m_genericRewards.Count <= 0) ||
+				(!ShowNextCompletedQuest() && !ShowNextUnAckedReward() && !ShowNextUnAckedGenericReward() && !ShowNextUnAckedPurchasedCardReward())
+			) &&
+			!ShowFixedRewards(CurrentRewardTimings) &&
+			!IsLoadingRewards &&
+			!ShowNextQuestNotification() &&
+			!ShowWelcomeQuests() &&
+			!ShowInGameMessagePopups())
 		{
 			NarrativeManager.Get().OnAllPopupsShown();
 			if (!IsShowing)
@@ -634,7 +656,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		}
 		Reward reward = m_purchasedCardRewards[0];
 		UserAttentionBlocker userAttentionBlockerForReward = RewardUtils.GetUserAttentionBlockerForReward(reward.Data.Origin, reward.Data.OriginData);
-		if (!UserAttentionManager.CanShowAttentionGrabber(userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
 		{
 			return false;
 		}
@@ -677,7 +699,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextTavernBrawlReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.UpdateTavernBrawlRewards"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// TB is not implemented yet
+			return false;
+        }
+
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.UpdateTavernBrawlRewards"))
 		{
 			return false;
 		}
@@ -726,7 +754,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextLeaguePromotionReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextLeaguePromotionReward"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextLeaguePromotionReward"))
 		{
 			return false;
 		}
@@ -780,7 +808,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextRankedIntro()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextRankedIntro"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextRankedIntro"))
 		{
 			return false;
 		}
@@ -802,7 +830,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextFreeDeckReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextFreeDeckReward"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextFreeDeckReward"))
 		{
 			return false;
 		}
@@ -827,14 +855,14 @@ public class PopupDisplayManager : IHasUpdate, IService
 		NetCache.ProfileNoticeFreeDeckChoice profileNoticeFreeDeckChoice = (NetCache.ProfileNoticeFreeDeckChoice)netCacheProfileNotices.Notices.Find((NetCache.ProfileNotice n) => n.Type == NetCache.ProfileNotice.NoticeType.FREE_DECK_CHOICE);
 		if (AssetLoader.Get() != null && profileNoticeFreeDeckChoice != null)
 		{
-			SceneMgr.Mode mode = SceneMgr.Get().GetMode();
+            SceneMgr.Mode mode = SceneMgr.Get().GetMode();
 			if (mode != SceneMgr.Mode.HUB && mode != SceneMgr.Mode.LOGIN)
 			{
-				return false;
+                return false;
 			}
 			if (ShouldDisableNotificationOnLogin() && Network.Get() != null)
 			{
-				Network.Get().AckNotice(profileNoticeFreeDeckChoice.NoticeID);
+                Network.Get().AckNotice(profileNoticeFreeDeckChoice.NoticeID);
 				netCacheProfileNotices.Notices.Remove(profileNoticeFreeDeckChoice);
 				return false;
 			}
@@ -876,7 +904,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextSellableDeckReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
@@ -1099,7 +1127,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextProgressionAchievementReward()
 	{
-		if (AchievementManager.Get() == null || !AchievementManager.Get().ShowNextReward(OnPopupClosed))
+        if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            // Not implemented yet
+            return false;
+        }
+
+        if (AchievementManager.Get() == null || !AchievementManager.Get().ShowNextReward(OnPopupClosed))
 		{
 			return false;
 		}
@@ -1151,6 +1185,11 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowRewardTrackSeasonRoll()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			return false; // Not yet implemented
+        }
+
 		if (RewardTrackManager.Get() == null || !RewardTrackManager.Get().ShowUnclaimedTrackRewardsPopup(OnPopupClosed))
 		{
 			return false;
@@ -1212,7 +1251,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private void ShowQuestProgressToasts()
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber("ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
 		{
 			if (QuestManager.Get() != null && QuestToastManager.Get() != null && QuestManager.Get().IsSystemEnabled)
 			{
@@ -1228,7 +1267,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	public bool ShowChangedCards(DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE, string featuredCardsEventTiming = null, List<CollectibleCard> cardsToShowOverride = null)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowChangedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowChangedCards"))
 		{
 			return false;
 		}
@@ -1254,11 +1293,12 @@ public class PopupDisplayManager : IHasUpdate, IService
 				flag = true;
 			}
 		}
-		if (Cheats.ShowFakeNerfedCards && !flag && !m_hasShownCheatedChangedCards)
+		//if (Cheats.ShowFakeNerfedCards && !flag && !m_hasShownCheatedChangedCards) <- was like this but was having some problems testing
+		if (Cheats.ShowFakeNerfedCards && !m_hasShownCheatedChangedCards)
 		{
 			UIStatus.Get().AddInfo("SHOWING FAKE NERFED CARDS!\nTo disable this, remove ShowFakeNerfedCards from client.config.", 5f);
 			list = CollectionManager.Get().GetAllCards().FindAll((CollectibleCard card) => card.PremiumType == TAG_PREMIUM.NORMAL)
-				.Take(3)
+				.Take(10)
 				.ToList();
 			flag = true;
 			m_hasShownCheatedChangedCards = true;
@@ -1284,7 +1324,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	public bool ShowAddedCards(DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE, string featuredCardsEventTiming = null, List<CollectibleCard> cardsToShowOverride = null)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowAddedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowAddedCards"))
 		{
 			return false;
 		}
@@ -1326,13 +1366,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 		return false;
 	}
 
-	private bool ShowFeaturedCards(string featuredCardsEventTiming, string headerText, DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE)
+	private bool ShowFeaturedCards(bool accessible, string featuredCardsEventTiming, string headerText, DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowFeaturedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowFeaturedCards"))
 		{
 			return false;
 		}
-		MultiPagePopup.Info info = new MultiPagePopup.Info
+		MultiPagePopup.Info info = new MultiPagePopup.Info(true)
 		{
 			m_callbackOnHide = callbackOnHide,
 			m_blurWhenShown = true
@@ -1348,7 +1388,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		{
 			return false;
 		}
-		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo
+		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo(true)
 		{
 			m_pageType = MultiPagePopup.PageType.CARD_LIST,
 			m_cardsToShow = changedCards,
@@ -1365,7 +1405,12 @@ public class PopupDisplayManager : IHasUpdate, IService
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber("ShowLoginPopupSequence"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Not implemented yet as there's a few tricky ones
+			return false;
+        }
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "ShowLoginPopupSequence"))
 		{
 			return false;
 		}
@@ -1426,7 +1471,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 				}
 				if ((uint)popupType > 1u && popupType == Assets.LoginPopupSequencePopup.LoginPopupSequencePopupType.FEATURED_CARDS)
 				{
-					if (ShowFeaturedCards(loginPopupSequencePopupDbfRecord.FeaturedCardsEvent, loginPopupSequencePopupDbfRecord.HeaderText, callbackOnHide))
+					if (ShowFeaturedCards(true, loginPopupSequencePopupDbfRecord.FeaturedCardsEvent, loginPopupSequencePopupDbfRecord.HeaderText, callbackOnHide))
 					{
 						result = true;
 					}
@@ -1436,7 +1481,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 					}
 					continue;
 				}
-				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info
+				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info(true)
 				{
 					m_headerText = loginPopupSequencePopupDbfRecord.HeaderText,
 					m_bodyText = loginPopupSequencePopupDbfRecord.BodyText,
@@ -1816,7 +1861,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		});
 	}
 
-	private Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
+	internal Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
 	{
 		PopupDisplayManagerBones popupDisplayManagerBones = ((boneSet != null) ? boneSet : ChestBones);
 		switch (SceneMgr.Get().GetMode())
diff --git a/Decompiled/Assembly-CSharp/PowerProcessor.cs b/Decompiled/Assembly-CSharp/PowerProcessor.cs
index 1d651f8..40b19d9 100644
--- a/Decompiled/Assembly-CSharp/PowerProcessor.cs
+++ b/Decompiled/Assembly-CSharp/PowerProcessor.cs
@@ -152,11 +152,11 @@ public class PowerProcessor
 				HistoryBlock.Type blockType = m_currentTaskList.GetBlockType();
 				if (sourceEntity != null && sourceEntity.HasTag(GAME_TAG.FAST_BATTLECRY) && blockType == HistoryBlock.Type.POWER)
 				{
-					HistoryManager.Get().CreateFastBigCardFromMetaData(entity);
+					HistoryManager.Get().CreateFastBigCardFromMetaData(m_currentTaskList, entity);
 					return;
 				}
 				int displayTimeMS = ((metaData.Info.Count > 1) ? metaData.Info[1] : 0);
-				HistoryManager.Get().CreatePlayedBigCard(entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
+				HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
 			}
 		}
 		else if (metaData.MetaType == HistoryMeta.Type.BEGIN_LISTENING_FOR_TURN_EVENTS)
@@ -1237,7 +1237,7 @@ public class PowerProcessor
 				{
 					bool countered = m_currentTaskList.WasThePlayedSpellCountered(sourceEntity2);
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreatePlayedBigCard(sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
+					HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
 				}
 			}
 			m_currentTaskList.NotifyHistoryOfAdditionalTargets();
@@ -1269,7 +1269,7 @@ public class PowerProcessor
 					HistoryManager.Get().CreateTriggerTile(sourceEntity);
 					m_currentTaskList.SetWillCompleteHistoryEntry(set: true);
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreateTriggeredBigCard(sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
+					HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
 				}
 				m_currentTaskList.NotifyHistoryOfAdditionalTargets();
 				break;
@@ -1288,7 +1288,7 @@ public class PowerProcessor
 					if (sourceEntity.GetController() != GameState.Get().GetFriendlySidePlayer() || !sourceEntity.HasTag(GAME_TAG.HISTORY_PROXY_NO_BIG_CARD))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(entity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, entity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 				}
 				else
@@ -1296,7 +1296,7 @@ public class PowerProcessor
 					if (ShouldShowTriggeredBigCard(sourceEntity))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 					HistoryManager.Get().CreateTriggerTile(sourceEntity);
 				}
@@ -1347,7 +1347,7 @@ public class PowerProcessor
 		m_historyBlocking = false;
 	}
 
-	private bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
+	internal static bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
 	{
 		if (!GameState.Get().GetBooleanGameOption(GameEntityOption.USES_BIG_CARDS))
 		{
@@ -1368,7 +1368,7 @@ public class PowerProcessor
 		return false;
 	}
 
-	private bool ShouldShowTriggeredBigCard(Entity sourceEntity)
+	internal static bool ShouldShowTriggeredBigCard(Entity sourceEntity)
 	{
 		if (sourceEntity.GetZone() != TAG_ZONE.HAND)
 		{
@@ -1492,7 +1492,7 @@ public class PowerProcessor
 		m_currentTaskList.DoAllTasks(delegate
 		{
 			EndCurrentTaskList();
-		});
+        });
 	}
 
 	private void EndCurrentTaskList()
diff --git a/Decompiled/Assembly-CSharp/PowerSpellController.cs b/Decompiled/Assembly-CSharp/PowerSpellController.cs
index 2a67bf4..a2ce113 100644
--- a/Decompiled/Assembly-CSharp/PowerSpellController.cs
+++ b/Decompiled/Assembly-CSharp/PowerSpellController.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class PowerSpellController : SpellController
 {
diff --git a/Decompiled/Assembly-CSharp/PowerTask.cs b/Decompiled/Assembly-CSharp/PowerTask.cs
index d1a44cd..9682c13 100644
--- a/Decompiled/Assembly-CSharp/PowerTask.cs
+++ b/Decompiled/Assembly-CSharp/PowerTask.cs
@@ -1,8 +1,11 @@
+using System;
 using System.Collections.Generic;
 using PegasusGame;
 
 public class PowerTask
 {
+	public delegate void TaskStartCallback(PowerTask task);
+
 	public delegate void TaskCompleteCallback();
 
 	private Network.PowerHistory m_power;
@@ -11,6 +14,8 @@ public class PowerTask
 
 	private TaskCompleteCallback m_onCompleted;
 
+	private TaskStartCallback m_onStarted;
+
 	public Network.PowerHistory GetPower()
 	{
 		return m_power;
@@ -40,6 +45,11 @@ public class PowerTask
 		m_onCompleted = onComplete;
 	}
 
+	public void SetTaskStartCallback(TaskStartCallback onStart)
+	{
+		m_onStarted = onStart;
+	}
+
 	private bool IsZoneTransition(TAG_ZONE fromZone, TAG_ZONE toZone)
 	{
 		if (IsCompleted())
@@ -95,7 +105,8 @@ public class PowerTask
 
 	public void DoRealTimeTask(List<Network.PowerHistory> powerList, int index)
 	{
-		GameState gameState = GameState.Get();
+        m_onStarted(this);
+        GameState gameState = GameState.Get();
 		switch (m_power.Type)
 		{
 		case Network.PowerType.CREATE_GAME:
@@ -150,10 +161,11 @@ public class PowerTask
 		}
 	}
 
-	public void DoTask()
+    public void DoTask()
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
@@ -228,6 +240,7 @@ public class PowerTask
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
@@ -351,4 +364,61 @@ public class PowerTask
 		}
 		return $"[id={netEntity.ID} cardId={netEntity.CardID} name={entityLogName}]";
 	}
+
+	#region Accessibility
+
+	public bool IsCardTrade(int entityId)
+    {
+		Network.PowerHistory power = GetPower();
+
+		if (power.Type == Network.PowerType.TAG_CHANGE)
+		{
+			Network.HistTagChange histTagChange = (Network.HistTagChange)power;
+			if (histTagChange.Tag == (int)GAME_TAG.IS_USING_TRADE_OPTION && histTagChange.Value == 1)
+			{
+				return true;
+			}
+		}
+		else if (power.Type == Network.PowerType.SHOW_ENTITY)
+        {
+			Network.HistShowEntity histShowEntity = (Network.HistShowEntity)power;
+			var entity = histShowEntity.Entity;
+
+			if (entity != null && entity.ID == entityId)
+            {
+				foreach (var tag in entity.Tags)
+                {
+					if (tag.Name == (int)GAME_TAG.IS_USING_TRADE_OPTION && tag.Value == 1)
+                    {
+						return true;
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public bool IsShowStartOfGameCard()
+    {
+		Network.PowerHistory power = GetPower();
+
+		if (power.Type == Network.PowerType.SHOW_ENTITY)
+        {
+			Network.HistShowEntity histShowEntity = (Network.HistShowEntity)power;
+			var entity = histShowEntity.Entity;
+
+            foreach (var tag in entity.Tags)
+            {
+                if (tag.Name == (int)GAME_TAG.START_OF_GAME && tag.Value == 1)
+                {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PowerTaskList.cs b/Decompiled/Assembly-CSharp/PowerTaskList.cs
index 22f279d..aaf5d5a 100644
--- a/Decompiled/Assembly-CSharp/PowerTaskList.cs
+++ b/Decompiled/Assembly-CSharp/PowerTaskList.cs
@@ -1,13 +1,15 @@
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class PowerTaskList
 {
 	public delegate void CompleteCallback(PowerTaskList taskList, int startIndex, int count, object userData);
 
-	public class DamageInfo
+    public class DamageInfo
 	{
 		public Entity m_entity;
 
@@ -505,6 +507,7 @@ public class PowerTaskList
 		PowerTask powerTask = new PowerTask();
 		powerTask.SetPower(netPower);
 		powerTask.SetTaskCompleteCallback(OnTaskCompleted);
+		powerTask.SetTaskStartCallback(OnTaskStarted);
 		m_tasks.Add(powerTask);
 		return powerTask;
 	}
@@ -1617,7 +1620,7 @@ public class PowerTaskList
 		callback?.Invoke(this, startIndex, count, userData);
 	}
 
-	private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
+    private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
 	{
 		for (int i = incompleteStartIndex; i <= endIndex; i++)
 		{
@@ -1888,4 +1891,33 @@ public class PowerTaskList
 			}
 		}
 	}
+
+    #region Accessibility
+
+	public delegate void GlobalCompleteCallback(PowerTaskList taskList);
+
+	private GlobalCompleteCallback m_globalCompleteCallback;
+
+    private bool m_startedTasks = false;
+
+    private void OnTaskStarted(PowerTask task)
+    {
+        if (!m_startedTasks)
+        {
+            m_startedTasks = true;
+            AccessiblePowerTaskListDescriber.OnPowerTaskListStart(this);
+        }
+    }
+
+    internal void SetGlobalCompleteCallback(GlobalCompleteCallback callback)
+    {
+		m_globalCompleteCallback = callback;
+    }
+
+	public void FireCompleteEvent()
+    {
+        m_globalCompleteCallback?.Invoke(this);
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
index ae7d38f..4ffae03 100644
--- a/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
@@ -3,6 +3,8 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
+using Assets;
 
 [CustomEditClass]
 public class PracticePickerTrayDisplay : MonoBehaviour
@@ -42,8 +44,6 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 
 	private List<PracticeAIButton> m_practiceAIButtons = new List<PracticeAIButton>();
 
-	private List<Achievement> m_lockedHeroes = new List<Achievement>();
-
 	private PracticeAIButton m_selectedPracticeAIButton;
 
 	private Map<string, DefLoader.DisposableFullDef> m_heroDefs = new Map<string, DefLoader.DisposableFullDef>();
@@ -156,7 +156,9 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 		Hashtable args = iTween.Hash("position", PracticeDisplay.Get().GetPracticePickerShowPosition(), "isLocal", true, "time", m_trayAnimationTime, "easetype", m_trayInEaseType, "delay", 0.001f);
 		iTween.MoveTo(base.gameObject, args);
 		SoundManager.Get().LoadAndPlay("choose_opponent_panel_slide_on.prefab:66491d3d01ed663429ab80daf6a5e880");
-		if (!Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_TRAY, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PracticePickerTrayDisplay.Show:" + Option.HAS_SEEN_PRACTICE_TRAY))
+
+		bool introducingPracticeTray = !Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_TRAY, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "PracticePickerTrayDisplay.Show:" + Option.HAS_SEEN_PRACTICE_TRAY);
+		if (introducingPracticeTray)
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_TRAY, val: true);
 			StartCoroutine(DoPickHeroLines());
@@ -166,7 +168,13 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			m_playButton.Enable();
 		}
 		Navigation.Push(OnNavigateBack);
-	}
+
+		if (!introducingPracticeTray)
+        {
+			// Only read out if we're not going to introduce the tray (see DoPickHeroLines() for that)
+            AccessibleAdventureScene.Get().OnPracticePickerTrayDisplayShown(m_practiceAIButtons);
+        }
+    }
 
 	private IEnumerator DoPickHeroLines()
 	{
@@ -176,11 +184,23 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			yield return null;
 		}
 		yield return new WaitForSeconds(firstPart.GetAudio().clip.length);
-		yield return new WaitForSeconds(6f);
-		if (!m_playButton.IsEnabled() && !GameMgr.Get().IsTransitionPopupShown())
+
+		if (!AccessibilityMgr.IsAccessibilityEnabled())
 		{
-			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_PRACTICE_INST2_08"), "VO_INNKEEPER_PRACTICE_INST2_08.prefab:7f8a9981df8853d44b3cc423d4f44f52", 2f);
+			// Ignore second part ("I'd personally choose Uther") if accessibility is enabled as it might confuse people
+			yield return new WaitForSeconds(6f);
+			if (!m_playButton.IsEnabled() && !GameMgr.Get().IsTransitionPopupShown())
+			{
+				Notification secondPart = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_PRACTICE_INST2_08"), "VO_INNKEEPER_PRACTICE_INST2_08.prefab:7f8a9981df8853d44b3cc423d4f44f52", 2f);
+				while (secondPart.GetAudio() == null)
+				{
+					yield return null;
+				}
+				yield return new WaitForSeconds(secondPart.GetAudio().clip.length);
+			}
 		}
+
+		AccessibleAdventureScene.Get().OnPracticePickerTrayDisplayShown(m_practiceAIButtons);
 	}
 
 	public void Hide()
@@ -358,14 +378,14 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			PracticeAIButton practiceAIButton = m_practiceAIButtons[i];
 			practiceAIButton.SetInfo(text, @class, disposableFullDef.DisposableCardDef, iD, flip: false);
 			bool shown = false;
-			foreach (Achievement lockedHero in m_lockedHeroes)
-			{
-				if (lockedHero.ClassReward.Value == @class)
-				{
-					shown = true;
-					break;
-				}
-			}
+
+            // "Undefeated" flags are broken on the official game so I had to tweak this
+            NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(@class);
+			if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
+            {
+				shown = true;
+            }
+
 			practiceAIButton.ShowQuestBang(shown);
 			if (practiceAIButton == m_selectedPracticeAIButton)
 			{
diff --git a/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs b/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs
index 1d7249c..581c813 100644
--- a/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs
+++ b/Decompiled/Assembly-CSharp/PrivacyFeaturesPopup.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class PrivacyFeaturesPopup : DialogBase
 {
@@ -260,6 +261,8 @@ public class PrivacyFeaturesPopup : DialogBase
 		m_buttonBlocked = true;
 		AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
 		FullScreenFXMgr.Get()?.StartStandardBlurVignette(0.1f);
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -267,4 +270,48 @@ public class PrivacyFeaturesPopup : DialogBase
 		FullScreenFXMgr.Get()?.EndStandardBlurVignette(0.1f);
 		base.Hide();
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    protected void ReadPopup()
+    {
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_choiceOneButton != null && m_choiceOneButton.isActiveAndEnabled)
+        {
+			m_accessibleMenu.AddOption(m_choiceOneButton.GetText(), () => m_choiceOneButton.TriggerRelease());
+        }
+
+		if (m_choiceTwoButton != null && m_choiceTwoButton.isActiveAndEnabled)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		if (m_continueButton != null && m_continueButton.isActiveAndEnabled)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, GameStrings.Get(m_titleText.Text));
+		AccessibilityMgr.Output(this, GameStrings.Get(m_searchText.Text));
+		AccessibilityMgr.Output(this, GameStrings.Get(m_successText.Text));
+
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs b/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
index 9726a07..6feb577 100644
--- a/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
+++ b/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using Hearthstone;
 using Hearthstone.UI;
 using UnityEngine;
 
-public class PrivacyPolicyPopup : DialogBase
+public class PrivacyPolicyPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool confirmedPrivacyPolicy);
 
diff --git a/Decompiled/Assembly-CSharp/QuestLog.cs b/Decompiled/Assembly-CSharp/QuestLog.cs
index f7ab00d..60e40ef 100644
--- a/Decompiled/Assembly-CSharp/QuestLog.cs
+++ b/Decompiled/Assembly-CSharp/QuestLog.cs
@@ -405,7 +405,7 @@ public class QuestLog : UIBPopup
 			if (AchieveManager.Get().HasUnlockedFeature(Achieve.Unlocks.DAILY))
 			{
 				m_noQuestText.Text = GameStrings.Get("GLUE_QUEST_LOG_NO_QUESTS_DAILIES_UNLOCKED");
-				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
+				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
 				{
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, 0f, 34.5f), GameStrings.Get("VO_INNKEEPER_OUT_OF_QUESTS"), "VO_INNKEEPER_OUT_OF_QUESTS.prefab:b0073c56bf38c664dab532ad92f3baf9");
 					Options.Get().SetBool(Option.HAS_RUN_OUT_OF_QUESTS, val: true);
diff --git a/Decompiled/Assembly-CSharp/QuestProgressToast.cs b/Decompiled/Assembly-CSharp/QuestProgressToast.cs
index dcc9ec6..f9b652d 100644
--- a/Decompiled/Assembly-CSharp/QuestProgressToast.cs
+++ b/Decompiled/Assembly-CSharp/QuestProgressToast.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class QuestProgressToast : GameToast
 {
@@ -31,5 +32,18 @@ public class QuestProgressToast : GameToast
 		}
 		m_questTitle.Text = title;
 		m_questDescription.Text = description;
-	}
+
+		// Accessibility
+		if (maxProgress > 1)
+        {
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+			AccessibilityMgr.OutputNotification(m_questTitle.Text);
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, progress, maxProgress));
+        }
+		else
+        {
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+			AccessibilityMgr.OutputNotification(m_questTitle.Text);
+        }
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/QuestTile.cs b/Decompiled/Assembly-CSharp/QuestTile.cs
index e2e800d..eff2b53 100644
--- a/Decompiled/Assembly-CSharp/QuestTile.cs
+++ b/Decompiled/Assembly-CSharp/QuestTile.cs
@@ -73,7 +73,7 @@ public class QuestTile : MonoBehaviour
 	[CustomEditField(Sections = "Special Event FX")]
 	public List<SpecialEventFxEntry> m_specialEventFx = new List<SpecialEventFxEntry>();
 
-	private Achievement m_quest;
+	internal Achievement m_quest;
 
 	private bool m_canShowCancelButton;
 
diff --git a/Decompiled/Assembly-CSharp/QuestToast.cs b/Decompiled/Assembly-CSharp/QuestToast.cs
index 12e5f8c..f909ac8 100644
--- a/Decompiled/Assembly-CSharp/QuestToast.cs
+++ b/Decompiled/Assembly-CSharp/QuestToast.cs
@@ -1,6 +1,7 @@
 using System.Linq;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class QuestToast : MonoBehaviour
 {
@@ -124,7 +125,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToast(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, bool updateCacheValues, Achievement quest, bool fullscreenEffects)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -167,7 +168,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToastPopup(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, RewardData rewardData, string name, string description, bool fullscreenEffects, bool updateCacheValues, Achievement quest)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : string.Concat(rewardData.Origin, ":", rewardData.OriginData, ":", rewardData.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : string.Concat(rewardData.Origin, ":", rewardData.OriginData, ":", rewardData.RewardType))))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -265,6 +266,10 @@ public class QuestToast : MonoBehaviour
 		m_clickCatcher.AddEventListener(UIEventType.RELEASE, CloseQuestToast);
 		m_questName.Text = m_toastName;
 		m_requirement.Text = m_toastDescription;
+		AccessibilityMgr.OutputNotification(LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_TOAST_TITLE));
+		AccessibilityMgr.OutputNotification(m_questName.Text);
+		AccessibilityMgr.OutputNotification(m_requirement.Text);
 		if (m_toastReward != null)
 		{
 			if (SpecialEventManager.Get().IsEventActive(SpecialEventType.SPECIAL_EVENT_GOLD_DOUBLED, activeIfDoesNotExist: false) && m_quest != null && m_quest.IsAffectedByDoubleGold && m_toastReward is GoldRewardData)
diff --git a/Decompiled/Assembly-CSharp/QuestlineController.cs b/Decompiled/Assembly-CSharp/QuestlineController.cs
index 7b5a7e2..18f890c 100644
--- a/Decompiled/Assembly-CSharp/QuestlineController.cs
+++ b/Decompiled/Assembly-CSharp/QuestlineController.cs
@@ -21,7 +21,7 @@ public class QuestlineController : MonoBehaviour
 
 	private Entity m_entity;
 
-	private QuestlineProgressUI m_QuestlineProgressUI;
+	internal QuestlineProgressUI m_QuestlineProgressUI;
 
 	private bool m_questCompleted;
 
diff --git a/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs b/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
index 54f93f0..bb1e4fe 100644
--- a/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
+++ b/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
@@ -4,6 +4,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedBonusStarsPopup : BasicPopup
@@ -11,6 +12,7 @@ public class RankedBonusStarsPopup : BasicPopup
 	public class BonusStarsPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+		public BonusStarsPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	public UberText m_descriptionText;
@@ -29,12 +31,18 @@ public class RankedBonusStarsPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+	#region Accessibility
+	private RankedPlayDataModel m_rankedPlayDataModel;
+
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -72,6 +80,8 @@ public class RankedBonusStarsPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -84,16 +94,18 @@ public class RankedBonusStarsPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
 		IncrementBonusStarsPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void OnWidgetReady()
 	{
 		IDataModel model = null;
 		m_widget.GetDataModel(123, out model);
-		RankedPlayDataModel rankedPlayDataModel = model as RankedPlayDataModel;
-		if (rankedPlayDataModel != null && m_descriptionText != null)
+		m_rankedPlayDataModel = model as RankedPlayDataModel;
+		if (m_rankedPlayDataModel != null && m_descriptionText != null)
 		{
-			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", rankedPlayDataModel.StarMultiplier);
+			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", m_rankedPlayDataModel.StarMultiplier);
 		}
 	}
 
@@ -112,4 +124,34 @@ public class RankedBonusStarsPopup : BasicPopup
 			GameSaveDataManager.Get().SaveSubkeys(list);
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_rankedPlayDataModel == null)
+        {
+			return;
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_RANKED_BONUS_STARS_POPUP, m_rankedPlayDataModel.StarMultiplier));
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankedIntroPopup.cs b/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
index cfeeade..7a99abb 100644
--- a/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
+++ b/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
@@ -2,6 +2,7 @@ using System;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedIntroPopup : BasicPopup
@@ -9,6 +10,8 @@ public class RankedIntroPopup : BasicPopup
 	public class RankedIntroPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public RankedIntroPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	private const string SHOW_EVENT_NAME = "CODE_DIALOGMANAGER_SHOW";
@@ -23,12 +26,16 @@ public class RankedIntroPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+    #region Accessibility
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -63,6 +70,8 @@ public class RankedIntroPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -75,6 +84,8 @@ public class RankedIntroPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
 		IncrementRankedIntroPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void IncrementRankedIntroPopupSeenCount()
@@ -89,4 +100,30 @@ public class RankedIntroPopup : BasicPopup
 			gameSaveDataManager.SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.RANKED_PLAY, GameSaveKeySubkeyId.RANKED_PLAY_INTRO_SEEN_COUNT, array));
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RANKED_INTRO_POPUP));
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs b/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
index 6409d63..c46f48e 100644
--- a/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
+++ b/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
@@ -5,9 +5,10 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class RankedRewardDisplay : MonoBehaviour
+public class RankedRewardDisplay : MonoBehaviour, AccessibleUI
 {
 	[CustomEditField(Sections = "Animate In")]
 	public Vector3_MobileOverride m_startScale;
@@ -56,6 +57,8 @@ public class RankedRewardDisplay : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (EndGameScreen.Get() != null)
 		{
 			EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
@@ -119,6 +122,8 @@ public class RankedRewardDisplay : MonoBehaviour
 		m_widget.Show();
 		AnimationUtil.ShowWithPunch(base.gameObject, m_startScale, m_punchScale, m_afterPunchScale, "OnShown", noFade: true);
 		m_fsm.SendEvent("Birth");
+
+		ReadRewardDisplay();
 	}
 
 	private void OnShown()
@@ -186,6 +191,8 @@ public class RankedRewardDisplay : MonoBehaviour
 
 	private void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (EndGameScreen.Get() != null)
 		{
 			EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
@@ -240,4 +247,30 @@ public class RankedRewardDisplay : MonoBehaviour
 		FullScreenFXMgr.Get().StopAllEffects();
 		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
 	}
+
+    #region Accessibility
+
+	private void ReadRewardDisplay()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RANKED_REWARD_DISPLAY));
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+            OnClick(new UIEvent(UIEventType.RELEASE, null));
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs b/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
index 6075f06..c3466e1 100644
--- a/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
+++ b/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Hearthstone;
 using UnityEngine;
 
@@ -23,7 +24,8 @@ public class ReconnectHelperDialog : DialogBase
 		BAD_VERSION_CAN_RESET,
 		BAD_VERSION_USE_LAUNCHER,
 		INACTIVE_TIMEOUT,
-		RESTART_REQUIRED
+		RESTART_REQUIRED,
+		EOE
 	}
 
 	private class Layout
@@ -47,9 +49,13 @@ public class ReconnectHelperDialog : DialogBase
 		public Action m_choiceButtonTwoAction;
 
 		public Action m_onInit;
-	}
 
-	public UIBButton m_continueButton;
+        #region Accessibility
+        public string m_accessibleMenuText = "Connection lost";
+        #endregion
+    }
+
+    public UIBButton m_continueButton;
 
 	public UIBButton m_choiceOneButton;
 
@@ -171,6 +177,7 @@ public class ReconnectHelperDialog : DialogBase
 	{
 		m_stateLayouts[DialogState.PROMPT] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_OFFLINE), LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED)),
 			m_activePanel = m_reconnectPromptPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -187,6 +194,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.FAILURE] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED),
 			m_activePanel = m_reconnectFailurePanel,
 			m_twoButtons = true,
 			m_successRingState = SpellStateType.DEATH,
@@ -197,6 +205,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.WIFI_DISABLED] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_NO_INTERNET),
 			m_activePanel = m_wifiDisabledPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -206,6 +215,10 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_CAN_RESET] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER),
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY)
+            ),
 			m_activePanel = m_badVersionCanResetPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_UPDATE"),
@@ -215,6 +228,10 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_USE_LAUNCHER] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER),
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY)
+            ),
 			m_activePanel = m_badVersionUseLauncherPanel,
 			m_twoButtons = false,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -223,6 +240,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.INACTIVE_TIMEOUT] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT),
 			m_activePanel = m_inactiveTimeoutPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -232,6 +250,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.RESTART_REQUIRED] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED),
 			m_activePanel = m_restartRequiredPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get(HearthstoneApplication.AllowResetFromFatalError ? "GLUE_RECONNECT_HELPER_RESTART_GAME" : "GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -272,9 +291,11 @@ public class ReconnectHelperDialog : DialogBase
 		{
 			layout.m_onInit();
 		}
+
+		ReadAccessibleDialog();
 	}
 
-	private void ChangeStateToPromptBasedOnReconnectMgr()
+    private void ChangeStateToPromptBasedOnReconnectMgr()
 	{
 		if (ReconnectMgr.Get().FullResetRequired)
 		{
@@ -355,6 +376,7 @@ public class ReconnectHelperDialog : DialogBase
 	private void OnReconnectSuccess()
 	{
 		ReconnectMgr.Get().SetNextReLoginCallback(m_reconnectSuccessCallback);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_RECONNECTED);
 		Hide();
 	}
 
@@ -403,4 +425,62 @@ public class ReconnectHelperDialog : DialogBase
 			ChangeState_FullResetRequired();
 		}
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    private void ReadAccessibleDialog()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING));
+			return;
+        }
+
+		Layout layout = m_stateLayouts[m_state];
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_continueButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_continueButton.GetText(), () => m_continueButton.TriggerRelease());
+        }
+
+		if (m_choiceOneButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceOneButton.GetText(), () => m_choiceOneButton.TriggerRelease());
+        }
+
+		if (m_choiceTwoButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_TITLE), true);
+		AccessibilityMgr.Output(this, layout?.m_accessibleMenuText);
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return;
+        }
+
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING), LocalizedText.GLOBAL_PLEASE_WAIT);
+        }
+
+		return m_accessibleMenu?.GetHelp();
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ReconnectMgr.cs b/Decompiled/Assembly-CSharp/ReconnectMgr.cs
index b9e7936..8356b7a 100644
--- a/Decompiled/Assembly-CSharp/ReconnectMgr.cs
+++ b/Decompiled/Assembly-CSharp/ReconnectMgr.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using bgs;
 using bgs.types;
 using Blizzard.T5.Jobs;
@@ -750,6 +751,8 @@ public class ReconnectMgr : IService, IHasUpdate
 
 	private void ChangeGameplayDialogToReconnected()
 	{
+		AccessibleGameplay.Get().OnReconnected();
+
 		if (!(m_gameplayReconnectDialog == null))
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
diff --git a/Decompiled/Assembly-CSharp/Reward.cs b/Decompiled/Assembly-CSharp/Reward.cs
index e152387..6ad24b1 100644
--- a/Decompiled/Assembly-CSharp/Reward.cs
+++ b/Decompiled/Assembly-CSharp/Reward.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public abstract class Reward : MonoBehaviour
+public abstract class Reward : MonoBehaviour, AccessibleUI
 {
 	public enum Type
 	{
@@ -11,19 +12,20 @@ public abstract class Reward : MonoBehaviour
 		BOOSTER_PACK,
 		CARD,
 		CARD_BACK,
-		CRAFTABLE_CARD,
-		FORGE_TICKET,
+		CRAFTABLE_CARD, // Not implemented
+		FORGE_TICKET, // Not implemented
 		GOLD,
 		MOUNT,
-		CLASS_CHALLENGE,
-		EVENT,
-		RANDOM_CARD,
-		BONUS_CHALLENGE,
-		ADVENTURE_DECK,
-		ADVENTURE_HERO_POWER,
+		CLASS_CHALLENGE, // Not implemented
+		EVENT, // Not implemented
+		RANDOM_CARD, // Not implemented
+		BONUS_CHALLENGE, // Not implemented
+		ADVENTURE_DECK, // Not implemented
+		ADVENTURE_HERO_POWER, // Not implemented
 		ARCANE_ORBS,
-		DECK,
-		MINI_SET
+		DECK, // Not implemented
+		MINI_SET,
+		EOE
 	}
 
 	public delegate void DelOnRewardLoaded(Reward reward, object callbackData);
@@ -124,9 +126,10 @@ public abstract class Reward : MonoBehaviour
 
 	protected virtual void OnDestroy()
 	{
-	}
+        AccessibilityMgr.HideUI(this);
+    }
 
-	public void Show(bool updateCacheValues)
+    public void Show(bool updateCacheValues)
 	{
 		Data.AcknowledgeNotices();
 		if (m_MeshRoot != null)
@@ -154,6 +157,8 @@ public abstract class Reward : MonoBehaviour
 		}
 		ShowReward(updateCacheValues);
 		m_shown = true;
+
+		ReadReward();
 	}
 
 	protected virtual void PlayShowSounds()
@@ -180,10 +185,14 @@ public abstract class Reward : MonoBehaviour
 			}
 		}
 		iTween.FadeTo(base.gameObject, 0f, RewardUtils.REWARD_HIDE_TIME);
+		AccessibilityMgr.HideUI(this);
+
 	}
 
 	public virtual void Hide(bool animate = false)
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (!animate)
 		{
 			OnHideAnimateComplete();
@@ -336,10 +345,48 @@ public abstract class Reward : MonoBehaviour
 
 	private void OnHide()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		OnHideListener[] array = m_hideListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
 			array[i].Fire();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleRewardData m_accessibleReward;
+
+	private void ReadReward()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleReward = new AccessibleRewardData(this, m_data);
+
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_REWARD_TITLE));
+		m_accessibleReward.ReadAllLines();
+    }
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			AccessibleInputMgr.ClickCenterOfScreen();
+        }
+        else
+        {
+			m_accessibleReward.HandleAccessibleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		var helpText = LocalizationUtils.Get(LocalizationKey.UI_REWARD_HELP);
+		var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+		return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs b/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
index d3fbb55..6adbd3a 100644
--- a/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
+++ b/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
@@ -3,9 +3,10 @@ using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class RewardBoxesDisplay : MonoBehaviour
+public class RewardBoxesDisplay : MonoBehaviour, AccessibleUI
 {
 	[Serializable]
 	public class RewardPackageData
@@ -113,6 +114,11 @@ public class RewardBoxesDisplay : MonoBehaviour
 
 	private List<RewardData> CurrentPageRewards => m_rewards.Skip(m_RewardSet.m_MaxPackagesPerPage * m_currentPageNum).Take(m_RewardSet.m_MaxPackagesPerPage).ToList();
 
+	#region Accessibility
+	private List<RewardBoxData> m_rewardsBoxData = new List<RewardBoxData>();
+	private int m_pendingAnimations;
+	#endregion
+
 	public bool IsClosing { get; private set; }
 
 	private void Awake()
@@ -222,6 +228,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 
 	public void AnimateRewards()
 	{
+		AccessibilityMgr.ShowUI(this);
+
 		List<RewardData> currentPageRewards = CurrentPageRewards;
 		int count = currentPageRewards.Count;
 		m_RewardPackages = GetPackageData(count);
@@ -286,6 +294,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			}
 		}
 		m_rewardPackageInstances.Clear();
+		m_rewardsBoxData.Clear(); // Accessibility
+		m_pendingAnimations = 0;
 		for (int i = 0; i < m_RewardPackages.Count; i++)
 		{
 			RewardPackageData rewardPackageData = m_RewardPackages[i];
@@ -321,6 +331,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			rewardBoxData.m_RewardPackage = component2;
 			rewardBoxData.m_FSM = component;
 			rewardBoxData.m_Index = i;
+			m_rewardsBoxData.Add(rewardBoxData);
+			m_pendingAnimations++;
 			iTween.MoveTo(gameObject, iTween.Hash("position", rewardPackageData.m_TargetBone.transform.position, "time", m_RewardSet.m_AnimationTime, "delay", rewardPackageData.m_StartDelay, "easetype", iTween.EaseType.linear, "onstarttarget", base.gameObject, "onstart", "RewardPackageOnStart", "onstartparams", rewardBoxData, "oncompletetarget", base.gameObject, "oncomplete", "RewardPackageOnComplete", "oncompleteparams", rewardBoxData));
 		}
 	}
@@ -340,9 +352,10 @@ public class RewardBoxesDisplay : MonoBehaviour
 		yield return new WaitForSeconds(0.5f);
 		SceneUtils.EnableColliders(boxData.m_GameObject, enable: true);
 		boxData.m_RewardPackage.AddEventListener(UIEventType.PRESS, RewardPackagePressed);
+		OnRewardPackageActivated();
 	}
 
-	private void RewardPackagePressed(UIEvent e)
+    private void RewardPackagePressed(UIEvent e)
 	{
 		Log.RewardBox.Print("box clicked!");
 	}
@@ -495,6 +508,7 @@ public class RewardBoxesDisplay : MonoBehaviour
 		{
 			FadeFullscreenEffectsOut();
 			Navigation.GoBack();
+			AccessibilityMgr.HideUI(this);
 			return;
 		}
 		m_currentPageNum++;
@@ -684,4 +698,109 @@ public class RewardBoxesDisplay : MonoBehaviour
 			Debug.Log($"  reward {i}={arg}");
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleRewardPackage> m_accessibleRewardPackages;
+
+    private void OnRewardPackageActivated()
+    {
+		m_pendingAnimations--;
+
+		if (m_pendingAnimations == 0)
+        {
+			List<AccessibleRewardPackage> rewardPackages = new List<AccessibleRewardPackage>(m_rewardsBoxData.Count);
+			m_rewardsBoxData.ForEach(r => rewardPackages.Add(new AccessibleRewardPackage(this, r, CurrentPageRewards[r.m_RewardPackage.m_RewardIndex])));
+			m_accessibleRewardPackages = new AccessibleListOfItems<AccessibleRewardPackage>(this, rewardPackages);
+
+			var numRewardPackages = m_rewardsBoxData.Count;
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_REWARD_BOXES_DISPLAY_TITLE, numRewardPackages));
+            m_accessibleRewardPackages.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (AllPackagesOpened())
+            {
+                m_DoneButton.TriggerRelease();
+            }
+			else
+            {
+                var focusedPackage = m_accessibleRewardPackages.GetItemBeingRead();
+
+                if (!focusedPackage.Open)
+                {
+                    focusedPackage.RewardBoxData.m_RewardPackage.TriggerPress();
+                    focusedPackage.Open = true;
+                    focusedPackage.ReadAllLines();
+
+                    OnRewardPackageOpened();
+                }
+            }
+        }
+		else
+        {
+			m_accessibleRewardPackages?.HandleAccessibleInput();
+        }
+    }
+
+    private void OnRewardPackageOpened()
+    {
+		if (AllPackagesOpened())
+        {
+            AccessibilityMgr.Output(this, GetAccessibleHelp());
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return LocalizedText.GLOBAL_PLEASE_WAIT;
+        }
+		else if (AllPackagesOpened())
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+        else
+        {
+			return LocalizationUtils.Format(LocalizationKey.UI_REWARD_BOXES_DISPLAY_HELP, AccessibleKey.CONFIRM);
+        }
+    }
+
+	private bool AllPackagesOpened()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return false;
+        }
+
+		return GetNumOpenPackages() == m_rewardsBoxData.Count;
+    }
+
+    private int GetNumOpenPackages()
+    {
+        if (m_accessibleRewardPackages == null)
+        {
+			return 0;
+        }
+		else
+        {
+			var ret = 0;
+			foreach (var package in m_accessibleRewardPackages.Items)
+            {
+				if (package.Open)
+                {
+					ret++;
+                }
+            }
+
+			return ret;
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardItemType.cs b/Decompiled/Assembly-CSharp/RewardItemType.cs
index ec526a4..82de567 100644
--- a/Decompiled/Assembly-CSharp/RewardItemType.cs
+++ b/Decompiled/Assembly-CSharp/RewardItemType.cs
@@ -21,12 +21,15 @@ public enum RewardItemType
 	MINI_SET,
 	CARD_SUBSET,
 	SELLABLE_DECK,
+  // TODO ALL FROM HERE vvv
 	MERCENARY_COIN,
 	MERCENARY,
 	MERCENARY_XP,
 	MERCENARY_EQUIPMENT,
 	MERCENARY_EQUIPMENT_ICON,
 	MERCENARY_BOOSTER,
+  // TODO ALL UNTIL HERE
 	BATTLEGROUNDS_HERO_SKIN,
-	BATTLEGROUNDS_GUIDE_SKIN
+	BATTLEGROUNDS_GUIDE_SKIN,
+  EOE
 }
diff --git a/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs b/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
index 3679527..b9a74a3 100644
--- a/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
+++ b/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
@@ -46,7 +46,7 @@ public class RewardTrackForgotRewardsPopup : MonoBehaviour
 		m_widget.Show();
 	}
 
-	public void Hide()
+    public void Hide()
 	{
 		m_widget.GetComponentInParent<RewardTrackSeasonRoll>();
 		m_widget.Hide();
diff --git a/Decompiled/Assembly-CSharp/RewardUtils.cs b/Decompiled/Assembly-CSharp/RewardUtils.cs
index cf4624f..20baa85 100644
--- a/Decompiled/Assembly-CSharp/RewardUtils.cs
+++ b/Decompiled/Assembly-CSharp/RewardUtils.cs
@@ -910,7 +910,7 @@ public class RewardUtils
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : string.Concat(reward.Data.Origin, ":", reward.Data.OriginData, ":", reward.Data.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : string.Concat(reward.Data.Origin, ":", reward.Data.OriginData, ":", reward.Data.RewardType))))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/ScenarioDbId.cs b/Decompiled/Assembly-CSharp/ScenarioDbId.cs
index e9f16a0..f9c1f79 100644
--- a/Decompiled/Assembly-CSharp/ScenarioDbId.cs
+++ b/Decompiled/Assembly-CSharp/ScenarioDbId.cs
@@ -560,5 +560,6 @@ public enum ScenarioDbId
 	TB_RumbleDome = 3710,
 	TB_Rumbledome_1p = 3713,
 	PVPDR_Tavern = 3745,
-	PVPDR_Season_1 = 3466
+	PVPDR_Season_1 = 3466,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/SceneMgr.cs b/Decompiled/Assembly-CSharp/SceneMgr.cs
index 83c258a..aecafe9 100644
--- a/Decompiled/Assembly-CSharp/SceneMgr.cs
+++ b/Decompiled/Assembly-CSharp/SceneMgr.cs
@@ -904,7 +904,7 @@ public class SceneMgr : IService, IHasUpdate
 
 	private void OnFatalError(FatalErrorMessage message, object userData)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			Log.Offline.Print("SceneMgr.OnFatalError: Error blocked by set rotation.");
 			SetNextMode(Mode.FATAL_ERROR);
@@ -955,7 +955,7 @@ public class SceneMgr : IService, IHasUpdate
 		}
 	}
 
-	private void GoToFatalErrorScreen(FatalErrorMessage message)
+	internal void GoToFatalErrorScreen(FatalErrorMessage message)
 	{
 		if (HearthstoneApplication.Get().ResetOnErrorIfNecessary())
 		{
diff --git a/Decompiled/Assembly-CSharp/ScrollbarControl.cs b/Decompiled/Assembly-CSharp/ScrollbarControl.cs
index 3770e48..38102ce 100644
--- a/Decompiled/Assembly-CSharp/ScrollbarControl.cs
+++ b/Decompiled/Assembly-CSharp/ScrollbarControl.cs
@@ -158,7 +158,7 @@ public class ScrollbarControl : MonoBehaviour
 		FireFinishEvent();
 	}
 
-	private void FireUpdateEvent()
+	internal void FireUpdateEvent()
 	{
 		if (m_updateHandler != null)
 		{
@@ -166,7 +166,7 @@ public class ScrollbarControl : MonoBehaviour
 		}
 	}
 
-	private void FireFinishEvent()
+	internal void FireFinishEvent()
 	{
 		if (m_finishHandler != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/SeasonEndDialog.cs b/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
index 6cdb353..7f5c913 100644
--- a/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
+++ b/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
@@ -6,6 +6,7 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class SeasonEndDialog : DialogBase
 {
@@ -38,7 +39,8 @@ public class SeasonEndDialog : DialogBase
 		REDUCED_WELCOME,
 		REMINDER_CHEST,
 		STAR_MULTIPLIER,
-		REMINDER_CARDBACK
+		REMINDER_CARDBACK,
+		EOE
 	}
 
 	public GameObject m_root;
@@ -177,6 +179,8 @@ public class SeasonEndDialog : DialogBase
 
 	private const string REWARD_CHEST_EARNED_STRING_FORMAT = "GLOBAL_REWARD_CHEST_TIER{0}_EARNED";
 
+	private const string REWARD_CHEST_WIDGET_OPEN_EVENT_NAME = "CLICKED";
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -342,8 +346,9 @@ public class SeasonEndDialog : DialogBase
 			m_currentMode = MODE.CHEST_EARNED;
 			m_medalPlayMaker.SendEvent("RevealRewardChest");
 			iTween.FadeTo(m_rankAchieved.gameObject, 0f, 0.5f);
-		}
-		else
+			HandleAccessibility();
+        }
+        else
 		{
 			GotoBonusStarsOrWelcome();
 		}
@@ -391,11 +396,13 @@ public class SeasonEndDialog : DialogBase
 
 	public void GoToStarMultiplier()
 	{
-		m_currentMode = MODE.STAR_MULTIPLIER;
+        m_currentMode = MODE.STAR_MULTIPLIER;
 		m_welcomeItems.SetActive(value: false);
+        HandleAccessibility();
+
 		if (m_skipRankedIntroPopup)
 		{
-			StartCoroutine(DoPageTear());
+            StartCoroutine(DoPageTear());
 			return;
 		}
 		HideRewardChestPage();
@@ -405,9 +412,9 @@ public class SeasonEndDialog : DialogBase
 		StartCoroutine(FadeWidgetIn(m_starMultiplierWidget, 0f));
 		iTween.FadeTo(m_bonusStarItems, 1f, 0f);
 		EnableOkayButton();
-	}
+    }
 
-	public void GotoReducedMedal()
+    public void GotoReducedMedal()
 	{
 		m_currentMode = MODE.REDUCED_WELCOME;
 		StartCoroutine(DoPageTear());
@@ -418,9 +425,10 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarLabel.Text = m_currentMedalInfo.GetRankName();
 		m_bonusStarTitle.Text = GameStrings.Get("GLOBAL_SEASON_END_BONUS_STAR_TITLE");
 		UpdateBonusStarFinePrint();
-	}
+        HandleAccessibility();
+    }
 
-	public void GotoChestReminder()
+    public void GotoChestReminder()
 	{
 		m_currentMode = MODE.REMINDER_CHEST;
 		HideRewardChestPage();
@@ -428,19 +436,21 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
 		int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
-		m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
-	}
+        m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
+        HandleAccessibility();
+    }
 
-	public void GoToCardBackReminder()
+    public void GoToCardBackReminder()
 	{
 		m_currentMode = MODE.REMINDER_CARDBACK;
 		HideRewardChestPage();
 		m_welcomeItems.SetActive(value: false);
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
-	}
+        HandleAccessibility();
+    }
 
-	public void GoToRankedIntroPopUp()
+    public void GoToRankedIntroPopUp()
 	{
 		iTween.ScaleTo(m_root, new Vector3(0f, 0f, 0f), 0.5f);
 		m_rankedIntroPopUpWidget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
@@ -459,9 +469,10 @@ public class SeasonEndDialog : DialogBase
 		HideRewardChestPage();
 		m_bonusStarItems.SetActive(value: false);
 		m_welcomeDetails.Text = GameStrings.Format("GLOBAL_SEASON_END_NEW_SEASON", newSeasonName);
-	}
+		HandleAccessibility();
+    }
 
-	public IEnumerator DoPageTear()
+    public IEnumerator DoPageTear()
 	{
 		m_medalPlayMaker.SendEvent("PageTear");
 		yield return new WaitForSeconds(0.69f);
@@ -538,6 +549,8 @@ public class SeasonEndDialog : DialogBase
 		DoShowAnimation();
 		UniversalInputManager.Get().SetGameDialogActive(active: true);
 		SoundManager.Get().LoadAndPlay("rank_window_expand.prefab:9f3f1c260a5d8b34f9705caf4925f5cb");
+
+		HandleAccessibility();
 	}
 
 	public override void Hide()
@@ -794,7 +807,7 @@ public class SeasonEndDialog : DialogBase
 
 	private void RankedChestEventListener(string eventName)
 	{
-		if (eventName.Equals("CLICKED") && !m_chestOpened)
+		if (eventName.Equals(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME) && !m_chestOpened)
 		{
 			m_chestOpened = true;
 			PlayMakerFSM componentInChildren = m_rankedRewardChestWidget.GetComponentInChildren<PlayMakerFSM>();
@@ -907,4 +920,111 @@ public class SeasonEndDialog : DialogBase
 		m_showAnimState = ShowAnimState.IN_PROGRESS;
 		AnimationUtil.ShowWithPunch(base.gameObject, START_SCALE, Vector3.Scale(PUNCH_SCALE, m_originalScale), m_originalScale, "OnShowAnimFinished", noFade: true);
 	}
+
+	private void HandleAccessibility()
+    {
+        switch (m_currentMode)
+        {
+            case MODE.RANK_EARNED:
+				AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				var seasonName = GetSeasonName(m_seasonEndInfo.m_seasonID);
+				var rankName = m_seasonBestMedalInfo.GetRankName();
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_RANK_EARNED, seasonName, rankName));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.CHEST_EARNED:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED));
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED_HELP, AccessibleKey.CONFIRM));
+                break;
+            case MODE.SEASON_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				var seasonName2 = GetSeasonName(m_rewardProgress.Season);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_SEASON_WELCOME, seasonName2));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REDUCED_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SEASON_END_DIALOG_REDUCED_WELCOME));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CHEST:
+                int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_REMINDER_CHEST, seasonRollRewardMinWins));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.STAR_MULTIPLIER:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_RANKED_BONUS_STARS_POPUP, m_currentMedalInfo.starsPerWin));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CARDBACK:
+                int seasonCardBackMinWins = RankMgr.Get().GetLocalPlayerMedalInfo().GetSeasonCardBackMinWins();
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_REMINDER_CARDBACK, seasonCardBackMinWins));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            default:
+                break;
+        }
+    }
+
+	private PegUIElement GetNextChest()
+    {
+		if (m_rewardChestLegacy != null)
+		{
+			return m_rewardChestLegacy;
+		}
+
+		foreach (var chest in m_rewardChests)
+		{
+			if (chest.gameObject.activeInHierarchy)
+            {
+				return chest;
+            }
+		}
+
+		return m_okayButton;
+    }
+
+	public override void HandleAccessibleInput()
+    {
+		if (m_currentMode == MODE.CHEST_EARNED && AccessibleKey.CONFIRM.IsPressed())
+		{
+			if (m_rewardChestLegacy != null)
+            {
+				m_rewardChestLegacy.TriggerRelease();
+				return;
+            }
+
+			if (!m_chestOpened)
+            {
+                m_rankedRewardChestWidget.TriggerEvent(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME);
+            }
+        }
+        else if (AccessibleKey.CONFIRM.IsPressed())
+		{
+            m_okayButton.TriggerRelease();
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+        if (m_currentMode == MODE.CHEST_EARNED)
+        {
+			return LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED_HELP, AccessibleKey.CONFIRM);
+        }
+		else
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/SetRotationManager.cs b/Decompiled/Assembly-CSharp/SetRotationManager.cs
index 6d315e0..354b1d6 100644
--- a/Decompiled/Assembly-CSharp/SetRotationManager.cs
+++ b/Decompiled/Assembly-CSharp/SetRotationManager.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class SetRotationManager : IService
 {
@@ -71,12 +72,23 @@ public class SetRotationManager : IService
 
 	public static bool HasSeenStandardModeTutorial()
 	{
+		// This is an entirely visual tutorial and players using OCR were having trouble
+		return true;
 		return Options.Get().GetBool(Option.HAS_SEEN_STANDARD_MODE_TUTORIAL, defaultVal: false);
 	}
 
 	public static bool ShouldShowSetRotationIntro()
 	{
-		if (ReturningPlayerMgr.Get().IsInReturningPlayerMode)
+		// This is an entirely visual tutorial and players using OCR were having trouble
+		return false;
+
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Not implemented yet - making the clock accessible would be quite tricky
+            return false;
+        }
+
+        if (ReturningPlayerMgr.Get().IsInReturningPlayerMode)
 		{
 			return false;
 		}
@@ -205,12 +217,13 @@ public class SetRotationManager : IService
 		{
 			return false;
 		}
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var popupText = GameStrings.Get("GLUE_NEW_PLAYER_SET_ROTATION_POPUP_BODY_NEW");
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add("SetRotationNewPlayerPopup.prefab:cb6eb3b3df79ec34f826043f13e9a609");
 		popupInfo.m_blurWhenShown = true;
 		if (!RankMgr.Get().UseLegacyRankedPlay())
 		{
-			popupInfo.m_bodyText = GameStrings.Get("GLUE_NEW_PLAYER_SET_ROTATION_POPUP_BODY_NEW");
+			popupInfo.m_bodyText = popupText;
 		}
 		popupInfo.m_responseCallback = delegate
 		{
diff --git a/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs b/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
index e3788b7..fd0eeb1 100644
--- a/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
+++ b/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class SetRotationRotatedBoostersPopup : BasicPopup
@@ -11,6 +12,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 	public class SetRotationRotatedBoostersPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public SetRotationRotatedBoostersPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	private Widget m_widget;
@@ -25,12 +28,18 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 
 	private SetRotationRotatedBoostersPopupInfo m_info;
 
+    #region Accessibility
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+
+	private PackListDataModel m_packListDataModel;
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -55,6 +64,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 			}
 			Hashtable args = iTween.Hash("scale", localScale, "time", 0.3f, "easetype", iTween.EaseType.easeOutBack);
 			iTween.ScaleTo(base.gameObject, args);
+
+			ReadPopup();
 		}
 	}
 
@@ -66,11 +77,13 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 			setRotationRotatedBoostersPopupInfo.m_onHiddenCallback();
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void BindRankedPackListDataModel()
 	{
-		PackListDataModel packListDataModel = new PackListDataModel();
+		m_packListDataModel = new PackListDataModel();
 		SpecialEventManager events = SpecialEventManager.Get();
 		List<BoosterDbfRecord> records = GameDbf.Booster.GetRecords((BoosterDbfRecord r) => events.IsEventActive(r.BuyWithGoldEvent, activeIfDoesNotExist: false));
 		records.Sort((BoosterDbfRecord a, BoosterDbfRecord b) => b.LatestExpansionOrder.CompareTo(a.LatestExpansionOrder));
@@ -81,13 +94,53 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 				PackDataModel packDataModel = new PackDataModel();
 				packDataModel.Type = (BoosterDbId)item.ID;
 				packDataModel.BoosterName = item.Name;
-				packListDataModel.Packs.Insert(0, packDataModel);
-				if (packListDataModel.Packs.Count >= 3)
+				m_packListDataModel.Packs.Insert(0, packDataModel);
+				if (m_packListDataModel.Packs.Count >= 3)
 				{
 					break;
 				}
 			}
 		}
-		m_widget.BindDataModel(packListDataModel);
+		m_widget.BindDataModel(m_packListDataModel);
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_widget == null || m_packListDataModel == null)
+        {
+			return;
+        }
+
+		var packNames = new List<string>();
+
+		foreach (var pack in m_packListDataModel.Packs)
+		{
+			packNames.Add(pack.BoosterName);
+		}
+
+		var packNamesList = AccessibleSpeechUtils.HumanizeList(packNames);
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE));
+		AccessibilityMgr.Output(this, packNamesList);
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/SocialToastMgr.cs b/Decompiled/Assembly-CSharp/SocialToastMgr.cs
index 3a57eb7..760afec 100644
--- a/Decompiled/Assembly-CSharp/SocialToastMgr.cs
+++ b/Decompiled/Assembly-CSharp/SocialToastMgr.cs
@@ -165,7 +165,7 @@ public class SocialToastMgr : MonoBehaviour
 
 	public void AddToast(UserAttentionBlocker blocker, string textArg, TOAST_TYPE toastType, float displayTime, bool playSound)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "SocialToastMgr.AddToast:" + toastType))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, blocker, "SocialToastMgr.AddToast:" + toastType))
 		{
 			return;
 		}
diff --git a/Decompiled/Assembly-CSharp/SoundManager.cs b/Decompiled/Assembly-CSharp/SoundManager.cs
index 57977a9..68a0635 100644
--- a/Decompiled/Assembly-CSharp/SoundManager.cs
+++ b/Decompiled/Assembly-CSharp/SoundManager.cs
@@ -11,6 +11,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 {
@@ -711,8 +712,8 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			SoundLoadContext soundLoadContext = new SoundLoadContext();
 			soundLoadContext.Init(parent, volume, callback, callbackData);
 			SoundLoader.LoadSound(assetRef, OnLoadAndPlaySoundLoaded, soundLoadContext, GetPlaceholderSound());
-		}
-	}
+        }
+    }
 
 	public void PlayPreloaded(AudioSource source)
 	{
@@ -744,7 +745,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 		InitSourceTransform(source, parentObject);
 		m_generatedSources.Add(source);
 		Play(source);
-	}
+    }
 
 	public AudioSource PlayClip(SoundPlayClipArgs args, bool createNewSource = true, SoundOptions options = null)
 	{
@@ -849,7 +850,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			return;
 		}
 		RegisterSourceBundle(assetRef, component);
-		component.volume = 0f;
+        component.volume = 0f;
 		component.Play();
 		component.Stop();
 		UnregisterSourceBundle(assetRef.ToString(), component);
@@ -2103,7 +2104,14 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			}
 			HearthstoneApplication.Get().StartCoroutine(EnableInstanceLimitedSound(source.gameObject.name, num2));
 		}
-		source.Play();
+
+		if (HearthstoneAccessConstants.DEBUG_SOUND)
+        {
+            AccessibilityUtils.LogDebug($"Playing sound: {source.name}");
+			AccessibilityUtils.LogDebug(Environment.StackTrace);
+        }
+
+        source.Play();
 		return source;
 	}
 
diff --git a/Decompiled/Assembly-CSharp/SpectatorManager.cs b/Decompiled/Assembly-CSharp/SpectatorManager.cs
index 8752c6a..e51b862 100644
--- a/Decompiled/Assembly-CSharp/SpectatorManager.cs
+++ b/Decompiled/Assembly-CSharp/SpectatorManager.cs
@@ -2294,7 +2294,7 @@ public class SpectatorManager
 					Processor.CancelScheduledCallback(SpectatePlayer_RequestInvite_OpposingSide_Timeout);
 				}
 			}
-			else if (!UserAttentionManager.CanShowAttentionGrabber("SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
+			else if (!UserAttentionManager.CanShowAttentionGrabber(false, "SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
 			{
 				flag3 = true;
 				text = "user_attention_blocked";
diff --git a/Decompiled/Assembly-CSharp/SubSpellController.cs b/Decompiled/Assembly-CSharp/SubSpellController.cs
index 04daa09..fb5629e 100644
--- a/Decompiled/Assembly-CSharp/SubSpellController.cs
+++ b/Decompiled/Assembly-CSharp/SubSpellController.cs
@@ -68,7 +68,7 @@ public class SubSpellController : SpellController
 		{
 			CheckForSubSpellEnd(taskList);
 		}
-		return num;
+        return num;
 	}
 
 	private SubSpellInstance GetSubSpellInstanceForTasklist(PowerTaskList taskList)
diff --git a/Decompiled/Assembly-CSharp/TAG_CLASS.cs b/Decompiled/Assembly-CSharp/TAG_CLASS.cs
index 25a920d..093b6c4 100644
--- a/Decompiled/Assembly-CSharp/TAG_CLASS.cs
+++ b/Decompiled/Assembly-CSharp/TAG_CLASS.cs
@@ -14,5 +14,6 @@ public enum TAG_CLASS
 	DREAM,
 	NEUTRAL,
 	WHIZBANG,
-	DEMONHUNTER
+	DEMONHUNTER,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs b/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs
index 11f69f0..86c4fe0 100644
--- a/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs
+++ b/Decompiled/Assembly-CSharp/TAG_PREMIUM.cs
@@ -2,5 +2,6 @@ public enum TAG_PREMIUM
 {
 	NORMAL,
 	GOLDEN,
-	DIAMOND
+	DIAMOND,
+	EOE // AccessibleCollectibleCard depends on this for reading premium
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_RARITY.cs b/Decompiled/Assembly-CSharp/TAG_RARITY.cs
index ab28cdd..ab9360c 100644
--- a/Decompiled/Assembly-CSharp/TAG_RARITY.cs
+++ b/Decompiled/Assembly-CSharp/TAG_RARITY.cs
@@ -5,5 +5,6 @@ public enum TAG_RARITY
 	FREE,
 	RARE,
 	EPIC,
-	LEGENDARY
+	LEGENDARY,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_STEP.cs b/Decompiled/Assembly-CSharp/TAG_STEP.cs
index 110d6bb..e3a41f1 100644
--- a/Decompiled/Assembly-CSharp/TAG_STEP.cs
+++ b/Decompiled/Assembly-CSharp/TAG_STEP.cs
@@ -17,5 +17,6 @@ public enum TAG_STEP
 	FINAL_WRAPUP,
 	FINAL_GAMEOVER,
 	MAIN_CLEANUP,
-	MAIN_START_TRIGGERS
+	MAIN_START_TRIGGERS,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_ZONE.cs b/Decompiled/Assembly-CSharp/TAG_ZONE.cs
index d0c316d..d9ee97b 100644
--- a/Decompiled/Assembly-CSharp/TAG_ZONE.cs
+++ b/Decompiled/Assembly-CSharp/TAG_ZONE.cs
@@ -8,5 +8,6 @@ public enum TAG_ZONE
 	REMOVEDFROMGAME,
 	SETASIDE,
 	SECRET,
-	STUB_ZONE_8
+	STUB_ZONE_8,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs b/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
index 03a819a..7ec2865 100644
--- a/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
+++ b/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
@@ -5,6 +5,7 @@ using Blizzard.T5.AssetManager;
 using Hearthstone.DungeonCrawl;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class TavernBrawlDisplay : MonoBehaviour
@@ -310,7 +311,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 			return;
 		}
 		UpdateRecordUI();
-		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
+		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
 		{
 			m_firstTimeIntroductionPopupShowing = true;
 			StartCoroutine(DoFirstTimeHeroicIntro());
@@ -916,7 +917,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 		{
 			return;
 		}
-		bool flag = UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.Show");
+		bool flag = UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.Show");
 		int latestSeenTavernBrawlChalkboard = TavernBrawlManager.Get().LatestSeenTavernBrawlChalkboard;
 		if (latestSeenTavernBrawlChalkboard == 0)
 		{
@@ -1693,6 +1694,10 @@ public class TavernBrawlDisplay : MonoBehaviour
 				collectionManagerDisplay.OnDoneEditingDeck();
 			}
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void OnDeckCreated(long deckID)
diff --git a/Decompiled/Assembly-CSharp/TooltipPanelManager.cs b/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
index d4e4ab0..2994aaf 100644
--- a/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
+++ b/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
@@ -948,4 +948,13 @@ public class TooltipPanelManager : MonoBehaviour
 		}
 		return result;
 	}
+
+	#region Accessibility
+
+	internal List<TooltipPanel> GetTooltipPanels()
+    {
+		return m_tooltipPanels;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TournamentDisplay.cs b/Decompiled/Assembly-CSharp/TournamentDisplay.cs
index 5502edf..6595454 100644
--- a/Decompiled/Assembly-CSharp/TournamentDisplay.cs
+++ b/Decompiled/Assembly-CSharp/TournamentDisplay.cs
@@ -47,7 +47,7 @@ public class TournamentDisplay : MonoBehaviour
 	private void OnDestroy()
 	{
 		s_instance = null;
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		UnregisterListeners();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/TurnStartManager.cs b/Decompiled/Assembly-CSharp/TurnStartManager.cs
index 8f84554..0c01f66 100644
--- a/Decompiled/Assembly-CSharp/TurnStartManager.cs
+++ b/Decompiled/Assembly-CSharp/TurnStartManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -319,6 +320,7 @@ public class TurnStartManager : MonoBehaviour
 				m_turnStartInstance.SetReminderText(GameState.Get().GetGameEntity().GetTurnStartReminderText());
 				m_turnStartInstance.Show();
 				SoundManager.Get().LoadAndPlay("ALERT_YourTurn_0v2.prefab:201bcb34d33384e48ab226f7e797771f");
+				AccessibleGameplay.Get().OnTurnStart();
 			}
 		}
 	}
diff --git a/Decompiled/Assembly-CSharp/TutorialEntity.cs b/Decompiled/Assembly-CSharp/TutorialEntity.cs
index a83ab46..3d1f872 100644
--- a/Decompiled/Assembly-CSharp/TutorialEntity.cs
+++ b/Decompiled/Assembly-CSharp/TutorialEntity.cs
@@ -1,7 +1,8 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
-public class TutorialEntity : MissionEntity
+public abstract class TutorialEntity : MissionEntity
 {
 	private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
 
@@ -74,14 +75,24 @@ public class TutorialEntity : MissionEntity
 				Notification notification = NotificationManager.Get().CreateSpeechBubble(GameStrings.Get("TUTORIAL02_JAINA_05"), Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: true);
 				SoundManager.Get().LoadAndPlay("VO_TUTORIAL_02_JAINA_05_20.prefab:700f7c6b778de5d41bf6d45a2e01b13d");
 				NotificationManager.Get().DestroyNotification(notification, 3.5f);
-				Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_01")));
+
+                if (!AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    // This is a visual-only reminder
+                    Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_01")));
+                }
 			}
 			else
 			{
 				Notification notification2 = NotificationManager.Get().CreateSpeechBubble(GameStrings.Get("TUTORIAL02_JAINA_04"), Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: true);
 				SoundManager.Get().LoadAndPlay("VO_TUTORIAL_02_JAINA_04_19.prefab:af04fcf53166d04469dc1b22b4181bf9");
 				NotificationManager.Get().DestroyNotification(notification2, 3.5f);
-				Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_03")));
+
+                if (!AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    // This is a visual-only reminder
+                    Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_03")));
+                }
 			}
 			return true;
 		}
@@ -230,9 +241,18 @@ public class TutorialEntity : MissionEntity
 			NotificationManager.Get().DestroyNotificationNowWithNoAnim(thatsABadPlayPopup);
 		}
 		Vector3 position = new Vector3(origin.x - 3f, origin.y, origin.z);
-		thatsABadPlayPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, GetTextScale(), GameStrings.Get("TUTORIAL01_HELP_07"));
-		NotificationManager.Get().DestroyNotification(thatsABadPlayPopup, 2.5f);
-	}
+
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_07);
+        }
+		else
+        {
+			// Visual-only popups
+            thatsABadPlayPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, GetTextScale(), GameStrings.Get("TUTORIAL01_HELP_07"));
+            NotificationManager.Get().DestroyNotification(thatsABadPlayPopup, 2.5f);
+        }
+    }
 
 	protected void HandleGameStartEvent()
 	{
@@ -312,4 +332,6 @@ public class TutorialEntity : MissionEntity
 	{
 		Options.Get().SetInt(Option.TUTORIAL_LOST_PROGRESS, 0);
 	}
+
+	protected abstract void MarkForAccessibility();
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs b/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
index 512c063..da825d4 100644
--- a/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
+++ b/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
@@ -190,4 +190,13 @@ public class TutorialKeywordManager : MonoBehaviour
 		}
 		return m_keywordPanels[0].transform.position;
 	}
+
+	#region Accessibility
+
+	internal List<TutorialKeywordTooltip> GetPanels()
+    {
+		return m_keywordPanels;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs b/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
index 767c3d4..a3740f4 100644
--- a/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
+++ b/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -401,17 +402,20 @@ public class TutorialProgressScreen : MonoBehaviour
 		coin.m_inputEnabled = false;
 		yield return new WaitForSeconds(1f);
 		coin.SetProgress(HeroCoin.CoinStatus.ACTIVE_TO_DEFEATED);
-	}
+		yield return new WaitForSeconds(2f);
+        AccessibleTutorialProgressScreen.Get().OnDefeatedOpponent(coin);
+    }
 
-	private IEnumerator SetUnrevealedToActive(HeroCoin coin)
+    private IEnumerator SetUnrevealedToActive(HeroCoin coin)
 	{
 		coin.SetProgress(HeroCoin.CoinStatus.UNREVEALED);
 		coin.m_inputEnabled = false;
-		yield return new WaitForSeconds(2f);
+		yield return new WaitForSeconds(4f);
 		coin.SetProgress(HeroCoin.CoinStatus.UNREVEALED_TO_ACTIVE);
-	}
+        AccessibleTutorialProgressScreen.Get().OnNextOpponent(coin);
+    }
 
-	private void ExitButtonPress(UIEvent e)
+    private void ExitButtonPress(UIEvent e)
 	{
 		SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
 		FullScreenFXMgr.Get().Vignette(0f, 0.5f, iTween.EaseType.easeInOutQuad);
diff --git a/Decompiled/Assembly-CSharp/Tutorial_01.cs b/Decompiled/Assembly-CSharp/Tutorial_01.cs
index c48462a..60c8817 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_01.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_01.cs
@@ -1,38 +1,39 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class Tutorial_01 : TutorialEntity
 {
-	private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
 
-	private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
 
-	private Notification endTurnNotifier;
+    private Notification endTurnNotifier;
 
-	private Notification handBounceArrow;
+    private Notification handBounceArrow;
 
-	private Notification handFadeArrow;
+    private Notification handFadeArrow;
 
-	private Notification noFireballPopup;
+    private Notification noFireballPopup;
 
-	private Notification attackWithYourMinion;
+    private Notification attackWithYourMinion;
 
-	private Notification crushThisGnoll;
+    private Notification crushThisGnoll;
 
-	private Notification freeCardsPopup;
+    private Notification freeCardsPopup;
 
-	private TooltipPanel attackHelpPanel;
+    private TooltipPanel attackHelpPanel;
 
-	private TooltipPanel healthHelpPanel;
+    private TooltipPanel healthHelpPanel;
 
-	private Card mousedOverCard;
+    private Card mousedOverCard;
 
-	private GameObject costLabel;
+    private GameObject costLabel;
 
-	private GameObject attackLabel;
+    private GameObject attackLabel;
 
-	private GameObject healthLabel;
+    private GameObject healthLabel;
 
 	private Card firstMurlocCard;
 
@@ -1171,4 +1172,8 @@ public class Tutorial_01 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_02.cs b/Decompiled/Assembly-CSharp/Tutorial_02.cs
index 883a882..23b4ec3 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_02.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_02.cs
@@ -528,4 +528,9 @@ public class Tutorial_02 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_02
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_03.cs b/Decompiled/Assembly-CSharp/Tutorial_03.cs
index 34e83b6..65b31e9 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_03.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_03.cs
@@ -400,4 +400,9 @@ public class Tutorial_03 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_03
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_04.cs b/Decompiled/Assembly-CSharp/Tutorial_04.cs
index e73d949..478ae18 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_04.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_04.cs
@@ -642,4 +642,9 @@ public class Tutorial_04 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_04
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_05.cs b/Decompiled/Assembly-CSharp/Tutorial_05.cs
index 1e509d0..b95df21 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_05.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_05.cs
@@ -285,4 +285,9 @@ public class Tutorial_05 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_05
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_06.cs b/Decompiled/Assembly-CSharp/Tutorial_06.cs
index c2e385c..592cc33 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_06.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_06.cs
@@ -319,4 +319,9 @@ public class Tutorial_06 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_06
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/UniversalInputManager.cs b/Decompiled/Assembly-CSharp/UniversalInputManager.cs
index 7908d8f..c35cac2 100644
--- a/Decompiled/Assembly-CSharp/UniversalInputManager.cs
+++ b/Decompiled/Assembly-CSharp/UniversalInputManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
@@ -271,6 +272,10 @@ public class UniversalInputManager : IHasUpdate, IService
 
 	private void OnGUI()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled() && !AccessibilityMgr.IsTextInputAllowed())
+        {
+			return;
+        }
 		IgnoreGUIInput();
 		HandleGUIInputInactive();
 		HandleGUIInputActive();
@@ -1003,6 +1008,12 @@ public class UniversalInputManager : IHasUpdate, IService
 
 	private void UpdateInput()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			AccessibilityMgr.HandleKeyboardInput();
+			return;
+        }
+
 		if (UpdateTextInput())
 		{
 			return;
diff --git a/Decompiled/Assembly-CSharp/UserAttentionManager.cs b/Decompiled/Assembly-CSharp/UserAttentionManager.cs
index 1cf9c76..57e1fbd 100644
--- a/Decompiled/Assembly-CSharp/UserAttentionManager.cs
+++ b/Decompiled/Assembly-CSharp/UserAttentionManager.cs
@@ -14,7 +14,7 @@ public static class UserAttentionManager
 		get
 		{
 			IEnumerable<string> source = (from UserAttentionBlocker r in Enum.GetValues(typeof(UserAttentionBlocker))
-				where IsBlockedBy(r)
+				where IsBlockedBy(true, r)
 				select r).Select(delegate(UserAttentionBlocker r)
 			{
 				UserAttentionBlocker userAttentionBlocker = r;
@@ -28,7 +28,12 @@ public static class UserAttentionManager
 
 	public static event Action OnBlockingEnd;
 
-	public static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
+	public static bool IsBlockedBy(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		return IsBlockedBy(attentionCategory);
+    }
+
+	private static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
 	{
 		if (attentionCategory != 0)
 		{
@@ -37,17 +42,27 @@ public static class UserAttentionManager
 		return false;
 	}
 
-	public static bool CanShowAttentionGrabber(string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, string callerName)
+    {
+		return CanShowAttentionGrabber(callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(string callerName)
 	{
-		return CanShowAttentionGrabber(UserAttentionBlocker.NONE, callerName);
+		return CanShowAttentionGrabber(true, UserAttentionBlocker.NONE, callerName);
 	}
 
-	public static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, UserAttentionBlocker attentionCategory, string callerName)
+    {
+		return CanShowAttentionGrabber(attentionCategory, callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
 	{
 		if ((s_blockedReasons & ~attentionCategory) != 0)
 		{
 			IEnumerable<string> source = (from UserAttentionBlocker r in Enum.GetValues(typeof(UserAttentionBlocker))
-				where r != attentionCategory && IsBlockedBy(r)
+				where r != attentionCategory && IsBlockedBy(true, r)
 				select r).Select(delegate(UserAttentionBlocker r)
 			{
 				UserAttentionBlocker userAttentionBlocker = r;
@@ -60,9 +75,14 @@ public static class UserAttentionManager
 		return true;
 	}
 
-	public static void StartBlocking(UserAttentionBlocker attentionCategory)
+	public static void StartBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StartBlocking(attentionCategory);
+    }
+
+	private static void StartBlocking(UserAttentionBlocker attentionCategory)
 	{
-		if (!IsBlockedBy(attentionCategory))
+		if (!IsBlockedBy(true, attentionCategory))
 		{
 			bool isBlocked = IsBlocked;
 			if (isBlocked)
@@ -79,7 +99,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static void StopBlocking(UserAttentionBlocker attentionCategory)
+	public static void StopBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StopBlocking(attentionCategory);
+    }
+
+	private static void StopBlocking(UserAttentionBlocker attentionCategory)
 	{
 		bool isBlocked = IsBlocked;
 		s_blockedReasons &= ~attentionCategory;
@@ -101,7 +126,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
+	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool markedForAccessibility, bool isFriendlyChallenge)
+    {
+		return GetAvailabilityBlockerReason(isFriendlyChallenge);
+    }
+
+	private static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
 	{
 		if (SpectatorManager.Get().IsInSpectatorMode())
 		{
diff --git a/Decompiled/Assembly-CSharp/WelcomeQuests.cs b/Decompiled/Assembly-CSharp/WelcomeQuests.cs
index 131c909..fa1f20c 100644
--- a/Decompiled/Assembly-CSharp/WelcomeQuests.cs
+++ b/Decompiled/Assembly-CSharp/WelcomeQuests.cs
@@ -1,8 +1,9 @@
 using System.Collections.Generic;
 using Assets;
 using UnityEngine;
+using Accessibility;
 
-public class WelcomeQuests : MonoBehaviour
+public class WelcomeQuests : MonoBehaviour, AccessibleUI
 {
 	public delegate void DelOnWelcomeQuestsClosed();
 
@@ -70,7 +71,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static bool Show(UserAttentionBlocker blocker, bool fromLogin, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.Show:" + fromLogin))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.Show:" + fromLogin))
 		{
 			onCloseCallback?.Invoke();
 			return false;
@@ -95,7 +96,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static void ShowSpecialQuest(UserAttentionBlocker blocker, Achievement achievement, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
 		{
 			onCloseCallback?.Invoke();
 			return;
@@ -173,6 +174,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		FadeEffectsOut();
 		if (s_instance != null)
 		{
@@ -271,6 +274,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void ReinitAndShow(ShowRequestData showRequestData)
 	{
+		AccessibilityMgr.HideUI(this); // Seems like an error condition but not really sure - best effort
+
 		FadeEffectsOut();
 		UnlockBnetButtons();
 		InitAndShow(showRequestData);
@@ -406,6 +411,8 @@ public class WelcomeQuests : MonoBehaviour
 			m_loginQuestShownTime = Time.realtimeSinceStartup;
 			m_clickCatcher.AddEventListener(UIEventType.RELEASE, SendTelemetry);
 		}
+
+		ReadQuests();
 	}
 
 	private void CheckShowInnkeepersSpecial()
@@ -485,6 +492,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void Close()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		CleanUpEventListeners();
 		UnlockBnetButtons();
 		s_instance = null;
@@ -583,4 +592,89 @@ public class WelcomeQuests : MonoBehaviour
 			m_bnetButtonsLocked = false;
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleQuestTile> m_accessibleQuests;
+
+	private AccessibleQuestTile m_accessibleQuestTile;
+
+	private void ReadQuests()
+    {
+		m_accessibleQuestTile = null;
+		m_accessibleQuests = null;
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, m_headlineBanner.m_headline.Text);
+
+		if (m_currentQuests.Count == 1)
+        {
+			m_accessibleQuestTile = new AccessibleQuestTile(this, m_currentQuests[0]);
+			m_accessibleQuestTile.ReadAllLines();
+        }
+		else
+        {
+            var accessibleQuests = new List<AccessibleQuestTile>();
+            foreach (var quest in m_currentQuests)
+            {
+                accessibleQuests.Add(new AccessibleQuestTile(this, quest));
+            }
+
+            m_accessibleQuests = new AccessibleListOfItems<AccessibleQuestTile>(this, accessibleQuests);
+            m_accessibleQuests.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_clickCatcher.TriggerRelease();
+        }
+        else
+        {
+			m_accessibleQuestTile?.HandleAccessibleInput();
+            m_accessibleQuests?.HandleAccessibleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_accessibleQuests != null)
+        {
+            GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+            {
+                new GameStrings.PluralNumber
+                {
+                    m_index = 0,
+                    m_number = 2 // Doesn't really matter as long as it's not 1
+                }
+            };
+
+			var text = LocalizationUtils.FormatPlurals(LocalizationKey.UI_WELCOME_QUESTS_HELP, pluralNumbers);
+			var confirmText = AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE;
+
+			return AccessibleSpeechUtils.CombineSentences(text, confirmText);
+        }
+		else if (m_accessibleQuestTile != null)
+        {
+            GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+            {
+                new GameStrings.PluralNumber
+                {
+                    m_index = 0,
+                    m_number = 1
+                }
+            };
+
+			var text = LocalizationUtils.FormatPlurals(LocalizationKey.UI_WELCOME_QUESTS_HELP, pluralNumbers);
+			var confirmText = AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE;
+
+			return AccessibleSpeechUtils.CombineSentences(text, confirmText);
+        }
+
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
