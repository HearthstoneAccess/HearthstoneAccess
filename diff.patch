diff --git a/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
index d4b7df8..389f126 100644
--- a/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
@@ -5,8 +5,9 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
+public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour, AccessibleScreen
 {
 	public delegate void DeckTrayLoaded();
 
@@ -127,7 +128,7 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	protected SlidingTray m_slidingTray;
 
-	protected PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
 	private AudioSource m_lastPickLine;
 
@@ -396,9 +397,11 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 				SceneMgr.Get().SetNextMode(SceneMgr.Get().GetPrevMode());
 			}
 		}
+
+		ReadHeroSelectionScreen();
 	}
 
-	protected virtual void InitForMode(SceneMgr.Mode mode)
+    protected virtual void InitForMode(SceneMgr.Mode mode)
 	{
 		switch (mode)
 		{
@@ -592,10 +595,12 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 				SoundManager.Get().LoadAndPlay(button.HeroPickerSelectedPrefab, button.gameObject, 1f, OnLastPickLineLoaded);
 			}
 			SetPlayButtonEnabled(flag);
-		}
-	}
 
-	protected virtual void UpdateHeroInfo(HeroPickerButton button)
+            OnChosenHero();
+        }
+    }
+
+    protected virtual void UpdateHeroInfo(HeroPickerButton button)
 	{
 	}
 
@@ -1662,4 +1667,104 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 	{
 		StartCoroutine(LoadHeroButtons(buttonsToDisplay));
 	}
+
+	#region Accessibility
+
+	private enum AccessibleState { LOADING, CHOOSING_HERO, HERO_CHOSEN };
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleMenu m_accessibleHeroes;
+
+    private void ReadHeroSelectionScreen()
+    {
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+		m_curAccessibleState = AccessibleState.CHOOSING_HERO;
+
+		AccessibilityMgr.SetScreen(this);
+
+		//m_accessibleHeroes = new AccessibleMenu("Choose an adventurer", () => m_backButton.TriggerRelease());
+		m_accessibleHeroes = new AccessibleMenu("Choose an adventurer", () => AccessibilityUtils.GoBackToHub());
+
+		var numSupportedBoHHeroes = 1; // Only Jaina is supported for now -> Remember to release according to Blizzard's order
+
+		//foreach (var hb in m_heroButtons)
+		for (var i = 0; i < 1; i++)
+        {
+			var hb = m_heroButtons[i];
+			var heroName = hb.GetEntityDef()?.GetName();
+
+			m_accessibleHeroes.AddOption(hb.GetEntityDef()?.GetName(), () => ChooseHero(hb));
+        }
+
+		m_accessibleHeroes.StartReading();
+    }
+
+	private void OnChosenHero()
+    {
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+        m_curAccessibleState = AccessibleState.HERO_CHOSEN;
+        AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_START);
+    }
+
+    private bool SupportedAdventure()
+    {
+		var selectedAdventure = AdventureConfig.Get().SelectedAdventure;
+
+		return selectedAdventure == AdventureDbId.BOH;
+    }
+
+    private void ChooseHero(HeroPickerButton hb)
+    {
+		hb.TriggerRelease();
+    }
+
+    public void HandleInput()
+    {
+		if (m_curAccessibleState == AccessibleState.CHOOSING_HERO)
+        {
+            m_accessibleHeroes.HandleAccessibleInput();
+        }
+		else if (m_curAccessibleState == AccessibleState.HERO_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_playButton.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				AccessibilityUtils.GoBackToHub();
+            }
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.CHOOSING_HERO)
+        {
+            return AccessibleSpeech.MENU_HELP(true);
+        }
+        else if (m_curAccessibleState == AccessibleState.HERO_CHOSEN)
+        {
+			return $"Press {AccessibleKey.CONFIRM} to start or {AccessibleKey.BACK} to go back to the main menu";
+        }
+		else
+        {
+			return ""; // Could say loading I guess. Need to test other adventures
+        }
+    }
+
+    public void OnGainedFocus()
+    {
+		AccessibilityMgr.Output("Choose Adventurer screen");
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
new file mode 100644
index 0000000..fbe9535
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
@@ -0,0 +1,7 @@
+﻿namespace Accessibility
+{
+    class AccessibilityConfig
+    {
+        internal static bool CAN_HEAR = true; // Could look into doing something like this for deaf-blind support
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
new file mode 100644
index 0000000..de54263
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
@@ -0,0 +1,483 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    static class AccessibilityMgr
+    {
+        private static AccessibleKey s_forcedKey; // Override everything else e.g. sometimes we need to press enter before anything is possible but we don't necessarily want a screen or UI
+        private static Action s_forcedAction;
+
+        private static List<AccessibleUI> s_curUIs = new List<AccessibleUI>();
+
+        private static AccessibleScreen s_curScreen;
+
+        private static PegUIElement s_curNotificationDismissButton;
+
+        private static HSASpeech s_helpSpeech;
+
+        // Our sound game object
+        private static GameObject s_soundGameObject;
+
+        private static bool s_enabled;
+
+        internal static void Initialize(GameObject rootGameObject)
+        {
+            try
+            {
+                Log.Accessibility.Print("Accessibility initialized");
+
+                // TODO: Think about whether we only want to enable if we detect a screen reader or if falling back to SAPI is fine
+                ScreenReader.Load();
+                rootGameObject.AddComponent<AccessibleInputMgr>();
+
+                s_enabled = true;
+
+                // Init sound stuff for narration
+                s_soundGameObject = InitSoundGameObject();
+                s_soundGameObject.transform.parent = rootGameObject.transform;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void Shutdown()
+        {
+            Log.Accessibility.Print("Accessibility shutdown");
+            ScreenReader.Unload();
+        }
+
+        internal static void SetScreen(AccessibleScreen screen)
+        {
+            Log.Accessibility.Print($"Setting screen {screen}");
+            var prevScreen = s_curScreen;
+            s_curScreen = screen;
+
+            if (s_curScreen != prevScreen && s_curUIs.Count == 0 && DialogManager.Get().GetNumQueuedDialogs() == 0)
+            {
+                NotifyScreenFocused();
+            }
+        }
+
+        private static void NotifyScreenFocused()
+        {
+            try
+            {
+                s_curScreen.OnGainedFocus();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void TransitioningScreens()
+        {
+            Log.Accessibility.Print($"Transitioning screens");
+            s_curScreen = null;
+        }
+
+        internal static void SetNotification(PegUIElement dismissButton)
+        {
+            if (s_curNotificationDismissButton != null)
+            {
+                // Remove any pending listeners
+                s_curNotificationDismissButton.RemoveEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+            }
+
+            s_curNotificationDismissButton = dismissButton;
+
+            s_curNotificationDismissButton.AddEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+        }
+
+        private static void OnNotificationDismissButtonReleased(UIEvent uiEvent)
+        {
+            s_curNotificationDismissButton = null;
+        }
+
+        public static void ShowUI(AccessibleUI ui)
+        {
+            try
+            {
+                Log.Accessibility.Print($"ShowUI({ui})");
+
+                if (GetFocusedUI() != ui)
+                {
+                    s_curUIs.Add(ui);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void HideUI(AccessibleUI ui)
+        {
+            try
+            {
+                var numRemovedUIs = s_curUIs.RemoveAll(obj => obj == ui);
+
+                if (numRemovedUIs > 0)
+                {
+                    OnUIPopped(ui);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void OnUIPopped(AccessibleUI ui)
+        {
+            var curUI = GetFocusedUI();
+
+            if (curUI == null)
+            {
+                if (s_curScreen != null)
+                {
+                    if (DialogManager.Get().GetCurrentDialog() == ui && DialogManager.Get().GetNumQueuedDialogs() > 0)
+                    {
+                        return;
+                    }
+
+                    NotifyScreenFocused();
+                }
+            }
+        }
+
+        private static AccessibleUI GetFocusedUI()
+        {
+            if (s_curUIs.Count == 0)
+            {
+                return null;
+            }
+
+            return s_curUIs[s_curUIs.Count - 1];
+        }
+
+        internal static void OutputAndWait(string text, Action onStart, Action onEnd)
+        {
+            GetSpeechMgr().OutputTextAndWait(text, onStart, onEnd);
+        }
+
+        public static void Output(string text, bool interrupt=false)
+        {
+            try
+            {
+                if (interrupt)
+                {
+                    GetSpeechMgr().OutputTextImmediately(text);
+                }
+                else
+                {
+                    Output(text);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void Output(string text)
+        {
+            GetSpeechMgr().OutputText(text);
+        }
+
+        public static void HandleKeyboardInput()
+        {
+            try
+            {
+                if (Input.anyKeyDown)
+                {
+                    InterruptHelpSpeeches();
+                }
+
+                HandleGlobalInput();
+
+                var curUI = GetFocusedUI();
+
+                if (AccessibleKey.HELP.IsPressed())
+                {
+                    if (s_helpSpeech != null)
+                    {
+                        NarrateHelp(s_helpSpeech);
+                    }
+                    else if (s_forcedKey != null)
+                    {
+                        Output($"Press {s_forcedKey} to continue");
+                    }
+                    else if (s_curNotificationDismissButton != null)
+                    {
+                        Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                    }
+                    else if (curUI != null)
+                    {
+                        Output(curUI.GetAccessibleHelp());
+                    }
+                    else if (s_curScreen != null)
+                    {
+                        Output(s_curScreen.GetHelp());
+                    }
+                    else
+                    {
+                        Output("Loading. Please wait");
+                    }
+
+                    return;
+                }
+
+                if (s_forcedKey != null)
+                {
+                    if (s_forcedKey.IsPressed())
+                    {
+                        s_forcedKey = null;
+                        s_forcedAction();
+                    }
+                }
+                else if (s_curNotificationDismissButton != null)
+                {
+                    if (AccessibleKey.CONFIRM.IsPressed())
+                    {
+                        s_curNotificationDismissButton.TriggerRelease();
+                    }
+                }
+                else if (curUI != null)
+                {
+                    curUI.HandleAccessibleInput();
+                }
+                else if (s_curScreen != null)
+                {
+                    s_curScreen.HandleInput();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void InterruptHelpSpeeches()
+        {
+            GetSpeechMgr().InterruptSpeeches();
+        }
+
+        private static void HandleGlobalInput()
+        {
+            BnetBar bnetBar = BnetBar.Get();
+
+            if (bnetBar != null && AccessibleKey.OPEN_GAME_MENU.IsPressed())
+            {
+                bnetBar.ToggleGameMenu();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F7))
+            {
+                InGameSystemTests.TestCardEffectInterpreter();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.Backslash))
+            {
+                HSADevTools.RunTests();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F4))
+            {
+                // Smoke test speeches
+                GetSpeechMgr().Narrate(false, null, AccessibleSpeech.WELCOME_TO_HEARTHSTONE);
+            }
+            else if (AccessibleKey.INCREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().IncreaseSpeechRate();
+            }
+            else if (AccessibleKey.DECREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().DecreaseSpeechRate();
+            }
+        }
+
+        public static void WaitForForcedKey(AccessibleKey key, Action action)
+        {
+            s_forcedKey = key;
+            s_forcedAction = action;
+        }
+
+        public static void BlockAllInput(bool blockGlobalInput=false, bool blockHelpSpeech=false)
+        {
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            foreach (var key in AccessibleKey.GetAllKeys(blockGlobalInput))
+            {
+                key.Disable();
+            }
+
+            if (!blockGlobalInput && blockHelpSpeech)
+            {
+                AccessibleKey.HELP.Disable();
+            }
+        }
+
+        public static void UnblockAllInput()
+        {
+            m_isInWhitelistMode = false;
+
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            s_helpSpeech = null;
+        }
+
+        public static void OverrideHelpSpeech(HSASpeech helpSpeech)
+        {
+            s_helpSpeech = helpSpeech;
+            AccessibleKey.HELP.Enable();
+        }
+
+        public static void BlockHelpSpeech()
+        {
+            AccessibleKey.HELP.Disable();
+        }
+
+        public static void ResetHelpSpeech()
+        {
+            s_helpSpeech = null;
+            AccessibleKey.HELP.Enable();
+        }
+
+        private static bool m_isInWhitelistMode;
+
+        public static void WhitelistKeys(HSASpeech helpSpeech, params AccessibleKey[] keys)
+        {
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Enable();
+            }
+
+            OverrideHelpSpeech(helpSpeech);
+            m_isInWhitelistMode = true;
+        }
+
+        public static void BlacklistKeys(params AccessibleKey[] keys)
+        {
+            if (!m_isInWhitelistMode)
+            {
+                // e.g. it's useful to be able to disable end turn on Tutorial01, but we don't always want to block input after that
+                return;
+            }
+
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Disable();
+            }
+
+            s_helpSpeech = null;
+            AccessibleKey.HELP.Disable();
+        }
+
+        private static GameObject InitSoundGameObject()
+        {
+            var ret = new GameObject();
+
+            ret.AddComponent<AudioSource>();
+            ret.AddComponent<AccessibleSpeechMgr>();
+
+            return ret;
+        }
+
+        public static IEnumerator Narrate(HSASpeech speech)
+        {
+            return GetSpeechMgr().Narrate(speech);
+        }
+
+        public static void NarrateHelp(params HSASpeech[] speeches)
+        {
+            try
+            {
+                NarrateSpeeches(true, null, speeches);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void NarrateAndWait(HSASpeech speech, Action onFinish=null)
+        {
+            try
+            {
+                NarrateSpeeches(false, onFinish, speech);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void NarrateSpeeches(bool interruptable, Action onFinish=null, params HSASpeech[] speeches)
+        {
+            try
+            {
+                if (speeches == null || speeches.Length == 0)
+                {
+                    return;
+                }
+
+                GetSpeechMgr().Narrate(interruptable, onFinish, speeches);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static AccessibleSpeechMgr GetSpeechMgr()
+        {
+            return s_soundGameObject.GetComponent<AccessibleSpeechMgr>();
+        }
+
+        internal static int GetCPS()
+        {
+            return GetSpeechMgr().GetCPS();
+        }
+
+        public static void InterruptTexts()
+        {
+            try
+            {
+                GetSpeechMgr().InterruptTexts();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static bool IsAccessibilityEnabled()
+        {
+            return s_enabled;
+        }
+
+        internal static void ToggleEnabled()
+        {
+            s_enabled = !s_enabled;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
new file mode 100644
index 0000000..9415edf
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
@@ -0,0 +1,339 @@
+﻿using System;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    public class AccessibilityUtils
+    {
+        private static bool s_logEnabled = HearthstoneAccessConstants.DEV_MODE;
+
+        public static void DisableLogs()
+        {
+            s_logEnabled = false;
+        }
+
+        public static void LogDebug(string text)
+        {
+            try
+            {
+                if (!s_logEnabled)
+                {
+                    return;
+                }
+
+                Log.Accessibility.Print(text);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static string CurateText(string text)
+        {
+            try
+            {
+                LogDebug($"CT Before: {text}");
+                text = text.Trim();
+                text = AccessibilityUtils.FixWeirdText(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.HandleNewLines(text);
+                text = AccessibilityUtils.HandleSequentialBolds(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveHTMLTags(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveLooseFormattingTags(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveReadOnlyCharacters(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveAttackHealthParenthesisText(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.FixForwardSlashes(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.CapitalizeSentences(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.RemoveUnderscores(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.CollapsePeriods(text);
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.NormalizeSpaces(text);
+                LogDebug($"CT: {text}");
+                text = text.Trim();
+                LogDebug($"CT: {text}");
+                text = AccessibilityUtils.ExpandPlusSigns(text);
+                LogDebug($"CT: {text}");
+                //text = AccessibilityUtils.ConvertNumbersToWrittenNumbers(text); // Bad idea as it breaks localization
+                LogDebug($"CT: {text}");
+
+                if (text.Length == 0)
+                {
+                    return text;
+                }
+
+                text = AccessibilityUtils.AddPeriodIfNeeded(text);
+
+                LogDebug($"CT After: {text}");
+
+                return text;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                return "";
+            }
+        }
+
+        private static string CapitalizeSentences(string text)
+        {
+            var sb = new StringBuilder(text.Length);
+
+            bool newSentence = true;
+
+            for (int i = 0; i < text.Length; i++)
+            {
+                if (newSentence && char.IsLetterOrDigit(text[i]))
+                {
+                    sb.Append(char.ToUpper(text[i]));
+                    newSentence = false;
+                }
+                else
+                {
+                    sb.Append(text[i]);
+                }
+
+                if (text[i] == '.' || text[i] == '?' || text[i] == '!' || text[i] == ';')
+                {
+                    newSentence = true;
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string CollapsePeriods(string text)
+        {
+            return text.Replace("...", ".").Replace("..", "."); // . reads better than ... (.. reads dot/dot so needs to be removed)
+        }
+
+        private static string RemoveUnderscores(string text)
+        {
+            return text.Replace("_", " ");
+        }
+
+        private static string NormalizeSpaces(string text)
+        {
+            var sb = new StringBuilder();
+            bool ws = false;
+
+            foreach(var c in text)
+            {
+                if (c == ' ')
+                {
+                    if (!ws)
+                    {
+                        sb.Append(c);
+                    }
+
+                    ws = true;
+                }
+                else
+                {
+                    ws = false;
+                    sb.Append(c);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string AddPeriodIfNeeded(string text)
+        {
+            if (text.EndsWith(".") || text.EndsWith(".\"") || text.EndsWith("!") || text.EndsWith("?"))
+            {
+                return text;
+            }
+
+            return text + ".";
+        }
+
+        private static Regex s_attackAndHealthParenthesisRegex = new Regex(@"(.*)(\(\+\d Attack\/\+\d Health\))(.*)");
+
+        private static string RemoveAttackHealthParenthesisText(string text)
+        {
+            var match = s_attackAndHealthParenthesisRegex.Match(text);
+
+            if (match.Success)
+            {
+                return text.Replace(match.Groups[2].Value, "");
+            }
+            else
+            {
+                return text;
+            }
+        }
+
+        private static string FixForwardSlashes(string text)
+        {
+            return text.Replace("/", " ");
+        }
+
+        private static string FixWeirdText(string text)
+        {
+            return text.Replace("HIMSELF", "himself") // Injured Blademaster
+                .Replace("ALL", "all"); // Various cards
+        }
+
+        private static Regex s_boldLinesRegex = new Regex("^<b>.*</b>$");
+
+        private static string HandleNewLines(string text)
+        {
+            // e.g. Battlecry on a single line and then something else below / Passive on a single line, etc.
+            var lines = text.Split('\n');
+            var sb = new StringBuilder();
+
+            for (var i = 0; i < lines.Length - 1; i++) // Last line doesn't matter
+            {
+                var line = lines[i];
+
+                if (s_boldLinesRegex.Match(line).Success)
+                {
+                    sb.Append($"{line}. ");
+                }
+                else
+                {
+                    sb.Append($"{line} ");
+                }
+            }
+
+            sb.Append(lines[lines.Length - 1]);
+
+            return sb.ToString();
+        }
+
+        private static Regex s_htmlTagsRegex = new Regex("<[^>]*>");
+
+        private static string RemoveHTMLTags(string text)
+        {
+            return s_htmlTagsRegex.Replace(text, "");
+        }
+
+        private static string HandleSequentialBolds(string text)
+        {
+            return text.Replace("</b> <b>", "</b>. <b>");
+        }
+
+        private static string RemoveLooseFormattingTags(string text)
+        {
+            return text.Replace("[X]", "")
+                .Replace("[x]", "");
+        }
+
+        private static string RemoveReadOnlyCharacters(string text)
+        {
+            return text.Replace("*", "");
+        }
+
+        private static string ExpandPlusSigns(string text)
+        {
+            var sb = new StringBuilder();
+
+            for (int i = 0; i < text.Length; i++)
+            {
+                var c = text[i];
+
+                if (c == '+' || c == '-')
+                {
+                    var replacedChar = true;
+
+                    if (c == '+')
+                    {
+                        sb.Append("plus");
+                    }
+                    else if (c == '-')
+                    {
+                        if (i > 0 && i < text.Length - 1 && text[i-1] == ' ' && text[i+1] != ' ') // Choose one - something
+                        {
+                            sb.Append("minus");
+                        }
+                        else
+                        {
+                            replacedChar = false; // e.g. Shadow-pan monk
+                        }
+                    }
+
+                    if (replacedChar)
+                    {
+                        int nextChar = i + 1;
+
+                        if (nextChar <= text.Length - 1 && text[nextChar] != ' ')
+                        {
+                            sb.Append(' ');
+                        }
+                    }
+                    else
+                    {
+                        sb.Append(c);
+                    }
+                }
+                else
+                {
+                    sb.Append(c);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        internal static void LogFatalError(Exception e)
+        {
+            Log.Accessibility.PrintError("FATAL ERROR - UNCAUGHT EXCEPTION");
+            Log.Accessibility.PrintError(e.Message);
+            Log.Accessibility.PrintError(e.Source);
+            Log.Accessibility.PrintError(e.StackTrace);
+        }
+
+        private static string ConvertNumbersToWrittenNumbers(string text)
+        {
+            var sb = new StringBuilder();
+
+            var words = text.Split(' ');
+
+            for (int i = 0; i < words.Length; i++)
+            {
+                var curWord = words[i];
+                var remSb = new StringBuilder();
+
+                if (i > 0)
+                {
+                    sb.Append(" ");
+                }
+
+                if (curWord.Length > 1 && curWord[curWord.Length - 1] == '.')
+                {
+                    remSb.Append(curWord[curWord.Length - 1]);
+                    curWord = curWord.Substring(0, curWord.Length - 1);
+                }
+
+                if (int.TryParse(curWord, out int number))
+                {
+                    sb.Append(NumberToWordsConverter.Convert(number));
+                }
+                else
+                {
+                    sb.Append(curWord);
+                }
+
+                sb.Append(remSb);
+            }
+
+            return sb.ToString();
+        }
+
+        internal static void GoBackToHub()
+        {
+			Navigation.Clear();
+            SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
new file mode 100644
index 0000000..055d860
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
@@ -0,0 +1,280 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleAdventureScene : AccessibleScreen
+    {
+        private enum State { LOADING, CHOOSING_ADVENTURE, CHOOSING_ADVENTURE_MODE, CHOOSING_DECK, CHOOSING_OPPONENT, CHOOSING_ADVENTURER }; // Finding game is a loading state as well
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_curMenu;
+
+        private AdventureChooserTray m_adventureChooserTray;
+
+        private List<CustomDeckPage> m_customDeckPages;
+
+        private List<PracticeAIButton> m_practiceAIButtons;
+
+        private static AccessibleAdventureScene s_instance = new AccessibleAdventureScene();
+
+        internal static AccessibleAdventureScene Get()
+        {
+            return s_instance;
+        }
+        
+        public void OnAdventureSceneShown()
+        {
+            try
+            {
+                m_practiceAIButtons = null; // Cleanup in case of unlocked heroes
+                m_curState = State.LOADING;
+
+                GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubSceneLoaded(AdventureData.Adventuresubscene subscene)
+        {
+            AccessibilityUtils.LogDebug($"OnSubSceneLoaded({subscene})");
+
+            try
+            {
+                if (subscene == AdventureData.Adventuresubscene.CHOOSER)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                    SetupAndReadChooseAdventureMenu();
+                }
+                else if (subscene == AdventureData.Adventuresubscene.PRACTICE)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                    AccessibilityMgr.Output("Practice mode");
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupAndReadChooseAdventureMenu()
+        {
+            m_curState = State.CHOOSING_ADVENTURE;
+            m_curMenu = new AccessibleMenu("Choose an adventure", OnGoBackToHub);
+
+            m_curMenu.AddOption("Practice", OnChoosePracticeAdventure);
+            m_curMenu.AddOption("Book of Heroes", OnChooseBookOfHeroesAdventure);
+            m_curMenu.AddOption("Go back", OnGoBackToHub);
+
+            m_curMenu.StartReading();
+        }
+
+        private void OnChoosePracticeAdventure()
+        {
+            m_curState = State.CHOOSING_ADVENTURE_MODE;
+            m_curMenu = new AccessibleMenu("Choose your opponent's difficulty", SetupAndReadChooseAdventureMenu);
+
+            m_curMenu.AddOption("Normal", OnChooseNormalAdventure);
+            m_curMenu.AddOption("Expert", OnChooseExpertAdventure);
+
+            m_curMenu.StartReading();
+        }
+
+        private void OnChooseExpertAdventure()
+        {
+            if (!AdventureConfig.CanPlayMode(AdventureDbId.PRACTICE, AdventureModeDbId.EXPERT))
+            {
+                AccessibilityMgr.Output("You must beat all normal opponents to unlock expert");
+            }
+            else
+            {
+                ChooseAdventure(AdventureDbId.PRACTICE, AdventureModeDbId.EXPERT);
+            }
+        }
+
+        private void OnChooseBookOfHeroesAdventure()
+        {
+            ChooseAdventure(AdventureDbId.BOH, AdventureModeDbId.DUNGEON_CRAWL);
+        }
+
+        public void OnAdventureChooserTrayAwake(AdventureChooserTray adventureChooserTray)
+        {
+            AccessibilityUtils.LogDebug($"OnAdventureChooserTrayAwake({adventureChooserTray})");
+            m_adventureChooserTray = adventureChooserTray;
+        }
+
+        private void OnChooseNormalAdventure()
+        {
+            ChooseAdventure(AdventureDbId.PRACTICE, AdventureModeDbId.LINEAR);
+        }
+
+        private void ChooseAdventure(AdventureDbId adventure, AdventureModeDbId mode)
+        {
+            AdventureConfig.Get().SetSelectedAdventureMode(adventure, mode);
+            m_adventureChooserTray.m_ChooseButton.TriggerRelease();
+        }
+
+        private void OnGoBackToHub()
+        {
+            m_adventureChooserTray.m_BackButton.TriggerRelease();
+        }
+
+        public void OnPracticePickerTrayDisplayShown(List<PracticeAIButton> practiceAIButtons)
+        {
+            try
+            {
+                m_practiceAIButtons = practiceAIButtons;
+                SetupChooseOpponentMenu();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupChooseOpponentMenu()
+        {
+            m_curState = State.CHOOSING_OPPONENT;
+            m_curMenu = new AccessibleMenu("Choose your opponent", OnGoBackToChooseDeckMenuFromChooseOpponentMenu);
+
+            foreach (var btn in m_practiceAIButtons)
+            {
+                var text = btn.m_name.Text;
+                if (btn.m_questBang.activeInHierarchy)
+                {
+                    text = $"Undefeated {text}";
+                }
+                m_curMenu.AddOption(text, () => SelectOpponent(btn));
+            }
+
+            m_curMenu.StartReading();
+        }
+
+        private void SetupChooseDeckMenu()
+        {
+            m_curState = State.CHOOSING_DECK;
+            m_curMenu = new AccessibleMenu("Choose your deck", OnGoBackToChooseAdventureFromChooseDeckMenu);
+
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+            var selectedDeckId = deckPickerTrayDisplay.GetLastChosenDeckId();
+            var selectedDeckIdx = 0;
+
+            for (int i = 0, curIdx = 0; i < m_customDeckPages.Count; i++)
+            {
+                var page = m_customDeckPages[i];
+                var pageDecks = page.m_customDecks;
+
+                for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+                {
+                    var deck = pageDecks[j];
+                    var deckId = deck.GetDeckID();
+
+                    if (deckId == -1L)
+                    {
+                        break;
+                    }
+                    else if (deckId == selectedDeckId)
+                    {
+                        selectedDeckIdx = curIdx;
+                    }
+
+                    var deckPageIdx = i;
+
+                    m_curMenu.AddOption(deck.GetDeckNameText().Text, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+                }
+            }
+
+            m_curMenu.SetIndex(selectedDeckIdx);
+
+            m_curMenu.StartReading();
+        }
+
+        private void OnGoBackToChooseDeckMenuFromChooseOpponentMenu()
+        {
+            PracticePickerTrayDisplay.Get().m_backButton.TriggerRelease();
+            SetupChooseDeckMenu();
+        }
+
+        private void OnGoBackToChooseAdventureFromChooseDeckMenu()
+        {
+            DeckPickerTrayDisplay.Get().m_backButton.TriggerRelease();
+        }
+
+        private void SelectOpponent(PracticeAIButton btn)
+        {
+            btn.TriggerRelease();
+            PracticePickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState != State.LOADING)
+            {
+                m_curMenu.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            if (m_curState != State.LOADING)
+            {
+                return AccessibleSpeech.MENU_HELP(true);
+            }
+
+            return "";
+        }
+
+        public void OnDeckPickerTrayDisplayReady(List<CustomDeckPage> pages)
+        {
+            try
+            {
+                m_customDeckPages = pages;
+                m_practiceAIButtons = null; // Cleanup in case we go out of adventure and in again
+                SetupChooseDeckMenu();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SelectDeck(CollectionDeckBoxVisual deck)
+        {
+            deck.TriggerRelease();
+            DeckPickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        private void ShowDeckPage(int pageIndex)
+        {
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+
+            if (deckPickerTrayDisplay.GetCurrentPageIndex() != pageIndex)
+            {
+                deckPickerTrayDisplay.ShowPage(pageIndex);
+            }
+        }
+
+        private bool OnFindGameEvent(FindGameEventData eventData, object userData)
+        {
+            m_curState = State.LOADING;
+
+            return false;
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState != State.LOADING)
+            {
+                m_curMenu.StartReading();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
new file mode 100644
index 0000000..cdc2bbd
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
@@ -0,0 +1,26 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class AccessibleAttackSpellController
+    {
+        private PowerTaskList m_taskList;
+
+        public AccessibleAttackSpellController(PowerTaskList taskList)
+        {
+            m_taskList = taskList;
+        }
+
+        public void OnLaunchAttack()
+        {
+            try
+            {
+                AccessiblePlayDescriber.Get().OnAttack(m_taskList);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs
new file mode 100644
index 0000000..2f394b3
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCard.cs
@@ -0,0 +1,342 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCard : AccessibleItem
+    {
+        private readonly Card m_card;
+
+        internal AccessibleCard(Card card) : base()
+        {
+            m_card = card;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_card.GetEntity().IsHero())
+            {
+                return GetLinesForHero();
+            }
+            else if (m_card.GetEntity().IsHeroPower())
+            {
+                return GetLinesForHeroPower();
+            }
+            else if (m_card.GetEntity().IsWeapon())
+            {
+                return GetLinesForWeapon();
+            }
+            else
+            {
+                return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    lines.Add(effects);
+                }
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (!IsCostHidden())
+            {
+                lines.Add(GetCost());
+            }
+
+            var description = GetDescription();
+            if (description.Length > 0)
+            {
+                lines.Add(description);
+            }
+
+            return lines;
+        }
+
+        private bool IsCostHidden()
+        {
+            return AreStatsHidden() || m_card.GetEntity().HasTag(GAME_TAG.HIDE_COST);
+        }
+
+        private bool IsAttackHidden()
+        {
+            return AreStatsHidden() || m_card.GetEntity().HasTag(GAME_TAG.HIDE_ATTACK);
+        }
+
+        private bool IsHealthHidden()
+        {
+            return AreStatsHidden() || m_card.GetEntity().HasTag(GAME_TAG.HIDE_HEALTH);
+        }
+
+        private bool IsArmorHidden()
+        {
+            return AreStatsHidden();
+        }
+
+        private bool AreStatsHidden()
+        {
+            return m_card.GetEntity().HasTag(GAME_TAG.HIDE_STATS);
+        }
+
+        private List<string> GetLinesForWeapon()
+        {
+            var isWielded = m_card.GetZone()?.GetType() == typeof(ZoneWeapon);
+
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (!isWielded)
+            {
+                lines.Add(GetCost());
+            }
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                lines.Add(resources);
+            }
+
+            var description = GetDescription();
+            if (description.Length > 0)
+            {
+                lines.Add(description);
+            }
+
+            if (!isWielded)
+            {
+                lines.Add(GetType());
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            var zone = m_card.GetEntity().GetZone();
+            var isInPlayZone = zone == TAG_ZONE.PLAY;
+            var isInSecretZone = zone == TAG_ZONE.SECRET;
+            var shouldReadCost = !isInPlayZone && !isInSecretZone;
+
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (shouldReadCost)
+            {
+                lines.Add(GetCost());
+            }
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                if (isInPlayZone)
+                {
+                    var effects = GetEffects();
+                    if (effects.Length > 0)
+                    {
+                        resources = $"{resources} {effects}";
+                    }
+                }
+
+                lines.Add(resources);
+            }
+            else if (isInPlayZone)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    lines.Add(effects);
+                }
+            }
+
+            var description = GetDescription();
+            if (description.Length > 0)
+            {
+                lines.Add(description);
+            }
+
+            var race = GetRace(); // Handles spell school as well
+            if (race.Length > 0)
+            {
+                lines.Add(race);
+            }
+
+            if (!isInPlayZone)
+            {
+                lines.Add(GetType());
+            }
+
+            return lines;
+        }
+
+        private string GetDescription()
+        {
+            Entity entity = m_card.GetEntity();
+            return $"{entity.GetCardTextBuilder().BuildCardTextInHand(entity)}";
+        }
+
+        private string GetType()
+        {
+            var type = m_card.GetEntity().GetCardType();
+            return $"{type}";
+        }
+
+        private string GetCost()
+        {
+            int cost = m_card.GetEntity().GetCost();
+
+            if (IsCostHidden())
+            {
+                cost = 0;
+            }
+
+            return $"{cost} mana";
+        }
+
+        private string GetResources()
+        {
+            if (m_card.GetEntity().IsMinion()) {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                return $"{atk} {hp}";
+            } 
+            else if (m_card.GetEntity().IsWeapon()) {
+                var atk = m_card.GetEntity().GetATK();
+                var durability = m_card.GetEntity().GetCurrentDurability();
+                return $"{atk} {durability}";
+            } 
+            else if (m_card.GetEntity().IsHero())
+            {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                var armor = m_card.GetEntity().GetArmor();
+
+                var atkHidden = IsAttackHidden();
+                var hpHidden = IsHealthHidden();
+                var armorHidden = IsArmorHidden();
+
+                var showAtk = !atkHidden && atk > 0;
+                var showHp = !hpHidden;
+                var showArmor = !armorHidden && armor > 0;
+
+                // showAtk = true
+                if (showAtk && showHp && showArmor)
+                {
+                    return $"{atk} attack, {armor} armor and {hp} health";
+                }
+                else if (showAtk && showHp && !showArmor)
+                {
+                    return $"{atk} attack and {hp} health";
+                }
+                else if (showAtk && !showHp && showArmor)
+                {
+                    return $"{atk} attack and {armor} armor";
+                }
+                else if (showAtk && !showHp && !showArmor)
+                {
+                    return $"{atk} attack";
+                }
+                // showAtk = false
+                if (!showAtk && showHp && showArmor)
+                {
+                    return $"{armor} armor and {hp} health";
+                }
+                else if (!showAtk && showHp && !showArmor)
+                {
+                    return $"{hp} health";
+                }
+                else if (!showAtk && !showHp && showArmor)
+                {
+                    return $"{armor} armor";
+                }
+                else
+                {
+                    Log.Accessibility.PrintWarning("AccessibleCard.GetResources() on a Hero reached unknown state");
+                    return ""; // Should never happen
+                }
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        private string GetRace()
+        {
+            // Note: This handles spell school as well
+            return m_card.GetEntity().GetEntityDef().GetRaceText();
+        }
+
+        internal string GetName()
+        {
+            if (m_card.GetEntity().IsHero())
+            {
+                if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+                {
+                    return "Your Hero";
+                }
+                else
+                {
+                    return "Opponent's Hero";
+                }
+            }
+            else
+            {
+                return m_card.GetEntity().GetEntityDef().GetName();
+            }
+        }
+
+        private string GetEffects()
+        {
+            List<string> effects = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            if (entity.HasDivineShield()) effects.Add("divine shield");
+            if (entity.IsFrozen()) effects.Add("frozen");
+            if (entity.HasLifesteal()) effects.Add("lifesteal");
+            if (entity.HasDeathrattle()) effects.Add("deathrattle");
+            if (entity.IsPoisonous()) effects.Add("poisonous");
+            if (entity.IsStealthed()) effects.Add("stealth");
+            if (entity.HasTaunt()) effects.Add("taunt");
+            if (entity.IsImmune()) effects.Add("immune");
+            if (entity.IsDormant()) effects.Add("dormant");
+
+            if (effects.Count == 0)
+            {
+                return "";
+            }
+
+            return AccessibleSpeechUtils.HumanizeList(effects);
+        }
+
+        internal Card GetCard()
+        {
+            return m_card;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
new file mode 100644
index 0000000..5ea7e1e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
@@ -0,0 +1,222 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectibleCard : AccessibleItem
+    {
+        private readonly CollectibleCard m_card;
+
+        private bool m_readCount;
+
+        internal AccessibleCollectibleCard(CollectibleCard card, bool readCount=true) : base()
+        {
+            m_card = card;
+            m_readCount = readCount;
+        }
+
+        internal override List<string> GetLines()
+        {
+            switch (m_card.CardType)
+            {
+                case TAG_CARDTYPE.HERO:
+                    return GetLinesForHero();
+                case TAG_CARDTYPE.HERO_POWER:
+                    return GetLinesForHeroPower();
+                case TAG_CARDTYPE.WEAPON:
+                    return GetLinesForWeapon();
+                case TAG_CARDTYPE.ENCHANTMENT:
+                case TAG_CARDTYPE.MINION:
+                case TAG_CARDTYPE.SPELL:
+                    return GetLinesForNormalCard();
+                default:
+                    Log.Accessibility.PrintError($"AccessibleCollectibleCard: Found unhandled CardType {m_card.CardType}");
+                    return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                lines.Add(resources);
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+
+            var description = GetDescription();
+            if (description.Length > 0)
+            {
+                lines.Add(description);
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForWeapon()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                lines.Add(resources);
+            }
+
+            var description = GetDescription();
+            if (description.Length > 0)
+            {
+                lines.Add(description);
+            }
+
+            lines.Add(GetType());
+
+            var cardCount = GetCardCount();
+            if (cardCount.Length > 0)
+            {
+                lines.Add(cardCount);
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                lines.Add(resources);
+            }
+
+            var description = GetDescription();
+            if (description.Length > 0)
+            {
+                lines.Add(description);
+            }
+
+            var race = GetRace(); // Handles spell school as well
+            if (race.Length > 0)
+            {
+                lines.Add(race);
+            }
+
+            lines.Add(GetType());
+
+            var cardCount = GetCardCount();
+            if (cardCount.Length > 0)
+            {
+                lines.Add(cardCount);
+            }
+
+            return lines;
+        }
+
+        private string GetDescription()
+        {
+            return m_card.CardInHandText;
+        }
+
+        private string GetType()
+        {
+            return $"{m_card.CardType}";
+        }
+
+        private string GetCost()
+        {
+            int cost = m_card.ManaCost;
+            return $"{cost} mana";
+        }
+
+        private string GetCardCount()
+        {
+            if (!m_readCount)
+            {
+                return "";
+            }
+
+            var numCopies = m_card.OwnedCount;
+
+            if (numCopies <= 1)
+            {
+                return "";
+            }
+
+            return $"{numCopies} copies";
+        }
+
+        private string GetResources()
+        {
+            if (m_card.CardType == TAG_CARDTYPE.MINION) {
+                return $"{m_card.Attack} {m_card.Health}";
+            } 
+            else if (m_card.CardType == TAG_CARDTYPE.WEAPON) {
+                return $"{m_card.Attack} {m_card.GetEntityDef().GetDurability()}";
+            } 
+            else if (m_card.CardType == TAG_CARDTYPE.HERO)
+            {
+                var atk = m_card.Attack;
+                var hp = m_card.Health;
+                var armor = m_card.GetEntityDef().GetArmor();
+
+                if (atk > 0)
+                {
+                    if (armor > 0)
+                    {
+                        return $"{atk} attack, {armor} armor and {hp} health";
+                    }
+                    else
+                    {
+                        return $"{atk} attack and {hp} health";
+                    }
+                } 
+                else
+                {
+                    if (armor > 0)
+                    {
+                        return $"{armor} armor and {hp} health";
+                    }
+                    else
+                    {
+                        return $"{hp} health";
+                    }
+                }
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        private string GetRace()
+        {
+            // Note: This handles spell school as well
+            return m_card.GetEntityDef().GetRaceText();
+        }
+
+        internal string GetName()
+        {
+            if (m_card.PremiumType != TAG_PREMIUM.NORMAL)
+            {
+                return $"{m_card.Name} - {m_card.PremiumType.ToString().ToLower()} edition";
+            }
+
+            return m_card.Name;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectionManager.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectionManager.cs
new file mode 100644
index 0000000..57a8fb9
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleCollectionManager.cs
@@ -0,0 +1,290 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    // WIP
+
+    class AccessibleCollectionManager : AccessibleScreen
+    {
+        private static AccessibleCollectionManager s_instance = new AccessibleCollectionManager();
+
+        //private PegUIElement m_continue;
+
+        internal static AccessibleCollectionManager Get() {
+            return s_instance;
+        }
+
+        public string GetHelp()
+        {
+            return "";
+        }
+
+        internal void OnCollectionManagerOpened()
+        {
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerOpened");
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        public void HandleInput()
+        {
+            // TODO: If mode etc
+            HandleManaFiltersInput();
+            if (!HandleClassTabsInput())
+            {
+                HandlePageInput(); // Protect against tabs
+            }
+            HandleBackInput();
+            HandleDeckInput();
+        }
+
+        public void OnGainedFocus()
+        {
+            // TODO/FIXME once this is properly done
+            AccessibilityMgr.Output("My collection");
+        }
+
+        private void HandleDeckInput()
+        {
+            var collectionDeckTray = CollectionDeckTray.Get();
+
+            if (collectionDeckTray == null)
+            {
+                return;
+            }
+
+            var decksContent = collectionDeckTray.GetDecksContent();
+            var newDeckButton = decksContent.m_newDeckButton;
+            bool canCreateNewDeck = newDeckButton.IsEnabled() && newDeckButton.IsUsable();
+
+            if (AccessibleKey.SEE_DECKS.IsPressed())
+            {
+                var traySections = decksContent.m_traySections;
+
+                AccessibilityUtils.LogDebug($"# traySections = {traySections.Count}");
+                foreach(var section in traySections)
+                {
+                    AccessibilityUtils.LogDebug($"{section.m_deckBox.GetDeckNameText().Text}");
+                }
+            }
+            else if (AccessibleKey.CREATE_DECK.IsPressed() && canCreateNewDeck)
+            {
+                newDeckButton.TriggerRelease();
+            }
+            else if (AccessibleKey.DELETE_DECK.IsPressed())
+            {
+                AccessibilityUtils.LogDebug("DELETE_DECK PRESSED");
+                var traySections = decksContent.m_traySections;
+                traySections[0].m_deckBox.m_deleteButton.TriggerRelease();
+            }
+            else if (AccessibleKey.EDIT_DECK.IsPressed())
+            {
+                AccessibilityUtils.LogDebug("EDIT_DECK PRESSED");
+                var traySections = decksContent.m_traySections;
+                AccessibleInputMgr.Click(traySections[0].m_deckBox.transform);
+                //traySections[0].m_deckBox.TriggerRelease();
+            }
+        }
+
+        private void HandleBackInput()
+        {
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                Navigation.GoBack();
+            }
+        }
+
+        private void HandlePageInput()
+        {
+            if (m_curPageCards != null)
+            {
+                if (!m_curPageCards.HandleAccessibleInput())
+                {
+                    if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+                    {
+                        m_justPressedLeft = true;
+                        GetCollectionPageManager().m_pageLeftClickableRegion.TriggerRelease();
+                    }
+                    else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+                    {
+                        GetCollectionPageManager().m_pageRightClickableRegion.TriggerRelease();
+                    }
+                }
+                else
+                {
+                    m_justPressedLeft = false;
+                }
+            }
+        }
+
+        private void HandleManaFiltersInput()
+        {
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                int pressedTab = numKeyPressed.Value;
+
+                if (pressedTab == 10)
+                {
+                    pressedTab = 0;
+                }
+                else if (pressedTab > ManaFilterTabManager.NUM_MANA_FILTERS)
+                {
+                    return;
+                }
+
+                var tabs = GetManaFilterTabManager().m_tabs;
+
+                if (pressedTab >= tabs.Count)
+                {
+                    return;
+                }
+
+                m_justPressedLeft = false;
+                tabs[pressedTab].TriggerRelease();
+            }
+        }
+
+        private bool HandleClassTabsInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(1);
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(-1);
+                return true;
+            }
+
+            return false;
+        }
+
+        private void FlipToNextClass(int inc)
+        {
+            m_justPressedLeft = false;
+
+            var classTabs = GetCollectionPageManager().m_classTabs.FindAll(t => t.IsVisible()); // Show only visible tabs due to filters
+
+            var curClassTab = 0;
+            for (int i = 0; i < classTabs.Count; i++)
+            {
+                if (classTabs[i].IsSelected())
+                {
+                    curClassTab = i;
+                    break;
+                }
+            }
+
+            int targetClassTab = curClassTab + inc;
+
+            if (targetClassTab < 0)
+            {
+                targetClassTab = classTabs.Count - 1;
+            }
+            else if (targetClassTab >= classTabs.Count)
+            {
+                targetClassTab = 0;
+            }
+
+            classTabs[targetClassTab].TriggerRelease();
+        }
+
+        private CollectionManagerDisplay GetCollectionManagerDisplay()
+        {
+            return CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        }
+
+        private ManaFilterTabManager GetManaFilterTabManager()
+        {
+            return GetCollectionManagerDisplay().m_manaTabManager;
+        }
+
+        private CollectionPageManager GetCollectionPageManager()
+        {
+            return GetCollectionManagerDisplay().m_pageManager;
+        }
+
+        private ClassFilterHeaderButton GetClassFilterHeaderButton()
+        {
+            return GetCollectionPageManager().m_classFilterHeader;
+        }
+
+        private TAG_CLASS m_curClassContext;
+        private AccessibleListOfItems<AccessibleCollectibleCard> m_curPageCards;
+        private bool m_justPressedLeft;
+
+        internal void OnPageChanged(List<CollectibleCard> cardsToDisplay)
+        {
+            AccessibilityUtils.LogDebug("CM OnPageChanged");
+            AccessibilityUtils.LogDebug($"CM cardsToDisplay {cardsToDisplay.Count}");
+
+            foreach (var card in cardsToDisplay)
+            {
+                AccessibilityUtils.LogDebug($"CM -- {card.Name}");
+            }
+
+            var classContext = GetCollectionPageManager().m_currentClassContext;
+
+            AccessibilityUtils.LogDebug($"CM classContext={classContext} | m_curClassContext={m_curClassContext}");
+            if (m_curClassContext != classContext)
+            {
+                AccessibilityMgr.Output(AccessibleSpeechUtils.StringifyClass(classContext));
+            }
+
+            var accessibleCards = new List<AccessibleCollectibleCard>(cardsToDisplay.Count);
+            cardsToDisplay.ForEach(c => accessibleCards.Add(new AccessibleCollectibleCard(c)));
+
+            var curPageCards = new AccessibleListOfItems<AccessibleCollectibleCard>(accessibleCards);
+
+            if (m_curPageCards == null || !SameCards(curPageCards.Items, m_curPageCards.Items))
+            {
+                if (m_justPressedLeft)
+                {
+                    curPageCards.StartReadingReverse();
+                }
+                else
+                {
+                    curPageCards.StartReading();
+                }
+            }
+
+            m_curPageCards = curPageCards;
+            m_curClassContext = classContext;
+            m_justPressedLeft = false;
+        }
+
+        private bool SameCards(List<AccessibleCollectibleCard> l1, List<AccessibleCollectibleCard> l2)
+        {
+            if (l1.Count != l2.Count)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < l1.Count; i++)
+            {
+                if (!l1[i].GetName().Equals(l2[i].GetName()))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        internal void OnCollectionManagerClosed()
+        {
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerClosed");
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        internal void OnCollectibleDisplayReady()
+        {
+            AccessibilityUtils.LogDebug("CM OnCollectibleDisplayReady");
+            // CollectionManager.Get().GetCollectibleDisplay().
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
new file mode 100644
index 0000000..74d5ecb
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
@@ -0,0 +1,40 @@
+﻿using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleEndGameScreen : AccessibleScreen
+    {
+        private static AccessibleEndGameScreen s_instance = new AccessibleEndGameScreen();
+
+        private PegUIElement m_continue;
+
+        internal static AccessibleEndGameScreen Get()
+        {
+            return s_instance;
+        }
+
+        internal void OnShown(PegUIElement hitbox)
+        {
+            m_continue = hitbox;
+
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_continue.TriggerRelease();
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
new file mode 100644
index 0000000..42b4eea
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
@@ -0,0 +1,2093 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleGameplay : AccessibleScreen
+    {
+        private enum AccessibleGamePhase
+        {
+            WAITING_FOR_GAME_TO_START,
+            MULLIGAN,
+            WAITING_FOR_OPPONENT_MULLIGAN,
+            PLAYING,
+            GAME_OVER
+        }
+
+        private enum AccessibleGameState
+        {
+            UNKNOWN,
+            WAITING,
+            OPPONENT_TURN,
+            MAIN_OPTION_MODE,
+            SUB_OPTION_MODE,
+            TARGET_MODE,
+            CHOICE_MODE,
+            SUMMONING_MINION,
+            PLAYING_CARD,
+            CONFIRMING_END_TURN,
+            BROWSING_HISTORY,
+            ALL_MINIONS_TO_FACE
+        }
+
+        private static AccessibleGameplay s_instance = new AccessibleGameplay();
+
+        internal static AccessibleGameplay Get()
+        {
+            return s_instance;
+        }
+
+        private AccessibleGamePhase m_curPhase;
+
+        private AccessibleGameState m_curState;
+
+        private AccessibleGameState m_prevState;
+
+        private GameState.ResponseMode m_curResponseMode;
+        private GameState.ResponseMode m_prevResponseMode;
+
+        private Zone m_curZone;
+
+        private AccessibleCard m_cardBeingRead;
+
+        private Card m_heldCard;
+
+        private bool m_playerTurn;
+
+        private bool m_confirmingEndTurn;
+
+        private bool m_sendingAllMinionsToFace;
+        private Card m_curFaceAttacker;
+
+        private float m_nextAction = 0; // Needed to circumvent a lot of frame-related issues that would arise otherwise
+
+        // Choice mode
+        private AccessibleListOfItems<AccessibleCard> m_accessibleChoiceCards;
+
+        // Mulligan
+        private AccessibleListOfItems<AccessibleCard> m_accessibleMulliganCards;
+        private Dictionary<AccessibleCard, bool> m_mulliganMarkedForReplacement;
+        private NormalButton m_mulliganConfirmButton;
+        private bool m_waitingForMulliganReplacementCards;
+
+        private static bool m_justReconnected;
+
+        public void OnTurnStart()
+        {
+            try
+            {
+                AccessiblePowerTaskListDescriber.OnTurnStart();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnCoinResult(bool friendlyPlayerGoesFirst)
+        {
+            if (friendlyPlayerGoesFirst)
+            {
+                AccessibilityMgr.Output("You go first");
+            }
+            else
+            {
+                AccessibilityMgr.Output("Your opponent goes first");
+            }
+        }
+
+        public void OnStartingHand(List<Card> cards)
+        {
+            AccessibilityMgr.Output($"You start with {cards.Count} cards");
+        }
+
+        public void EndMulligan()
+        {
+            try
+            {
+                if (m_accessibleMulliganCards != null)
+                {
+                    var originalCards = new HashSet<Card>(m_accessibleMulliganCards.Count);
+                    m_accessibleMulliganCards.Items.ForEach(c => originalCards.Add(c.GetCard()));
+                    var cardsAfterMulligan = GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCards();
+                    var newCards = new List<Card>();
+                    var droppedCards = new List<Card>();
+
+                    foreach (var card in originalCards)
+                    {
+                        if (!cardsAfterMulligan.Contains(card))
+                        {
+                            droppedCards.Add(card);
+                        }
+                    }
+
+                    foreach (var card in cardsAfterMulligan)
+                    {
+                        if (!originalCards.Contains(card) && !IsCoinCard(card.GetEntity()))
+                        {
+                            newCards.Add(card);
+                        }
+                    }
+
+                    if (droppedCards.Count > 0)
+                    {
+                        var droppedNames = AccessibleSpeechUtils.GetNames(droppedCards);
+                        var newNames = AccessibleSpeechUtils.GetNames(newCards);
+
+                        AccessibilityMgr.Output($"You drew {newNames}");
+                    }
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            m_accessibleMulliganCards = null;
+            m_waitingForMulliganReplacementCards = false;
+
+            OnGameStart();
+        }
+
+        private bool IsCoinCard(Entity entity)
+        {
+            return entity.GetCardId() == CoinManager.Get()?.GetFavoriteCoinCardId();
+        }
+
+        public void OnMulliganCardsDealt(List<Card> cards)
+        {
+        }
+
+        public void OnGameplayScreenStart()
+        {
+            Reset();
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        private void Reset()
+        {
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            m_curState = AccessibleGameState.UNKNOWN;
+            m_prevState = AccessibleGameState.UNKNOWN;
+            m_prevResponseMode = GameState.ResponseMode.NONE;
+            m_curZone = null;
+            m_cardBeingRead = null;
+            m_confirmingEndTurn = false;
+            m_sendingAllMinionsToFace = false;
+            m_playerTurn = false;
+            m_heldCard = null;
+            m_zoneSelectedListeners.Clear();
+            m_cardSelectedListeners.Clear();
+            m_summoningMinionListeners.Clear();
+            m_stopHidingMouse = false;
+            m_waitingForMulliganReplacementCards = false;
+            AccessibleHistoryMgr.Get().Reset();
+        }
+
+        public void OnCoinCard()
+        {
+            AccessibilityMgr.Output("You get The Coin");
+        }
+
+        public void WaitingForOpponentToFinishMulligan()
+        {
+            AccessibilityMgr.Output("Waiting for opponent");
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN;
+        }
+
+        public void OnDrawCard(Card card)
+        {
+        }
+
+        private void SetCardBeingRead(Card card, bool forceZoneRead)
+        {
+            m_cardBeingRead = new AccessibleCard(card);
+            var prevZone = m_curZone;
+            m_curZone = card.GetZone();
+            ReadZoneChangeIfNecessary(card, prevZone, m_curZone, forceZoneRead);
+        }
+
+        private void ReadZoneChangeIfNecessary(Card card, Zone fromZone, Zone toZone, bool forceZoneRead)
+        {
+            if (fromZone == toZone && !forceZoneRead)
+            {
+                return;
+            }
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            if (card.GetEntity() == player.GetHeroPower())
+            {
+                AccessibilityMgr.Output("Hero Power");
+            }
+            else if (card.GetEntity() == opponent.GetHeroPower())
+            {
+                AccessibilityMgr.Output("Opponent's Hero Power");
+            }
+            else if (card == player.GetWeaponCard())
+            {
+                AccessibilityMgr.Output("Weapon");
+            }
+            else if (card == opponent.GetWeaponCard())
+            {
+                AccessibilityMgr.Output("Opponent's weapon");
+            }
+            else if (toZone == player.GetHandZone())
+            {
+                AccessibilityMgr.Output("Hand");
+            }
+            else if (toZone == opponent.GetHandZone())
+            {
+                AccessibilityMgr.Output("Opponent's hand"); // Not needed atm
+            }
+            else if (toZone == player.GetBattlefieldZone())
+            {
+                AccessibilityMgr.Output("Minions");
+            }
+            else if (toZone == opponent.GetBattlefieldZone())
+            {
+                AccessibilityMgr.Output("Opponent's minions");
+            }
+            else if (toZone == player.GetSecretZone())
+            {
+                AccessibilityMgr.Output("Secrets");
+            }
+            else if (toZone == opponent.GetSecretZone())
+            {
+                AccessibilityMgr.Output("Opponent's secrets"); // Not needed atm
+            }
+        }
+
+        public void HandleInput()
+        {
+            if (GameState.Get() == null || InputManager.Get() == null)
+            {
+                // Game hasn't even started yet
+                return;
+            }
+
+            if (GameState.Get().IsMulliganPhase())
+            {
+                m_curPhase = AccessibleGamePhase.MULLIGAN;
+            }
+            else if (GameState.Get().IsGameOver())
+            {
+                m_curPhase = AccessibleGamePhase.GAME_OVER;
+            }
+            else if (GameState.Get().IsGameCreated())
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+            }
+            else
+            {
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                HandleTooltipReading();
+            }
+
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.PLAYING:
+                    HandleInGameInput();
+                    break;
+                case AccessibleGamePhase.MULLIGAN:
+                    HandleMulliganInput();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private void HandleMulliganInput()
+        {
+            if (m_accessibleMulliganCards == null)
+            {
+                return; // yield
+            }
+
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+            }
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                var focusedCard = m_accessibleMulliganCards.GetItemBeingRead();
+                AccessibleInputMgr.MoveMouseTo(focusedCard.GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+                m_mulliganMarkedForReplacement[focusedCard] = !m_mulliganMarkedForReplacement[focusedCard];
+
+                if (m_mulliganMarkedForReplacement[focusedCard])
+                {
+                    AccessibilityMgr.Output("Will be replaced");
+                }
+                else
+                {
+                    AccessibilityMgr.Output("Will not be replaced");
+                }
+            }
+            else if (AccessibleKey.CONFIRM_MULLIGAN.IsPressed())
+            {
+                m_mulliganConfirmButton.TriggerRelease();
+
+                // Prevent flicker while the game starts and new cards are drawn
+                m_waitingForMulliganReplacementCards = true;
+                HideMouse();
+            }
+            else if (!m_waitingForMulliganReplacementCards)
+            {
+                m_accessibleMulliganCards.HandleAccessibleInput();
+                MoveMouseToCard(m_accessibleMulliganCards.GetItemBeingRead().GetCard());
+            }
+        }
+
+        private void HandleInGameInput()
+        {
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    AccessibilityMgr.Output("Your turn");
+                }
+                else
+                {
+                    AccessibilityMgr.Output("Opponent's turn");
+                }
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+                AccessiblePowerTaskListDescriber.OnReconnected();
+            }
+
+            UpdateState();
+
+            if (m_curState == AccessibleGameState.ALL_MINIONS_TO_FACE)
+            {
+                HandleAllMinionsToFace();
+                return;
+            }
+
+            UpdateMousePosition();
+
+            if (m_curState == AccessibleGameState.CONFIRMING_END_TURN)
+            {
+                if (AccessibleKey.CONFIRM.IsPressedDown() || AccessibleKey.END_TURN.IsPressedDown())
+                {
+                    EndTurn();
+                    return;
+                }
+                else if (Input.anyKeyDown)
+                {
+                    m_confirmingEndTurn = false;
+                }
+            }
+
+            switch(m_curState)
+            {
+                case AccessibleGameState.WAITING:
+                case AccessibleGameState.UNKNOWN:
+                case AccessibleGameState.OPPONENT_TURN:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleZoneInput();
+                    HandleValidOptionsSelectionInput();
+                    HandleZoneSelection();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleMainOptionMode();
+                    HandleEndTurnInput();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    HandleSubOptionMode();
+                    return;
+                case AccessibleGameState.CHOICE_MODE:
+                    HandleChoiceMode();
+                    return;
+                case AccessibleGameState.TARGET_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleTargetMode();
+                    return;
+                case AccessibleGameState.SUMMONING_MINION:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleSummoningMinion();
+                    return;
+                case AccessibleGameState.PLAYING_CARD:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandlePlayingCard();
+                    return;
+                case AccessibleGameState.BROWSING_HISTORY:
+                    HandleHistoryInput();
+                    return;
+                default:
+                    return;
+            }
+        }
+
+        private void HandleTooltipReading()
+        {
+            foreach (var tooltip in TooltipPanelManager.Get()?.GetTooltipPanels())
+            {
+                AccessibilityMgr.Output($"{tooltip.m_name.Text}: {tooltip.m_body.Text}");
+            }
+
+            foreach (var tooltip in TutorialKeywordManager.Get()?.GetPanels())
+            {
+                AccessibilityMgr.Output($"{tooltip.m_name.Text}: {tooltip.m_body.Text}");
+            }
+        }
+
+        private void HandleAllMinionsToFace()
+        {
+            if (Time.time < m_nextAction)
+            {
+                return;
+            }
+
+            if (m_curFaceAttacker != null)
+            {
+                ClickCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+                m_curFaceAttacker = null;
+                SetNextAction();
+            }
+            else
+            {
+                List<Card> remainingAttackers = GetValidFaceAttackers();
+
+                if (remainingAttackers.Count > 0)
+                {
+                    m_curFaceAttacker = remainingAttackers[0];
+                    ClickCard(m_curFaceAttacker);
+                    SetNextAction();
+                }
+                else
+                {
+                    m_sendingAllMinionsToFace = false;
+                }
+            }
+        }
+
+        private void SetNextAction()
+        {
+            m_nextAction = Time.time + 1.0f;
+        }
+
+        private void ClickCard(Card card)
+        {
+            MoveMouseToCard(card);
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        private void UpdateMousePosition()
+        {
+            if (m_heldCard != null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead != null)
+            {
+                MoveMouseToCard(m_cardBeingRead.GetCard());
+            }
+            else
+            {
+                HideMouse();
+            }
+        }
+
+        private void HideMouse()
+        {
+            if (!m_stopHidingMouse)
+            {
+                AccessibleInputMgr.HideMouse();
+            }
+        }
+
+        private int m_summonPos;
+
+        private void HandleSummoningMinion()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    AccessibilityMgr.Output("Summon?");
+                    OnSummoningMinion(m_heldCard);
+                }
+
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    m_summonPos = playerMinions.GetLastPos();
+                    QuerySummonPosition(0);
+                }
+
+                HandleSummoningPositionInput();
+
+                if (m_summonPos == playerMinions.GetLastPos())
+                {
+                    MoveMouseToRightOfZone(playerMinions);
+                }
+                else if (m_summonPos == 1)
+                {
+                    MoveMouseToLeftOfZone(playerMinions);
+                }
+                else
+                {
+                    var prevMinion = playerMinions.GetCardAtPos(m_summonPos - 1);
+                    var nextMinion = playerMinions.GetCardAtPos(m_summonPos);
+                    var pos = prevMinion.transform.position + (nextMinion.transform.position - prevMinion.transform.position) / 2;
+                    AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+                }
+            }
+
+            HandleConfirmOrCancel();
+        }
+
+        private void HandleSummoningPositionInput()
+        {
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                QuerySummonPosition(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                QuerySummonPosition(1);
+            }
+        }
+
+        private void QuerySummonPosition(int inc)
+        {
+            var prevSummonPos = m_summonPos;
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var lastPos = playerMinions.GetLastPos();
+
+            m_summonPos += inc;
+
+            if (m_summonPos > lastPos)
+            {
+                m_summonPos = lastPos;
+            }
+            else if (m_summonPos < 1)
+            {
+                m_summonPos = 1;
+            }
+
+            if (inc != 0 && prevSummonPos == m_summonPos)
+            {
+                return;
+            }
+
+            if (m_summonPos == lastPos)
+            {
+                AccessibilityMgr.Output("Summon at the right?");
+                OnSummoningMinion(m_heldCard);
+            }
+            else if (m_summonPos == 1)
+            {
+                AccessibilityMgr.Output("Summon at the left?");
+                OnSummoningMinion(m_heldCard);
+            }
+            else
+            {
+                var prevMinion = playerMinions.GetCardAtPos(m_summonPos - 1);
+                var nextMinion = playerMinions.GetCardAtPos(m_summonPos);
+                AccessibilityMgr.Output($"Summon between {prevMinion.GetEntity().GetName()} and {nextMinion.GetEntity().GetName()}?");
+                OnSummoningMinion(m_heldCard);
+            }
+        }
+
+        private void HandlePlayingCard()
+        { 
+            if (AccessibleUnityInput.Get().GetMousePosition().y < AccessibleInputMgr.GetMousePosition(GameState.Get().GetFriendlySidePlayer().GetHeroCard()).y)
+            {
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                HandleTargetMode();
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.PLAYING_CARD && !RequiresTarget(m_heldCard)) // If a target is required, "choose a target" will already indicate we're using it
+                {
+                    QueryPlayCard();
+                }
+
+                HandleConfirmOrCancel();
+            }
+        }
+
+        private bool RequiresTarget(Card heldCard)
+        {
+            return GameState.Get().EntityHasTargets(heldCard.GetEntity());
+        }
+
+        private void QueryPlayCard()
+        {
+            AccessibilityMgr.Output("Play card?");
+        }
+
+        private void HandleConfirmOrCancel(bool targetRequired=false)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (!targetRequired || m_cardBeingRead != null)
+                {
+                    AccessibleInputMgr.ClickLeftMouseButton();
+                }
+            }
+            else if (AccessibleKey.BACK.IsPressed())
+            {
+                CancelOption();
+            }
+        }
+
+        private void HandleEndTurnInput()
+        {
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                return;
+            }
+
+            if (AccessibleKey.FORCE_END_TURN.IsPressedDown())
+            {
+                EndTurn();
+            }
+
+            if (AccessibleKey.END_TURN.IsPressedDown())
+            {
+                if (EndTurnButton.Get().HasNoMorePlays())
+                {
+                    EndTurn();
+                }
+                else
+                {
+                    AccessibilityMgr.Output("You still have valid plays. Are you sure?");
+                    StopReadingCard();
+                    m_confirmingEndTurn = true;
+                }
+            }
+        }
+
+        private void HandleMainOptionMode()
+        {
+            if (AccessibleKey.SEND_ALL_MINIONS_TO_FACE.IsPressed())
+            {
+                SendAllMinionsToFace();
+                return;
+            }
+
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                ClickCard();
+            }
+        }
+
+        private void SendAllMinionsToFace()
+        {
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output("You don't have any summoned minions");
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeAttacked())
+            {
+                AccessibilityMgr.Output("Your opponent's Hero can't be attacked");
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeTargetedByOpponents())
+            {
+                AccessibilityMgr.Output("Your opponent's Hero can't be targeted");
+                return;
+            }
+
+            List<Card> validAttackers = GetValidFaceAttackers();
+
+            if (validAttackers.Count == 0)
+            {
+                AccessibilityMgr.Output("None of your minions can attack your opponent's Hero");
+            }
+            else
+            {
+                m_sendingAllMinionsToFace = true;
+            }
+        }
+
+        public void OnReconnected()
+        {
+            AccessibilityMgr.InterruptTexts();
+            AccessibilityMgr.Output("Reconnected");
+
+            m_justReconnected = true;
+        }
+
+        private List<Card> GetValidFaceAttackers()
+        {
+            List<Card> ret = new List<Card>();
+            List<Entity> faceTargetters = GetOptionsWithTarget(GameState.Get().GetOpposingSidePlayer().GetHero());
+
+            foreach (var entity in faceTargetters)
+            {
+                if (entity.GetCard()?.GetZone() == GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone())
+                {
+                    ret.Add(entity.GetCard());
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Entity> GetOptionsWithTarget(Entity target)
+        {
+            List<Entity> ret = new List<Entity>();
+            Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+
+            if (optionsPacket == null) {
+                return ret;
+            }
+
+            for (int i = 0; i < optionsPacket.List.Count; i++)
+            {
+                Network.Options.Option option = optionsPacket.List[i];
+                if (option.Type == Network.Options.Option.OptionType.POWER)
+                {
+                    if (option.Main.IsValidTarget(target.GetEntityId()))
+                    {
+                        ret.Add(GameState.Get().GetEntity(option.Main.ID));
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private void EndTurn()
+        {
+            InputManager.Get().DoEndTurnButton();
+            StopReadingCard();
+        }
+
+        private void HandleSubOptionMode()
+        {
+            if (m_accessibleChoiceCards == null)
+            {
+                return; // yield
+            }
+
+            m_cardBeingRead = m_accessibleChoiceCards.GetItemBeingRead();
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                AccessibleInputMgr.MoveMouseTo(m_accessibleChoiceCards.GetItemBeingRead().GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+            }
+            else
+            {
+                m_accessibleChoiceCards.HandleAccessibleInput();
+            }
+        }
+
+        private void HandleChoiceMode()
+        {
+            if (m_accessibleChoiceCards == null)
+            {
+                return; // yield
+            }
+
+            m_cardBeingRead = m_accessibleChoiceCards.GetItemBeingRead();
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                AccessibleInputMgr.MoveMouseTo(m_accessibleChoiceCards.GetItemBeingRead().GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+            }
+            else
+            {
+                m_accessibleChoiceCards.HandleAccessibleInput();
+            }
+        }
+
+        private void HandleTargetMode()
+        {
+            //if (m_prevState != AccessibleGameState.TARGET_MODE) // Was broken due to play
+            if (m_prevResponseMode != m_curResponseMode)
+            {
+                AccessibilityMgr.Output("Choose a target");
+
+                if (m_cardBeingRead != null && m_cardBeingRead.GetCard().GetZone() == GameState.Get().GetFriendlySidePlayer().GetHandZone())
+                {
+                    StopReadingCard(false);
+                }
+            }
+
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection(true);
+
+            HandleConfirmOrCancel(true);
+        }
+
+        private void UpdateState()
+        {
+            UpdateCardBeingReadState();
+
+            m_heldCard = InputManager.Get().GetHeldCard();
+            m_playerTurn = GameState.Get().IsFriendlySidePlayerTurn();
+
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                m_confirmingEndTurn = false;
+            }
+
+            m_prevState = m_curState;
+            m_prevResponseMode = m_curResponseMode;
+            m_curResponseMode = GameState.Get().GetResponseMode();
+
+            // Proper states
+            if (!m_playerTurn)
+            {
+                m_curState = AccessibleGameState.OPPONENT_TURN;
+            } 
+            else if (m_sendingAllMinionsToFace)
+            {
+                m_curState = AccessibleGameState.ALL_MINIONS_TO_FACE;
+            }
+            else if (m_confirmingEndTurn)
+            {
+                m_curState = AccessibleGameState.CONFIRMING_END_TURN;
+            }
+            else if (AccessibleHistoryMgr.Get().IsReadingHistory())
+            {
+                m_curState = AccessibleGameState.BROWSING_HISTORY;
+            }
+            else if (m_heldCard != null)
+            {
+                if (m_heldCard.GetEntity().IsMinion())
+                {
+                    m_curState = AccessibleGameState.SUMMONING_MINION;
+                }
+                else if (GameState.Get().IsInMainOptionMode())
+                {
+                    m_curState = AccessibleGameState.PLAYING_CARD;
+                }
+            }
+            else if (GameState.Get().IsInMainOptionMode())
+            {
+                m_curState = AccessibleGameState.MAIN_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                m_curState = AccessibleGameState.SUB_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                m_curState = AccessibleGameState.CHOICE_MODE;
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                m_curState = AccessibleGameState.TARGET_MODE;
+            } 
+            else
+            {
+                // Normally happens in between turns (i.e. after button press but before response) due to network time
+                m_curState = AccessibleGameState.UNKNOWN;
+            }
+
+            if (m_curState != AccessibleGameState.BROWSING_HISTORY)
+            {
+                // Reset history in case turn ends while we're reading history or something
+                AccessibleHistoryMgr.Get().StopReadingHistory();
+            }
+        }
+
+        private void UpdateCardBeingReadState()
+        {
+            if (m_cardBeingRead == null || m_curZone == null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead.GetCard().GetZone() != m_curZone)
+            {
+                StopReadingCard();
+            }
+        }
+
+        private void StopReadingCard(bool hideMouse=true)
+        {
+            m_cardBeingRead = null;
+            m_curZone = null;
+
+            if (hideMouse)
+            {
+                HideMouse();
+            }
+        }
+
+        private void HandleZoneSelection(bool minionsAndHeroesOnly = false)
+        {
+            if (AccessibleKey.SEE_PLAYER_HAND.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerHand();
+            }
+            else if (AccessibleKey.SEE_PLAYER_SECRETS.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerSecrets();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_SECRETS.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeeOpponentSecrets();
+            }
+            else if (AccessibleKey.SEE_PLAYER_MINIONS.IsPressed())
+            {
+                SeePlayerMinions();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MINIONS.IsPressed())
+            {
+                SeeOpponentMinions();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HERO.IsPressed())
+            {
+                SeeOpponentHero();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HERO.IsPressed())
+            {
+                SeePlayerHero();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HERO_POWER.IsPressed())
+            {
+                SeePlayerHeroPower();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HERO_POWER.IsPressed())
+            {
+                SeeOpponentHeroPower();
+            }
+            else if (AccessibleKey.SEE_PLAYER_WEAPON.IsPressed())
+            {
+                SeePlayerWeapon();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_WEAPON.IsPressed())
+            {
+                SeeOpponentWeapon();
+            }
+        }
+
+        private void HandleHistoryInput()
+        {
+            AccessibleHistoryMgr.Get().HandleAccessibleInput();
+        }
+
+        private void HandleCheckStatusKeys()
+        {
+            if (AccessibleKey.SEE_PLAYER_MANA.IsPressed())
+            {
+                ReadPlayerMana();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MANA.IsPressed())
+            {
+                ReadOpponentMana();
+            }
+            else if (AccessibleKey.SEE_PLAYER_DECK.IsPressed())
+            {
+                ReadPlayerDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_DECK.IsPressed())
+            {
+                ReadOpponentDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HAND.IsPressed())
+            {
+                ReadOpponentHand();
+            }
+        }
+
+        private void HandleCardReadingInput()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            m_cardBeingRead.HandleAccessibleInput();
+        }
+
+        private void SeeOpponentMinions()
+        {
+            var opponentMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+
+            if (opponentMinions.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output($"Your opponent has no summoned minions");
+            }
+            else
+            {
+                SeeZone(opponentMinions);
+            }
+        }
+
+        private void SeePlayerMinions()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output($"You have no summoned minions");
+            }
+            else
+            {
+                SeeZone(playerMinions);
+            }
+        }
+
+        private void SeePlayerSecrets()
+        {
+            var playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+
+            if (playerSecrets.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output($"You have no secrets");
+            }
+            else
+            {
+                SeeZone(playerSecrets);
+            }
+        }
+
+        private void SeeOpponentSecrets()
+        {
+            int numSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone().GetCardCount();
+
+            if (numSecrets == 0)
+            {
+                AccessibilityMgr.Output($"Your opponent has no secrets");
+            }
+            else
+            {
+                var suffix = numSecrets > 1 ? "s" : "";
+                AccessibilityMgr.Output($"Your opponent has {numSecrets} secret{suffix}");
+            }
+        }
+
+
+        private void SeeOpponentHero()
+        {
+            FocusOnCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), false);
+        }
+
+        private void SeePlayerHero()
+        {
+            FocusOnCard(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), false);
+        }
+
+        private void SeePlayerHeroPower()
+        {
+            var heroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output("You have no hero power");
+            }
+        }
+
+        private void SeeOpponentHeroPower()
+        {
+            var heroPower = GameState.Get().GetOpposingSidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output("Your opponent has no hero power");
+            }
+        }
+
+        private void SeePlayerWeapon()
+        {
+            var weapon = GameState.Get().GetFriendlySidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output("You have no equipped weapon");
+            }
+        }
+
+        private void SeeOpponentWeapon()
+        {
+            var weapon = GameState.Get().GetOpposingSidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output("Your opponent has no equipped weapon");
+            }
+        }
+
+        private void ClickCard()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        private void ReadPlayerMana()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int availableMana = player.GetNumAvailableResources();
+            int totalMana = player.GetTag(GAME_TAG.RESOURCES);
+
+            if (availableMana != totalMana)
+            {
+                AccessibilityMgr.Output($"You have {availableMana} out of {totalMana} mana");
+            }
+            else
+            {
+                AccessibilityMgr.Output($"You have {availableMana} mana");
+            }
+        }
+
+        private void ReadOpponentMana()
+        {
+            int totalMana = GameState.Get().GetOpposingSidePlayer().GetTag(GAME_TAG.RESOURCES);
+            AccessibilityMgr.Output($"Your opponent has {totalMana} mana");
+        }
+
+        private void HandleZoneInput()
+        {
+            if (m_curZone == null)
+            {
+                return;
+            }
+
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                ReadCardInZone(numKeyPressed.Value);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos + 1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos - 1);
+            }
+        }
+
+        private void HandleValidOptionsSelectionInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard();
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard(true);
+            }
+        }
+
+        private void FindNextValidCard(bool reverseDirection = false)
+        {
+            List<Card> candidates = GetCandidateOptions();
+            List<Card> validOptions = GetValidOptions(candidates);
+
+            if (validOptions.Count == 0)
+            {
+                OnNoValidPlays();
+                return;
+            }
+            else if (validOptions.Count == 1 && m_cardBeingRead != null && validOptions[0] == m_cardBeingRead.GetCard())
+            {
+                AccessibilityMgr.Output("No more valid options");
+                return;
+            }
+
+            if (GameState.Get().IsInTargetMode() && m_cardBeingRead?.GetCard() == GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard())
+            {
+                m_cardBeingRead = null;
+            }
+
+            if (m_cardBeingRead == null)
+            {
+                if (reverseDirection)
+                {
+                    FocusOnCard(validOptions[validOptions.Count - 1], false);
+                    return;
+                }
+                else
+                {
+                    FocusOnCard(validOptions[0], false);
+                    return;
+                }
+            }
+
+            int curCardIndex = 0;
+            for (int i = 0; i < candidates.Count; i++)
+            {
+                if (candidates[i] == m_cardBeingRead.GetCard())
+                {
+                    curCardIndex = i;
+                }
+            }
+
+            int inc = reverseDirection ? -1 : 1;
+
+            for (int toRead = candidates.Count - 1, i = curCardIndex + inc; toRead > 0; toRead--, i += inc)
+            {
+                if (i < 0)
+                {
+                    i = candidates.Count - 1;
+                }
+                else if (i >= candidates.Count)
+                {
+                    i = 0;
+                }
+
+                var card = candidates[i];
+
+                if (IsValidOption(card))
+                {
+                    FocusOnCard(card, false);
+                    return;
+                }
+            }
+        }
+
+        private List<Card> GetValidOptions(List<Card> candidates)
+        {
+            var ret = new List<Card>();
+
+            foreach (var card in candidates)
+            {
+                if (IsValidOption(card))
+                {
+                    ret.Add(card);
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Card> GetCandidateOptions()
+        {
+            var cycleFriendlyEntitiesFirst = true;
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                var source = GameState.Get().GetSelectedNetworkOption();
+                var sourceEntity = GameState.Get().GetEntity(source.Main.ID);
+
+                var cardText = sourceEntity.GetCardTextBuilder().BuildCardTextInHand(sourceEntity);
+
+                if (CardEffectInterpreter.GetEffect(cardText) == CardEffectInterpreter.CardEffect.UNFRIENDLY)
+                {
+                    cycleFriendlyEntitiesFirst = false;
+                }
+            }
+
+            var ret = new List<Card>();
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerWeapon = player.GetWeaponCard();
+            var playerHero = player.GetHeroCard();
+            var playerHeroPower = player.GetHeroPowerCard();
+            var opponentWeapon = opponent.GetWeaponCard();
+            var opponentHero = opponent.GetHeroCard();
+            var opponentHeroPower = opponent.GetHeroPowerCard();
+
+            var playerEntities = new List<Card>();
+            var opponentEntities = new List<Card>();
+
+            playerEntities.AddRange(player.GetHandZone().GetCards());
+            if (playerWeapon != null) playerEntities.Add(playerWeapon);
+            if (playerHero != null) playerEntities.Add(playerHero);
+            if (playerHeroPower != null) playerEntities.Add(playerHeroPower);
+            playerEntities.AddRange(player.GetBattlefieldZone().GetCards());
+
+            opponentEntities.AddRange(opponent.GetBattlefieldZone().GetCards());
+            if (opponentHero != null) opponentEntities.Add(opponentHero);
+            if (opponentWeapon != null) opponentEntities.Add(opponentWeapon);
+            if (opponentHeroPower != null) opponentEntities.Add(opponentHeroPower);
+
+            if (cycleFriendlyEntitiesFirst)
+            {
+                ret.AddRange(playerEntities);
+                ret.AddRange(opponentEntities);
+            }
+            else
+            {
+                ret.AddRange(opponentEntities);
+                ret.AddRange(playerEntities);
+            }
+
+
+            return ret;
+        }
+
+        private bool IsValidOption(Card card)
+        {
+            if (card == null)
+            {
+                return false;
+            }
+
+            Entity entity = card.GetEntity();
+
+            if (GameState.Get().IsInMainOptionMode())
+            {
+                return GameState.Get().IsValidOption(entity);
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                return GameState.Get().IsValidSubOption(entity);
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                return GameState.Get().IsChoice(entity);
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                return GameState.Get().IsValidOptionTarget(entity, true);
+            }
+
+            return false;
+        }
+
+        private int GetCardBeingReadPosition()
+        {
+            for (int i = 1; i <= m_curZone.GetCardCount(); i++)
+            {
+                if (m_curZone.GetCardAtPos(i) == m_cardBeingRead.GetCard())
+                {
+                    return i;
+                }
+            }
+
+            return 0;
+        }
+
+        private void ReadCardInZone(int pos)
+        {
+            Card card = m_curZone.GetCardAtPos(pos);
+
+            if (card != null)
+            {
+                FocusOnCard(card, false);
+            }
+        }
+
+        private void FocusOnCard(Card card, bool forceZoneRead)
+        {
+            SetCardBeingRead(card, forceZoneRead);
+
+            var speech = m_cardBeingRead.GetLine(0);
+
+            var zonePos = card.GetZone().FindCardPos(card); // card.GetZonePosition() isn't trustworthy. Wasn't working for secrets
+
+            if (ShouldReadCardAsList(card))
+            {
+                AccessibilityMgr.Output(AccessibleSpeech.MENU_OPTION(speech, zonePos, card.GetZone().GetCardCount()));
+            }
+            else
+            {
+                AccessibilityMgr.Output(speech);
+            }
+            MoveMouseToCard(card);
+            OnCardSelected(card, m_cardBeingRead);
+        }
+
+        private bool ShouldReadCardAsList(Card card)
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var cardZone = card.GetZone();
+
+            return cardZone == player.GetHandZone() ||
+                cardZone == opponent.GetHandZone() ||
+                cardZone == player.GetBattlefieldZone() ||
+                cardZone == opponent.GetBattlefieldZone() ||
+                cardZone == player.GetSecretZone() ||
+                cardZone == opponent.GetSecretZone();
+        }
+
+        private void MoveMouseToCard(Card card)
+        {
+            if (card.GetZone()?.GetType() == typeof(ZoneHand))
+            {
+                if (!card.IsMousedOver())
+                {
+                    AccessibleInputMgr.MoveMouseTo(card.GetActor().m_manaObject.transform);
+                }
+            }
+            else
+            {
+                AccessibleInputMgr.MoveMouseTo(card);
+            }
+        }
+
+        private void MoveMouseToZone(Zone zone)
+        {
+            Vector3 zoneCenter = zone.GetComponent<Collider>().bounds.center;
+            AccessibleInputMgr.MoveMouseToWorldPosition(zoneCenter);
+        }
+
+        private void MoveMouseToRightOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x += bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        private void MoveMouseToLeftOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x -= bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        private void CancelOption()
+        {
+            AccessibleInputMgr.ClickRightMouseButton();
+            HideMouse();
+        }
+
+        private void ReadOpponentHand()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetHandZone().GetCardCount();
+
+            AccessibilityMgr.Output($"Opponent's hand. {numCards} cards");
+        }
+
+        private void ReadPlayerDeck()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int numCards = player.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output($"Deck. {numCards} cards");
+        }
+
+        private void ReadOpponentDeck()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output($"Opponent's Deck. {numCards} cards");
+        }
+
+        internal Card GetSelectedCard()
+        {
+            return m_cardBeingRead?.GetCard();
+        }
+
+        private void SeePlayerHand()
+        {
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            if (playerHand.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output($"Your hand is empty");
+            }
+            else
+            {
+                SeeZone(playerHand);
+            }
+        }
+
+        private void SeeZone(Zone zone)
+        {
+            if (zone == null)
+            {
+                return;
+            }
+
+            Card card = zone.GetCardAtPos(1);
+
+            if (card != null) // Race conditions
+            {
+                FocusOnCard(card, true);
+            }
+        }
+
+        private void OnGameStart()
+        {
+            try
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+                m_curState = AccessibleGameState.WAITING;
+                AccessibleHistoryMgr.Get().Reset();
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void OnGameOver(TAG_PLAYSTATE playState, object userData)
+        {
+            m_curPhase = AccessibleGamePhase.GAME_OVER;
+
+            AccessibilityMgr.Output(GetGameOverMessage(playState));
+        }
+
+        private string GetGameOverMessage(TAG_PLAYSTATE playState)
+        {
+            switch (playState)
+            {
+                case TAG_PLAYSTATE.WON:
+                    return "You win";
+                    break;
+                case TAG_PLAYSTATE.LOST:
+                case TAG_PLAYSTATE.CONCEDED:
+                    return "You lose";
+                    break;
+                case TAG_PLAYSTATE.TIED:
+                    return "You tied";
+                    break;
+                default:
+                    return "game over";
+                    break;
+            }
+        }
+
+        public void OnRevealDrawnOpponentCard(Card card)
+        {
+        }
+
+        public void OnDrawUnknownOpponentCard(Card card)
+        {
+        }
+
+        public void OnCardToDeck(Card card)
+        {
+        }
+
+        public void OnShowBigCard(HistoryCard card)
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug($"Card played: {card.GetEntity().GetName()} / type = {card.m_historyInfoType}");
+
+                if (card.m_historyInfoType == HistoryInfoType.CARD_PLAYED)
+                {
+                    OnCardPlayed(card.OriginTaskList, card.GetEntity());
+                }
+                else if (card.m_historyInfoType == HistoryInfoType.TRIGGER)
+                {
+                    OnCardTriggered(card.OriginTaskList, card.GetEntity());
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void OnCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardTriggered(taskList, card);
+        }
+
+        private void OnCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardPlayed(taskList, card);
+        }
+
+        public void OnChoice(List<Card> cards, Banner choiceBanner, NormalButton confirmChoiceButton)
+        {
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(new AccessibleCard(c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(accessibleCards);
+
+                AccessibilityMgr.Output($"{choiceBanner.m_headline.Text}");
+                m_accessibleChoiceCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubOption(List<Card> cards)
+        {
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(new AccessibleCard(c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(accessibleCards);
+
+                AccessibilityMgr.Output($"Choose one");
+                m_accessibleChoiceCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnMulliganChoiceStart(List<Card> startingCards, NormalButton mulliganConfirmButton)
+        {
+            try
+            {
+                m_mulliganConfirmButton = mulliganConfirmButton;
+
+                var accessibleCards = new List<AccessibleCard>(startingCards.Count);
+                startingCards.ForEach(c => accessibleCards.Add(new AccessibleCard(c)));
+
+                m_accessibleMulliganCards = new AccessibleListOfItems<AccessibleCard>(accessibleCards);
+                m_mulliganMarkedForReplacement = new Dictionary<AccessibleCard, bool>();
+                accessibleCards.ForEach(c => m_mulliganMarkedForReplacement.Add(c, false));
+
+                AccessibilityMgr.Output($"Mulligan");
+                AccessibilityMgr.Output($"Keep or replace cards");
+                m_accessibleMulliganCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Help
+        public string GetHelp()
+        {
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.WAITING_FOR_GAME_TO_START:
+                    return GetWaitingForGameToStartHelp();
+                case AccessibleGamePhase.MULLIGAN:
+                    return GetMulliganHelp();
+                case AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN:
+                    return GetWaitingForOpponentHelp();
+                case AccessibleGamePhase.PLAYING:
+                    return GetPlayingHelp();
+                case AccessibleGamePhase.GAME_OVER:
+                    return GetGameOverHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetGameOverHelp()
+        {
+            return "Game ended";
+        }
+
+        private string GetPlayingHelp()
+        {
+            switch (m_curState)
+            {
+                case AccessibleGameState.OPPONENT_TURN:
+                    return GetOpponentTurnHelp();
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    return GetMainOptionModeHelp();
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    return GetSubOptionModeHelp();
+                case AccessibleGameState.TARGET_MODE:
+                    return GetTargetModeHelp();
+                case AccessibleGameState.CHOICE_MODE:
+                    return GetChoiceModeHelp();
+                case AccessibleGameState.SUMMONING_MINION:
+                    return GetSummoningMinionHelp();
+                case AccessibleGameState.PLAYING_CARD:
+                    return GetPlayingCardHelp();
+                case AccessibleGameState.CONFIRMING_END_TURN:
+                    return GetConfirmingEndTurnHelp();
+                case AccessibleGameState.BROWSING_HISTORY:
+                    return GetBrowsingHistoryHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetWaitingForOpponentHelp()
+        {
+            return "Waiting for your opponent";
+        }
+
+        private string GetMulliganHelp()
+        {
+            return $"Use the arrow keys to go through your starting cards. Use {AccessibleKey.CONFIRM} to mark the cards you'd like to replace. Press {AccessibleKey.CONFIRM_MULLIGAN} once you're done";
+        }
+
+        private string GetWaitingForGameToStartHelp()
+        {
+            return "The game is about to start. Please wait";
+        }
+
+        private string GetBrowsingHistoryHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_READ_HISTORY_HELP);
+        }
+
+        private string GetConfirmingEndTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CONFIRM_END_TURN_HELP);
+        }
+
+        private string GetPlayingCardHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+        }
+
+        private string GetSummoningMinionHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_SUMMON_MINION_HELP);
+        }
+
+        private string GetChoiceModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        private string GetTargetModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOOSE_TARGET_HELP);
+        }
+
+        private string GetSubOptionModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        private string GetMainOptionModeHelp()
+        {
+            if (m_cardBeingRead != null)
+            {
+                return NarrateMainOptionWhenCardBeingRead();
+            }
+            else
+            {
+                return NarrateMainOption();
+            }
+        }
+
+        private string NarrateMainOption()
+        {
+            var speeches = GetMainOptionSpeeches(false);
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        private List<HSASpeech> GetMainOptionSpeeches(bool hasReadEndTurn, bool readManaFirst=false)
+        {
+            var playerHasValidOptions = PlayerHasValidOptions();
+
+            var speeches = new List<HSASpeech>();
+
+            if (!hasReadEndTurn && !playerHasValidOptions)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+            }
+
+            if (readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_VALID_OPTIONS);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HAND_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetSecretZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_SECRETS_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_HERO_HELP);
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP);
+            }
+
+            if (GameState.Get().GetOpposingSidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_HERO_HELP);
+
+            if (GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP);
+            }
+
+            // Counts
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_PLAYER_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_HAND_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP);
+            }
+
+            if (!readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_MANA_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_OPEN_HISTORY_LOG_HELP);
+            }
+
+            return speeches;
+        }
+
+        private bool IsPlayingTutorial()
+        {
+            var gameEntity = GameState.Get().GetGameEntity();
+
+            return gameEntity.GetType().IsSubclassOf(typeof(TutorialEntity));
+        }
+
+        private bool PlayerHasValidOptions()
+        {
+            var candidates = GetCandidateOptions();
+            return GetValidOptions(candidates).Count > 0;
+        }
+
+        private string NarrateMainOptionWhenCardBeingRead()
+        {
+            var card = m_cardBeingRead.GetCard();
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            var playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var playerHero = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+            var playerHeroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+
+            var speeches = new List<HSASpeech>();
+
+            var hasReadEndTurn = false;
+
+            if (!PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                hasReadEndTurn = true;
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_HELP);
+
+            if (TooltipPanelManager.Get()?.GetTooltipPanels()?.Count > 0 || TutorialKeywordManager.Get()?.GetPanels()?.Count > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_TOOLTIP_HELP);
+            }
+
+            var readManaFirst = false;
+
+            if (IsValidOption(card))
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+                }
+                else if (card.GetZone() == playerBattlefield)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_MINION_HELP);
+                }
+                else if (card == playerHero)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_HERO_HELP);
+                }
+                else if (card == playerHeroPower)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_USE_HERO_POWER_HELP);
+                }
+            }
+            else
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    readManaFirst = true;
+                }
+            }
+
+            speeches.AddRange(GetMainOptionSpeeches(hasReadEndTurn, readManaFirst));
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        private string GetOpponentTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_OPPONENT_TURN_VOICE);
+        }
+
+        private string GetOrNarrateHelpSpeech(HSASpeech speech)
+        {
+            if (IsPlayingTutorial())
+            {
+                AccessibilityMgr.NarrateHelp(speech);
+                return "";
+            }
+            else
+            {
+                return speech.Value;
+            }
+        }
+
+        private string GetOrNarrateHelpSpeeches(List<HSASpeech> speeches)
+        {
+            if (IsPlayingTutorial())
+            {
+                AccessibilityMgr.NarrateHelp(speeches.ToArray());
+                return "";
+            }
+            else
+            {
+                var lines = new List<string>(speeches.Count);
+                speeches.ForEach(s => lines.Add(s.Value));
+
+                return AccessibleSpeechUtils.CombineLines(lines);
+            }
+        }
+
+        #endregion Help
+
+        public void OnGainedFocus()
+        {
+            // TODO: Think about this but we probably don't want to say anything given that no one will forget they're playing a game
+        }
+
+        #region Tutorial stuff
+        private Dictionary<Zone, Action> m_zoneSelectedListeners = new Dictionary<Zone, Action>();
+        private Dictionary<Card, Action<AccessibleCard>> m_cardSelectedListeners = new Dictionary<Card, Action<AccessibleCard>>();
+        private Dictionary<Card, Action> m_summoningMinionListeners = new Dictionary<Card, Action>();
+
+        private void OnZoneSelected(Zone zone)
+        {
+            if (m_zoneSelectedListeners.ContainsKey(zone))
+            {
+                m_zoneSelectedListeners[zone]();
+                m_zoneSelectedListeners.Remove(zone);
+            }
+        }
+
+        private void OnCardSelected(Card card, AccessibleCard accessibleCard)
+        {
+            OnZoneSelected(card.GetZone());
+
+            if (m_cardSelectedListeners.ContainsKey(card))
+            {
+                m_cardSelectedListeners[card](accessibleCard);
+                m_cardSelectedListeners.Remove(card);
+            }
+        }
+
+        private void OnSummoningMinion(Card card)
+        {
+            if (m_summoningMinionListeners.ContainsKey(card))
+            {
+                m_summoningMinionListeners[card]();
+                m_summoningMinionListeners.Remove(card);
+            }
+        }
+
+        internal void RegisterZoneSelectedListener(Zone zone, Action action)
+        {
+            m_zoneSelectedListeners[zone] = action;
+        }
+
+        internal void RegisterCardSelectedListener(Card card, Action<AccessibleCard> action)
+        {
+            m_cardSelectedListeners[card] = action;
+        }
+
+        internal void RegisterSummoningCardListener(Card card, Action action)
+        {
+            m_summoningMinionListeners[card] = action;
+        }
+
+        private Action m_noValidPlaysListener;
+
+        internal void RegisterNoValidPlaysListener(Action action)
+        {
+            m_noValidPlaysListener = action;
+        }
+
+        private void OnNoValidPlays()
+        {
+            AccessibilityMgr.Output("You have no valid plays");
+            StopReadingCard();
+
+            if (m_noValidPlaysListener != null)
+            {
+                m_noValidPlaysListener();
+                m_noValidPlaysListener = null;
+            }
+        }
+
+
+        private bool m_stopHidingMouse;
+
+        // Useful for e.g. pack opening in the tutorial
+        internal void StopHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+
+        internal void StartHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
new file mode 100644
index 0000000..7093ee8
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
@@ -0,0 +1,62 @@
+﻿using System;
+using System.Net;
+
+namespace Accessibility
+{
+    static class AccessibleHearthstoneApplication
+    {
+        internal static void OnLoading()
+        {
+            AccessibilityMgr.Output("Loading game");
+
+            Log.Accessibility.Print($"Hearthstone version: {HearthstoneAccessConstants.HEARTHSTONE_VERSION}");
+            Log.Accessibility.Print($"Hearthstone Access version: {HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION}");
+
+            if (HearthstoneAccessUpdateRequired())
+            {
+                AccessibilityMgr.Output($"A new version of Hearthstone Access is available. Please run the patcher again whenever possible as it may contain bug fixes");
+            }
+        }
+
+        internal static void OnClosing()
+        {
+            AccessibilityMgr.Output("Closing game");
+        }
+
+        private static bool HearthstoneAccessUpdateRequired()
+        {
+            try
+            {
+                var fileName = "hsa-version";
+                var hsaRepoUrl = HearthstoneAccessConstants.GetHearthstoneAccessRepoUrl();
+                var url = $"{hsaRepoUrl}/{HearthstoneAccessConstants.HEARTHSTONE_VERSION}/{fileName}";
+
+                ServicePointManager.Expect100Continue = true;
+                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;
+
+                using (WebClient wc = new WebClient())
+                {
+                    var githubToken = HearthstoneAccessConstants.GetGithubToken();
+                    if (githubToken != null)
+                    {
+                        // Dev only
+                        wc.Headers.Add("Authorization", $"token {githubToken}");
+                    }
+
+                    wc.Headers.Add(HttpRequestHeader.UserAgent, "HSA");
+
+                    var hsaVersion = wc.DownloadString(url);
+
+                    return !hsaVersion.Equals(HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION);
+                }
+            }
+            catch (Exception e)
+            {
+                // Not really fatal since we'll just keep going but let's log it as such in case someone runs into issues
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
new file mode 100644
index 0000000..2ddc41b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
@@ -0,0 +1,126 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleHistoryMgr
+    {
+        private List<string> m_entries = new List<string>();
+
+        private int m_entryBeingReadIndex;
+
+        private bool m_readingHistory;
+
+        private static AccessibleHistoryMgr s_instance;
+
+        internal static AccessibleHistoryMgr Get()
+        {
+            if (s_instance == null)
+            {
+                s_instance = new AccessibleHistoryMgr();
+            }
+
+            return s_instance;
+        }
+
+        internal void AddEntry(string entry)
+        {
+            if (entry == null || entry.Length == 0)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"HIST add entry: {entry}");
+            m_entries.Add(entry);
+        }
+
+        internal void Reset()
+        {
+            AccessibilityUtils.LogDebug("HIST Reset");
+            m_entries.Clear();
+            m_entryBeingReadIndex = -1;
+            m_readingHistory = false;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.SEE_HISTORY.IsPressed() && !m_readingHistory)
+            {
+                StartReadingHistory();
+                return true;
+            }
+            else if (AccessibleKey.BACK.IsPressed() && m_readingHistory)
+            {
+                StopReadingHistory();
+                return true;
+            }
+            else if (m_readingHistory && AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex + 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex - 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadToEnd();
+            }
+
+            return false;
+        }
+
+        private void ReadToEnd()
+        {
+            for (int i = m_entryBeingReadIndex; i < m_entries.Count; i++)
+            {
+                ReadEntry(i);
+            }
+        }
+
+        private void StartReadingHistory()
+        {
+            if (m_entries.Count == 0)
+            {
+                AccessibilityMgr.Output("Nothing has been played yet");
+            }
+            else
+            {
+                m_readingHistory = true;
+                ReadEntry(m_entries.Count - 1);
+            }
+        }
+
+        private void ReadEntry(int index)
+        {
+            if (index < 0 || index >= m_entries.Count)
+            {
+                return;
+            }
+
+            m_entryBeingReadIndex = index;
+
+            var curEntry = m_entries[m_entryBeingReadIndex];
+            AccessibilityMgr.Output($"{m_entryBeingReadIndex + 1} of {m_entries.Count} {curEntry}");
+        }
+
+        internal bool IsReadingHistory()
+        {
+            return m_readingHistory;
+        }
+
+        internal void StopReadingHistory()
+        {
+            if (m_readingHistory)
+            {
+                AccessibilityMgr.Output("Stopped reading history");
+                m_entryBeingReadIndex = -1;
+                m_readingHistory = false;
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs
new file mode 100644
index 0000000..a77ba73
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleHub.cs
@@ -0,0 +1,89 @@
+﻿using System;
+
+namespace Accessibility
+{
+    class AccessibleHub : AccessibleScreen
+    {
+        private enum State { LOADING, MAIN_MENU };
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_mainMenu;
+
+        private static AccessibleHub s_instance = new AccessibleHub();
+
+        internal static AccessibleHub Get()
+        {
+            return s_instance;
+        }
+
+        public void OnHubOpened()
+        {
+            try
+            {
+                m_curState = State.MAIN_MENU;
+
+                SetupMainMenu();
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(AccessibleSpeech.HUB_MAIN_MENU_TITLE, null);
+
+            m_mainMenu.AddOption(AccessibleSpeech.HUB_SOLO_ADVENTURES_OPTION, OnClickSoloAdventures);
+            m_mainMenu.AddOption(AccessibleSpeech.HUB_HELP_OPTION, OnClickHelp);
+            m_mainMenu.AddOption(AccessibleSpeech.HUB_GAME_MENU_OPTION, OnClickGameMenu);
+        }
+
+        private void OnClickGameMenu()
+        {
+            AccessibilityMgr.Output(AccessibleSpeech.HUB_GAME_MENU);
+        }
+
+        private void OnClickHelp()
+        {
+            AccessibilityMgr.Output(AccessibleSpeech.HUB_HELP);
+        }
+
+        private void OnClickSoloAdventures()
+        {
+            Box.Get().m_SoloAdventuresButton.TriggerRelease();
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return AccessibleSpeech.MENU_HELP(false);
+                default:
+                    break;
+            }
+
+            return "";
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu.StartReading();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
new file mode 100644
index 0000000..fd78b9f
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
@@ -0,0 +1,1711 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessibleInGameState
+    {
+        private class EntityDiff
+        {
+            private Entity m_before, m_after;
+
+            private bool m_died;
+            private bool m_transformed;
+            private bool m_revealed;
+            private int m_healedAmt;
+            private int m_healthDiff;
+            private int m_armorDiff;
+            private int m_atkDiff;
+            private bool m_becameInvulnerable;
+
+            private string m_desc;
+
+            internal EntityDiff(Entity before, Entity after, AccessibleInGameState gameStateBefore, AccessibleInGameState gameStateAfter)
+            {
+                m_before = before;
+                m_after = after;
+
+                m_died = HasDied(before, after);
+                m_transformed = HasTransformed(before, after);
+                m_revealed = HasRevealed(before, after);
+                m_healedAmt = Math.Abs(Math.Min(after.GetDamage() - before.GetDamage(), 0));
+                m_healthDiff = after.GetHealth() - before.GetHealth();
+                m_armorDiff = after.GetArmor() - before.GetArmor();
+                m_atkDiff = after.GetATK() - before.GetATK();
+                m_becameInvulnerable = before.CanBeAttacked() && !after.CanBeAttacked();
+
+                m_desc = GetDiffDescription();
+            }
+
+            private int GetDamageTaken()
+            {
+                if (m_after.IsCharacter())
+                {
+                    var afterDmg = m_after.GetDamage();
+                    var beforeDmg = m_before.GetDamage();
+                    var afterArmor = m_after.GetArmor();
+                    var beforeArmor = m_before.GetArmor();
+
+                    var dmgTaken = 0;
+
+                    if (afterDmg > beforeDmg)
+                    {
+                        dmgTaken += afterDmg - beforeDmg;
+                    }
+
+                    if (afterArmor < beforeArmor)
+                    {
+                        dmgTaken += beforeArmor - afterArmor;
+                    }
+
+                    return dmgTaken;
+                }
+                else if (m_after.IsWeapon())
+                {
+                    var afterDurability = m_after.GetCurrentDurability();
+                    var beforeDurability = m_before.GetCurrentDurability();
+
+                    if (afterDurability < beforeDurability)
+                    {
+                        return beforeDurability - afterDurability;
+                    }
+                }
+
+                return 0;
+            }
+
+            internal List<string> GetRawDiff()
+            {
+                var ret = new List<string>();
+
+                var beforeTags = m_before.GetTags().GetMap();
+                var afterTags = m_after.GetTags().GetMap();
+
+                foreach (var beforeEntry in beforeTags)
+                {
+                    int tag = beforeEntry.Key;
+                    int beforeVal = beforeEntry.Value;
+
+                    if (!afterTags.ContainsKey(tag))
+                    {
+                        ret.Add($"--- {GetTagName(tag)} ({beforeVal})");
+                    }
+                    else
+                    {
+                        int afterVal = afterTags[tag];
+
+                        if (beforeVal != afterVal)
+                        {
+                            ret.Add($"CCC {GetTagName(tag)}: {beforeVal} -> {afterVal}");
+                        }
+                    }
+                }
+
+                foreach (var afterEntry in afterTags)
+                {
+                    int tag = afterEntry.Key;
+                    int afterVal = afterEntry.Value;
+                    if (!beforeTags.ContainsKey(tag))
+                    {
+                        ret.Add($"+++ {GetTagName(tag)}={afterVal}");
+                    }
+                }
+
+                return ret;
+            }
+
+            private string GetTagName(int tag)
+            {
+                var ret = Enum.GetName(typeof(GAME_TAG), tag);
+
+                if (ret == null)
+                {
+                    ret = tag.ToString();
+                }
+
+                return ret;
+            }
+
+            internal int GetEntityId()
+            {
+                return m_before.GetEntityId();
+            }
+
+            internal bool HasDied()
+            {
+                return m_died;
+            }
+
+            private static bool IsInvalid(Entity entity)
+            {
+                return entity.GetCardType() == TAG_CARDTYPE.INVALID;
+            }
+
+            private static bool IsDead(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsDeadZone(entity.GetZone());
+            }
+
+            private static bool IsAlive(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsAliveZone(entity.GetZone());
+            }
+
+            private static bool IsDeadZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.GRAVEYARD || zone == TAG_ZONE.REMOVEDFROMGAME || zone == TAG_ZONE.SETASIDE;
+            }
+
+            private static bool IsAliveZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.PLAY; // Only PLAY should count as alive as e.g. in-hand cards are not "alive"
+            }
+
+            private static bool IsAbleToLive(Entity entity)
+            {
+                return entity.IsCharacter() || entity.IsWeapon();
+            }
+
+            internal string GetDeathSpeech()
+            {
+                if (m_before.IsWeapon())
+                {
+                    if (m_after.GetController().GetWeaponCard() == null)
+                    {
+                        return "broke";
+                    }
+                    else
+                    {
+                        return "";
+                    }
+                }
+                else
+                {
+                    return "died";
+                }
+            }
+
+            private static bool HasDied(Entity before, Entity after)
+            {
+                var died = IsAlive(before) && IsDead(after);
+
+                if (!died)
+                {
+                    return false;
+                }
+
+                if (!before.IsWeapon())
+                {
+                    return true;
+                }
+
+                if (after.GetController().GetWeaponCard() == null)
+                {
+                    s_heroWeaponBroke.Add(after.GetController().GetHero());
+                }
+
+                return true;
+            }
+
+            internal bool HasChanges()
+            {
+                return !m_died && !m_transformed && GetDiffDescription().Length > 0;
+            }
+
+            internal Entity GetBeforeEntity()
+            {
+                return m_before;
+            }
+
+            internal Entity GetAfterEntity()
+            {
+                return m_after;
+            }
+
+            internal string GetTransformedSpeech()
+            {
+                return $"transformed into one {m_after.GetName()}";
+            }
+
+            internal bool HasTransformed()
+            {
+                return m_transformed;
+            }
+
+            private bool HasTransformed(Entity before, Entity after)
+            {
+                return !MovedZone() && !HasRevealed(before, after) && !m_after.GetName().Equals(m_before.GetName());
+            }
+
+            private bool HasRevealed(Entity before, Entity after)
+            {
+                return before.GetZone() == TAG_ZONE.SECRET && !MovedZone() && !m_after.GetName().Equals(m_before.GetName());
+            }
+
+            internal bool MovedZone()
+            {
+                return !m_died && (m_before.GetZone() != m_after.GetZone()) || (m_before.GetController() != m_after.GetController());
+            }
+
+            internal string GetDiffDescription()
+            {
+                if (m_desc != null)
+                {
+                    return m_desc;
+                }
+
+                if (m_died || m_transformed || m_revealed)
+                {
+                    return "";
+                }
+
+                if (IsInvalid(m_before) || IsInvalid(m_after))
+                {
+                    return "";
+                }
+
+                if (IsDead(m_before) && IsDead(m_after))
+                {
+                    // Has been dead for a while
+                    return "";
+                }
+
+                if (MovedZone() && (m_after.GetZone() != TAG_ZONE.PLAY))
+                {
+                    // We don't want to call out stat changes in things like return to hand
+                    return "";
+                }
+
+                List<string> descriptions = new List<string>();
+                List<string> gainedDescriptions = new List<string>();
+                List<string> lostDescriptions = new List<string>();
+
+                bool gainedAtk = m_atkDiff > 0;
+                bool lostAtk = m_atkDiff < 0;
+                bool gainedHealth = m_healthDiff > 0;
+                bool lostHealth = m_healthDiff < 0;
+                bool gainedArmor = m_armorDiff > 0;
+                // TODO: describe as lost armor instead? This is currently handled as damage taken
+
+                int dmgTaken = GetDamageTaken();
+
+                if (dmgTaken > 0 && !m_after.IsWeapon())
+                {
+                    descriptions.Add($"took {dmgTaken} damage");
+                }
+
+                if (m_healedAmt > 0)
+                {
+                    if (m_after.IsWeapon())
+                    {
+                        gainedDescriptions.Add($"{m_healedAmt} durability");
+                    }
+                    else
+                    {
+                        descriptions.Add($"recovered {m_healedAmt} health");
+                    }
+                }
+
+                if (m_becameInvulnerable && !PlayingTutorial()) // Heroes and minions become invulnerable randomly in tutorial games for some reason (even though they wouldn't even get hit)
+                {
+                    descriptions.Add($"became invulnerable");
+                }
+
+                if (!m_before.IsSilenced() && m_after.IsSilenced())
+                {
+                    descriptions.Add("was silenced");
+                }
+                else
+                {
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasTaunt(), m_after.HasTaunt(), "taunt");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasDeathrattle(), m_after.HasDeathrattle(), "deathrattle");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasBattlecry(), m_after.HasBattlecry(), "battlecry");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasCharge(), m_after.HasCharge(), "charge");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasLifesteal(), m_after.HasLifesteal(), "lifesteal");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasRush(), m_after.HasRush(), "rush");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasWindfury(), m_after.HasWindfury(), "windfury");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.HasDivineShield(), m_after.HasDivineShield(), "divine shield");
+                    AddGainedOrLostDescriptionIfExists(descriptions, m_before.IsDormant(), m_after.IsDormant(), "became dormant", "is no longer dormant");
+                    AddGainedOrLostDescriptionIfExists(gainedDescriptions, lostDescriptions, m_before.IsFreeze(), m_after.IsFreeze(), "freeze");
+                    AddGainedOrLostDescriptionIfExists(descriptions, m_before.IsFrozen(), m_after.IsFrozen(), "became frozen", "is no longer frozen");
+                    AddGainedOrLostDescriptionIfExists(descriptions, m_before.IsImmune(), m_after.IsImmune(), "became immune", "is no longer immune");
+                    AddGainedOrLostDescriptionIfExists(descriptions, m_before.IsMagnet(), m_after.IsMagnet(), "became magnetic", "is no longer magnetic");
+                    AddGainedOrLostDescriptionIfExists(descriptions, m_before.IsPoisonous(), m_after.IsPoisonous(), "became poisonous", "is no longer poisonous");
+                    AddGainedDescriptionIfExists(descriptions, m_before.IsStealthed(), m_after.IsStealthed(), "became stealthed");
+                }
+
+                // Handle weapons to prevent spam on sheathe/unsheathe/break
+                if (lostAtk && s_heroSheathedWeapon.Contains(m_after))
+                {
+                    lostAtk = false;
+                    s_heroSheathedWeapon.Remove(m_after);
+                    AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to sheathe");
+                }
+                else if (lostAtk && s_heroWeaponBroke.Contains(m_after))
+                {
+                    lostAtk = false;
+                    s_heroWeaponBroke.Remove(m_after);
+                    AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to broken weapon");
+                }
+                else if (gainedAtk && s_heroUnsheathedWeapon.Contains(m_after))
+                {
+                    gainedAtk = false;
+                    s_heroUnsheathedWeapon.Remove(m_after);
+                    AccessibilityUtils.LogDebug("WEP Ignoring gainAtk due to unsheathe");
+                }
+
+                // Normal stats
+                if (gainedAtk)
+                {
+                    gainedDescriptions.Add($"{m_atkDiff} attack");
+                }
+                else if (lostAtk)
+                {
+                    lostDescriptions.Add($"{Math.Abs(m_atkDiff)} attack");
+                }
+
+                if (gainedHealth)
+                {
+                    gainedDescriptions.Add($"{m_healthDiff} health");
+                }
+                else if (lostHealth)
+                {
+                    lostDescriptions.Add($"{Math.Abs(m_healthDiff)} health");
+                }
+
+                if (gainedArmor)
+                {
+                    gainedDescriptions.Add($"{m_armorDiff} armor");
+                }
+
+                var groupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(gainedDescriptions);
+                var groupedLostDescriptions = AccessibleSpeechUtils.HumanizeList(lostDescriptions);
+
+                if (groupedGainedDescriptions.Length > 0)
+                {
+                    descriptions.Add($"gained {groupedGainedDescriptions}");
+                }
+
+                if (groupedLostDescriptions.Length > 0)
+                {
+                    descriptions.Add($"lost {groupedLostDescriptions}");
+                }
+
+                return AccessibleSpeechUtils.HumanizeList(descriptions);
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> gainedDescriptions, List<string> lostDescriptions, bool hadBefore, bool hasAfter, string gainedOrLostText)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    gainedDescriptions.Add(gainedOrLostText);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    lostDescriptions.Add(gainedOrLostText);
+                }
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> descriptions, bool hadBefore, bool hasAfter, string gainedText, string lostText)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    descriptions.Add(gainedText);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    descriptions.Add(lostText);
+                }
+            }
+
+            private void AddGainedDescriptionIfExists(List<string> descriptions, bool hadBefore, bool hasAfter, string gainedText)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    descriptions.Add(gainedText);
+                }
+            }
+        }
+
+        private class EntityGroup
+        {
+            private string m_name;
+            private List<Entity> m_entities;
+
+            internal EntityGroup(string name, List<Entity> entities)
+            {
+                m_name = name;
+                m_entities = entities;
+            }
+
+            internal bool IsSubsetOf(List<Entity> entities)
+            {
+                var entitiesMap = new HashSet<Entity>(entities, new EntityComparer());
+
+                foreach (var entity in m_entities)
+                {
+                    if (!entitiesMap.Contains(entity))
+                    {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+
+            internal string GetName()
+            {
+                return m_name;
+            }
+
+            internal List<Entity> GetEntities()
+            {
+                return m_entities;
+            }
+        }
+
+        private PowerTaskList m_powerTaskList;
+
+        private bool m_gameCreated;
+
+        private TAG_STEP m_step;
+
+        private Player m_currentPlayer;
+        private int m_playerAvailableResources;
+        private int m_playerResources;
+        private int m_opponentAvailableResources;
+        private int m_opponentResources;
+        private int m_playerNumTurnsInPlay;
+        private int m_playerSpellpower;
+        private int m_opponentSpellpower;
+
+        private Entity m_playerHero, m_opponentHero;
+        private Entity m_playerHeroPower, m_opponentHeroPower;
+        private Entity m_playerWeapon, m_opponentWeapon;
+
+        private List<Entity> m_playerHand, m_opponentHand;
+        private List<Entity> m_playerDeck, m_opponentDeck;
+        private List<Entity> m_playerGraveyard, m_opponentGraveyard;
+        private List<Entity> m_playerMinions, m_opponentMinions;
+        private List<Entity> m_playerSecrets, m_opponentSecrets;
+
+        private List<Entity> m_entities;
+
+        private AccessibleInGameState(PowerTaskList powerTaskList)
+        {
+            m_powerTaskList = powerTaskList;
+
+            if (!GameState.Get().IsGameCreated())
+            {
+                return;
+            }
+
+            m_gameCreated = true;
+
+            m_step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            m_currentPlayer = GameState.Get().GetCurrentPlayer();
+
+            Player player = GameState.Get().GetFriendlySidePlayer();
+            Player opponent = GameState.Get().GetOpposingSidePlayer();
+
+            m_playerAvailableResources = player.GetNumAvailableResources();
+            m_opponentAvailableResources = opponent.GetNumAvailableResources();
+            m_playerResources = player.GetTag(GAME_TAG.RESOURCES);
+            m_opponentResources = opponent.GetTag(GAME_TAG.RESOURCES);
+            m_playerSpellpower = player.TotalSpellpower();
+            m_opponentSpellpower = opponent.TotalSpellpower();
+            m_playerNumTurnsInPlay = player.GetNumTurnsInPlay();
+
+            m_playerHero = Clone(player.GetHero());
+            m_opponentHero = Clone(opponent.GetHero());
+            m_playerHeroPower = Clone(player.GetHeroPower());
+            m_opponentHeroPower = Clone(opponent.GetHeroPower());
+            m_playerWeapon = Clone(player.GetWeaponCard()?.GetEntity());
+            m_opponentWeapon = Clone(opponent.GetWeaponCard()?.GetEntity());
+
+            m_playerHand = Clone(GetEntitiesFromZone(player.GetHandZone()));
+            m_opponentHand = Clone(GetEntitiesFromZone(opponent.GetHandZone()));
+            m_playerDeck = Clone(GetEntitiesFromZone(player.GetDeckZone()));
+            m_opponentDeck = Clone(GetEntitiesFromZone(opponent.GetDeckZone()));
+            m_playerGraveyard = Clone(GetEntitiesFromZone(player.GetGraveyardZone()));
+            m_opponentGraveyard = Clone(GetEntitiesFromZone(opponent.GetGraveyardZone()));
+            m_playerMinions = Clone(GetEntitiesFromZone(player.GetBattlefieldZone()));
+            m_opponentMinions = Clone(GetEntitiesFromZone(opponent.GetBattlefieldZone()));
+            m_playerSecrets = Clone(GetEntitiesFromZone(player.GetSecretZone()));
+            m_opponentSecrets = Clone(GetEntitiesFromZone(opponent.GetSecretZone()));
+
+            m_entities = new List<Entity>();
+            m_entities.Add(m_playerHero);
+            m_entities.Add(m_opponentHero);
+            if (m_playerHeroPower != null) m_entities.Add(m_playerHeroPower);
+            if (m_opponentHeroPower != null) m_entities.Add(m_opponentHeroPower);
+            if (m_playerWeapon != null) m_entities.Add(m_playerWeapon);
+            if (m_opponentWeapon != null) m_entities.Add(m_opponentWeapon);
+            m_entities.AddRange(m_playerHand);
+            m_entities.AddRange(m_opponentHand);
+            m_entities.AddRange(m_playerDeck);
+            m_entities.AddRange(m_opponentDeck);
+            m_entities.AddRange(m_playerGraveyard);
+            m_entities.AddRange(m_opponentGraveyard);
+            m_entities.AddRange(m_playerMinions);
+            m_entities.AddRange(m_opponentMinions);
+            m_entities.AddRange(m_playerSecrets);
+            m_entities.AddRange(m_opponentSecrets);
+        }
+
+        internal bool HasWeaponEquipped(Entity hero)
+        {
+            return GetWeapon(hero.GetController()) != null;
+        }
+
+        private Entity GetWeapon(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerWeapon;
+            }
+            else
+            {
+                return m_opponentWeapon;
+            }
+        }
+
+        private Entity GetHero(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerHero;
+            }
+            else
+            {
+                return m_opponentHero;
+            }
+        }
+
+        internal static AccessibleInGameState GetCurrentState(PowerTaskList powerTaskList)
+        {
+            return new AccessibleInGameState(powerTaskList);
+        }
+
+        internal Entity GetEntity(int entityId)
+        {
+            foreach (var entity in m_entities)
+            {
+                if (entity.GetEntityId() == entityId)
+                {
+                    return entity;
+                }
+            }
+
+            return null;
+        }
+
+        private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            // Groups
+            var allFriendlyCharacters = ConcatEntities(before.m_playerMinions, before.m_playerHero);
+            var allEnemies = ConcatEntities(before.m_opponentMinions, before.m_opponentHero);
+            var allMinions = ConcatEntities(before.m_playerMinions, before.m_opponentMinions);
+            var everyone = ConcatEntities(allFriendlyCharacters, allEnemies);
+            var bothHeroes = ConcatEntities(before.m_playerHero, before.m_opponentHero);
+
+            var groups = new List<EntityGroup>();
+            if (everyone.Count > 2) groups.Add(new EntityGroup("Everyone", everyone));
+            groups.Add(new EntityGroup("Both heroes", bothHeroes));
+            if (allMinions.Count > 0 && before.m_playerMinions.Count > 0 && before.m_opponentMinions.Count > 0) groups.Add(new EntityGroup("All minions", allMinions));
+            if (allEnemies.Count > 1) groups.Add(new EntityGroup("Your enemies", allEnemies));
+            if (allFriendlyCharacters.Count > 1) groups.Add(new EntityGroup("Your friendly characters", allFriendlyCharacters));
+            if (before.m_opponentMinions.Count > 1) groups.Add(new EntityGroup("Your opponent's minions", before.m_opponentMinions));
+            if (before.m_playerMinions.Count > 1) groups.Add(new EntityGroup("Your minions", before.m_playerMinions));
+
+            if (sourceEntity != null)
+            {
+                AddOtherThanSourceEntityGroups(sourceEntity, everyone, groups, "Everyone else");
+                AddOtherThanSourceEntityGroups(sourceEntity, allMinions, groups, "All other minions");
+                AddOtherThanSourceEntityGroups(sourceEntity, allEnemies, groups, "Your other enemies");
+                AddOtherThanSourceEntityGroups(sourceEntity, allFriendlyCharacters, groups, "Your other friendly characters");
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_opponentMinions, groups, "Your other opponent's minions");
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_playerMinions, groups, "Your other minions");
+            }
+            AddSameNameEntityGroups(before.m_playerMinions, groups, "Your");
+            AddSameNameEntityGroups(before.m_opponentMinions, groups, "Your opponent's");
+
+            return GetDiffSpeech(sourceEntity, before, after, groups);
+        }
+
+        private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after, List<EntityGroup> groups)
+        {
+            // Note: sourceEntity is a duplicate but I think it can be null in some cases
+
+            List<Entity> destroyedEntities = GetDestroyedEntities(before, after);
+            List<Entity> newEntities = GetNewEntities(before, after);
+
+            var newEntitySpeeches = GetNewEntitySpeeches(newEntities);
+
+            List<EntityDiff> entityDiffs = CreateEntityDiffs(before, after);
+            List<EntityDiff> affectedEntities = GetAffectedEntities(entityDiffs);
+            List<EntityDiff> movedEntities = GetMovedEntities(sourceEntity, entityDiffs, after.m_entities);
+            List<EntityDiff> transformedEntities = GetTransformedEntities(entityDiffs); // Technically a change but we want to state these first due to enchantments (e.g. polymorph on a stormwind champion)
+            List<EntityDiff> justDiedEntities = GetJustDiedEntities(entityDiffs);
+
+            DebugEntityDiffs(entityDiffs);
+
+            AccessibilityUtils.LogDebug($"DBG justDiedEntities: {GetEntityNamesDbg(justDiedEntities)}");
+
+            var ret = new List<string>();
+
+            // Testing
+            var affectedEntitySpeeches = GetEntitySpeeches(affectedEntities);
+            var transformedEntitySpeeches = GetTransformedEntitySpeeches(transformedEntities);
+            var deadEntitySpeeches = GetDeadEntitySpeeches(justDiedEntities);
+
+            var groupedMovementSpeeches = GetZoneMovementSpeeches(movedEntities, groups);
+
+            AccessibilityUtils.LogDebug("DBG Groups");
+            foreach (var group in groups)
+            {
+                AccessibilityUtils.LogDebug($"DBG {group.GetName()}: {GetEntityNamesDbg(group.GetEntities())}");
+            }
+
+            AccessibilityUtils.LogDebug("DBG Grouping affectedEntities speeches");
+            var groupedSpeeches = GroupSpeeches(affectedEntities, groups, affectedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping transformedEntities speeches");
+            var groupedTransformedSpeeches = GroupSpeeches(transformedEntities, groups, transformedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping justDiedEntities speeches");
+            var groupedDeathSpeeches = GroupSpeeches(justDiedEntities, groups, deadEntitySpeeches, false);
+
+            ret.AddRange(newEntitySpeeches);
+            ret.AddRange(groupedMovementSpeeches);
+            ret.AddRange(groupedTransformedSpeeches);
+            ret.AddRange(groupedDeathSpeeches);
+            ret.AddRange(groupedSpeeches);
+
+            return ret;
+        }
+
+        private static void AddOtherThanSourceEntityGroups(Entity source, List<Entity> entities, List<EntityGroup> groups, string groupName)
+        {
+            var otherEntities = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                if (entity.GetEntityId() != source.GetEntityId())
+                {
+                    otherEntities.Add(entity);
+                }
+            }
+
+            if (otherEntities.Count > 1)
+            {
+                groups.Add(new EntityGroup(groupName, otherEntities));
+            }
+        }
+
+        private static void AddSameNameEntityGroups(List<Entity> entities, List<EntityGroup> groups, string prefix)
+        {
+            Dictionary<string, List<Entity>> entitiesByName = new Dictionary<string, List<Entity>>();
+
+            foreach (var entity in entities)
+            {
+                if (!entitiesByName.ContainsKey(entity.GetName()))
+                {
+                    var newList = new List<Entity>();
+                    newList.Add(entity);
+                    entitiesByName.Add(entity.GetName(), newList);
+                }
+                else
+                {
+                    entitiesByName[entity.GetName()].Add(entity);
+                }
+            }
+
+            foreach (var entry in entitiesByName)
+            {
+                if (entry.Value.Count > 1)
+                {
+                    groups.Add(new EntityGroup($"{prefix} {entry.Value.Count} {entry.Key}", entry.Value));
+                }
+            }
+        }
+
+        private static List<string> GroupSpeeches(List<EntityDiff> entityDiffs, List<EntityGroup> groups, Dictionary<Entity, string> entitySpeeches, bool useZoneOrder)
+        {
+            var handled = new Dictionary<Entity, bool>(new EntityComparer());
+            var entities = new List<Entity>(entityDiffs.Count);
+
+            entityDiffs.ForEach(e => entities.Add(e.GetBeforeEntity()));
+            entityDiffs.ForEach(e => handled.Add(e.GetBeforeEntity(), false));
+
+            var groupedSpeeches = new Dictionary<string, string>();
+
+            AccessibilityUtils.LogDebug("DBG Grouping speeches");
+            AccessibilityUtils.LogDebug($"DBG entities: {GetEntityNamesDbg(entities)}");
+            AccessibilityUtils.LogDebug($"DBG speeches:");
+            foreach (var entry in entitySpeeches)
+            {
+                AccessibilityUtils.LogDebug($"DBG {entry.Key.GetName()}: {entry.Value}");
+            }
+
+            foreach (var group in groups)
+            {
+                if (group.GetEntities().Count > 1 && group.IsSubsetOf(entities))
+                {
+                    AccessibilityUtils.LogDebug($"DBG Group with > 1 and subset found: {group.GetName()}");
+                    if (!SpeechesAlreadyHandled(group, handled) && AllEntitiesShareSpeech(group.GetEntities(), entitySpeeches))
+                    {
+                        AccessibilityUtils.LogDebug($"DBG Handling group {group.GetName()}");
+                        var speech = entitySpeeches[group.GetEntities()[0]];
+                        speech = AccessibleSpeechUtils.PluralizeFirstVerbIfNeeded(speech);
+
+                        groupedSpeeches[group.GetName()] = speech;
+                        MarkHandled(group, handled);
+                    }
+                }
+            }
+
+            var remainingEntities = GetUnhandledEntities(handled);
+            AccessibilityUtils.LogDebug($"DBG remainingEntities: {GetEntityNamesDbg(remainingEntities)}");
+            remainingEntities.ForEach(e =>
+            {
+                if (entitySpeeches.ContainsKey(e))
+                {
+                    // Only add if we have proper changes (e.g. being destroyed does not warrant a speech as it would be covered by death anyways)
+                    if (useZoneOrder)
+                    {
+                        groupedSpeeches.Add(GetFullNameInZone(e), entitySpeeches[e]);
+                    }
+                    else
+                    {
+                        // e.g. Death speeches (since we may have more than one in graveyard)
+                        groupedSpeeches.Add(GetFullNameInList(e, remainingEntities), entitySpeeches[e]);
+                    }
+                }
+            });
+
+            return CombineSpeeches(groupedSpeeches);
+        }
+
+        private static string GetEntityNamesDbg(List<Entity> entities)
+        {
+            var sb = new StringBuilder();
+            sb.Append("[");
+
+            for (int i = 0; i < entities.Count; i++)
+            {
+                if (i != 0)
+                {
+                    sb.Append(", ");
+                }
+
+                sb.Append(entities[i].GetName());
+            }
+
+            sb.Append("]");
+            return sb.ToString();
+        }
+
+        private static string GetEntityNamesDbg(List<EntityDiff> entityDiffs)
+        {
+            var entities = new List<Entity>(entityDiffs.Count);
+
+            foreach (var diff in entityDiffs)
+            {
+                entities.Add(diff.GetAfterEntity());
+            }
+
+            return GetEntityNamesDbg(entities);
+        }
+
+        private static List<string> CombineSpeeches(Dictionary<string, string> speeches)
+        {
+            var ret = new List<string>();
+            var speechToEntityNames = new Dictionary<string, List<string>>();
+
+            foreach (var entry in speeches)
+            {
+                if (speechToEntityNames.ContainsKey(entry.Value))
+                {
+                    speechToEntityNames[entry.Value].Add(entry.Key);
+                }
+                else
+                {
+                    speechToEntityNames.Add(entry.Value, new List<string> { entry.Key });
+                }
+            }
+
+            foreach (var entry in speechToEntityNames)
+            {
+                var speech = entry.Key;
+                var entities = entry.Value;
+
+                if (entities.Count > 1)
+                {
+                    speech = PluralizeFirstVerbIfNeeded(speech);
+                }
+
+                ret.Add($"{AccessibleSpeechUtils.HumanizeList(entities)} {speech}");
+            }
+
+            return ret;
+        }
+
+        private static bool AllEntitiesShareSpeech(List<Entity> entities, Dictionary<Entity, string> speeches)
+        {
+            string speech = null;
+
+            foreach (var entity in entities)
+            {
+                if (!speeches.ContainsKey(entity))
+                {
+                    return false;
+                }
+
+                if (speech == null)
+                {
+                    speech = speeches[entity];
+                }
+                else if (speeches[entity] != speech)
+                {
+                    return false;
+                }
+            }
+
+            return speech.Length > 0; // We're not interested if they're not saying anything
+        }
+
+        private static bool SpeechesAlreadyHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                if (handled[entity])
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private static void MarkHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                handled[entity] = true;
+            }
+        }
+
+        private static List<Entity> GetUnhandledEntities(Dictionary<Entity, bool> handled)
+        {
+            var ret = new List<Entity>();
+
+            foreach (var entry in handled)
+            {
+                if (!entry.Value)
+                {
+                    ret.Add(entry.Key);
+                }
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, string> GetEntitySpeeches(List<EntityDiff> entities)
+        {
+            var ret = new Dictionary<Entity, string>(new EntityComparer());
+
+            foreach (var entity in entities)
+            {
+                var desc = entity.GetDiffDescription();
+
+                if (desc.Length > 0)
+                {
+                    ret[entity.GetAfterEntity()] = desc;
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetNewEntitySpeeches(List<Entity> entities)
+        {
+            var ret = new List<string>();
+            var addedToPlayerHand = new List<string>();
+            var addedToOpponentHand = new List<string>();
+            var addedToPlayerDeck = new List<string>();
+            var addedToOpponentDeck = new List<string>();
+            var addedToPlayerBattlefield = new List<string>();
+            var addedToOpponentBattlefield = new List<string>();
+            var addedToPlayerSecrets = new List<string>();
+            var addedToOpponentSecrets = new List<string>();
+
+            foreach (var entity in entities)
+            {
+                Zone curZone = entity.GetCard().GetZone();
+
+                string cardName = GetCardNameForZoneMovement(entity);
+
+                Zone playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+                Zone opponentHand = GameState.Get().GetOpposingSidePlayer().GetHandZone();
+                Zone playerDeck = GameState.Get().GetFriendlySidePlayer().GetDeckZone();
+                Zone opponentDeck = GameState.Get().GetOpposingSidePlayer().GetDeckZone();
+                Zone playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+                Zone opponentBattlefield = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+                Zone playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+                Zone opponentSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone();
+
+                // Spawned card
+                if (curZone == playerHand)
+                {
+                    addedToPlayerHand.Add(cardName);
+                }
+                else if (curZone == opponentHand)
+                {
+                    addedToOpponentHand.Add(cardName);
+                }
+                else if (curZone == playerDeck)
+                {
+                    addedToPlayerDeck.Add(cardName);
+                }
+                else if (curZone == opponentDeck)
+                {
+                    addedToOpponentDeck.Add(cardName);
+                }
+                else if (curZone == playerBattlefield)
+                {
+                    addedToPlayerBattlefield.Add(cardName);
+                }
+                else if (curZone == opponentBattlefield)
+                {
+                    addedToOpponentBattlefield.Add(cardName);
+                }
+                else if (entity.GetCard() == GameState.Get().GetFriendlySidePlayer().GetWeaponCard())
+                {
+                    ret.Add($"your Hero equipped one {cardName}");
+                }
+                else if (entity.GetCard() == GameState.Get().GetOpposingSidePlayer().GetWeaponCard())
+                {
+                    ret.Add($"your opponent's Hero equipped one {cardName}");
+                }
+                else if (curZone == playerSecrets)
+                {
+                    addedToPlayerSecrets.Add(cardName);
+                }
+                else if (curZone == opponentSecrets)
+                {
+                    var secretClass = entity.GetClass();
+                    addedToOpponentSecrets.Add(secretClass.ToString());
+                }
+                else if (entity == GameState.Get().GetFriendlySidePlayer().GetHeroPower())
+                {
+                    ret.Add($"your Hero power became {cardName}");
+                }
+                else if (entity == GameState.Get().GetOpposingSidePlayer().GetHeroPower())
+                {
+                    ret.Add($"your opponent's Hero power became {cardName}");
+                }
+            }
+
+            InsertZoneMovements(ret, addedToPlayerHand, "", "was", "were", "added to your hand");
+            InsertZoneMovements(ret, addedToOpponentHand, "", "was", "were", "added to your opponent's hand");
+            InsertZoneMovements(ret, addedToPlayerDeck, "", "was", "were", "shuffled into your deck");
+            InsertZoneMovements(ret, addedToOpponentDeck, "", "was", "were", "shuffled into your opponent's deck");
+            InsertZoneMovements(ret, addedToPlayerBattlefield, "", "was", "were", "summoned into your battlefield");
+            InsertZoneMovements(ret, addedToOpponentBattlefield, "", "was", "were", "summoned into your opponent's battlefield");
+            //InsertZoneMovements(ret, addedToPlayerSecrets, "you cast", "", "", "", ""); // Ran into a "you cast ice barrier. you cast 1 ice barrier" thingy. Testing like this
+            InsertZoneMovements(ret, addedToOpponentSecrets, "your opponent cast", "", "", "secret", "secrets");
+
+            return ret;
+        }
+
+        private static List<string> GetZoneMovementSpeeches(List<EntityDiff> entities, List<EntityGroup> groups)
+        {
+            var drawnPlayerCards = new List<string>();
+            var drawnOpponentCards = new List<string>();
+            var discardedPlayerCards = new List<string>();
+            var discardedOpponentCards = new List<string>();
+            var takenControlByPlayerCards = new List<string>();
+            var takenControlByOpponentCards = new List<string>();
+            var castPlayerSecrets = new List<string>();
+            int castOpponentSecrets = 0;
+
+            var speeches = new Dictionary<Entity, string>(new EntityComparer());
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerHand = player.GetHandZone();
+            var opponentHand = opponent.GetHandZone();
+            var playerMinions = player.GetBattlefieldZone();
+            var opponentMinions = opponent.GetBattlefieldZone();
+            var playerSecrets = player.GetSecretZone();
+            var opponentSecrets = opponent.GetSecretZone();
+            var playerDeck = player.GetDeckZone();
+            var opponentDeck = opponent.GetDeckZone();
+            var playerGraveyard = player.GetGraveyardZone();
+            var opponentGraveyard = opponent.GetGraveyardZone();
+            var playerWeaponCard = player.GetWeaponCard();
+            var opponentWeaponCard = opponent.GetWeaponCard();
+
+            var zoneNames = new Dictionary<Zone, string>();
+            zoneNames.Add(playerHand, "your hand");
+            zoneNames.Add(opponentHand, "your opponent's hand");
+            zoneNames.Add(playerMinions, "your battlefield");
+            zoneNames.Add(opponentMinions, "your opponent's battlefield");
+            zoneNames.Add(playerSecrets, "your secrets");
+            zoneNames.Add(opponentSecrets, "your opponent's secrets");
+            zoneNames.Add(playerDeck, "your deck");
+            zoneNames.Add(opponentDeck, "your opponent's deck");
+            zoneNames.Add(playerGraveyard, "your graveyard");
+            zoneNames.Add(opponentGraveyard, "your opponent's graveyard");
+
+            foreach (var entity in entities)
+            {
+                var before = entity.GetBeforeEntity();
+                var after = entity.GetAfterEntity();
+
+                var beforeZoneType = before.GetZone();
+                var afterZoneType = after.GetZone();
+
+                var beforeZone = GetZone(before);
+                var afterZone = GetZone(after);
+
+                // Note: play->graveyard movements are currently covered by EntityDiffs themselves (when checking HasMoved)
+                // Other -> graveyard movements aren't though (e.g. secrets being triggered)
+                if (afterZoneType == TAG_ZONE.GRAVEYARD)
+                {
+                    if (beforeZoneType != TAG_ZONE.PLAY && beforeZoneType != TAG_ZONE.SECRET)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+
+                    continue;
+                }
+
+                // Weapons are edge cases since we don't really know if they were equipped before or not
+                if (beforeZoneType == TAG_ZONE.PLAY && before.GetCardType() == TAG_CARDTYPE.WEAPON && before.GetControllerSide() == Player.Side.FRIENDLY)
+                {
+                    if (before.GetControllerSide() == Player.Side.FRIENDLY && afterZone == playerHand)
+                    {
+                        speeches.Add(after, "returned to your hand");
+                    }
+                    else if (before.GetControllerSide() == Player.Side.OPPOSING && afterZone == opponentHand)
+                    {
+                        speeches.Add(after, "returned to your opponent's hand");
+                    }
+                    else
+                    {
+                        speeches.Add(after, $"moved to {afterZone}");
+                    }
+
+                    continue;
+                }
+
+                // Fallback zones
+                if (beforeZone == null || afterZone == null)
+                {
+                    if (after.GetZone() == TAG_ZONE.SETASIDE)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+                    else
+                    {
+                        speeches.Add(after, "moved zones");
+                    }
+
+                    continue;
+                }
+
+                // Normal scenarios
+                if (zoneNames.ContainsKey(beforeZone) && zoneNames.ContainsKey(afterZone))
+                {
+                    if (beforeZone == playerDeck && afterZone == playerHand)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+                        drawnPlayerCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentDeck && afterZone == opponentHand)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+                        drawnOpponentCards.Add(cardName);
+                    }
+                    else if ((beforeZone == playerMinions || beforeZone == playerSecrets) && afterZone == playerHand)
+                    {
+                        speeches.Add(after, "returned to your hand");
+                    }
+                    else if ((beforeZone == opponentMinions || beforeZone == opponentSecrets) && afterZone == opponentHand)
+                    {
+                        speeches.Add(after, "returned to your opponent's hand");
+                    }
+                    else if (beforeZone == playerMinions && afterZone == opponentMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByOpponentCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentMinions && afterZone == playerMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByPlayerCards.Add(cardName);
+                    }
+                    else if (afterZone == opponentSecrets)
+                    {
+                        castOpponentSecrets++;
+                    }
+                    else if (afterZone == playerSecrets)
+                    {
+                        var cardName = GetName(after);
+                        castPlayerSecrets.Add(cardName);
+                    }
+                    else
+                    {
+                        var beforeZoneName = zoneNames[beforeZone];
+                        var afterZoneName = zoneNames[afterZone];
+                        speeches.Add(after, $"moved from {beforeZoneName} into {afterZoneName}");
+                    }
+                }
+                else if (zoneNames.ContainsKey(afterZone))
+                {
+                    speeches.Add(after, $"moved into {zoneNames[afterZone]}");
+                }
+                else
+                {
+                    speeches.Add(after, "moved zones");
+                }
+            }
+
+            var groupedMovementSpeeches = GroupSpeeches(entities, groups, speeches, false);
+
+            var ret = new List<string>();
+            InsertZoneMovements(ret, drawnPlayerCards, "you drew", "", "", "", "");
+            InsertZoneMovements(ret, drawnOpponentCards, "your opponent drew", "", "", "", "");
+            InsertZoneMovements(ret, discardedPlayerCards, "you discarded", "", "", "", "");
+            InsertZoneMovements(ret, discardedOpponentCards, "your opponent discarded", "", "", "", "");
+            InsertZoneMovements(ret, takenControlByPlayerCards, "you took control of", "", "", "", "");
+            InsertZoneMovements(ret, takenControlByOpponentCards, "your opponent took control of", "", "", "", "");
+            InsertZoneMovements(ret, castPlayerSecrets, "you cast", "", "", "", "");
+
+            if (castOpponentSecrets > 0)
+            {
+                var suffix = castOpponentSecrets > 1 ? "s" : "";
+                ret.Add($"Your opponent cast {castOpponentSecrets} secret{suffix}");
+            }
+
+            ret.AddRange(groupedMovementSpeeches);
+
+            return ret;
+        }
+
+        private static Zone GetZone(Entity entity)
+        {
+            var controller = entity.GetController();
+
+            switch(entity.GetZone())
+            {
+                case TAG_ZONE.PLAY:
+                    return controller.GetBattlefieldZone();
+                case TAG_ZONE.DECK:
+                    return controller.GetDeckZone();
+                case TAG_ZONE.HAND:
+                    return controller.GetHandZone();
+                case TAG_ZONE.GRAVEYARD:
+                    return controller.GetGraveyardZone();
+                case TAG_ZONE.SECRET:
+                    return controller.GetSecretZone();
+                default:
+                    return null;
+            }
+        }
+
+        private static void InsertZoneMovements(List<string> ret, List<string> cards, string prefix, string verbSingular, string verbPlural, string suffix)
+        {
+            InsertZoneMovements(ret, cards, prefix, verbSingular, verbPlural, suffix, suffix);
+        }
+
+        private static void InsertZoneMovements(List<string> ret, List<string> cards, string prefix, string verbSingular, string verbPlural, string suffixSingular, string suffixPlural)
+        {
+            if (cards.Count == 0)
+            {
+                return;
+            }
+
+            if (cards.Count == 1)
+            {
+                string desc = $"{prefix} 1 {cards[0]} {verbSingular} {suffixSingular}".Trim();
+                ret.Add(desc);
+            }
+            else
+            {
+                var counts = new Dictionary<string, int>();
+                foreach (var card in cards)
+                {
+                    if (!counts.ContainsKey(card))
+                    {
+                        counts.Add(card, 1);
+                    }
+                    else
+                    {
+                        counts[card]++;
+                    }
+                }
+
+                var cardNames = AccessibleSpeechUtils.HumanizeNames(cards, counts);
+
+                string desc = $"{prefix} {cardNames} {verbPlural} {suffixPlural}".Trim();
+                ret.Add(desc);
+            }
+        }
+
+        private static string GetCardNameForZoneMovement(Entity entity)
+        {
+            if (entity.GetCardType() != TAG_CARDTYPE.INVALID)
+            {
+                return entity.GetName();
+            }
+            else
+            {
+                return "card";
+            }
+        }
+
+        private static Dictionary<Entity, string> GetTransformedEntitySpeeches(List<EntityDiff> transformedEntities)
+        {
+            var ret = new Dictionary<Entity, string>(new EntityComparer());
+
+            foreach (var entity in transformedEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetTransformedSpeech();
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, string> GetDeadEntitySpeeches(List<EntityDiff> deadEntities)
+        {
+            var ret = new Dictionary<Entity, string>(new EntityComparer());
+
+            foreach (var entity in deadEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetDeathSpeech();
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> list, Entity entity)
+        {
+            var ret = new List<Entity>(list.Count + 1);
+            ret.AddRange(list);
+            ret.Add(entity);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> l1, List<Entity> l2)
+        {
+            var ret = new List<Entity>(l1.Count + l2.Count);
+            ret.AddRange(l1);
+            ret.AddRange(l2);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(Entity e1, Entity e2)
+        {
+            var ret = new List<Entity>(2);
+            ret.Add(e1);
+            ret.Add(e2);
+            return ret;
+        }
+
+        private static void DebugEntityDiffs(List<EntityDiff> entityDiffs)
+        {
+            AccessibilityUtils.LogDebug("DebugEntityDiffs start");
+            foreach (var diff in entityDiffs)
+            {
+                var rawDiff = diff.GetRawDiff();
+                if (rawDiff.Count > 0)
+                {
+                    AccessibilityUtils.LogDebug($"DBG {diff.GetAfterEntity().GetName()}:");
+                    foreach (var entry in rawDiff)
+                    {
+                        AccessibilityUtils.LogDebug($"DBG {entry}");
+                    }
+                }
+                else
+                {
+                    AccessibilityUtils.LogDebug($"DBG {diff.GetAfterEntity().GetName()} - NO CHANGES");
+                }
+            }
+        }
+
+        internal static string DescribeDiff(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var lines = new List<string>();
+
+            // Handle starting turn when the game has just been created
+            if (before == null && after != null && after.m_gameCreated)
+            {
+                // TODO: describer already has logic for this as well and Hogger is weird. Need to think
+                return null;
+            }
+
+            if (before == null || after == null || !before.m_gameCreated || !after.m_gameCreated)
+            {
+                return null;
+            }
+
+            var sourceEntity = taskList.GetSourceEntity();
+
+            AccessibilityUtils.LogDebug($"DBG Describing diff. sourceEntity={sourceEntity}");
+            AccessibilityUtils.LogDebug(Environment.StackTrace);
+            AccessibilityUtils.LogDebug("DebugDiff done");
+
+            lines.AddRange(GetSpeechLines(taskList, before, after));
+
+            // Turn stuff. At the end so we describe any pending triggers before this (done when NEXT_STEP = MAIN_START)
+            if (before.m_step != after.m_step && after.m_step == TAG_STEP.MAIN_START && after.m_currentPlayer == GameState.Get().GetFriendlySidePlayer())
+            {
+                // TODO: Doing this in powerlist describer now to see if it makes more sense to sync up with the animation
+                //lines.Add($"You have {after.m_playerAvailableResources} mana");
+            }
+            else if (after.m_step > TAG_STEP.MAIN_START && after.m_step < TAG_STEP.MAIN_END)
+            {
+                lines.AddRange(GetResourceChanges(before, after));
+            }
+
+            lines.AddRange(GetSpellpowerChanges(before, after));
+
+            return CombineLines(lines);
+        }
+
+        private static List<string> GetSpellpowerChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            if (before.m_playerSpellpower < after.m_playerSpellpower)
+            {
+                ret.Add($"You gained {after.m_playerSpellpower - before.m_playerSpellpower} Spell Damage");
+            }
+            else if (after.m_playerSpellpower < before.m_playerSpellpower)
+            {
+                ret.Add($"You lost {before.m_playerSpellpower - after.m_playerSpellpower} Spell Damage");
+            }
+
+            if (before.m_opponentSpellpower < after.m_opponentSpellpower)
+            {
+                ret.Add($"Your opponent gained {after.m_opponentSpellpower - before.m_opponentSpellpower} Spell Damage");
+            }
+            else if (after.m_opponentSpellpower < before.m_opponentSpellpower)
+            {
+                ret.Add($"Your opponent lost {before.m_opponentSpellpower - after.m_opponentSpellpower} Spell Damage");
+            }
+
+            return ret;
+        }
+
+        private static string CombineLines(List<string> lines)
+        {
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (sb.Length > 0)
+                {
+                    sb.Append(". ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetResourceChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            var playerAvailableResourcesDiff = after.m_playerAvailableResources - before.m_playerAvailableResources;
+            var playerResourcesDiff = after.m_playerResources - before.m_playerResources;
+            var opponentAvailableResourcesDiff = after.m_opponentAvailableResources - before.m_opponentAvailableResources;
+            var opponentResourcesDiff = after.m_opponentResources - before.m_opponentResources;
+
+            ret.AddRange(GetResourceChanges("You", playerAvailableResourcesDiff, playerResourcesDiff));
+            ret.AddRange(GetResourceChanges("Your opponent", opponentAvailableResourcesDiff, opponentResourcesDiff));
+
+            return ret;
+        }
+
+        private static List<string> GetResourceChanges(string playerLabel, int availableResourcesDiff, int resourcesDiff)
+        {
+            var ret = new List<string>();
+
+            var manaCrystalsLabel = "mana crystal";
+
+            if (resourcesDiff > 0)
+            {
+                if (availableResourcesDiff > 0)
+                {
+                    if (availableResourcesDiff >= resourcesDiff)
+                    {
+                        ret.Add($"{playerLabel} gained {availableResourcesDiff} mana");
+                    }
+                    else
+                    {
+                        var numEmptyManaCrystals = resourcesDiff - availableResourcesDiff;
+                        var emptyManaCrystalsLabel = numEmptyManaCrystals > 1 ? $"{manaCrystalsLabel}s" : manaCrystalsLabel;
+
+                        ret.Add($"{playerLabel} gained {availableResourcesDiff} mana and {availableResourcesDiff} empty {emptyManaCrystalsLabel}");
+                    }
+                }
+                else
+                {
+                    var emptyManaCrystalsLabel = resourcesDiff > 1 ? $"{manaCrystalsLabel}s" : manaCrystalsLabel;
+                    ret.Add($"{playerLabel} gained {resourcesDiff} empty {emptyManaCrystalsLabel}");
+                }
+            }
+            else if (availableResourcesDiff > 0)
+            {
+                ret.Add($"{playerLabel} gained {availableResourcesDiff} mana");
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetSpeechLines(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            return GetDiffSpeech(taskList.GetSourceEntity(), before, after);
+        }
+
+        private static List<EntityDiff> GetAffectedEntities(List<EntityDiff> entityDiffs)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (diff.HasChanges())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> CreateEntityDiffs(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                var entityAfter = after.GetEntity(entityBefore.GetEntityId());
+
+                if (entityAfter != null)
+                {
+                    ret.Add(new EntityDiff(entityBefore, entityAfter, before, after));
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetMovedEntities(Entity sourceEntity, List<EntityDiff> entityDiffs, List<Entity> entitiesAfterMovement)
+        {
+            var ret = new List<EntityDiff>();
+
+            // Must iterate through entitiesAfterMovement or they will be out of order. e.g. drawing 2 cards means drawing the last 2 from your deck into your hand in rev order
+            Dictionary<Entity, EntityDiff> entityAfterToEntityDiff = new Dictionary<Entity, EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (!entityAfterToEntityDiff.ContainsKey(diff.GetAfterEntity()))
+                {
+                    entityAfterToEntityDiff.Add(diff.GetAfterEntity(), diff);
+                }
+                else
+                {
+                    Log.Accessibility.Print($"Ignored duplicate entity in GetMovedEntities: {diff.GetAfterEntity().GetName()}");
+                }
+            }
+
+            var orderedEntityDiffs = new List<EntityDiff>(entityDiffs.Count);
+
+            foreach (var entity in entitiesAfterMovement)
+            {
+                if (entityAfterToEntityDiff.ContainsKey(entity))
+                {
+                    orderedEntityDiffs.Add(entityAfterToEntityDiff[entity]);
+                }
+            }
+
+            foreach (var diff in orderedEntityDiffs)
+            {
+                if (sourceEntity != null && diff.GetEntityId() == sourceEntity.GetEntityId())
+                {
+                    // Ignore source as we handle explicit movement outside (in the powerTaskList describer)
+                    continue;
+                }
+
+                if (diff.MovedZone())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetDestroyedEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                if (after.GetEntity(entityBefore.GetEntityId()) == null)
+                {
+                    ret.Add(entityBefore);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetNewEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityAfter in after.m_entities)
+            {
+                if (before.GetEntity(entityAfter.GetEntityId()) == null)
+                {
+                    ret.Add(entityAfter);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetTransformedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasTransformed())
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetJustDiedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasDied() && entityDiff.GetDeathSpeech().Length > 0) // Length > 0 is because of replacing weapons e.g. equipping 1 wicked knife when 1 already exists
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> Clone(List<Entity> entities)
+        {
+            List<Entity> ret = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                ret.Add(entity.CloneForAccessibility());
+            }
+
+            return ret;
+        }
+
+        private static Entity Clone(Entity entity)
+        {
+            if (entity == null)
+            {
+                return null;
+            }
+
+            return entity.CloneForAccessibility();
+        }
+
+        private static List<Entity> GetEntitiesFromZone(Zone zone)
+        {
+            var ret = new List<Entity>();
+            var cards = zone.GetCards();
+
+            if (cards == null)
+            {
+                return ret;
+            }
+
+            foreach (var card in cards)
+            {
+                ret.Add(card.GetEntity());
+            }
+
+            return ret;
+        }
+        internal static bool PlayingTutorial()
+        {
+            return GameState.Get().GetGameEntity() is TutorialEntity;
+        }
+
+        #region Weapon stuff
+
+        private static HashSet<Entity> s_heroWeaponBroke = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroSheathedWeapon = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroUnsheathedWeapon = new HashSet<Entity>(new EntityComparer());
+
+        internal static void MarkWeaponUnsheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponUnsheathed: {hero}");
+            s_heroUnsheathedWeapon.Add(hero);
+        }
+
+        internal static void MarkWeaponSheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponSheathed: {hero}");
+            s_heroSheathedWeapon.Add(hero);
+        }
+
+
+        internal static void Reset()
+        {
+            s_heroWeaponBroke.Clear();
+            s_heroSheathedWeapon.Clear();
+            s_heroUnsheathedWeapon.Clear();
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
new file mode 100644
index 0000000..541cb10
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
@@ -0,0 +1,192 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleInputMgr : MonoBehaviour
+    {
+        private static bool[] m_setMouseButtonDown = new bool[3];
+
+        private static Vector3 m_setMousePosition = Vector3.zero;
+
+        private void LateUpdate()
+        {
+            AccessibleUnityInput.Get().SetMousePosition(m_setMousePosition);
+
+            for (int button = 0; button < m_setMouseButtonDown.Length; button++) 
+            {
+                AccessibleUnityInput.Get().SetMouseButtonDown(button, m_setMouseButtonDown[button]);
+                m_setMouseButtonDown[button] = false; // TODO: Would have to add a lot more logic if we wanted to hold/drag/etc. but don't think that'll be needed
+            }
+
+            if (AccessibleKey.TOGGLE_ACCESSIBILITY.IsPressed())
+            {
+                AccessibleUnityInput.Get().ToggleEnabled();
+                AccessibilityMgr.ToggleEnabled();
+            }
+
+            // Debug stuff
+            if (HearthstoneAccessConstants.DEV_MODE && Input.GetKeyUp(KeyCode.F6))
+            {
+                Vector3 dbgMousePos = Input.mousePosition;
+                AccessibilityUtils.LogDebug($"[DBG] Mouse position is {dbgMousePos}");
+            }
+        }
+
+        private static void ClickLeftMouseButtonImpl()
+        {
+            AccessibilityUtils.LogDebug($"[DBG] Clicked left mouse at {m_setMousePosition}");
+            m_setMouseButtonDown[0] = true;
+        }
+
+        public static void ClickLeftMouseButton()
+        {
+            ClickLeftMouseButtonImpl();
+        }
+
+        public static void ClickLeftMouseButton(Component component)
+        {
+            MoveMouseTo(component);
+            ClickLeftMouseButtonImpl();
+        }
+
+        internal static void ClickRightMouseButton()
+        {
+            m_setMouseButtonDown[1] = true;
+        }
+
+        private static void ClickMiddleMouseButton()
+        {
+            m_setMouseButtonDown[2] = true;
+        }
+
+        private static void SetMousePosition(Vector3 pos)
+        {
+            m_setMousePosition = pos;
+        }
+
+        internal static void MoveMouseTo(Component component)
+        {
+            if (component == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(component.transform);
+        }
+
+        internal static Vector3 GetMousePosition(Component component)
+        {
+            return GetMousePosition(component.transform);
+        }
+
+        internal static void MoveMouseToTransform(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+
+            MoveMouseToWorldPosition(transform.position);
+        }
+
+        internal static Vector3 GetMousePosition(Transform transform)
+        {
+            return GetMousePosition(transform.position);
+        }
+
+        public static void ClickCenterOfScreen()
+        {
+            MoveMouseToCenterOfScreen();
+            ClickLeftMouseButton();
+        }
+
+        internal static void MoveMouseToCenterOfScreen()
+        {
+            var center = new Vector3(Screen.width / 2, Screen.height / 2);
+            SetMousePosition(center);
+        }
+
+        internal static void MoveMouseToWorldPosition(Vector3 pos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(pos);
+            screenPos.z = 0;
+            SetMousePosition(screenPos);
+        }
+
+        internal static Vector3 GetMousePosition(Vector3 worldPos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPos);
+            screenPos.z = 0;
+            return screenPos;
+        }
+
+        internal static void HideMouse()
+        {
+            SetMousePosition(Vector3.zero);
+        }
+
+        internal static void Click(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(transform);
+            ClickLeftMouseButton();
+        }
+
+        internal static void Click(Vector3 worldPosition)
+        {
+            SetMousePosition(worldPosition);
+            ClickLeftMouseButton();
+        }
+
+        private static bool m_holdingAnyKeyDown;
+
+        internal static bool AnyKeyUp()
+        {
+            var ret = false;
+
+            if (Input.anyKey)
+            {
+                m_holdingAnyKeyDown = true;
+            }
+
+            if (!Input.anyKey)
+            {
+                if (m_holdingAnyKeyDown)
+                {
+                    ret = true;
+                }
+
+                m_holdingAnyKeyDown = false;
+            }
+
+            return ret;
+        }
+
+        internal static int? TryGetPressedNumKey()
+        {
+            for (var i = 0; i <= 9; i++)
+            {
+                if (Input.GetKeyUp(KeyCode.Alpha0 + i))
+                {
+                    if (i == 0)
+                    {
+                        return 10;
+                    } else
+                    {
+                        return i;
+                    }
+                }
+            }
+
+            return null;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs
new file mode 100644
index 0000000..da27390
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleItem.cs
@@ -0,0 +1,172 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    abstract class AccessibleItem
+    {
+        // TODO: consider having short vs long descriptions in the future?
+        private string[] m_lines;
+
+        private int m_curLine;
+
+        private Action m_finishReadAction;
+
+        protected AccessibleItem() : this(0) { }
+
+        protected AccessibleItem(int startReadingFromLine)
+        {
+            m_curLine = startReadingFromLine;
+        }
+
+        private void SetupLines()
+        {
+            var lines = GetLines();
+            m_lines = lines.ToArray();
+        }
+
+        internal abstract List<string> GetLines();
+
+        internal void ReadLine()
+        {
+            SetupLines();
+            ReadLineImpl();
+        }
+
+        internal void ReadLine(int line)
+        {
+            SetupLines();
+            ReadLineImpl(line);
+        }
+
+        internal string GetLine(int line)
+        {
+            SetupLines();
+
+            if (line >= m_lines.Length)
+            {
+                return "";
+            }
+
+            return m_lines[line];
+        }
+
+        private void ReadLineImpl()
+        {
+            ReadLineImpl(m_curLine);
+        }
+
+        private void ReadLineImpl(int line)
+        {
+            if (line >= m_lines.Length)
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output($"{m_lines[line]}");
+        }
+
+        internal void ReadNextLine()
+        {
+            SetupLines();
+
+            if (IncLine(1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void ReadPrevLine()
+        {
+            SetupLines();
+            if (IncLine(-1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void Reset()
+        {
+            m_curLine = 0;
+        }
+
+        private bool IncLine(int inc)
+        {
+            m_curLine += inc;
+
+            if (m_curLine < 0)
+            {
+                m_curLine = 0;
+                return false;
+            }
+            else if (m_curLine >= m_lines.Length)
+            {
+                m_curLine = m_lines.Length - 1;
+                return false;
+            }
+
+            if (m_curLine == m_lines.Length - 1)
+            {
+                OnFinishReading();
+            }
+
+            return true; // new line
+        }
+
+        private void OnFinishReading()
+        {
+            if (m_finishReadAction != null)
+            {
+                m_finishReadAction();
+                m_finishReadAction = null;
+            }
+        }
+
+        internal void RegisterFinishReadListener(Action action)
+        {
+            m_finishReadAction = action;
+        }
+
+        internal void ReadAllLines()
+        {
+            if (m_curLine == 0)
+            {
+                SetupLines();
+            }
+
+            while (m_curLine < m_lines.Length - 1)
+            {
+                ReadLineImpl();
+                IncLine(1); // This has a guard so we need to read after as well
+            }
+
+            ReadLineImpl();
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadNextLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadPrevLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadLineImpl();
+                return true;
+            }
+            else if (AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadAllLines();
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs
new file mode 100644
index 0000000..4809243
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleKey.cs
@@ -0,0 +1,248 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleKey
+    {
+        internal static AccessibleKey CONFIRM = CreateKey(KeyCode.Return);
+        internal static AccessibleKey GLOBAL_CONFIRM = CreateGlobalKey(KeyCode.Return);
+        internal static AccessibleKey BACK = CreateKey(KeyCode.Backspace);
+        internal static AccessibleKey GLOBAL_BACK = CreateGlobalKey(KeyCode.Backspace);
+        internal static AccessibleKey OPEN_GAME_MENU = CreateGlobalKey(KeyCode.Escape);
+        internal static AccessibleKey HELP = CreateGlobalKey(KeyCode.F1);
+        internal static AccessibleKey TOGGLE_ACCESSIBILITY = CreateGlobalKey(KeyCode.F8);
+        internal static AccessibleKey READ_NEXT_LINE = CreateKey(KeyCode.DownArrow);
+        internal static AccessibleKey READ_PREV_LINE = CreateKey(KeyCode.UpArrow);
+        internal static AccessibleKey READ_CUR_LINE = CreateKey(KeyCode.UpArrow, true);
+        internal static AccessibleKey READ_TO_END = CreateKey(KeyCode.DownArrow, true);
+        internal static AccessibleKey READ_NEXT_ITEM = CreateKey(KeyCode.RightArrow);
+        internal static AccessibleKey READ_PREV_ITEM = CreateKey(KeyCode.LeftArrow);
+        internal static AccessibleKey READ_NEXT_VALID_ITEM = CreateKey(KeyCode.Tab);
+        internal static AccessibleKey READ_PREV_VALID_ITEM = CreateKey(KeyCode.Tab, true);
+
+        internal static AccessibleKey DECREASE_GAME_SPEED = CreateKey(KeyCode.F11);
+        internal static AccessibleKey INCREASE_GAME_SPEED = CreateKey(KeyCode.F12);
+
+        #region Menu Controls
+        internal static AccessibleKey READ_NEXT_MENU_OPTION = CreateKey(KeyCode.DownArrow);
+        internal static AccessibleKey READ_PREV_MENU_OPTION = CreateKey(KeyCode.UpArrow);
+        internal static AccessibleKey READ_NEXT_VALID_MENU_OPTION = CreateKey(KeyCode.Tab);
+        internal static AccessibleKey READ_PREV_VALID_MENU_OPTION = CreateKey(KeyCode.Tab, true);
+        internal static AccessibleKey READ_NEXT_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.DownArrow);
+        internal static AccessibleKey READ_PREV_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.UpArrow);
+        internal static AccessibleKey READ_NEXT_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab);
+        internal static AccessibleKey READ_PREV_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab, true);
+        #endregion
+
+        #region Hub
+        internal static AccessibleKey PLAY_SOLO_ADVENTURES = CreateKey(KeyCode.S);
+        internal static AccessibleKey MY_COLLECTION = CreateKey(KeyCode.C);
+        #endregion
+
+        #region Options
+        internal static AccessibleKey OPTIONS_REDUCE_VOLUME = CreateGlobalKey(KeyCode.LeftArrow);
+        internal static AccessibleKey OPTIONS_INCREASE_VOLUME = CreateGlobalKey(KeyCode.RightArrow);
+        #endregion
+
+        #region My Collection
+        internal static AccessibleKey SEE_DECKS = CreateKey(KeyCode.D);
+        internal static AccessibleKey CREATE_DECK = CreateKey(KeyCode.N);
+        internal static AccessibleKey DELETE_DECK = CreateKey(KeyCode.Delete);
+        internal static AccessibleKey EDIT_DECK = CreateKey(KeyCode.E);
+        #endregion
+
+        #region Game Keys
+        internal static AccessibleKey CONFIRM_MULLIGAN = CreateKey(KeyCode.Space);
+        internal static AccessibleKey SEE_PLAYER_HAND = CreateKey(KeyCode.C);
+        internal static AccessibleKey SEE_OPPONENT_HAND = CreateKey(KeyCode.C, true);
+        internal static AccessibleKey SEE_PLAYER_DECK = CreateKey(KeyCode.D);
+        internal static AccessibleKey SEE_OPPONENT_DECK = CreateKey(KeyCode.D, true);
+        internal static AccessibleKey SEE_PLAYER_MANA = CreateKey(KeyCode.A);
+        internal static AccessibleKey SEE_OPPONENT_MANA = CreateKey(KeyCode.A, true);
+        internal static AccessibleKey SEE_PLAYER_SECRETS = CreateKey(KeyCode.S);
+        internal static AccessibleKey SEE_OPPONENT_SECRETS = CreateKey(KeyCode.S, true);
+        internal static AccessibleKey SEE_PLAYER_MINIONS = CreateKey(KeyCode.B);
+        internal static AccessibleKey SEE_OPPONENT_MINIONS = CreateKey(KeyCode.G);
+        internal static AccessibleKey SEE_OPPONENT_HERO = CreateKey(KeyCode.F);
+        internal static AccessibleKey SEND_ALL_MINIONS_TO_FACE = CreateKey(KeyCode.F, true);
+        internal static AccessibleKey SEE_PLAYER_HERO = CreateKey(KeyCode.V);
+        internal static AccessibleKey SEE_PLAYER_HERO_POWER = CreateKey(KeyCode.R);
+        internal static AccessibleKey SEE_OPPONENT_HERO_POWER = CreateKey(KeyCode.R, true);
+        internal static AccessibleKey SEE_PLAYER_WEAPON = CreateKey(KeyCode.W);
+        internal static AccessibleKey SEE_OPPONENT_WEAPON = CreateKey(KeyCode.W, true);
+        internal static AccessibleKey SEE_HISTORY = CreateKey(KeyCode.Y);
+        internal static AccessibleKey END_TURN = CreateKey(KeyCode.E);
+        internal static AccessibleKey FORCE_END_TURN = CreateKey(KeyCode.E, true);
+        internal static AccessibleKey READ_TOOLTIP = CreateKey(KeyCode.I);
+        #endregion
+
+        private bool m_requiresModifier;
+
+        private KeyCode m_keyCode;
+
+        private bool m_enabled;
+
+        private AccessibleKey(KeyCode keyCode, bool requiresModifier = false)
+        {
+            m_keyCode = keyCode;
+            m_requiresModifier = requiresModifier;
+            m_enabled = true;
+        }
+
+        internal bool IsPressed()
+        {
+            if (!m_enabled)
+            {
+                if (Input.GetKeyUp(m_keyCode))
+                {
+                    AccessibilityUtils.LogDebug($"ZYY Tried to press {m_keyCode} but it was disabled");
+                }
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && Input.GetKeyUp(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && Input.GetKeyUp(m_keyCode);
+            }
+        }
+
+        internal bool IsDown()
+        {
+            if (!m_enabled)
+            {
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && Input.GetKey(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && Input.GetKey(m_keyCode);
+            }
+        }
+
+        internal bool IsPressedDown()
+        {
+            if (!m_enabled)
+            {
+                return false;
+            }
+
+            if (m_requiresModifier)
+            {
+                return IsHoldingModifier() && Input.GetKeyDown(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingModifier() && Input.GetKeyDown(m_keyCode);
+            }
+        }
+
+        private static bool IsHoldingModifier()
+        {
+            return Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
+        }
+
+        public override string ToString()
+        {
+            if (m_requiresModifier)
+            {
+                return $"Shift + {ReadKey(m_keyCode)}";
+            }
+            else
+            {
+                return ReadKey(m_keyCode);
+            }
+        }
+
+        private string ReadKey(KeyCode keyCode)
+        {
+            switch(keyCode)
+            {
+                case KeyCode.Return:
+                    return "Enter";
+                case KeyCode.A:
+                    return "eh"; // meh.. both NVDA and TTS had issues
+                default:
+                    return keyCode.ToString();
+            }
+        }
+
+        internal void Enable()
+        {
+            m_enabled = true;
+        }
+
+        internal void Disable()
+        {
+            m_enabled = false;
+        }
+
+        #region Key Registation
+        private static HashSet<AccessibleKey> s_allKeys;
+        private static HashSet<AccessibleKey> s_nonGlobalKeys;
+        private static HashSet<AccessibleKey> s_globalKeys;
+
+        private static AccessibleKey CreateKey(KeyCode keyCode, bool requiresModifier=false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresModifier);
+            s_allKeys.Add(newKey);
+            s_nonGlobalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static AccessibleKey CreateGlobalKey(KeyCode keyCode, bool requiresModifier=false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresModifier);
+            s_allKeys.Add(newKey);
+            s_globalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static void InitializeKeySetsIfNeeded()
+        {
+            if (s_allKeys == null)
+            {
+                s_allKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_nonGlobalKeys == null)
+            {
+                s_nonGlobalKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_globalKeys == null)
+            {
+                s_globalKeys = new HashSet<AccessibleKey>();
+            }
+        }
+
+        internal static HashSet<AccessibleKey> GetAllKeys(bool includeGlobals=true)
+        {
+            if (includeGlobals)
+            {
+                return s_allKeys;
+            }
+            else
+            {
+                return s_nonGlobalKeys;
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
new file mode 100644
index 0000000..db45671
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
@@ -0,0 +1,102 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleListOfItems<T> where T : AccessibleItem
+    {
+        private readonly List<T> m_items;
+
+        private int m_curItemIdx;
+
+        private T m_curItem;
+
+        internal int Count => m_items.Count;
+
+        internal List<T> Items => m_items;
+
+        internal AccessibleListOfItems(List<T> items)
+        {
+            m_items = items;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                return ReadNextItem(1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                return ReadNextItem(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                return ReadNextItem(1, true);
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                return ReadNextItem(-1, true);
+            }
+            else if (m_curItem.HandleAccessibleInput())
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        private bool ReadNextItem(int inc, bool wrapAround = false)
+        {
+            int nextItemIdx = m_curItemIdx + inc;
+
+            if (nextItemIdx < 0 || nextItemIdx >= m_items.Count)
+            {
+                if (wrapAround && m_items.Count > 0)
+                {
+                    nextItemIdx = inc < 0 ? m_items.Count - 1 : 0;
+                }
+                else
+                {
+                    return false;
+                }
+            }
+
+            m_curItemIdx = nextItemIdx;
+            m_curItem = m_items[m_curItemIdx];
+            m_curItem.Reset();
+            var line = m_curItem.GetLine(0);
+            if (line.Length > 0)
+            {
+                AccessibilityMgr.Output(AccessibleSpeech.MENU_OPTION(line, m_curItemIdx + 1, m_items.Count));
+            }
+
+            return true;
+        }
+
+        internal bool IsReading()
+        {
+            return m_curItem != null;
+        }
+
+        internal void StartReading()
+        {
+            ReadNextItem(0);
+        }
+
+        internal void StartReadingReverse()
+        {
+            ReadNextItem(m_items.Count - 1);
+        }
+
+        internal T GetItemBeingRead()
+        {
+            return m_curItem;
+        }
+
+        internal int GetItemBeingReadIndex()
+        {
+            return m_curItemIdx;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
new file mode 100644
index 0000000..0e4bf4c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
@@ -0,0 +1,43 @@
+﻿using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleLoginScreen : AccessibleScreen
+    {
+        private static AccessibleLoginScreen s_instance = new AccessibleLoginScreen();
+
+        private PegUIElement m_startButton;
+
+        internal static AccessibleLoginScreen Get() {
+            return s_instance;
+        }
+
+        public void OnGameLoaded(PegUIElement startButton)
+        {
+            m_startButton = startButton;
+
+            AccessibilityMgr.Output(AccessibleSpeech.TUTORIAL_PROGRESS_SCREEN_LOADED);
+
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_START;
+        }
+
+        public void HandleInput()
+        {
+            if (m_startButton != null && AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_startButton.TriggerRelease();
+                AccessibilityMgr.TransitioningScreens();
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+            // TODO: Review if this really isn't needed
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs
new file mode 100644
index 0000000..7fe96c9
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMenu.cs
@@ -0,0 +1,193 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class AccessibleMenu
+    {
+        private class MenuOption
+        {
+            internal string m_text;
+            internal Action m_onClickAction;
+            internal Action m_onReadAction;
+
+            internal MenuOption(string text, Action onClickAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+            }
+
+            internal MenuOption(string text, Action onClickAction, Action onReadAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+                m_onReadAction = onReadAction;
+            }
+        }
+
+        private string m_menuName;
+
+        private List<MenuOption> m_options;
+
+        private int m_curOptionIdx;
+
+        private Action m_goBackAction;
+
+        private bool m_isReading;
+
+        private bool m_isGlobalMenu;
+
+        public AccessibleMenu(string menuName, Action goBackAction, bool globalMenu=false)
+        {
+            m_menuName = menuName;
+            m_options = new List<MenuOption>();
+            m_goBackAction = goBackAction;
+            m_isGlobalMenu = globalMenu;
+        }
+
+        public void AddOption(string option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(string option, Action onClickAction, Action onReadAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction, onReadAction));
+        }
+
+        public bool HandleAccessibleInput()
+        {
+            try
+            {
+                if (ReadNextIsPressed())
+                {
+                    return ReadNextOption(1);
+                }
+                else if (ReadPrevIsPressed())
+                {
+                    return ReadNextOption(-1);
+                }
+                else if (ConfirmIsPressed())
+                {
+                    return SelectOption();
+                }
+                else if (BackIsPressed())
+                {
+                    return GoBack();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+
+        private bool BackIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.GLOBAL_BACK.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.BACK.IsPressed();
+            }
+        }
+
+        private bool ConfirmIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.GLOBAL_CONFIRM.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.CONFIRM.IsPressed();
+            }
+        }
+
+        private bool ReadPrevIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_PREV_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_GLOBAL_VALID_MENU_OPTION.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_PREV_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadNextIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_NEXT_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_GLOBAL_VALID_MENU_OPTION.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_NEXT_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadNextOption(int inc)
+        {
+            int nextOptionIdx = m_curOptionIdx + inc;
+
+            if (nextOptionIdx < 0 || nextOptionIdx >= m_options.Count)
+            {
+                return false;
+            }
+
+            m_curOptionIdx = nextOptionIdx;
+            var curOption = m_options[m_curOptionIdx];
+
+            var speech = AccessibleSpeech.MENU_OPTION(curOption.m_text, m_curOptionIdx + 1, m_options.Count);
+            AccessibilityMgr.Output(speech);
+
+            if (curOption.m_onReadAction != null)
+            {
+                curOption.m_onReadAction();
+            }
+
+            return true;
+        }
+
+        private bool SelectOption()
+        {
+            if (!m_isReading || m_options.Count == 0)
+            {
+                return false;
+            }
+
+            m_options[m_curOptionIdx].m_onClickAction();
+
+            return true;
+        }
+
+        private bool GoBack()
+        {
+            if (m_goBackAction == null) {
+                return false;
+            }
+
+            m_goBackAction();
+
+            return true;
+        }
+
+        public void StartReading()
+        {
+            AccessibilityMgr.Output(m_menuName);
+            ReadNextOption(0);
+            m_isReading = true;
+        }
+
+        public void SetIndex(int index)
+        {
+            m_curOptionIdx = index;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
new file mode 100644
index 0000000..39d2b39
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
@@ -0,0 +1,20 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleMultilineText : AccessibleItem
+    {
+        private List<string> m_lines;
+
+        internal AccessibleMultilineText(List<string> lines) : base()
+        {
+            m_lines = lines;
+        }
+
+        internal override List<string> GetLines()
+        {
+            return m_lines;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
new file mode 100644
index 0000000..72b735c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
@@ -0,0 +1,26 @@
+﻿using System;
+
+namespace Accessibility
+{
+    static class AccessibleNotificationMgr
+    {
+        public static void OnCreateNotificationWithoutSound(Notification notification)
+        {
+            ReadNotification(notification);
+        }
+
+        public static void OnCreateNotificationWithSound(Notification notification)
+        {
+            if (!AccessibilityConfig.CAN_HEAR)
+            {
+                // Could look into doing something like this for deaf-blind support
+                ReadNotification(notification);
+            }
+        }
+
+        private static void ReadNotification(Notification notification)
+        {
+            AccessibilityMgr.Output(notification.speechUberText.Text);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
new file mode 100644
index 0000000..93a422d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
@@ -0,0 +1,366 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePlayDescriber
+    {
+        private static AccessiblePlayDescriber s_AccessiblePlayDescriber;
+
+
+        private HashSet<PowerTaskList> m_describedTaskLists = new HashSet<PowerTaskList>();
+
+        private int m_pendingReadings;
+
+        private AccessiblePlayDescriber() { }
+
+        internal static AccessiblePlayDescriber Get()
+        {
+            if (s_AccessiblePlayDescriber == null)
+            {
+                s_AccessiblePlayDescriber = new AccessiblePlayDescriber();
+            }
+
+            return s_AccessiblePlayDescriber;
+        }
+
+        internal void Reset()
+        {
+            m_describedTaskLists.Clear();
+        }
+
+        private bool ShouldCalloutTrigger(Entity entity)
+        {
+            if (entity == null)
+            {
+                return false;
+            }
+
+            if (entity.IsCharacter() || entity.IsWeapon() || entity.IsSecret() || entity.IsQuest() || entity.IsSideQuest() || entity.IsHeroPower())
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal string OnCardTriggered(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity();
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (PowerProcessor.ShouldShowTriggeredBigCard(card))
+            {
+                return GetBigCardTriggeredText(card);
+            }
+
+            if (!ShouldCalloutTrigger(card))
+            {
+                return null;
+            }
+
+            var fullCardName = AccessibleSpeechUtils.GetFullNameInZone(card);
+
+            // Not really a play but the card itself may be useful if the player wants to read it
+            return RegisterPlay($"{fullCardName} triggered");
+        }
+
+        internal string OnCardPlayed(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity();
+            var blockStart = taskList.GetBlockStart();
+
+            AccessibilityUtils.LogDebug($"OnCardPlayed taskList ID: {taskList.GetId()}");
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (PowerProcessor.ShouldShowPlayedBigCard(card, blockStart))
+            {
+                var text = GetBigCardPlayedText(card);
+
+                if (text.Length > 0)
+                {
+                    return text; // We ignore some things like hero powers 
+                }
+            }
+
+            var cardName = card.GetName();
+            var action = "played";
+
+            if (card.IsMinion())
+            {
+                action = "summoned";
+            }
+            else if (card.IsWeapon())
+            {
+                action = "equipped";
+            }
+            else if (card.IsHeroPower())
+            {
+                action = "used";
+            }
+            else if (card.IsSecret())
+            {
+                if (card.IsControlledByFriendlySidePlayer())
+                {
+                    action = "cast";
+                }
+                else
+                {
+                    action = "cast";
+                    cardName = "one secret";
+                }
+                // FIXME: not sure if this won't break
+            }
+
+            if (card.IsControlledByFriendlySidePlayer())
+            {
+                return RegisterPlay($"You {action} {cardName}");
+            }
+            else
+            {
+                return RegisterPlay($"Your opponent {action} {cardName}");
+            }
+        }
+
+        private string GetBigCardPlayedText(Entity card)
+        {
+            var cardName = card.GetName();
+            var cardDesc = $"{card.GetCardTextBuilder().BuildCardTextInHand(card)}";
+            string text = "";
+            var action = "played";
+
+            if (card.IsMinion())
+            {
+                action = "summoned";
+                var atk = card.GetATK();
+                var hp = card.GetHealth();
+
+                text = $"{cardName}; {atk} {hp} {cardDesc}";
+            }
+            else if (card.IsSpell())
+            {
+                text = $"{cardName}; {cardDesc}";
+            }
+            else if (card.IsHeroPower()) // This is tricky as it would fire after ptldescriber + we probably don't want to repeat this all the time
+            {
+                // Note: This wasn't being read but I think it's a good idea to do so since they're short anyways and can be read in the animation - experimenting
+                action = "used";
+                text = $"{cardName}; {cardDesc}";
+            } 
+            else if (card.IsWeapon())
+            {
+                action = "equipped";
+                var atk = card.GetATK();
+                var durability = card.GetDurability();
+                text = $"{cardName}; {atk} {durability} {cardDesc}";
+            }
+            else if (card.IsSecret())
+            {
+                // FIXME: At some point I thought this would break so this needs testing
+                action = "cast";
+
+                if (card.GetCardType() == TAG_CARDTYPE.INVALID)
+                {
+                    text = "one secret";
+                }
+                else
+                {
+                    text = $"{cardName}; {cardDesc}";
+                }
+            }
+            else if (card.GetCardType() == TAG_CARDTYPE.ENCHANTMENT)
+            {
+                text = $"{cardName}; {cardDesc}";
+            }
+            else
+            {
+                Log.Accessibility.Print($"GetBigCardPlayedText unknown type: {card.GetName()} / type = {card.GetCardType()}");
+                return "";
+            }
+
+            if (card.IsControlledByFriendlySidePlayer())
+            {
+                // This might be the one that shows up for things like random spells and whatnot - confirm this
+                return RegisterPlay($"You {action} {text}");
+            }
+            else
+            {
+                return RegisterPlay($"Your opponent {action} {text}");
+            }
+        }
+
+        private string GetBigCardTriggeredText(Entity card)
+        {
+            var cardName = card.GetName();
+            var cardDesc = $"{card.GetCardTextBuilder().BuildCardTextInHand(card)}";
+
+            if (card.IsControlledByFriendlySidePlayer())
+            {
+                // This might be the one that shows up for things like random spells and whatnot - confirm this
+                return RegisterPlay($"Your {cardName} triggered");
+            }
+            else
+            {
+                return RegisterPlay($"Your opponent's {cardName} triggered; {cardDesc}");
+            }
+        }
+
+        internal void OnBigCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardPlayed called with null taskList - dropping");
+            }
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return;
+            }
+
+            var text = GetBigCardPlayedText(card);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+        }
+
+        internal void OnBigCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardTriggered called with null curTaskList - dropping");
+            }
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return;
+            }
+
+            var text = GetBigCardTriggeredText(card);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+        }
+
+        internal string OnFatigue(PowerTaskList taskList)
+        {
+            var source = taskList.GetSourceEntity();
+
+            if (source == null)
+            {
+                Log.Accessibility.Print("Fatigue had null source");
+                return null;
+            }
+
+            var side = source.GetControllerSide();
+
+            if (side == Player.Side.FRIENDLY)
+            {
+                return RegisterPlay("You tried to draw a card from an empty deck");
+            }
+            else
+            {
+                return RegisterPlay("Your opponent tried to draw a card from an empty deck");
+            }
+        }
+
+        internal List<string> OnCardsBurned(List<Entity> burnedCards)
+        {
+            var ret = new List<string>();
+
+            foreach(var card in burnedCards)
+            {
+                var side = card.IsControlledByFriendlySidePlayer() ? "You" : "Your opponent";
+                var cardName = card.GetName();
+
+                ret.Add(RegisterPlay($"{side} drew one {cardName} but it burned"));
+            }
+
+            return ret;
+        }
+
+        internal void OnAttack(PowerTaskList taskList)
+        {
+            var text = GetAttackText(taskList);
+
+            if (text != null)
+            {
+                AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+            }
+        }
+
+        internal string GetAttackText(PowerTaskList taskList)
+        {
+            if (m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            var attacker = taskList.GetAttacker();
+            var defender = taskList.GetDefender();
+            var proposedDefender = taskList.GetProposedDefender();
+
+            if (proposedDefender != null && proposedDefender.GetEntityId() != defender.GetEntityId())
+            {
+                return RegisterPlay($"{GetFullNameInZone(attacker)} attempted to attack {GetFullNameInZone(proposedDefender)} but attacked {GetFullNameInZone(defender)} instead");
+            } 
+            else
+            {
+                return RegisterPlay($"{GetFullNameInZone(attacker)} attacked {GetFullNameInZone(defender)}");
+            }
+        }
+
+        private void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPSGP Unblocking power processor");
+            m_pendingReadings--;
+        }
+
+        public bool IsBusy()
+        {
+            return m_pendingReadings > 0;
+        }
+
+        // History stuff
+        private string RegisterPlay(string action)
+        {
+            AccessibleHistoryMgr.Get().AddEntry(action);
+            return action;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
new file mode 100644
index 0000000..3ac0dc2
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
@@ -0,0 +1,430 @@
+﻿using PegasusGame;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePowerTaskListDescriber
+    {
+        private static AccessibleInGameState s_lastDescribedState;
+
+        private static bool s_blocked;
+
+        private static bool s_canSnapshot;
+
+        private static bool s_waitingForYourTurnBanner;
+
+        private static List<string> s_descriptionsWaitingForTurnChange = new List<string>();
+
+        private static TAG_STEP s_prevStep;
+
+        private static bool s_gameOfficiallyStarted;
+
+        private static bool s_turnStarted;
+
+        private static int s_numEndTurnAttempts;
+
+        public static void OnGameStart()
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug("PTL OnGameStart");
+
+                s_lastDescribedState = null;
+                s_canSnapshot = false;
+                s_waitingForYourTurnBanner = false;
+                s_descriptionsWaitingForTurnChange.Clear();
+                s_prevStep = TAG_STEP.INVALID;
+                s_gameOfficiallyStarted = false;
+                s_turnStarted = false;
+                s_numEndTurnAttempts = 0;
+
+                AccessiblePlayDescriber.Get().Reset();
+                AccessibleInGameState.Reset();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void OnPowerTaskListStart(PowerTaskList taskList)
+        {
+            try
+            {
+                taskList.SetGlobalCompleteCallback(OnPowerTaskListEnd);
+
+                Network.HistBlockStart blockStart = taskList.GetBlockStart();
+                AccessibilityUtils.LogDebug($">>> Starting PowerTaskList.Id: {taskList.GetId()}. BlockType: {blockStart?.BlockType}");
+
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void OnPowerTaskListEnd(PowerTaskList taskList)
+        {
+            try
+            {
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+                AccessibilityUtils.LogDebug($">>> Ending PowerTaskList. Id: {taskList.GetId()}.");
+                AccessibilityUtils.LogDebug("SPS blocking power processor");
+                s_blocked = true;
+
+                var lines = new List<string>();
+
+                var canDescribe = true;
+
+                if (!GameHasOfficiallyStarted())
+                {
+                    canDescribe = false;
+                }
+
+                if (taskList.IsOrigin() && taskList.IsPlayBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardPlayed(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.FATIGUE))
+                {
+                    AccessibilityUtils.LogDebug("Fatigue");
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnFatigue(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.ATTACK))
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().GetAttackText(taskList));
+                    canDescribe = false;
+
+                    if ((taskList.GetAttacker()?.IsHero() ?? false) || (taskList.GetDefender()?.IsHero() ?? false))
+                    {
+                        canDescribe = true; // Describe state when a Hero is involved as dmg taken is more important there
+                    }
+                }
+
+                if (taskList.IsOrigin() && taskList.IsTriggerBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardTriggered(taskList));
+                }
+
+                var burnedCards = GetBurnedCards(taskList);
+                if (burnedCards.Count > 0)
+                {
+                    lines.AddRange(AccessiblePlayDescriber.Get().OnCardsBurned(burnedCards));
+                }
+
+                SnapshotAndDescribeGameState(lines, taskList, canDescribe);
+            }
+            catch (Exception e)
+            {
+                s_blocked = false;
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static bool GameHasOfficiallyStarted()
+        {
+            if (!GameState.Get().IsGameCreated())
+            {
+                return false;
+            }
+
+            if (s_gameOfficiallyStarted)
+            {
+                return true;
+            }
+
+            // Tutorial games (no mulligan) must all go through one initial MAIN_READY step before they start (or so it seems)
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_READY)
+            {
+                s_gameOfficiallyStarted = true;
+            }
+
+            return s_gameOfficiallyStarted;
+        }
+
+        private static void AddIfNotNull(List<string> lines, string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                return;
+            }
+
+            lines.Add(text);
+        }
+
+        private static List<Entity> GetBurnedCards(PowerTaskList taskList)
+        {
+            var ret = new List<Entity>();
+
+            List<PowerTask> taskList2 = taskList.GetTaskList();
+            for (int i = 0; i < taskList2.Count; i++)
+            {
+                Network.PowerHistory power = taskList2[i].GetPower();
+                if (power.Type != Network.PowerType.META_DATA)
+                {
+                    continue;
+                }
+                Network.HistMetaData histMetaData = (Network.HistMetaData)power;
+                if (histMetaData.MetaType != HistoryMeta.Type.BURNED_CARD)
+                {
+                    continue;
+                }
+                if (histMetaData.Info.Count == 0)
+                {
+                    continue;
+                }
+
+                foreach (var entityId in histMetaData.Info)
+                {
+                    var entity = GameState.Get().GetEntity(entityId);
+
+                    if (entity != null)
+                    {
+                        ret.Add(entity);
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private static void SnapshotAndDescribeGameState(List<string> lines, PowerTaskList taskList, bool canDescribe=true)
+        {
+            AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState canDescribe={canDescribe}");
+
+            var nextStep = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.NEXT_STEP);
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_END)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D1");
+
+                if (s_prevStep != step && s_turnStarted && IsRealEndTurn()) // IsRealEndTurn is because of Hemet Nesingwary and Illidan who break the game by ending the turn twice
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D2");
+                    lines.Add(AccessibleSpeech.GAMEPLAY_TURN_ENDED);
+
+                    OnTurnEnded();
+                    s_canSnapshot = true;
+                }
+            }
+            else if (step == TAG_STEP.MAIN_READY) // Allow trigger effects to be described before turn-related stuff
+            {
+                lines.AddRange(OnTurnChange());
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D3");
+                s_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START_TRIGGERS)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D4");
+                s_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D5");
+                s_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.BEGIN_MULLIGAN)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D6");
+                s_canSnapshot = true;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    s_waitingForYourTurnBanner = true;
+                }
+            }
+            else if (s_prevStep == TAG_STEP.BEGIN_MULLIGAN && step != s_prevStep)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D7");
+                s_canSnapshot = false;
+            }
+
+            s_prevStep = step;
+
+            if (s_lastDescribedState == null)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D8");
+                s_canSnapshot = true; // Start snapshotting after game starts due to tutorial stuff
+            }
+
+            if (!s_canSnapshot)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D9");
+
+                if (!s_waitingForYourTurnBanner)
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D10");
+                    Output(lines);
+                }
+                else
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D11");
+                    s_descriptionsWaitingForTurnChange.AddRange(lines);
+                    s_blocked = false;
+                }
+                return;
+            }
+
+            var newState = AccessibleInGameState.GetCurrentState(taskList);
+
+            if (canDescribe) // TODO: Rethink this
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D12");
+                var description = AccessibleInGameState.DescribeDiff(taskList, s_lastDescribedState, newState);
+
+                AddIfNotNull(lines, description);
+                AccessibleHistoryMgr.Get().AddEntry(description);
+            }
+
+            s_lastDescribedState = newState;
+
+            if (!s_waitingForYourTurnBanner)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D13");
+                Output(lines);
+            }
+            else
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D14");
+                s_descriptionsWaitingForTurnChange.AddRange(lines);
+                s_blocked = false;
+            }
+        }
+
+        private static bool IsRealEndTurn()
+        {
+            s_numEndTurnAttempts++;
+
+            if (GameState.Get().GetGameEntity() is Tutorial_04 && s_numEndTurnAttempts == 3)
+            {
+                return false;
+            }
+            else if (GameState.Get().GetGameEntity() is Tutorial_05 && s_numEndTurnAttempts == 7)
+            {
+                return false;
+            }
+
+            return true;
+        }
+
+        private static List<string> OnTurnChange()
+        {
+            var ret = new List<string>();
+
+            if (s_turnStarted)
+            {
+                return ret;
+            }
+
+            s_turnStarted = true;
+
+            if (GameState.Get().IsFriendlySidePlayerTurn())
+            {
+                s_waitingForYourTurnBanner = true;
+            }
+            else
+            {
+                ret.Add(AccessibleSpeech.GAMEPLAY_OPPONENT_TURN);
+            }
+
+            return ret;
+        }
+
+        internal static void OnTurnStart()
+        {
+            s_waitingForYourTurnBanner = false;
+            s_turnStarted = true;
+
+            var descriptions = new List<string>();
+            descriptions.Add(AccessibleSpeech.GAMEPLAY_YOUR_TURN);
+            descriptions.Add($"You have {GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources()} mana");
+            descriptions.AddRange(s_descriptionsWaitingForTurnChange);
+            s_descriptionsWaitingForTurnChange.Clear();
+
+            Output(descriptions);
+        }
+
+        private static void Output(string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                s_blocked = false;
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"SPS Describing blocked task list: {text}");
+            AccessibilityMgr.OutputAndWait(text, OnOutputStart, OnOutputEnd);
+        }
+
+        private static void Output(List<string> lines)
+        {
+            if (lines == null || lines.Count == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                s_blocked = false;
+            }
+            else
+            {
+                Output(AccessibleSpeechUtils.CombineLines(lines));
+            }
+        }
+
+        private static void OnOutputStart()
+        {
+        }
+
+        private static void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+            s_blocked = false;
+        }
+
+        public static bool IsBusy()
+        {
+            return s_blocked;
+        }
+
+        #region Weapon stuff
+
+        private static void OnTurnEnded()
+        {
+            var curPlayer = GameState.Get().GetCurrentPlayer();
+            var otherPlayer = GameState.Get().GetFirstOpponentPlayer(curPlayer);
+
+            if (curPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponSheathed(curPlayer.GetHero());
+            }
+
+            if (otherPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponUnsheathed(otherPlayer.GetHero());
+            }
+
+            s_turnStarted = false;
+        }
+
+        internal static void OnReconnected()
+        {
+            AccessibilityUtils.LogDebug("PTL OnReconnected");
+            s_gameOfficiallyStarted = true;
+            s_turnStarted = true;
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs
new file mode 100644
index 0000000..e2a4f9c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuest.cs
@@ -0,0 +1,90 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuest : AccessibleItem
+    {
+        private readonly QuestDataModel m_quest;
+
+        internal AccessibleQuest(QuestDataModel quest) : base()
+        {
+            m_quest = quest;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            if (m_quest.Name?.Length > 0) // New quests don't have a name. Instead, they have the XP scroll at the top so we use GetRewards as the name
+            {
+                ret.Add(m_quest.Name);
+            }
+
+            var rewards = GetRewards();
+
+            if (rewards.Length > 0)
+            {
+                ret.Add(rewards);
+            }
+
+            ret.Add(m_quest.Description);
+
+            var progress = GetProgress();
+
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            // TODO: Reroll
+
+            return ret;
+        }
+
+        private string GetRewards()
+        {
+            if (m_quest.RewardTrackXp > 0) // New quests give XP as rewards instead of anything else
+            {
+                return $"{m_quest.RewardTrackXp} XP quest";
+            }
+
+            var rewards = m_quest.Rewards; // Non-XP quests give other rewards
+
+            if (rewards == null)
+            {
+                return "";
+            }
+
+            if (rewards.Description?.Length > 0)
+            {
+                return $"Rewards {rewards.Description}";
+            }
+
+            var rwds = new List<string>();
+            foreach (var rwd in rewards.Items)
+            {
+                rwds.Add(new AccessibleRewardItemDataModel(rwd).GetLine(0));
+            }
+
+            var lst = AccessibleSpeechUtils.HumanizeList(rwds);
+
+            if (rewards.ChooseOne)
+            {
+                return $"Rewards one of {lst}";
+            }
+
+            return lst;
+        }
+
+        private string GetProgress()
+        {
+            if (m_quest.Quota == 0)
+            {
+                return "";
+            }
+
+            return $"Current progress is {m_quest.Progress} out of {m_quest.Quota}";
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
new file mode 100644
index 0000000..40ffcb4
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
@@ -0,0 +1,82 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuestTile : AccessibleItem
+    {
+        private readonly QuestTile m_quest;
+
+        internal AccessibleQuestTile(QuestTile quest) : base()
+        {
+            m_quest = quest;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_quest.m_questName.Text);
+            ret.Add(GetRewards());
+            ret.Add(m_quest.m_requirement.Text);
+
+            var progress = GetProgress();
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            return ret;
+        }
+
+        private string GetRewards()
+        {
+            var rewards = m_quest.m_quest.Rewards;
+
+            var rewardTexts = new List<string>();
+
+            foreach (var reward in rewards)
+            {
+                rewardTexts.Add(StringifyRewardType(reward.RewardType));
+            }
+
+            return $"Rewards {AccessibleSpeechUtils.HumanizeList(rewardTexts)}";
+        }
+
+        private string GetProgress()
+        {
+            var achievement = m_quest.m_quest;
+            if (achievement.MaxProgress > 1)
+            {
+                return $"Current progress is {achievement.Progress} out of {achievement.MaxProgress}";
+            }
+
+            return "";
+        }
+
+        private string StringifyRewardType(Reward.Type rewardType)
+        {
+            switch (rewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return "Arcane Dust";
+                case Reward.Type.BOOSTER_PACK:
+                    return "One card pack";
+                case Reward.Type.CARD:
+                    return "One card";
+                case Reward.Type.CARD_BACK:
+                    return "One card back";
+                case Reward.Type.GOLD:
+                    return "Gold";
+                case Reward.Type.MOUNT:
+                    return "One mount";
+                case Reward.Type.ARCANE_ORBS:
+                    return "Arcane Orbs";
+                case Reward.Type.MINI_SET:
+                    return "One mini set";
+                default:
+                    return "One unknown reward";
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
new file mode 100644
index 0000000..c33639d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
@@ -0,0 +1,246 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Accessibility
+{
+    class AccessibleRewardData : AccessibleItem
+    {
+        internal RewardData RewardData { get; }
+
+        private List<string> m_cachedLines;
+
+        internal AccessibleRewardData(RewardData rewardData) : base()
+        {
+            RewardData = rewardData;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            switch (RewardData.RewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return GetLinesForArcaneDustReward();
+                case Reward.Type.BOOSTER_PACK:
+                    return GetLinesForBoosterPackReward();
+                case Reward.Type.GOLD:
+                    return GetLinesForGoldReward();
+                 case Reward.Type.CARD:
+                    return GetLinesForCardReward();
+                 case Reward.Type.CARD_BACK:
+                    return GetLinesForCardBackReward();
+                 case Reward.Type.MOUNT:
+                    return GetLinesForMountReward();
+                 case Reward.Type.ARCANE_ORBS:
+                    return GetLinesForArcaneOrbsReward();
+                 case Reward.Type.MINI_SET:
+                    return GetLinesForMiniSetReward();
+                 case Reward.Type.FORGE_TICKET:
+                    return GetLinesForForgeTicketReward();
+                 case Reward.Type.CRAFTABLE_CARD:
+                 case Reward.Type.CLASS_CHALLENGE:
+                 case Reward.Type.EVENT:
+                 case Reward.Type.RANDOM_CARD:
+                 case Reward.Type.BONUS_CHALLENGE:
+                 case Reward.Type.ADVENTURE_DECK:
+                 case Reward.Type.ADVENTURE_HERO_POWER:
+                 case Reward.Type.DECK:
+                 default:
+                    var ret = new List<string>();
+                    ret.Add("This reward type hasn't been made accessible yet");
+                    return ret;
+            }
+        }
+
+        private List<string> GetLinesForForgeTicketReward()
+        {
+            var ret = new List<string>();
+
+            ForgeTicketRewardData reward = (ForgeTicketRewardData)RewardData;
+
+            var numTickets = reward.Quantity;
+
+            if (numTickets > 1)
+            {
+                ret.Add($"{numTickets} forge tickets");
+            }
+            else
+            {
+                ret.Add($"{numTickets} forge ticket");
+            }
+            return ret;
+        }
+
+        private List<string> GetLinesForMiniSetReward()
+        {
+            var ret = new List<string>();
+
+            MiniSetRewardData reward = (MiniSetRewardData)RewardData;
+
+			MiniSetDbfRecord record = GameDbf.MiniSet.GetRecord(reward.MiniSetID);
+			int count = record.DeckRecord.Cards.Count;
+
+            ret.Add($"Mini set with {count} cards");
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneOrbsReward()
+        {
+            var ret = new List<string>();
+
+            SimpleRewardData reward = (SimpleRewardData)RewardData;
+
+            ret.Add($"{reward.Amount} arcane orbs");
+            return ret;
+        }
+
+        private List<string> GetLinesForMountReward()
+        {
+            var ret = new List<string>();
+
+            MountRewardData reward = (MountRewardData)RewardData;
+
+            switch (reward.Mount)
+            {
+                case MountRewardData.MountType.HEROES_MAGIC_CARPET_CARD:
+                    ret.Add($"You got a Magic Carpet mount in Heroes of the Storm");
+                    break;
+                case MountRewardData.MountType.WOW_HEARTHSTEED:
+                    ret.Add($"You got a Hearthsteed mount in World of Warcraft");
+                    break;
+                default:
+                    ret.Add($"You got a mount");
+                    break;
+
+            }
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneDustReward()
+        {
+            var ret = new List<string>();
+
+            ArcaneDustRewardData reward = (ArcaneDustRewardData)RewardData;
+
+            ret.Add($"{reward.Amount} arcane dust");
+            return ret;
+        }
+
+        private List<string> GetLinesForBoosterPackReward()
+        {
+            var ret = new List<string>();
+
+            BoosterPackRewardData reward = (BoosterPackRewardData)RewardData;
+
+            var numPacks = reward.Count;
+
+            if (numPacks > 1)
+            {
+                ret.Add($"{numPacks} card packs");
+            }
+            else
+            {
+                ret.Add($"{numPacks} card pack");
+            }
+            return ret;
+        }
+
+        private List<string> GetLinesForGoldReward()
+        {
+            var ret = new List<string>();
+
+            GoldRewardData reward = (GoldRewardData)RewardData;
+
+            ret.Add($"{reward.Amount} gold");
+            return ret;
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            CardRewardData reward = (CardRewardData)RewardData;
+
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(reward.CardID);
+            if (entityDef.IsHeroSkin())
+            {
+                return GetLinesForUnlockedHero(reward);
+            }
+            else
+            {
+                var ret = new List<string>();
+                var numCards = reward.Count;
+                var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, reward.Premium);
+                var cardClass = AccessibleSpeechUtils.StringifyClass(entityDef.GetClass());
+
+                if (entityDef.IsCoreCard())
+                {
+                    cardClass = $"core {cardClass}";
+                }
+
+                if (numCards > 1)
+                {
+                    ret.Add($"{numCards} copies of one {cardClass} card");
+                }
+                else
+                {
+                    ret.Add($"{numCards} {cardClass} card");
+                }
+
+                ret.AddRange(new AccessibleCollectibleCard(collectibleCard, false).GetLines());
+
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForUnlockedHero(CardRewardData reward)
+        {
+            var ret = new List<string>();
+
+            var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, TAG_PREMIUM.NORMAL);
+            var heroName = collectibleCard.Name;
+            var className = GameStrings.GetClassName(DefLoader.Get().GetEntityDef(reward.CardID).GetClass());
+
+            if (reward.Premium == TAG_PREMIUM.GOLDEN)
+            {
+                ret.Add($"Golden {heroName}");
+                ret.Add($"{className} Hero");
+                return ret;
+            }
+            else if (GameUtils.IsVanillaHero(reward.CardID))
+            {
+                var numHeroes = AchieveManager.Get().NumDefaultHeroesUnlocked();
+                var numUnlockedHeroes = AchieveManager.Get().NumDefaultHeroesUnlocked();
+
+                ret.Add($"{className} unlocked!");
+                ret.Add($"{numUnlockedHeroes} out of {numHeroes} Heroes unlocked");
+                return ret;
+            }
+            else
+            {
+                ret.Add($"{heroName}");
+                ret.Add($"{className} Hero");
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForCardBackReward()
+        {
+            var ret = new List<string>();
+
+            CardBackRewardData reward = (CardBackRewardData)RewardData;
+
+            ret.Add("one card back");
+            return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
new file mode 100644
index 0000000..9e87764
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
@@ -0,0 +1,115 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleRewardItemDataModel : AccessibleItem
+    {
+        private RewardItemDataModel m_reward;
+
+        private List<string> m_cachedLines;
+
+        internal AccessibleRewardItemDataModel(RewardItemDataModel reward) : base()
+        {
+            m_reward = reward;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            var suffix = m_reward.Quantity > 1 ? "s" : "";
+            var bonusSuffix = m_reward.Quantity > 1 ? "es" : ""; // bonuses
+
+            switch (m_reward.ItemType)
+            {
+                case RewardItemType.BOOSTER:
+                    return AsList($"{m_reward.Quantity} {m_reward.Booster.BoosterName} card pack{suffix}");
+                case RewardItemType.DUST:
+                    return AsList($"{m_reward.Quantity} Arcane dust");
+                case RewardItemType.HERO_SKIN:
+                    return AsList($"{m_reward.Quantity} Hero skin{suffix}");
+                case RewardItemType.CARD_BACK:
+                    return AsList($"{m_reward.Quantity} Card back{suffix}");
+                case RewardItemType.ADVENTURE_WING:
+                    return AsList($"{m_reward.Quantity} Adventure Wing{suffix}");
+                case RewardItemType.ARENA_TICKET:
+                    return AsList($"{m_reward.Quantity} Arena ticket{suffix}");
+                case RewardItemType.RANDOM_CARD:
+                    return AsList($"{m_reward.Quantity} random card{suffix}");
+                case RewardItemType.RUNESTONES:
+                    return AsList($"{m_reward.Quantity} Runestone{suffix}");
+                case RewardItemType.ARCANE_ORBS:
+                    return AsList($"{m_reward.Quantity} Arcane Orb{suffix}");
+                case RewardItemType.ADVENTURE:
+                    return AsList($"{m_reward.Quantity} Adventure{suffix}");
+                case RewardItemType.CARD:
+                    return GetLinesForCardReward();
+                case RewardItemType.BATTLEGROUNDS_BONUS:
+                    return AsList($"{m_reward.Quantity} Battlegrounds bonus{bonusSuffix}");
+                case RewardItemType.TAVERN_BRAWL_TICKET:
+                    return AsList($"{m_reward.Quantity} Tavern Brawl ticket{suffix}");
+                case RewardItemType.GOLD:
+                    return AsList($"{m_reward.Quantity} Gold");
+                case RewardItemType.CUSTOM_COIN:
+                    return AsList($"{m_reward.Quantity} custom coin{suffix}");
+                case RewardItemType.PROGRESSION_BONUS:
+                    return AsList($"{m_reward.Quantity} progression bonus{bonusSuffix}");
+                case RewardItemType.REWARD_TRACK_XP_BOOST:
+                    return AsList($"{m_reward.Quantity}% XP boost");
+                case RewardItemType.MINI_SET:
+                    return AsList($"{m_reward.Quantity} Mini set{suffix}");
+                case RewardItemType.CARD_SUBSET:
+                    return AsList($"{m_reward.Quantity} Card subset{suffix}");
+                case RewardItemType.SELLABLE_DECK:
+                    return AsList($"{m_reward.Quantity} Sellable deck{suffix}");
+                case RewardItemType.BATTLEGROUNDS_HERO_SKIN:
+                    return AsList($"{m_reward.Quantity} Battlegrounds Hero skin{suffix}");
+                case RewardItemType.BATTLEGROUNDS_GUIDE_SKIN:
+                    return AsList($"{m_reward.Quantity} Battlegrounds Guide skin{suffix}");
+                default:
+                    var ret = new List<string>();
+                    ret.Add("This reward type hasn't been made accessible yet");
+                    return ret;
+            }
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            var ret = new List<string>();
+
+            if (m_reward.Quantity > 1)
+            {
+                ret.Add($"{m_reward.Quantity} copies of one card");
+            }
+            else
+            {
+                ret.Add($"{m_reward.Quantity} card");
+            }
+
+            var card = CollectionManager.Get().GetCard(m_reward.Card.CardId, m_reward.Card.Premium);
+            var accessibleCard = new AccessibleCollectibleCard(card, false);
+
+            ret.AddRange(accessibleCard.GetLines());
+
+            return ret;
+        }
+
+        private List<string> AsList(string str)
+        {
+			var ret = new List<string>();
+			ret.Add(str);
+			return ret;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
new file mode 100644
index 0000000..2a84a0a
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
@@ -0,0 +1,35 @@
+﻿using System;
+using System.Collections.Generic;
+using static RewardBoxesDisplay;
+
+namespace Accessibility
+{
+    class AccessibleRewardPackage : AccessibleItem
+    {
+        internal RewardBoxData RewardBoxData { get; }
+
+        internal AccessibleRewardData RewardData { get; }
+
+        internal bool Open { get; set; }
+
+        internal AccessibleRewardPackage(RewardBoxData rewardBoxData, RewardData rewardData) : base()
+        {
+            RewardBoxData = rewardBoxData;
+            RewardData = new AccessibleRewardData(rewardData);
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (!Open)
+            {
+                var ret = new List<string>();
+                ret.Add("Reward package");
+                return ret;
+            }
+            else
+            {
+                return RewardData.GetLines();
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs
new file mode 100644
index 0000000..c715eaa
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleScreen.cs
@@ -0,0 +1,11 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleScreen
+    {
+        void HandleInput();
+
+        string GetHelp();
+
+        void OnGainedFocus();
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
new file mode 100644
index 0000000..2dc1054
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
@@ -0,0 +1,345 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Runtime.CompilerServices;
+
+namespace Accessibility
+{
+    public class AccessibleSpeech
+    {
+        #region Global
+        public static string PRESS_ENTER_TO_START = PRESS_CONFIRM_TO("start");
+        public static string PRESS_ENTER_TO_CONTINUE = PRESS_CONFIRM_TO("continue");
+        private static string PRESS_KEY_TO(AccessibleKey key, string action) { return $"Press {key} to {action}"; }
+        private static string PRESS_CONFIRM_TO(string action) { return PRESS_KEY_TO(AccessibleKey.CONFIRM, action); }
+
+        public static HSASpeech PRESS_ENTER_TO_START_VOICE = CreateSpeech(PRESS_ENTER_TO_START);
+        #endregion
+
+        #region Menus
+        private static string MENU_HELP_NO_BACK_BUTTON = $"Use the up and down arrow keys to navigate the menu. {PRESS_CONFIRM_TO("select an option")}";
+        private static string MENU_HELP_WITH_BACK_BUTTON = $"{MENU_HELP_NO_BACK_BUTTON}. {PRESS_KEY_TO(AccessibleKey.BACK, "go back")}";
+        public static string MENU_HELP(bool hasBackButton) { return hasBackButton ? MENU_HELP_WITH_BACK_BUTTON : MENU_HELP_NO_BACK_BUTTON; }
+        public static string MENU_OPTION(string optionName, int optionNumber, int optionsCount) { return $"{optionName} {optionNumber} of {optionsCount}"; }
+        #endregion
+
+        #region Game Menu
+        public static string GAME_MENU_TITLE = "Game Menu";
+
+        public static string OPTIONS_MENU_TITLE = "Options Menu";
+        public static string OPTIONS_MENU_MASTER_VOLUME_OPTION = "Adjust Master Volume";
+        public static string OPTIONS_MENU_FULLSCREEN_OPTION = "Toggle Fullscreen";
+        public static string OPTIONS_MENU_ADJUST_MASTER_VOLUME = "Use the left and right arrow keys to adjust the volume";
+        public static string OPTIONS_MENU_FULLSCREEN_STATE(bool state) { return $"Fullscreen {(state ? "on" : "off")}"; }
+        public static string OPTIONS_MENU_MASTER_VOLUME_STATE(float val) { return $"{(int)Math.Round(val*100)}"; }
+        #endregion
+
+        #region Hub
+        public static string HUB_MAIN_MENU_TITLE = "Main Menu";
+        public static string HUB_SOLO_ADVENTURES_OPTION = "Solo Adventures";
+        public static string HUB_HELP_OPTION = "Help";
+        public static string HUB_GAME_MENU_OPTION = "Game Menu";
+        public static string HUB_GAME_MENU = $"Press {AccessibleKey.OPEN_GAME_MENU} at any time to open the game menu. Try it now!";
+        public static string HUB_HELP = $"Press {AccessibleKey.HELP} at any time if you're feeling lost. If you need help from a sighted person, you can always press {AccessibleKey.TOGGLE_ACCESSIBILITY} to disable accessibility and allow them to control the game using the mouse as normal. Just remember to press {AccessibleKey.TOGGLE_ACCESSIBILITY} once they're done to reactivate accessibility";
+        #endregion
+
+        #region Tutorial Progress Screen
+        public static string TUTORIAL_PROGRESS_SCREEN_LOADED = $"Game loaded. {PRESS_ENTER_TO_START}";
+        public static HSASpeech TUTORIAL_WELCOME_BACK = CreateSpeech("Welcome back to the tutorial");
+        public static HSASpeech TUTORIAL_DEFEATED_HOGGER = CreateSpeech("You've defeated Hogger");
+        public static HSASpeech TUTORIAL_DEFEATED_MILLHOUSE = CreateSpeech("You've defeated Millhouse Manastorm");
+        public static HSASpeech TUTORIAL_DEFEATED_CHO = CreateSpeech("You've defeated Lorewalker Cho");
+        public static HSASpeech TUTORIAL_DEFEATED_MUKLA = CreateSpeech("You've defeated King Mukla");
+        public static HSASpeech TUTORIAL_DEFEATED_NESINGWARY = CreateSpeech("You've defeated Hemet Nesingwary");
+        public static HSASpeech TUTORIAL_DEFEATED_ILLIDAN = CreateSpeech("You've defeated Illidan Stormrage");
+        public static HSASpeech TUTORIAL_NEXT_HOGGER = CreateSpeech("Your next opponent is Hogger");
+        public static HSASpeech TUTORIAL_NEXT_MILLHOUSE = CreateSpeech("Your next opponent is Millhouse Manastorm");
+        public static HSASpeech TUTORIAL_NEXT_CHO = CreateSpeech("Your next opponent is Lorewalker Cho");
+        public static HSASpeech TUTORIAL_NEXT_MUKLA = CreateSpeech("Your next opponent is King Mukla");
+        public static HSASpeech TUTORIAL_NEXT_NESINGWARY = CreateSpeech("Your next opponent is Hemet Nesingwary");
+        public static HSASpeech TUTORIAL_NEXT_ILLIDAN = CreateSpeech("Your next and final opponent is Illidan Stormrage");
+        #endregion
+
+        #region Gameplay
+        public static string GAMEPLAY_YOUR_TURN = "Your turn";
+        public static string GAMEPLAY_OPPONENT_TURN = "Opponent's turn";
+        public static string GAMEPLAY_TURN_ENDED = "Turn ended";
+        #endregion
+
+        #region Gameplay Help Speeches
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateSpeech($"{PRESS_KEY_TO(AccessibleKey.SEE_PLAYER_HERO, "look at your hero")}");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateSpeech($"{PRESS_KEY_TO(AccessibleKey.SEE_OPPONENT_HERO, "look at your opponent's hero")}");
+        public static HSASpeech GAMEPLAY_READ_CARDS_HELP = CreateSpeech("Use the up and down arrow keys to read cards");
+        public static HSASpeech GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateSpeech($"Press {AccessibleKey.CONFIRM} to attack this target");
+
+        public static HSASpeech GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateSpeech($"Press {AccessibleKey.CONFIRM} to summon this minion");
+
+        // General gameplay ones
+        public static HSASpeech GAMEPLAY_OPPONENT_TURN_VOICE = CreateSpeech($"Your opponent is playing");
+        public static HSASpeech GAMEPLAY_CONFIRM_END_TURN_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} or {AccessibleKey.END_TURN} to end your turn. Press any other key to cancel");
+        public static HSASpeech GAMEPLAY_SEE_VALID_OPTIONS = CreateSpeech($"Use {AccessibleKey.READ_NEXT_VALID_ITEM} to go through your valid options");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_HAND} to look at your hand");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateSpeech($"Press {AccessibleKey.SEE_OPPONENT_HAND} to count the cards in your opponent's hand");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateSpeech($"{PRESS_KEY_TO(AccessibleKey.SEE_PLAYER_MINIONS, "look at your summoned minions")}");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateSpeech($"{PRESS_KEY_TO(AccessibleKey.SEE_OPPONENT_MINIONS, "look at your opponent's minions")}");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_SECRETS} to look at your secrets");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateSpeech($"Press {AccessibleKey.SEE_OPPONENT_SECRETS} to count your opponent's secrets");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_WEAPON} to read your weapon");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateSpeech($"Press {AccessibleKey.SEE_OPPONENT_WEAPON} to read your opponent's weapon");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_HERO_POWER} to read your hero power");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateSpeech($"Press {AccessibleKey.SEE_OPPONENT_HERO_POWER} to read your opponent's hero power");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_HERO_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_HERO} to read your hero");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_HERO_HELP = CreateSpeech($"Press {AccessibleKey.SEE_OPPONENT_HERO} to read your opponent's hero");
+        public static HSASpeech GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_DECK} to count the remaining cards in your deck");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateSpeech($"Press {AccessibleKey.SEE_OPPONENT_DECK} to count the remaining cards in your opponent's deck");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_MANA_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_MANA} to read your mana");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateSpeech($"Press {AccessibleKey.SEE_OPPONENT_MANA} to read your opponent's mana");
+        public static HSASpeech GAMEPLAY_READ_CARD_HELP = CreateSpeech("Use the up and down arrow keys to read this card");
+        public static HSASpeech GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateSpeech($"Press {AccessibleKey.READ_TOOLTIP} to get a description of this card's abilities");
+        public static HSASpeech GAMEPLAY_PLAY_CARD_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to play this card");
+        public static HSASpeech GAMEPLAY_SUMMON_MINION_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to summon this minion");
+        public static HSASpeech GAMEPLAY_CHOICE_MODE_HELP = CreateSpeech($"Use the arrow keys to go through your options. Press {AccessibleKey.CONFIRM} to choose one");
+        public static HSASpeech GAMEPLAY_CHOOSE_TARGET_HELP = CreateSpeech($"Use {AccessibleKey.READ_NEXT_VALID_ITEM} or the Zone keys to go through your targets. Press {AccessibleKey.CONFIRM} to choose a target or {AccessibleKey.BACK} to cancel");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to attack with this minion");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to attack with your hero");
+        public static HSASpeech GAMEPLAY_USE_HERO_POWER_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to use your hero power");
+        public static HSASpeech GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateSpeech($"Use {AccessibleKey.READ_NEXT_VALID_ITEM} to read through your valid targets");
+        public static HSASpeech GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to attack this minion");
+        public static HSASpeech GAMEPLAY_ATTACK_PLAYER_HERO_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to attack your hero");
+        public static HSASpeech GAMEPLAY_ATTACK_OPPONENT_HERO_HELP = CreateSpeech($"Press {AccessibleKey.CONFIRM} to attack your opponent's hero");
+        public static HSASpeech GAMEPLAY_CANCEL_ATTACK_HELP = CreateSpeech($"Press {AccessibleKey.BACK} to cancel the attack");
+        public static HSASpeech GAMEPLAY_CANCEL_HELP = CreateSpeech($"Press {AccessibleKey.BACK} to cancel");
+        public static HSASpeech GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateSpeech($"Use the left and right arrow keys to choose a position for this minion");
+        public static HSASpeech GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateSpeech($"Press {AccessibleKey.SEE_HISTORY} to open the play history log");
+        public static HSASpeech GAMEPLAY_READ_HISTORY_HELP = CreateSpeech($"Use the up and down arrow keys to read the play history. Press {AccessibleKey.BACK} to close the history log");
+        public static HSASpeech GAMEPLAY_END_TURN_HELP = CreateSpeech($"Press {AccessibleKey.END_TURN} to end your turn");
+        #endregion
+
+        #region Tutorials
+        public static string TUTORIAL_LOADING_FIRST_TIME = "Loading tutorial. Please wait";
+        public static string TUTORIAL_DIALOG_HEADER = "Tutorial Dialog";
+        public static string TUTORIAL_DIALOG_NOTIFICATION(string text, string startButtonText) { return $"{text}. {PRESS_CONFIRM_TO(startButtonText)}"; }
+        public static HSASpeech WELCOME_TO_HEARTHSTONE = CreateSpeech("Welcome to Hearthstone");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO = CreateSpeech($"I'll be teaching you how to play through a set of six tutorial games");
+        public static HSASpeech TUTORIAL_NARRATOR_HELP_KEYS = CreateSpeech($"If you ever feel lost, press {AccessibleKey.HELP}. Even after the tutorial or when navigating menus, you can always use {AccessibleKey.HELP} whenever you need help");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO_END = CreateSpeech("Alright, let's get on with it");
+        public static HSASpeech TUTORIAL_FREE_STARTING_PACK = CreateSpeech($"Here's a basic Mage pack of cards to get you started. Press {AccessibleKey.CONFIRM} to open it");
+
+        public static HSASpeech TUTORIAL_NICE_WORK = CreateSpeech("Nice work");
+        public static HSASpeech TUTORIAL_NICE_JOB = CreateSpeech("Nice job");
+        public static HSASpeech TUTORIAL_NICE_ONE = CreateSpeech("Nice one");
+        public static HSASpeech TUTORIAL_GOOD_JOB = CreateSpeech("Good job");
+        public static HSASpeech TUTORIAL_YOU_GOT_IT = CreateSpeech("You got it!");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateSpeech("Remember how to do it?");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateSpeech("Remember how to do that?");
+        public static HSASpeech TUTORIAL_TRY_IT_OUT = CreateSpeech("Try it out!");
+        public static HSASpeech TUTORIAL_ALL_RIGHT = CreateSpeech("All right!");
+        public static HSASpeech TUTORIAL_LETS_LEARN_HOW = CreateSpeech("Let's learn how");
+        public static HSASpeech TUTORIAL_CAN_YOU_DO_IT = CreateSpeech("Can you do it?");
+        public static HSASpeech TUTORIAL_THINK_YOU_CAN_DO_IT = CreateSpeech("Think you can do it?");
+        public static HSASpeech TUTORIAL_GOT_IT = CreateSpeech("Got it");
+
+        // General tutorial notifications
+        public static HSASpeech TUTORIAL_NO_ENDTURN_ATK = CreateSpeech("Not yet! You can still attack");
+        public static HSASpeech TUTORIAL_NO_ENDTURN = CreateSpeech("Not yet! You have more cards to play!");
+        public static HSASpeech TUTORIAL_NO_ENDTURN_HP = CreateSpeech($"Not yet! Use your Hero Power. Press {AccessibleKey.SEE_PLAYER_HERO_POWER} to select it");
+
+        #region Hogger
+        public static HSASpeech TUTORIAL_HOGGER_START = CreateSpeech($"Your first opponent is a gnoll named Hogger. You will be playing as the powerful mage Jaina Proudmoore");
+
+        // Notifications
+        public static HSASpeech TUTORIAL01_HELP_07 = CreateSpeech("Save that for the enemy!");
+        public static HSASpeech TUTORIAL01_HELP_08 = CreateSpeech("Ignore the puny gnoll and finish off Hogger");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_CARD_READ = CreateSpeech($"Use the up and down arrow keys to read this card first");
+        public static HSASpeech TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateSpeech($"Summon the minion you just got first");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateSpeech($"Use {AccessibleKey.SEE_OPPONENT_MINIONS} and the arrow keys to read your opponent's minions first");
+
+        // Turn 2
+        public static HSASpeech TUTORIAL_HOGGER_2_0 = CreateSpeech($"When a turn starts, you always begin by drawing a card from your deck. Let's see the one we just drew");
+        public static HSASpeech TUTORIAL_HOGGER_2_1 = CreateSpeech($"{PRESS_KEY_TO(AccessibleKey.SEE_PLAYER_HAND, "look at the cards in your hand")}");
+        // Use the arrow keys to read this card
+        public static HSASpeech TUTORIAL_HOGGER_2_2 = CreateSpeech($"Ok, so... This card is a minion named Murloc Raider");
+        public static HSASpeech TUTORIAL_HOGGER_2_2B = CreateSpeech($"Minions are creatures that you can summon onto the battlefield to fight for your Hero");
+        public static HSASpeech TUTORIAL_HOGGER_2_2D = CreateSpeech($"This one costs 1 mana to summon and has 2 attack and 1 health");
+        public static HSASpeech TUTORIAL_HOGGER_2_3 = CreateSpeech($"Let's start by summoning this minion");
+        public static HSASpeech TUTORIAL_HOGGER_2_4 = CreateSpeech($"Press {AccessibleKey.CONFIRM} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_2_5 = CreateSpeech($"Press {AccessibleKey.CONFIRM} to confirm or {AccessibleKey.BACK} to cancel");
+        public static HSASpeech TUTORIAL_HOGGER_2_6 = CreateSpeech($"Minions must wait a turn to attack once they're summoned, so we have nothing left to do");
+        // Press E to end your turn
+
+        // Turn 3
+        public static HSASpeech TUTORIAL_HOGGER_3_0 = CreateSpeech("Your opponent's minion attacked your Hero so you took some damage");
+        public static HSASpeech TUTORIAL_HOGGER_3_1 = CreateSpeech("Let's see how much health we have left");
+        // Press V to look at your Hero
+        public static HSASpeech TUTORIAL_HOGGER_3_2 = CreateSpeech($"Use the up and down arrow keys to read your hero card");
+        public static HSASpeech TUTORIAL_HOGGER_3_2_HELP = CreateSpeech($"Use {AccessibleKey.SEE_PLAYER_HERO} and the arrow keys to find out how much health your Hero has");
+        public static HSASpeech TUTORIAL_HOGGER_3_3 = CreateSpeech($"If your Hero runs out of health, you lose. 28 health is still plenty though");
+        public static HSASpeech TUTORIAL_HOGGER_3_4 = CreateSpeech($"Let's look at your opponent's hero now. Press {AccessibleKey.SEE_OPPONENT_HERO}");
+        public static HSASpeech TUTORIAL_HOGGER_3_5 = CreateSpeech($"Can you find how much health he has?");
+        public static HSASpeech TUTORIAL_HOGGER_3_5_HELP = CreateSpeech($"Use the up and down arrow keys to read your opponent's hero card");
+        // Ues the arrow keys to read cards
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_3_6 = CreateSpeech($"Once your opponent's Hero runs out of health, you win");
+        public static HSASpeech TUTORIAL_HOGGER_3_7 = CreateSpeech($"Let's carry on");
+
+        // Turn 4
+        public static HSASpeech TUTORIAL_HOGGER_4_1 = CreateSpeech($"Looks like you got another minion. Can you summon this one yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_1_HELP = CreateSpeech($"Use {AccessibleKey.SEE_PLAYER_HAND} and {AccessibleKey.CONFIRM} to summon your minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_2 = CreateSpeech($"When you already have minions on the battlefield, you can use the left and right arrow keys to select where the new minion will be placed");
+        // Try it out
+        public static HSASpeech TUTORIAL_HOGGER_4_4 = CreateSpeech($"You now have two minions on the battlefield. This one was just summoned so it must wait a turn to attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_5 = CreateSpeech("Let's learn how to navigate the battlefield");
+        // Press B to look at your summoned minions
+        public static HSASpeech TUTORIAL_HOGGER_4_6 = CreateSpeech($"Use the left and right arrow keys to navigate your minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_6_HELP = CreateSpeech($"Use {AccessibleKey.SEE_PLAYER_MINIONS} and the arrow keys to navigate your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_8 = CreateSpeech($"Let's look at your opponent's minions now. Press {AccessibleKey.SEE_OPPONENT_MINIONS} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_4_9 = CreateSpeech($"Can you read this minion by yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_9_HELP = CreateSpeech($"Use the up and down arrow keys to read your opponent's minions");
+        // You got it
+        public static HSASpeech TUTORIAL_HOGGER_4_10 = CreateSpeech($"Let's try to attack this minion now");
+        public static HSASpeech TUTORIAL_HOGGER_4_11 = CreateSpeech($"Select the Murloc Raider you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_4_11_HELP = CreateSpeech($"Use {AccessibleKey.SEE_PLAYER_MINIONS} to get to your minion and {AccessibleKey.CONFIRM} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_12 = CreateSpeech($"Press {AccessibleKey.CONFIRM} to attack with this minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_13 = CreateSpeech($"Can you attack your opponent's minion?");
+        public static HSASpeech TUTORIAL_HOGGER_4_13_HELP = CreateSpeech($"Use {AccessibleKey.SEE_OPPONENT_MINIONS} and {AccessibleKey.CONFIRM} to attack your opponent's minion");
+        // Press G to look at your opponent's minions and enter to attack
+        // Nice one
+        public static HSASpeech TUTORIAL_HOGGER_4_16 = CreateSpeech($"Both minions had 2 attack and 1 health so they killed each other");
+        public static HSASpeech TUTORIAL_HOGGER_4_17 = CreateSpeech($"Your other minion is still exhausted so there's nothing left to do. Remember how to end your turn?");
+
+        // Turn 6
+        public static HSASpeech TUTORIAL_HOGGER_6_1 = CreateSpeech($"Looks like you got another minion");
+        public static HSASpeech TUTORIAL_HOGGER_6_2 = CreateSpeech($"This means you have two possible options right now");
+        public static HSASpeech TUTORIAL_HOGGER_6_3 = CreateSpeech($"You can either summon the minion you just got, or use the one you summoned last turn to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_4 = CreateSpeech($"One way to do this would be using keys such as {AccessibleKey.SEE_PLAYER_HAND} to look at your hand or {AccessibleKey.SEE_PLAYER_MINIONS} to look at your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_6_5 = CreateSpeech($"However, there's an easier way to do it");
+        // Let's learn how
+        public static HSASpeech TUTORIAL_HOGGER_6_6 = CreateSpeech($"Press {AccessibleKey.READ_NEXT_VALID_ITEM}");
+        public static HSASpeech TUTORIAL_HOGGER_6_7 = CreateSpeech($"You're now looking at your first option, which would be to summon the minion you just got");
+        public static HSASpeech TUTORIAL_HOGGER_6_8 = CreateSpeech($"Try pressing {AccessibleKey.READ_NEXT_VALID_ITEM} again");
+        public static HSASpeech TUTORIAL_HOGGER_6_9 = CreateSpeech($"You're now looking at your second option, which would be to attack with the minion you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_6_10 = CreateSpeech($"You can always use {AccessibleKey.READ_NEXT_VALID_ITEM} to go through your valid options, so make sure to remember this key!");
+        public static HSASpeech TUTORIAL_HOGGER_6_12 = CreateSpeech($"Alright. Let's begin by summoning the minion we just got"); // TODO: We may be too strict here
+        // Can you do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_12_HELP = CreateSpeech($"Use {AccessibleKey.READ_NEXT_VALID_ITEM} or {AccessibleKey.SEE_PLAYER_HAND} and {AccessibleKey.CONFIRM} to summon your minion");
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_6_13 = CreateSpeech($"Let's try to attack with our other minion now");
+        // Think you can do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_13_HELP = CreateSpeech($"Use {AccessibleKey.READ_NEXT_VALID_ITEM} or {AccessibleKey.SEE_PLAYER_MINIONS} to find your minion and {AccessibleKey.CONFIRM} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_14 = CreateSpeech($"You now have another choice to make. You can either attack one of your opponent's minions, or your opponent's hero himself");
+        public static HSASpeech TUTORIAL_HOGGER_6_15 = CreateSpeech($"You can either use {AccessibleKey.READ_NEXT_VALID_ITEM} to go through your valid targets or select your target directly using {AccessibleKey.SEE_OPPONENT_MINIONS} or {AccessibleKey.SEE_OPPONENT_HERO}");
+        public static HSASpeech TUTORIAL_HOGGER_6_16 = CreateSpeech($"Go ahead and choose a target to attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_16_HELP = CreateSpeech($"Use {AccessibleKey.READ_NEXT_VALID_ITEM} and {AccessibleKey.CONFIRM} to launch an attack");
+        // Nice work
+        public static HSASpeech TUTORIAL_HOGGER_6_21 = CreateSpeech($"We're ready to end our turn!");
+
+        // Turn 8
+        public static HSASpeech TUTORIAL_HOGGER_8_1 = CreateSpeech($"I'll let you continue playing by yourself. Just let me know if you need anything");
+
+        #endregion
+
+        #region Millhouse
+        public static HSASpeech TUTORIAL_02_HELP_01 = CreateSpeech("You gain a Mana Crystal every turn");
+        public static HSASpeech TUTORIAL02_HELP_03 = CreateSpeech("Your used Mana Crystals refill each turn");
+        public static HSASpeech TUTORIAL02_HELP_06 = CreateSpeech("Get Millhouse!");
+        public static HSASpeech TUTORIAL02_HELP_07 = CreateSpeech("Expend your Mana each turn to crush this annoying gnome!");
+
+        public static HSASpeech TUTORIAL_RAID_LEADER_DESCRIPTION = CreateSpeech("This minion has a power that lasts until he dies");
+        public static HSASpeech TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateSpeech("You can have 10 cards in your hand");
+
+        // Turn 1
+        public static HSASpeech TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateSpeech($"Press {AccessibleKey.SEE_PLAYER_MANA} at any time to see how much mana you have");
+        #endregion
+
+        #region Lorewalker Cho
+        public static HSASpeech TUTORIAL06_HELP_03 = CreateSpeech("Minions with Battlecry do something special when you summon them"); // Adapation of the original one
+        public static HSASpeech TUTORIAL_CHO_1 = CreateSpeech("This Voodoo Doctor healed your opponent's Hero");
+        public static HSASpeech TUTORIAL06_HELP_02 = CreateSpeech("When minions fight each other, they both take damage");
+        public static HSASpeech TUTORIAL06_HELP_04 = CreateSpeech("Kill enemy minions before they become a problem!");
+        #endregion
+
+        #region King Mukla
+        public static HSASpeech TUTORIAL_MUKLA_START = CreateSpeech("In this game, you'll see some cards with abilities you haven't seen before");
+        public static HSASpeech TUTORIAL_MUKLA_START_B = CreateSpeech($"If you run into something you don't understand when reading a card such as Charge or Taunt, press {AccessibleKey.READ_TOOLTIP} to get more information");
+        public static HSASpeech TUTORIAL_MUKLA_START_C = CreateSpeech($"Press {AccessibleKey.CONFIRM} whenever you're ready to start");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP = CreateSpeech($"This gorilla your opponent just summoned has an ability named Taunt");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_B = CreateSpeech($"Minions with Taunt must always be killed before you can attack anyone else");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_C = CreateSpeech($"Taunt is an important ability as it can be used to protect your Hero");
+        #endregion
+
+        #region Nesingwary
+        public static HSASpeech TUTORIAL04_HELP_14 = CreateSpeech($"Welcome to the Jungle");
+        public static HSASpeech TUTORIAL04_HELP_15 = CreateSpeech($"Kill his minions or he'll overwhelm you!");
+        public static HSASpeech TUTORIAL04_HELP_16 = CreateSpeech($"Subdue minions with your hero power and spells!");
+        public static HSASpeech TUTORIAL04_HELP_02 = CreateSpeech($"Sheep it!");
+        public static HSASpeech TUTORIAL04_HELP_03 = CreateSpeech($"Save that for the Fen Creeper!");
+
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP = CreateSpeech($"From now on, your Hero and your opponent's Hero will normally have a Hero Power");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateSpeech($"Every Hero has its own Hero Power and you can use it once per turn");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateSpeech($"You can always press {AccessibleKey.SEE_PLAYER_HERO_POWER} to see your Hero Power and {AccessibleKey.SEE_OPPONENT_HERO_POWER} to see your opponent's Hero Power");
+        // Try it out!
+        #endregion
+
+        #region Illidan
+        public static HSASpeech TUTORIAL05_HELP_03 = CreateSpeech($"This fight is totally not fair. Blame the terrible game designers");
+        public static HSASpeech TUTORIAL05_HELP_04 = CreateSpeech($"Your Taunt minions can protect you from attacks!");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateSpeech($"It looks like your opponent equipped a weapon");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateSpeech($"Weapons are special cards which can be equipped by heroes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateSpeech($"Each weapon has some attack and some durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateSpeech($"Once equipped, heroes can attack other characters during their turn");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateSpeech($"Your opponent equipped Warglaive of Azzinoth: a weapon with 2 attack and 2 durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateSpeech($"This means your opponent's Hero will have 2 attack during his turn, and will be able to attack any of your characters");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateSpeech($"Mages don't often use weapons, but you'll be able to play with some later on once you've unlocked other classes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateSpeech($"You can press {AccessibleKey.SEE_PLAYER_WEAPON} at any time to see your weapon or {AccessibleKey.SEE_OPPONENT_WEAPON} to see your opponent's one");
+
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateSpeech($"Hear that sound? Weapons lose durability every time their Hero attacks");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateSpeech($"Once they reach 0 durability, they break and the Hero can no longer attack");
+        #endregion
+
+        #endregion
+
+        #region In-game "Tutorials"
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateSpeech($"Every normal game starts with the mulligan phase");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateSpeech($"In this phase, both players can replace cards in their starting hand with random ones from their deck");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateSpeech($"Use the arrow keys or {AccessibleKey.READ_NEXT_VALID_ITEM} to go through your starting hand");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateSpeech($"If you see a card you don't like, press {AccessibleKey.CONFIRM} to mark it for replacement");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateSpeech($"Once you've marked all cards you'd like to replace, press {AccessibleKey.CONFIRM_MULLIGAN} to draw new ones and start the game");
+        #endregion
+
+        private static List<HSASpeech> s_speeches;
+        private static Dictionary<string, HSASpeech> s_speechDict;
+
+        private static HSASpeech CreateSpeech(string value, [CallerMemberName] string key=null)
+        {
+            if (key == null)
+            {
+                throw new ArgumentException($"Invoked CreateSpeech in an invalid context");
+            }
+
+            var newSpeech = new HSASpeech(key, value);
+            if (s_speeches == null)
+            {
+                s_speeches = new List<HSASpeech>();
+            }
+
+            if (s_speechDict == null)
+            {
+                s_speechDict = new Dictionary<string, HSASpeech>();
+            }
+
+            if (s_speechDict.ContainsKey(key))
+            {
+                throw new ArgumentException($"Fatal error initializing accessible speeches. Found duplicate speech: {key}");
+            }
+
+            s_speeches.Add(newSpeech);
+            s_speechDict.Add(key, newSpeech);
+
+            return newSpeech;
+        }
+
+        public static List<HSASpeech> GetAllSpeeches()
+        {
+            return s_speeches;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
new file mode 100644
index 0000000..c6ee0c2
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
@@ -0,0 +1,376 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleSpeechMgr : MonoBehaviour
+    {
+        class QueuedHSASpeech
+        {
+            internal HSASpeech Speech;
+            internal bool Interruptable;
+            internal Action OnFinishListener;
+
+            internal void OnFinish()
+            {
+                if (OnFinishListener != null)
+                {
+                    OnFinishListener();
+                }
+            }
+        }
+
+        private Queue<QueuedHSASpeech> m_queuedNarrations = new Queue<QueuedHSASpeech>();
+        private QueuedHSASpeech m_curNarration;
+
+        private Queue<QueuedText> m_queuedTexts = new Queue<QueuedText>();
+        private QueuedText m_curText;
+        private List<QueuedText> m_prevTexts = new List<QueuedText>();
+
+        private List<int> m_WPMSpeeds = new List<int>() { 100, 125, 150, 175, 200, 225, 250, 275, 300, 10000 };
+        private int m_curGameSpeed = 3; // Index based i.e. 150WPM
+        private int m_curCPS = CalcCPS(150);
+        private bool m_gameSpeedOptionLoaded;
+
+        private void Update()
+        {
+            if (Input.anyKeyDown && m_curText != null)
+            {
+                InterruptTexts();
+            }
+
+            if (m_curText == null && m_curNarration == null)
+            {
+                if (m_queuedTexts.Count > 0)
+                {
+                    var nextText = m_queuedTexts.Dequeue();
+                    AccessibleSpeechOptimizer.OptimizeText(nextText, m_prevTexts);
+                    StartCoroutine(OutputText(nextText));
+                }
+                else if (m_queuedNarrations.Count > 0)
+                {
+                    StartCoroutine(Play(m_queuedNarrations.Dequeue()));
+                }
+            }
+        }
+
+        internal void InterruptTexts()
+        {
+            m_curText?.Interrupt();
+
+            while (m_queuedTexts.Count > 0)
+            {
+                m_queuedTexts.Dequeue()?.Interrupt();
+            }
+        }
+
+        internal void Narrate(bool interruptable, Action onFinish, params HSASpeech[] speeches)
+        {
+            foreach (var speech in speeches)
+            {
+                m_queuedNarrations.Enqueue(new QueuedHSASpeech()
+                {
+                    Speech = speech,
+                    Interruptable = interruptable,
+                    OnFinishListener = onFinish,
+                });
+            }
+        }
+
+        internal void InterruptSpeeches()
+        {
+            var source = GetAudioSource();
+
+            if (m_curNarration != null)
+            {
+                if (m_curNarration.Interruptable)
+                {
+                    source?.Stop();
+                }
+                else
+                {
+                    return;
+                }
+            }
+
+            while (m_queuedNarrations.Count > 0 && m_queuedNarrations.Peek().Interruptable)
+            {
+                var s = m_queuedNarrations.Dequeue();
+                s?.OnFinish();
+            }
+        }
+
+        private AudioSource GetAudioSource()
+        {
+            return GetComponent<AudioSource>();
+        }
+
+        internal IEnumerator Narrate(HSASpeech speech)
+        {
+            InterruptSpeeches();
+
+            var newSpeech = new QueuedHSASpeech
+            {
+                Interruptable = false,
+                Speech = speech
+            };
+
+            m_queuedNarrations.Enqueue(newSpeech);
+
+            while (m_curNarration != newSpeech)
+            {
+                yield return null;
+            }
+
+            while (m_curNarration == newSpeech)
+            {
+                yield return null;
+            }
+        }
+
+        private IEnumerator Play(QueuedHSASpeech speech)
+        {
+            if (speech == null)
+            {
+                yield break;
+            }
+
+            m_curNarration = speech;
+
+            var hsDir = Directory.GetCurrentDirectory();
+            AccessibilityUtils.LogDebug($"CurrentWorkDir: {hsDir}");
+            var speechFileName = speech.Speech.GetFileName();
+            AccessibilityUtils.LogDebug($"Play: {speechFileName}");
+            var speechPath = Path.Combine(hsDir, "Accessibility", "Speeches", speechFileName);
+
+            var uri = new Uri(speechPath);
+            string url = uri.AbsoluteUri;
+
+            WWW www = new WWW(url);
+            yield return www;
+
+            var source = GetAudioSource();
+            source.clip = www.GetAudioClip(false, false, AudioType.OGGVORBIS);
+            source.Play();
+            // TODO: Figure out a way to play with the Narrator volume
+            //SoundManager.Get().Play(source, new SoundDef() { m_IgnoreDucking = true }); Not quite
+            //SoundManager.Get().PlayOneShot(source, null);
+
+            while (source.isPlaying)
+            {
+                yield return null;
+            }
+
+            speech.OnFinish();
+            m_curNarration = null;
+        }
+
+        internal void CalibrateScreenReaderSpeed(KeyCode key)
+        {
+            StartCoroutine(Calibrate(key));
+        }
+
+        private IEnumerator Calibrate(KeyCode key)
+        {
+            var text1 = "Your turn.";
+            var text2 = "You draw Firelands.";
+            var text3 = "You draw Shadow Word: Death.";
+            var text4 = "Your River Crocolisk attacks your opponent's Gurubashi Berserker.";
+
+            yield return RunCalibrationTest(text1, key);
+            yield return RunCalibrationTest(text2, key);
+            yield return RunCalibrationTest(text3, key);
+            yield return RunCalibrationTest(text4, key);
+        }
+
+        private IEnumerator RunCalibrationTest(string text, KeyCode key)
+        {
+            ScreenReader.Output("Ready?");
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            var stopwatch = new Stopwatch();
+            stopwatch.Start();
+            ScreenReader.Output(text);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            stopwatch.Stop();
+
+            LogCalibrationTime(text, stopwatch.ElapsedMilliseconds);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+        }
+
+        private void LogCalibrationTime(string text, float elapsedMillis)
+        {
+            var cps = (1000 * text.Length) / elapsedMillis;
+            var numWords = NumWords(text);
+            var wpm = (1000*60 * numWords) / elapsedMillis;
+
+            AccessibilityUtils.LogDebug($"CPS: {cps} / WPM: {wpm} ({numWords} words in {elapsedMillis}ms) text: {text}");
+        }
+
+        private int NumWords(string text)
+        {
+            var ret = 1;
+
+            foreach (var c in text)
+            {
+                if (c == ' ')
+                {
+                    ret++;
+                }
+            }
+
+            return ret;
+        }
+
+        #region TTS
+
+        private IEnumerator OutputText(QueuedText text)
+        {
+            m_curText = text;
+
+            text.Play();
+
+            while (text.IsPlaying())
+            {
+                yield return null;
+            }
+
+            m_prevTexts.Add(m_curText);
+            m_curText = null;
+        }
+
+        internal void OutputTextAndWait(string text, Action onStart=null, Action onEnd=null)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            if (text.Length == 0)
+            {
+                if (onStart != null) onStart();
+                if (onEnd != null) onEnd();
+                return;
+            }
+
+            m_queuedTexts.Enqueue(new QueuedText(text, onStart, onEnd));
+        }
+
+        internal void OutputText(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, false, false));
+        }
+
+        internal void OutputTextImmediately(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            InterruptTexts();
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, true, false));
+        }
+
+        internal void IncreaseSpeechRate()
+        {
+            IncWPM(1);
+        }
+
+        internal void DecreaseSpeechRate()
+        {
+            IncWPM(-1);
+        }
+
+        private void IncWPM(int inc)
+        {
+            LoadGameSpeedOptionIfNecessary();
+
+            var curIndex = m_curGameSpeed - 1;
+            var targetIndex = curIndex + inc;
+
+            if (targetIndex < 0 || targetIndex >= m_WPMSpeeds.Count)
+            {
+                return;
+            }
+            else
+            {
+                m_curGameSpeed = targetIndex + 1;
+                UpdateCPS();
+                SaveGameSpeed();
+                ScreenReader.Output($"Game speed {m_curGameSpeed}");
+
+                foreach(var text in m_queuedTexts)
+                {
+                    text.UpdateSpeed();
+                }
+            }
+        }
+
+        private void SaveGameSpeed()
+        {
+            Options.Get().SetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+        }
+
+        private void UpdateCPS()
+        {
+            var wpm = m_WPMSpeeds[m_curGameSpeed - 1];
+            m_curCPS = CalcCPS(wpm);
+        }
+
+        private static int CalcCPS(int wpm)
+        {
+            return wpm * 6 / 60;
+        }
+
+        internal int GetCPS()
+        {
+            LoadGameSpeedOptionIfNecessary();
+
+            return m_curCPS;
+        }
+
+        private void LoadGameSpeedOptionIfNecessary()
+        {
+            if (!m_gameSpeedOptionLoaded)
+            {
+                m_gameSpeedOptionLoaded = true;
+
+                int gameSpeed = Options.Get().GetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+
+                int wpmIndex = gameSpeed - 1;
+                if (wpmIndex < 0 || wpmIndex >= m_WPMSpeeds.Count)
+                {
+                    SaveGameSpeed();
+                    return;
+                }
+
+                m_curGameSpeed = gameSpeed;
+                UpdateCPS();
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
new file mode 100644
index 0000000..35bf872
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
@@ -0,0 +1,263 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleSpeechOptimizer
+    {
+        public static void OptimizeText(QueuedText text, List<QueuedText> prevTexts)
+        {
+            try
+            {
+                if (text == null)
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndDiedText(text, prevTexts))
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndTookDamageText(text, prevTexts))
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Attack and Died
+
+        private static bool OptimizeAttackAndDiedText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneDied(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            attacker = CleanUpOrderIfNeeded(attacker);
+            defender = CleanUpOrderIfNeeded(defender);
+
+            if (EqualsIgnoreCase(text, $"{attacker} and {defender} died.") ||
+                EqualsIgnoreCase(text, $"{defender} and {attacker} died.") ||
+                EqualsIgnoreCase(text, "All minions died."))
+            {
+                var entityTypes = "minions";
+
+                if (IsHero(attacker) || IsHero(defender))
+                {
+                    entityTypes = "characters";
+                }
+
+                queuedText.UpdateText($"Both {entityTypes} died.");
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{attacker} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(attacker);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{defender} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(defender);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+
+            return false;
+        }
+        private static bool OptimizeAttackAndTookDamageText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneTookDamage(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            var aAndBTookNDamageMatch = Regex.Match(text, $@"{attacker} and {defender} took (.*) damage.");
+            string dmgTaken;
+
+            if (aAndBTookNDamageMatch.Success)
+            {
+                dmgTaken = aAndBTookNDamageMatch.Groups[1].Value;
+            }
+            else
+            {
+                var bAndATookNDamageMatch = Regex.Match(text, $@"{defender} and {attacker} took (.*) damage.");
+
+                if (!bAndATookNDamageMatch.Success)
+                {
+                    return false;
+                }
+                else
+                {
+                    dmgTaken = bAndATookNDamageMatch.Groups[1].Value;
+                }
+            }
+
+            var entityTypes = "minions";
+
+            if (IsHero(attacker) || IsHero(defender))
+            {
+                entityTypes = "characters";
+            }
+            queuedText.UpdateText($"Both {entityTypes} took {dmgTaken} damage.");
+
+            return true;
+        }
+
+        private static string CleanUpOrderIfNeeded(string fullEntityName)
+        {
+            var parts = fullEntityName.Split(' ');
+
+            if (parts.Length == 0)
+            {
+                return fullEntityName;
+            }
+
+            if (EqualsIgnoreCase(parts[0], "your"))
+            {
+                if (parts.Length >= 2 && EqualsIgnoreCase(parts[1], "opponent's"))
+                {
+
+                    if (parts.Length >= 3 && AccessibleSpeechUtils.IsOrder(parts[2]))
+                    {
+                        return CreateNameWithoutOrder(parts, 2);
+                    }
+                }
+                else if (parts.Length >= 2 && AccessibleSpeechUtils.IsOrder(parts[1]))
+                {
+                    return CreateNameWithoutOrder(parts, 1);
+                }
+            }
+
+            return fullEntityName;
+        }
+
+        private static string CreateNameWithoutOrder(string[] parts, int orderIndex)
+        {
+            var sb = new StringBuilder();
+
+            for (int i = 0; i < parts.Length; i++)
+            {
+                if (i != orderIndex)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(' ');
+                    }
+
+                    sb.Append(parts[i]);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string SimplifyEntityDiedText(string entity)
+        {
+            if (IsHero(entity))
+            {
+                return $"{entity} died.";
+            }
+            else if (IsOpponentEntity(entity))
+            {
+                return "Your opponent's minion died.";
+            }
+            else if (IsPlayerEntity(entity))
+            {
+                return "Your minion died.";
+            }
+
+            Log.Accessibility.PrintWarning($"Failed to simplify entity died text: {entity}");
+            return entity;
+        }
+
+        private static bool SomeoneDied(string text)
+        {
+            return Regex.Match(text, @"(.*) died.").Success;
+        }
+
+        private static bool SomeoneTookDamage(string text)
+        {
+            return Regex.Match(text, @"(.*) took .* damage.").Success;
+        }
+
+        #endregion
+
+        private static bool IsOpponentEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your opponent's ");
+        }
+
+        private static bool IsPlayerEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your ");
+        }
+
+        private static bool StartsWithIgnoreCase(string s1, string s2)
+        {
+            return s1.ToLowerInvariant().StartsWith(s2.ToLowerInvariant());
+        }
+
+        private static bool IsHero(string entity)
+        {
+            return EqualsIgnoreCase(entity, "Your hero") || EqualsIgnoreCase(entity, "Your opponent's hero");
+        }
+
+        private static bool EqualsIgnoreCase(string a, string b)
+        {
+            return a.Equals(b, StringComparison.InvariantCultureIgnoreCase);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
new file mode 100644
index 0000000..b8c7cc7
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
@@ -0,0 +1,299 @@
+﻿using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class AccessibleSpeechUtils
+    {
+        private static Dictionary<int, string> ORDERS = new Dictionary<int, string>
+        {
+            [1] = "first",
+            [2] = "second",
+            [3] = "third",
+            [4] = "fourth",
+            [5] = "fifth",
+            [6] = "sixth",
+            [7] = "seventh",
+            [8] = "eighth",
+            [9] = "ninth",
+            [10] = "tenth",
+        };
+
+        private static string GetFullName(Entity entity)
+        {
+            return $"{GetPossessivePronoun(entity)} {GetName(entity)}";
+        }
+
+        internal static string GetFullNameInZone(Entity entity)
+        {
+            if (entity.GetZone() == TAG_ZONE.GRAVEYARD ||
+                entity.GetZone() == TAG_ZONE.INVALID ||
+                entity.GetZone() == TAG_ZONE.REMOVEDFROMGAME ||
+                entity.GetZone() == TAG_ZONE.SETASIDE)
+            {
+                return GetFullName(entity);
+            }
+
+            var entitiesInZone = new List<Entity>();
+
+            foreach (var card in entity.GetCard().GetZone()?.GetCards())
+            {
+                entitiesInZone.Add(card.GetEntity());
+            }
+
+            return GetFullNameInList(entity, entitiesInZone);
+        }
+
+        internal static string GetFullNameInList(Entity entity, List<Entity> entitiesInZone)
+        {
+            // TODO: entities are not necessarily in the same zone so there may be cases where this is confusing.. e.g. your X (in your hand) and your X (in your battlefield) did Y
+            // Haven't really run into anything yet so keeping it like this for now
+
+            int entityNum = 0;
+            int entityCount = 0;
+
+            foreach(var ent in entitiesInZone)
+            {
+                if (GetFullName(ent).Equals(GetFullName(entity)))
+                {
+                    entityCount++;
+                }
+
+                if (ent.GetEntityId() == entity.GetEntityId())
+                {
+                    entityNum = entityCount;
+                }
+            }
+
+            if (entityCount <= 1)
+            {
+                return $"{GetPossessivePronoun(entity)} {GetName(entity)}";
+            }
+            else
+            {
+                return $"{GetPossessivePronoun(entity)} {GetOrder(entityNum)} {GetName(entity)}";
+            }
+        }
+
+        private static string GetOrder(int entityNum)
+        {
+            if (entityNum >= 1 && entityNum <= 10)
+            {
+                return ORDERS[entityNum];
+            }
+
+            Log.Accessibility.Print($"GetOrder called with entityNum={entityNum}");
+            return "other";
+        }
+
+        internal static bool IsOrder(string order)
+        {
+            return ORDERS.ContainsValue(order);
+        }
+
+        private static string GetPossessivePronoun(Entity entity)
+        {
+            if (entity.IsControlledByFriendlySidePlayer())
+            {
+                return "your";
+            }
+            else
+            {
+                return "your opponent's";
+            }
+        }
+
+        internal static string GetName(Entity entity)
+        {
+            if (entity.IsHero())
+            {
+                return "Hero";
+            }
+            else if (entity.IsHeroPower())
+            {
+                return "Hero Power";
+            }
+            else if (entity.GetCardType() == TAG_CARDTYPE.INVALID)
+            {
+                return "card";
+            }
+            else
+            {
+                return entity.GetName();
+            }
+        }
+
+        internal static string GetNames(List<Card> cards)
+        {
+            // Mostly used for mulligan (cards only i.e. no heroes)
+            var nameCounts = new Dictionary<string, int>();
+            var orderedCardNames = new List<string>(); // Could just create an insertion-order dictionary but whatever
+
+            foreach (var card in cards)
+            {
+                var cardName = card.GetEntity().GetName();
+
+                if (nameCounts.ContainsKey(cardName))
+                {
+                    nameCounts[cardName]++;
+                }
+                else
+                {
+                    nameCounts.Add(cardName, 1);
+                    orderedCardNames.Add(cardName);
+                }
+            }
+
+            return HumanizeNames(orderedCardNames, nameCounts);
+        }
+
+        internal static string HumanizeNames(List<string> orderedNames, Dictionary<string, int> nameCounts)
+        {
+            var sb = new StringBuilder();
+            int idx = 0;
+
+            orderedNames = GetDistinct(orderedNames);
+
+            foreach(var name in orderedNames)
+            {
+                if (idx > 0)
+                {
+                    if (idx < orderedNames.Count - 1)
+                    {
+                        sb.Append(", ");
+                    }
+                    else
+                    {
+                        sb.Append(" and ");
+                    }
+                }
+
+                var curNameCount = nameCounts[name];
+
+                if (curNameCount > 1 && name.Equals("card"))
+                {
+                    sb.Append($"{curNameCount} cards");
+                }
+                else
+                {
+                    sb.Append($"{curNameCount} {name}");
+                }
+
+                idx++;
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetDistinct(List<string> elems)
+        {
+            var ret = new List<string>();
+            var handled = new HashSet<string>();
+
+            foreach(var elem in elems)
+            {
+                if (!handled.Contains(elem))
+                {
+                    ret.Add(elem);
+                    handled.Add(elem);
+                } 
+            }
+
+            return ret;
+        }
+
+        public static string HumanizeList(List<string> list)
+        {
+            if (list.Count == 0)
+            {
+                return "";
+            }
+
+            if (list.Count == 1)
+            {
+                return list[0];
+            }
+            else
+            {
+                var sb = new StringBuilder();
+
+                for (int i = 0; i < list.Count - 1; i++)
+                {
+                    if (i != 0)
+                    {
+                        sb.Append(", ");
+                    }
+
+                    sb.Append($"{list[i]}");
+                }
+
+                sb.Append($" and {list[list.Count - 1]}");
+
+                return sb.ToString();
+            }
+        }
+
+        private static bool EqualsIgnoreCase(string a, string b)
+        {
+            return a.Equals(b, System.StringComparison.InvariantCultureIgnoreCase);
+        }
+
+        internal static string StringifyClass(TAG_CLASS clazz)
+        {
+            if (clazz == TAG_CLASS.DEMONHUNTER)
+            {
+                return "Demon Hunter";
+            }
+            else if (clazz == TAG_CLASS.DEATHKNIGHT)
+            {
+                return "Death Knight";
+            }
+            else
+            {
+                return clazz.ToString().ToLower();
+            }
+        }
+
+        internal static string CombineLines(List<string> lines)
+        {
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (line.Length == 0)
+                {
+                    continue;
+                }
+
+                if (sb.Length > 0)
+                {
+                    if (sb[sb.Length - 1] != '.')
+                    {
+                        sb.Append(".");
+                    }
+
+                    sb.Append(" ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        internal static string PluralizeFirstVerbIfNeeded(string speech)
+        {
+            if (speech.StartsWith("was "))
+            {
+                speech = speech.Replace("was ", "were ");
+            }
+            else if (speech.StartsWith("is "))
+            {
+                speech = speech.Replace("is ", "are ");
+            }
+
+            return speech;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
new file mode 100644
index 0000000..e4c4811
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
@@ -0,0 +1,151 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleTutorialProgressScreen : AccessibleScreen
+    {
+        private static AccessibleTutorialProgressScreen s_instance = new AccessibleTutorialProgressScreen();
+
+        internal static AccessibleTutorialProgressScreen Get()
+        {
+            return s_instance;
+        }
+
+        private enum AccessibleTutorialProgressScreenState {
+            READY_TO_START,
+            WAITING_FOR_ANIMATIONS
+        }
+
+        private AccessibleTutorialProgressScreenState m_curState;
+
+        private HeroCoin m_nextOpponentCoin;
+
+        public static void OnStartTutorial()
+        {
+            AccessibilityMgr.Output(AccessibleSpeech.TUTORIAL_LOADING_FIRST_TIME);
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed() && m_curState == AccessibleTutorialProgressScreenState.READY_TO_START)
+            {
+                m_nextOpponentCoin.TriggerRelease();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case AccessibleTutorialProgressScreenState.READY_TO_START:
+                    return $"Press {AccessibleKey.CONFIRM} to start";
+                default:
+                    return "";
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+            // TODO: Think about this
+            AccessibilityMgr.Output("Tutorial screen");
+        }
+
+        public void OnDefeatedOpponent(HeroCoin heroCoin)
+        {
+            try
+            {
+                AccessibilityMgr.SetScreen(this);
+
+                var missionId = heroCoin.GetMissionId();
+                ScenarioDbId scenario = (ScenarioDbId)missionId;
+
+                HSASpeech speech = null;
+
+                switch (scenario)
+                {
+                    case ScenarioDbId.TUTORIAL_HOGGER:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_HOGGER;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MILLHOUSE:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_MILLHOUSE;
+                        break;
+                    case ScenarioDbId.TUTORIAL_CHO:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_CHO;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MUKLA:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_MUKLA;
+                        break;
+                    case ScenarioDbId.TUTORIAL_NESINGWARY:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_NESINGWARY;
+                        break;
+                    case ScenarioDbId.TUTORIAL_ILLIDAN:
+                        speech = AccessibleSpeech.TUTORIAL_DEFEATED_ILLIDAN;
+                        break;
+                }
+
+                if (speech != null)
+                {
+                    AccessibilityMgr.NarrateAndWait(speech);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnNextOpponent(HeroCoin heroCoin)
+        {
+            try
+            {
+                AccessibilityMgr.SetScreen(this);
+                m_nextOpponentCoin = heroCoin;
+
+                var missionId = heroCoin.GetMissionId();
+                ScenarioDbId scenario = (ScenarioDbId)missionId;
+
+                HSASpeech speech = null;
+
+                switch (scenario)
+                {
+                    case ScenarioDbId.TUTORIAL_HOGGER:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_HOGGER;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MILLHOUSE:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_MILLHOUSE;
+                        break;
+                    case ScenarioDbId.TUTORIAL_CHO:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_CHO;
+                        break;
+                    case ScenarioDbId.TUTORIAL_MUKLA:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_MUKLA;
+                        break;
+                    case ScenarioDbId.TUTORIAL_NESINGWARY:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_NESINGWARY;
+                        break;
+                    case ScenarioDbId.TUTORIAL_ILLIDAN:
+                        speech = AccessibleSpeech.TUTORIAL_NEXT_ILLIDAN;
+                        break;
+                }
+
+                if (speech != null)
+                {
+                    AccessibilityMgr.NarrateAndWait(speech);
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE, () => m_curState = AccessibleTutorialProgressScreenState.READY_TO_START);
+                }
+                else
+                {
+                    Log.Accessibility.PrintWarning($"Failed to describe next tutorial. Unknown tutorial missionID: {scenario}");
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    m_curState = AccessibleTutorialProgressScreenState.READY_TO_START;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs
new file mode 100644
index 0000000..4adc09b
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUI.cs
@@ -0,0 +1,9 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleUI
+    {
+        void HandleAccessibleInput();
+
+        string GetAccessibleHelp();
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
new file mode 100644
index 0000000..0306ff0
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
@@ -0,0 +1,137 @@
+﻿using UnityEngine;
+
+public class AccessibleUnityInput : IInput
+{
+	private Vector3 m_mousePosition;
+	private bool[] m_buttonIsDown = new bool[3];
+	private bool[] m_buttonWasDown = new bool[3];
+
+	private static AccessibleUnityInput s_instance;
+
+	private static bool m_enabled = true;
+
+	private AccessibleUnityInput() { }
+
+	public static AccessibleUnityInput Get()
+    {
+		if (s_instance == null)
+        {
+			s_instance = new AccessibleUnityInput();
+        }
+
+		return s_instance;
+    }
+
+	public bool GetMousePosition(out Vector3 position)
+	{
+		position = m_mousePosition;
+		return m_enabled;
+	}
+
+	public Vector3 GetMousePosition()
+	{
+		return m_mousePosition;
+	}
+
+	public bool GetAnyKey(out bool value)
+	{
+		value = Input.anyKey;
+		return m_enabled;
+	}
+
+	public bool GetAnyKeyDown(out bool value)
+	{
+		value = Input.anyKeyDown;
+		return m_enabled;
+	}
+
+	public bool GetKey(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKey(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyDown(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyDown(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyUp(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyUp(keycode);
+		return m_enabled;
+	}
+
+	public bool GetMouseButton(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButton on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonDown(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonDown on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = !m_buttonWasDown[button] && m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonUp(int button, out bool value)
+	{
+        if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonUp on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonWasDown[button] && !m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	internal void SetMousePosition(Vector3 pos)
+    {
+		m_mousePosition = pos;
+    }
+
+	// Must only be called once per frame per button!
+	internal void SetMouseButtonDown(int button, bool isDown)
+    {
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to SetMouseButtonDown on invalid button {button}");
+			return;
+        }
+
+		m_buttonWasDown[button] = m_buttonIsDown[button];
+		m_buttonIsDown[button] = isDown;
+    }
+
+	internal void ToggleEnabled()
+    {
+		m_enabled = !m_enabled;
+    }
+
+	private bool IsValidButton(int button)
+    {
+		return button >= 0 && button <= 2;
+    }
+
+	internal bool Enabled
+    {
+		get { return m_enabled;  }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs b/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
new file mode 100644
index 0000000..4197759
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
@@ -0,0 +1,390 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    public class CardEffectInterpreter
+    {
+        public enum CardEffect { UNKNOWN, FRIENDLY, UNFRIENDLY };
+
+        public static CardEffect GetEffect(string cardText)
+        {
+            try
+            {
+                return GetSpellEffect(cardText);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        private static CardEffect GetSpellEffect(string cardText)
+        {
+            if (IsSecret(cardText) ||
+                IsChooseAFriendlyMinion(cardText) ||
+                IsDiscover(cardText) ||
+                IsChooseN(cardText) ||
+                IsGiveSomething(cardText) ||
+                IsGainSomething(cardText) ||
+                IsDrawSomething(cardText) ||
+                IsRestoreSomething(cardText) ||
+                IsDoubleSomething(cardText) ||
+                IsPutACopyOf(cardText) ||
+                IsQuest(cardText) ||
+                IsWheneverItAttacks(cardText) ||
+                IsShuffle(cardText) ||
+                IsTrigger(cardText) ||
+                IsReveal(cardText) ||
+                IsSwap(cardText) ||
+                IsAddToHand(cardText) ||
+                IsReplaceYour(cardText) ||
+                IsAdapt(cardText) ||
+                IsResurrect(cardText) ||
+                IsSetGoodStats(cardText) ||
+                IsReturn(cardText) ||
+                IsRecruit(cardText) ||
+                IsSummon(cardText) ||
+                IsCostsLess(cardText) ||
+                IsWildcard(cardText)
+                )
+            {
+                return CardEffect.FRIENDLY;
+            }
+            else if (IsDealNDamage(cardText) ||
+                IsDestroySomething(cardText) ||
+                IsFreezeSomething(cardText) ||
+                IsTakeControl(cardText) ||
+                IsGainControl(cardText) ||
+                IsTransformSomething(cardText) ||
+                IsChangeSomething(cardText) ||
+                IsReturnSomething(cardText) ||
+                IsSilenceSomething(cardText) ||
+                IsShoot(cardText) ||
+                IsDealDamage(cardText) ||
+                IsThrowWeaponAt(cardText) ||
+                IsReduce(cardText) ||
+                IsChooseAnEnemyMinion(cardText) ||
+                IsSetBadStats(cardText) ||
+                IsForceMinion(cardText)
+                )
+            {
+                return CardEffect.UNFRIENDLY;
+            }
+
+            return CardEffect.UNKNOWN;
+        }
+
+        private static Regex s_costsLessRegex = new Regex(@" costs \(\d\) less.");
+        private static bool IsCostsLess(string cardText)
+        {
+            return s_costsLessRegex.Match(cardText).Success;
+        }
+
+        private static bool IsChooseAnEnemyMinion(string cardText)
+        {
+            return cardText.Contains("Choose an enemy minion");
+        }
+
+        private static bool IsReduce(string cardText)
+        {
+            return cardText.Contains("Reduce ");
+        }
+
+        private static bool IsThrowWeaponAt(string cardText)
+        {
+            return cardText.Contains("Throw your weapon ");
+        }
+
+        private static bool IsRecruit(string cardText)
+        {
+            return cardText.Contains("<b>Recruit</b>");
+        }
+
+        private static bool IsReturn(string cardText)
+        {
+            return cardText.Contains(" return it ");
+        }
+
+        private static Regex s_setAtkHealthRegex = new Regex(@"Set a minion's Attack and Health to (\d).");
+        private static bool IsSetBadStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val < 3;
+        }
+
+        private static bool IsSetGoodStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val >= 3;
+        }
+
+        private static bool IsResurrect(string cardText)
+        {
+            return cardText.Contains("Resurrect ");
+        }
+
+        private static bool IsAdapt(string cardText)
+        {
+            return cardText.Contains("<b>Adapt</b>");
+        }
+
+        private static bool IsReplaceYour(string cardText)
+        {
+            return cardText.Contains("Replace your ");
+        }
+
+        private static Regex s_addToHandRegex = new Regex(@"Add .* to your hand.*");
+        private static Regex s_addToHandLCRegex = new Regex(@" add .* to your hand.*");
+        private static Regex s_addToHandBrokenRegex = new Regex(@"Add .* to_your hand.*");
+        private static Regex s_addToHandBroken2Regex = new Regex(@"Add .* to your_hand.*");
+        private static bool IsAddToHand(string cardText)
+        {
+            return s_addToHandRegex.Match(cardText).Success ||
+                s_addToHandLCRegex.Match(cardText).Success ||
+                s_addToHandBrokenRegex.Match(cardText).Success ||
+                s_addToHandBroken2Regex.Match(cardText).Success;
+        }
+
+        private static bool IsSwap(string cardText)
+        {
+            return cardText.Contains("Swap ");
+        }
+
+        private static bool IsReveal(string cardText)
+        {
+            return cardText.Contains("Reveal ");
+        }
+
+        private static bool IsTrigger(string cardText)
+        {
+            return cardText.Contains("Trigger ");
+        }
+
+        private static bool IsShuffle(string cardText)
+        {
+            return cardText.Contains("Shuffle ");
+        }
+
+        private static bool IsDealDamage(string cardText)
+        {
+            return cardText.Contains("Deal damage ") || cardText.Contains("Deal that much damage");
+        }
+
+        private static bool IsWheneverItAttacks(string cardText)
+        {
+            return cardText.Contains("Whenever it attacks");
+        }
+
+        private static bool IsShoot(string cardText)
+        {
+            return cardText.Contains("Shoot ");
+        }
+
+        private static bool IsQuest(string cardText)
+        {
+            return cardText.Contains("<b>Quest:</b>") || cardText.Contains("<b>Sidequest:</b>");
+        }
+
+        private static bool IsPutACopyOf(string cardText)
+        {
+            return cardText.Contains("Put a copy of");
+        }
+
+        private static bool IsDoubleSomething(string cardText)
+        {
+            return cardText.Contains("Double ");
+        }
+
+        private static bool IsSilenceSomething(string cardText)
+        {
+            return cardText.Contains("<b>Silence</b> ");
+        }
+
+        private static bool IsRestoreSomething(string cardText)
+        {
+            return cardText.Contains("Restore ");
+        }
+
+        private static bool IsReturnSomething(string cardText)
+        {
+            return cardText.Contains("Return ");
+        }
+
+        private static bool IsChangeSomething(string cardText)
+        {
+            return cardText.Contains("Change ");
+        }
+
+        private static bool IsTransformSomething(string cardText)
+        {
+            return cardText.Contains("Transform ");
+        }
+
+        private static bool IsDrawSomething(string cardText)
+        {
+            return cardText.Contains("Draw ");
+        }
+
+        private static bool IsGainSomething(string cardText)
+        {
+            return cardText.Contains("Gain ");
+        }
+
+        private static bool IsForceMinion(string cardText)
+        {
+            return cardText.Contains("Force ");
+        }
+
+        private static bool IsGainControl(string cardText)
+        {
+            return cardText.Contains("Gain control ") || cardText.Contains("gain control");
+        }
+
+        private static bool IsFreezeSomething(string cardText)
+        {
+            return cardText.Contains("<b>Freeze</b> a");
+        }
+
+        private static bool IsSummon(string cardText)
+        {
+            return cardText.Contains("Summon ") || cardText.Contains(" summon ");
+        }
+
+        private static bool IsDestroySomething(string cardText)
+        {
+            return cardText.Contains("Destroy ") || cardText.Contains(" destroy it");
+        }
+
+        private static bool IsGiveSomething(string cardText)
+        {
+            return cardText.Contains("Give ") || cardText.Contains(" give it") || cardText.Contains("G[x]ive ");
+        }
+
+        private static Regex s_dealNDamageRegex = new Regex(@".*Deal \*?\d+\*? damage.*");
+        private static Regex s_dealXYDamageRegex = new Regex(@".*Deal \*?\d+\*?-\*?\d\*? damage.*");
+        private static Regex s_dealNDamageBrokenRegex = new Regex(@".*Deal_\*?\d+\*? damage.*");
+        private static Regex s_dealNDamageBroken2Regex = new Regex(@".*Deal_\*?\d+\*?_damage.*");
+        private static Regex s_dealNDamageMidStringRegex = new Regex(@".*, deal \*?\d+\*? damage.*"); // See Scalerider
+        private static bool IsDealNDamage(string cardText)
+        {
+            return s_dealNDamageRegex.Match(cardText).Success ||
+                s_dealXYDamageRegex.Match(cardText).Success ||
+                s_dealNDamageBrokenRegex.Match(cardText).Success ||
+                s_dealNDamageBroken2Regex.Match(cardText).Success ||
+                s_dealNDamageMidStringRegex.Match(cardText).Success;
+        }
+
+        private static bool IsTakeControl(string cardText)
+        {
+            return cardText.Contains("Take control ");
+        }
+
+        private static bool IsChooseN(string cardText)
+        {
+            return cardText.Contains("<b>Choose One ") || cardText.Contains("<b>Choose Twice");
+        }
+
+        private static bool IsDiscover(string cardText)
+        {
+            return cardText.Contains("<b>Discover</b>");
+        }
+
+        private static bool IsSecret(string cardText)
+        {
+            return cardText.Contains("<b>Secret:</b>");
+        }
+
+        private static bool IsChooseAFriendlyMinion(string cardText)
+        {
+            return cardText.Contains("Choose a friendly minion");
+        }
+
+        private static HashSet<string> s_wildcards = new HashSet<string>()
+        {
+            "The next spell you cast this turn costs (2) less.",
+"Put a random minion from each player's hand into the battlefield.",
+"When you play or discard this, deal 4 damage to a random enemy.",
+"This turn, your healing effects deal damage instead.",
+"Add two Razorpetals to_your hand that deal_1 damage.",
+"Each time you play a Beast this turn, add_a_random Beast to_your hand.",
+"The next spell you cast this turn costs Health instead of Mana.",
+"Copy the lowest Cost minion in your hand.",
+"Each turn this is in your hand, transform it into a random Mage spell.",
+"Enemy spells cost (5) more next turn.",
+"Each player gains 2_Mana Crystals.",
+"Add 2 random <b>Deathrattle</b> cards to_your hand.",
+"Each player draws 2_cards.",
+"Whenever a minion dies this turn, gain 1 Mana Crystal this turn only.",
+"Your hero is <b>Immune</b> until your next turn.",
+"The next Elemental you_play this turn costs (2) less.",
+"Choose a minion. Add_a copy of it to your hand.",
+"Each player transforms a random minion in their hand into a Demon.",
+"Add a random card from another class to_your hand.",
+"Copy all Beasts in your_hand.",
+"Add a random Hunter Beast, <b>Secret</b>, and weapon to your_hand.",
+"Your hero can't take damage this turn.",
+"Your opponent has 2 fewer Mana Crystals next turn.",
+"Set the Attack of all enemy minions to 1 until your next turn.",
+"Your next spell this turn casts twice.",
+"Set each player to 0 Mana Crystals. Set the Cost of cards in all hands and decks to (1).",
+"Cast 10 random spells <i>(targets chosen randomly).</i>",
+        };
+
+        private static HashSet<string> s_wildcardSubsets = new HashSet<string>()
+        {
+            "Put one of each <b>Secret</b> from your deck into",
+            "Each player equips",
+            "Set the Attack and Health of all minions",
+            "Cast a random",
+            "Fill your hand with",
+            "When you play",
+            "At the start of your next turn",
+            "Increase the damage of",
+            "Play 3 cards\n with",
+            "Play 3 different",
+            "At the start of your next",
+            "Unlock your <b>Overloaded</b>",
+            "Take 6\n damage on your turns",
+            "Take 6\ndamage on your turns",
+        };
+
+        private static bool IsWildcard(string cardText)
+        {
+            if (s_wildcards.Contains(cardText))
+            {
+                return true;
+            }
+
+            foreach (var wc in s_wildcardSubsets)
+            {
+                if (cardText.Contains(wc))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs b/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs
new file mode 100644
index 0000000..9ad24e7
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/EntityComparer.cs
@@ -0,0 +1,38 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class EntityComparer : IEqualityComparer<Entity>
+    {
+        public bool Equals(Entity e1, Entity e2)
+        {
+            if (e1 == null || e2 == null)
+            {
+                // None of this should happen but..
+                if (e1 == e2)
+                {
+                    return true; // Keep the hashCode contract
+                }
+
+                return false;
+            }
+
+            return e1.GetEntityId() == e2.GetEntityId();
+        }
+
+        public int GetHashCode(Entity e)
+        {
+            if (e == null)
+            {
+                return 0;
+            }
+
+            return e.GetEntityId().GetHashCode();
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs b/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs
new file mode 100644
index 0000000..be55c7c
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HSADevTools.cs
@@ -0,0 +1,256 @@
+﻿using PegasusShared;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    class HSADevTools
+    {
+        private static int s_curCheat;
+
+        internal static void Init()
+        {
+            // Disable cinematics and other things blind users wouldn't be able to enjoy
+            InitNecessaryOverrides();
+
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+
+            //ResetRotationTutorial();
+
+            //ShowFakeNerfedCards();
+
+            //ShowFakeAddedCards();
+
+            //ShowGoldCapAlert();
+
+            //ShowFakeBreakingNews();
+
+            //ResetLoginPopupSequence();
+
+            //SetNewPlayerFirstTime();
+
+            //SetFirstTimeHub(); // Only applies on the next login actually
+
+            //SetNotReturningPlayer(); // Ran into something weird here and had to fix it -- TODO: Rethink this
+
+            //SetReturningPlayer(); // Done via method -- TODO: Rethink this
+        }
+
+        private static void ResetRotationTutorial()
+        {
+            SetNotReturningPlayer();
+            CheatMgr.Get().ProcessCheat("resetrotationtutorial veteran");
+        }
+
+        private static void ShowGoldCapAlert()
+        {
+            NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().Cap = -1;
+        }
+
+        private static void ShowFakeBreakingNews()
+        {
+            Vars.Key("Cheats.ShowFakeBreakingNews").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeAddedCards()
+        {
+            Vars.Key("Cheats.ShowFakeAddedCards").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeNerfedCards()
+        {
+            Vars.Key("Cheats.ShowFakeNerfedCards").Set(true.ToString(), false);
+        }
+
+        private static void ResetLoginPopupSequence()
+        {
+            GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.PLAYER_OPTIONS, GameSaveKeySubkeyId.LOGIN_POPUP_SEQUENCE_SEEN_POPUPS, new long[0]));
+        }
+
+        private static void InitNecessaryOverrides()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_NEW_CINEMATIC, true);
+        }
+
+        private static void SetNotReturningPlayer()
+        {
+            ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_NOT_RETURNING_PLAYER);
+        }
+
+        private static void SetReturningPlayer()
+        {
+            ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_ACTIVE);
+            Options.Get().SetInt(Option.RETURNING_PLAYER_BANNER_SEEN, 0);
+        }
+
+        private static void SetFirstTimeHub()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_HUB, false);
+            Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_TRAY, false);
+            Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, false);
+        }
+
+        private static void SetNewPlayerFirstTime()
+        {
+            var profileProgress = ReactiveNetCacheObject<NetCache.NetCacheProfileProgress>.CreateInstance();
+            profileProgress.Value.CampaignProgress = TutorialProgress.NOTHING_COMPLETE;
+        }
+
+        internal static void RunTests()
+        {
+            //ShowFatalError(); // TODO: Figure out where we want to test this given that it forces a close
+
+            RunManualTests();
+        }
+
+        private static void RunManualTests()
+        {
+            var cheats = new string[]{
+                // Daily quests on login
+                "iks",
+
+                // ReconnectHelperDialog
+                "hsashowreconnecthelperdialog false false false",
+                "hsashowreconnecthelperdialog false true false",
+                "hsashowreconnecthelperdialog true false false",
+
+                // Quest toasts
+                "notice gold 327 1 true",
+                "notice arcane_orbs 327 1 true",
+                "notice dust 327 1 true",
+                "notice booster 2 1 true",
+                "notice booster 1 10 true",
+                "notice card 2 NEW1_040 true",
+                "notice cardback 1 1 true",
+                "notice cardback 2 1 true",
+                "hsashowquesttoastmount",
+                "hsashowquesttoastminiset",
+
+                // Welcome quests
+                "hsashowwelcomequests",
+
+                // Returning player banner
+                "hsashowreturningplayerbanner",
+
+                // Show Set Rotation Tutorial Popup
+                "setrotationrotatedboosterspopup",
+
+                // Show Ranked Intro Popup
+                "rankedintropopup",
+
+                // Show login popup sequence - Not used for now as we're blocking it
+                // "loginpopupsequence",
+
+                // Show arena coming soon popup
+                // TODO: CheatMgr has an "arena popup" command for this but we never have prefabs for the next one so
+
+                // Alerts & Warnings
+                "alert",
+                "warning",
+
+                // Other popups
+                "hsashowstandardcomingsoonpopup",
+                "hsashowcoresetavailablepopup",
+                "hsashowwhizbangpopup",
+
+                // Quest progress legacy popup
+                "questprogresspopup QuestTitle QuestDescription 3 10",
+
+                // Quest complete popups
+                "questcompletepopup 1", // Hero
+                "questcompletepopup 11", // Card pack
+                "questcompletepopup 12", // Gold
+                "questcompletepopup 55", // Arcane Dust
+                "questcompletepopup 58", // Card
+                "questcompletepopup 59", // Gold Card
+                "questcompletepopup 60", // Rare Card
+                "questcompletepopup 61", // Gold legendary card
+                "questcompletepopup 94", // Free ticket
+                "questcompletepopup 98", // Golden hero unlocked (druid)
+                "questcompletepopup 110", // Mount
+                "questcompletepopup 130", // Two cards
+                "questcompletepopup 215", // Card back
+                "questcompletepopup 2628", // Arcane orbs
+
+                // Season end dialog with reward chests
+                "seasondialog diamond1",
+
+                // Banners
+                "banner",
+
+                // End of game experience
+                "simendofgamexp 7",
+
+                // Quote
+                "quote default",
+
+                // Fixed rewards
+                "fixedrewardcomplete 5794",
+
+                // Legacy rewards
+                //"hsashowleaguepromotionrewards", // Seems broken as it's missing a "done" button at the end when all packages open
+                //"hsashowquestchestreward", // Seems broken as it's missing a "done" button at the end when all packages open
+
+                // Rank rewards
+                "rankreward bronze5 all", // TODO: Not implemented yet
+
+                // Track rewards
+                "showtrackreward 1 1 1", // 1 Card
+                "showtrackreward 1 1 2", // 2 Boosters
+                "showtrackreward 1 1 4", // 1 Random card
+                "showtrackreward 1 1 5", // 1 Custom coin
+                "showtrackreward 1 1 7", // GOLD; DUST; BOOSTER; BOOSTER; TAVERN_TICKET; CARD; RANDOM_CARD; CARD_BACK; HERO_SKIN; CUSTOM_COIN;
+                "showtrackreward 1 1 10", // CARD; REWARD_TRACK_XP_BOOST;
+                "showtrackreward 1 1 15", // Hero skin
+                "showtrackreward 1 1 16", // Gold
+                "showtrackreward 1 1 20", // Card back
+                "showtrackreward 1 1 26", // Tavern ticket
+                "showtrackreward 1 1 68", // 10 Hero skins (Choose one)
+                "showtrackreward 1 1 78", // Arcane orbs
+                "showtrackreward 1 1 162", // Card subset (all from 162 - 205)
+
+                // ReconnectHelperDialog forcing a close
+                "hsashowreconnecthelperdialog true false true",
+
+                ///
+                ///
+                ///
+
+                // TODO: Decide how we're going to handle these which require something to change at login time (e.g. returning player, veteran, etc.)
+                // Used to test track rewards scroll vvv
+                //"hsashowchangedcardspopup", // 5 changed cards
+                //"hsashowaddedcardspopup", // 5 added cards
+
+                // TODO: Test fatal errors?
+            };
+
+            var curCheat = s_curCheat % cheats.Length;
+            var cheat = cheats[curCheat];
+
+            AccessibilityUtils.LogDebug($"Running test cheat: {cheat}");
+            CheatMgr.Get().ProcessCheat(cheat);
+
+            s_curCheat++;
+        }
+
+        private static void ShowFatalError()
+        {
+            /*var fatalErrorMessage = new FatalErrorMessage();
+            FatalErrorMgr.Get().Add(fatalErrorMessage);*/
+            Error.AddFatal(FatalErrorReason.INACTIVITY_TIMEOUT, "GLOBAL_ERROR_INACTIVITY_KICK");
+            var fatalErrorMessage = new FatalErrorMessage();
+            fatalErrorMessage.m_text = "It's been a while since your last Hearthstone action and your connection was shut down. Relaunch the game when you're ready!";
+            fatalErrorMessage.m_reason = FatalErrorReason.INACTIVITY_TIMEOUT;
+
+            SceneMgr.Get().GoToFatalErrorScreen(fatalErrorMessage);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs b/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs
new file mode 100644
index 0000000..6f06a3e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HSASpeech.cs
@@ -0,0 +1,52 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class HSASpeech
+    {
+        public static string FILE_EXTENSION = ".ogg";
+
+        public string Key { get; }
+
+        public string Value { get; }
+
+        public int Hash { get; }
+
+        public HSASpeech(string key, string value)
+        {
+            Key = key;
+            Value = value;
+            Hash = ComputeHashCode(value);
+        }
+
+        public HSASpeech(string key, int hash)
+        {
+            Key = key;
+            Hash = hash;
+        }
+
+        public string GetFileName()
+        {
+            return $"{Key}-{Hash}{FILE_EXTENSION}";
+        }
+
+        private int ComputeHashCode(string value)
+        {
+            unchecked
+            {
+                int hash1 = 5381;
+                int hash2 = hash1;
+
+                for (int i = 0; i < value.Length && value[i] != '\0'; i += 2)
+                {
+                    hash1 = ((hash1 << 5) + hash1) ^ value[i];
+                    if (i == value.Length - 1 || value[i + 1] == '\0')
+                        break;
+                    hash2 = ((hash2 << 5) + hash2) ^ value[i + 1];
+                }
+
+                return Math.Abs(hash1 + (hash2 * 1566083941));
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs b/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
new file mode 100644
index 0000000..9454a89
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
@@ -0,0 +1,32 @@
+﻿using System.IO;
+
+namespace Accessibility
+{
+    public class HearthstoneAccessConstants
+    {
+        public static string HEARTHSTONE_VERSION = "21.0.0.88998";
+
+        public static string HEARTHSTONE_ACCESS_VERSION = "1";
+
+        public static bool DEV_MODE = false;
+
+        public static bool DEBUG_SOUND = false;
+
+        public static string GetGithubToken()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-token.txt")) : null;
+        }
+
+        private static string GetGithubGroupName()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-group.txt")) : "HearthstoneAccess";
+        }
+
+        public static string GetHearthstoneAccessRepoUrl()
+        {
+            var githubGroupName = GetGithubGroupName();
+
+            return $"https://raw.githubusercontent.com/{githubGroupName}/HearthstoneAccess";
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs b/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs
new file mode 100644
index 0000000..b43e501
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/InGameSystemTests.cs
@@ -0,0 +1,57 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class InGameSystemTests
+    {
+        internal static void TestCardEffectInterpreter()
+        {
+            var allCards = CollectionManager.Get().GetAllCards();
+            AccessibilityUtils.LogDebug($"Testing {allCards.Count} cards");
+
+            int okCount = 0;
+            int failCount = 0;
+
+            foreach (var card in allCards)
+            {
+                //if (card.CardType == TAG_CARDTYPE.SPELL || IsBattlecryMinion(card)) // We don't really care about battlecries right now as none of the unhandled ones is really in a grey area
+                if (card.CardType == TAG_CARDTYPE.SPELL || card.CardType == TAG_CARDTYPE.HERO_POWER)
+                {
+                    if (IsEffectHandled(card))
+                    {
+                        okCount++;
+                    }
+                    else
+                    {
+                        failCount++;
+                        AccessibilityUtils.LogDebug($"Failed to handle {card.Name} - {card.CardInHandText}");
+                    }
+                }
+            }
+
+            AccessibilityUtils.LogDebug("Test ended");
+            AccessibilityUtils.LogDebug($"#OK: {okCount}");
+            AccessibilityUtils.LogDebug($"#FAIL: {failCount}");
+            AccessibilityUtils.LogDebug($"#TOTAL: {okCount + failCount}");
+        }
+
+        private static bool IsBattlecryMinion(CollectibleCard card)
+        {
+            if (card.CardType != TAG_CARDTYPE.MINION)
+            {
+                return false;
+            }
+
+            return card.CardInHandText.Contains("<b>Battlecry:</b>");
+        }
+
+        private static bool IsEffectHandled(CollectibleCard card)
+        {
+            return CardEffectInterpreter.GetEffect(card.CardInHandText) != CardEffectInterpreter.CardEffect.UNKNOWN;
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs b/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
new file mode 100644
index 0000000..b86947e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
@@ -0,0 +1,20 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    public abstract class InaccessibleDialogBase : DialogBase
+    {
+        public override string GetAccessibleHelp()
+        {
+            return "Unimplemented dialog. Please get help from someone sighted and report this to Guide Dev";
+        }
+
+        public override void HandleAccessibleInput()
+        {
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/NumberToWordsConverter.cs b/Decompiled/Assembly-CSharp/Accessibility/NumberToWordsConverter.cs
new file mode 100644
index 0000000..9216a11
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/NumberToWordsConverter.cs
@@ -0,0 +1,175 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    // Extracted from Humanizer's source code so we don't have to distribute that as well
+
+    class NumberToWordsConverter
+    {
+        private static readonly string[] UnitsMap = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen" };
+        private static readonly string[] TensMap = { "zero", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety" };
+
+        private static readonly Dictionary<long, string> OrdinalExceptions = new Dictionary<long, string>
+        {
+            {1, "first"},
+            {2, "second"},
+            {3, "third"},
+            {4, "fourth"},
+            {5, "fifth"},
+            {8, "eighth"},
+            {9, "ninth"},
+            {12, "twelfth"},
+        };
+
+        public static string Convert(long number)
+        {
+            return Convert(number, false);
+        }
+
+        public static string Convert(long number, bool addAnd = true)
+        {
+            return Convert(number, false, addAnd);
+        }
+
+        public static string ConvertToOrdinal(int number)
+        {
+            return Convert(number, true);
+        }
+
+        private static string Convert(long number, bool isOrdinal, bool addAnd = true)
+        {
+            if (number == 0)
+            {
+                return GetUnitValue(0, isOrdinal);
+            }
+
+            if (number < 0)
+            {
+                return string.Format("minus {0}", Convert(-number));
+            }
+
+            var parts = new List<string>();
+
+            if ((number / 1000000000000000000) > 0)
+            {
+                parts.Add(string.Format("{0} quintillion", Convert(number / 1000000000000000000)));
+                number %= 1000000000000000000;
+            }
+
+            if ((number / 1000000000000000) > 0)
+            {
+                parts.Add(string.Format("{0} quadrillion", Convert(number / 1000000000000000)));
+                number %= 1000000000000000;
+            }
+
+            if ((number / 1000000000000) > 0)
+            {
+                parts.Add(string.Format("{0} trillion", Convert(number / 1000000000000)));
+                number %= 1000000000000;
+            }
+
+            if ((number / 1000000000) > 0)
+            {
+                parts.Add(string.Format("{0} billion", Convert(number / 1000000000)));
+                number %= 1000000000;
+            }
+
+            if ((number / 1000000) > 0)
+            {
+                parts.Add(string.Format("{0} million", Convert(number / 1000000)));
+                number %= 1000000;
+            }
+
+            if ((number / 1000) > 0)
+            {
+                parts.Add(string.Format("{0} thousand", Convert(number / 1000)));
+                number %= 1000;
+            }
+
+            if ((number / 100) > 0)
+            {
+                parts.Add(string.Format("{0} hundred", Convert(number / 100)));
+                number %= 100;
+            }
+
+            if (number > 0)
+            {
+                if (parts.Count != 0 && addAnd)
+                {
+                    parts.Add("and");
+                }
+
+                if (number < 20)
+                {
+                    parts.Add(GetUnitValue(number, isOrdinal));
+                }
+                else
+                {
+                    var lastPart = TensMap[number / 10];
+                    if ((number % 10) > 0)
+                    {
+                        lastPart += string.Format("-{0}", GetUnitValue(number % 10, isOrdinal));
+                    }
+                    else if (isOrdinal)
+                    {
+                        lastPart = lastPart.TrimEnd('y') + "ieth";
+                    }
+
+                    parts.Add(lastPart);
+                }
+            }
+            else if (isOrdinal)
+            {
+                parts[parts.Count - 1] += "th";
+            }
+
+            var toWords = string.Join(" ", parts.ToArray());
+
+            if (isOrdinal)
+            {
+                toWords = RemoveOnePrefix(toWords);
+            }
+
+            return toWords;
+        }
+
+        private static string GetUnitValue(long number, bool isOrdinal)
+        {
+            if (isOrdinal)
+            {
+                if (ExceptionNumbersToWords(number, out var exceptionString))
+                {
+                    return exceptionString;
+                }
+                else
+                {
+                    return UnitsMap[number] + "th";
+                }
+            }
+            else
+            {
+                return UnitsMap[number];
+            }
+        }
+
+        private static string RemoveOnePrefix(string toWords)
+        {
+            // one hundred => hundredth
+            if (toWords.IndexOf("one", StringComparison.Ordinal) == 0)
+            {
+                toWords = toWords.Remove(0, 4);
+            }
+
+            return toWords;
+        }
+
+        private static bool ExceptionNumbersToWords(long number, out string words)
+        {
+            return OrdinalExceptions.TryGetValue(number, out words);
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs b/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs
new file mode 100644
index 0000000..e626599
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/QueuedText.cs
@@ -0,0 +1,143 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class QueuedText
+    {
+        private string m_text;
+
+        private bool m_playing;
+
+        private Stopwatch m_stopwatch;
+
+        private float m_playTimeMs;
+
+        private Action m_onStart, m_onEnd;
+
+        private bool m_interrupt;
+        private bool m_wait;
+
+        public QueuedText(string text, Action onStart, Action onEnd, bool interrupt=false, bool wait=true)
+        {
+            m_wait = wait; // Needs to be set first so we handle all text updates properly
+
+            UpdateText(text);
+            m_stopwatch = new Stopwatch();
+
+            m_onStart = onStart;
+            m_onEnd = onEnd;
+
+            m_interrupt = interrupt;
+
+            //Log.Accessibility.Print($"SPS New QueuedText({text}) / PlayTime={m_playTimeMs}");
+        }
+
+        internal void UpdateText(string text)
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_text = text;
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        internal void UpdateSpeed()
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        private float EstimatePlayTimeMs()
+        {
+            // Was like this when testing initially vv
+            // Normal english speaking person rate = somewhere between 140~160. 150 seems like a good baseline
+            // Normal characters per word in english is ~4.5/wordl 5 seems like a good rate
+            // So 150WPM * 5Chars = 12.5CPS -> seems like a good baseline
+            // <100WPM is slow. JFK's speech was ~95WPM
+            // 100WPM is 8CPS
+            //int cps = 15; // This assumes 5/word + random spaces/punctuation = 1/word = 150WPM*6/60 = 15 CPS
+
+            //float safetyNet = 500;
+            //float safetyNet = 0;
+
+            if (!m_wait)
+            {
+                // Used for menus, popups, etc
+                return 0;
+            }
+
+            return (m_text.Length) / AccessibilityMgr.GetCPS() * 1000;
+        }
+
+        internal void Play()
+        {
+            if (!ScreenReader.Output(m_text, m_interrupt))
+            {
+                // e.g. optimized text which became empty
+                OnStartPlaying();
+                OnEndPlaying();
+            }
+            else
+            {
+                OnStartPlaying();
+            }
+        }
+
+        private void OnStartPlaying()
+        {
+            m_playing = true;
+            m_stopwatch.Start();
+
+            if (m_onStart != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnStartPlaying {m_text}");
+                m_onStart();
+            }
+        }
+
+        internal void Interrupt()
+        {
+            OnEndPlaying();
+        }
+
+        private void OnEndPlaying()
+        {
+            m_playing = false;
+            m_stopwatch.Stop();
+
+            if (m_onEnd != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnEndPlaying {m_text}");
+                m_onEnd();
+            }
+        }
+
+        internal bool IsPlaying()
+        {
+            if (m_stopwatch.ElapsedMilliseconds >= m_playTimeMs)
+            {
+                OnEndPlaying();
+            }
+
+            return m_playing;
+        }
+
+        public string GetText()
+        {
+            return m_text;
+        }
+    }
+}
\ No newline at end of file
diff --git a/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs b/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs
new file mode 100644
index 0000000..155515d
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/ScreenReader.cs
@@ -0,0 +1,41 @@
+﻿using DavyKager;
+using System;
+using System.IO;
+
+namespace Accessibility
+{
+    class ScreenReader
+    {
+        internal static bool Output(string text, bool interrupt=false)
+        {
+            if (text.Length == 0)
+            {
+                return false;
+            }
+
+            bool success = Tolk.Output(text, interrupt);
+
+            AccessibilityUtils.LogDebug($"Output to screen reader (success={success}): {text}");
+
+            return success;
+        }
+
+        internal static void Load()
+        {
+            // Append accessibility deps (e.g. Tolk, NVDA drivers, etc.) to PATH
+            string path = System.Environment.GetEnvironmentVariable("PATH", System.EnvironmentVariableTarget.Process);
+            string accessibilityAssembliesDir = Path.Combine(Directory.GetCurrentDirectory(), "Hearthstone_Data", "Managed", "Accessibility");
+            path += $";{accessibilityAssembliesDir}";
+            System.Environment.SetEnvironmentVariable("PATH", path, System.EnvironmentVariableTarget.Process);
+
+            // Load Tolk
+            Tolk.TrySAPI(true);
+            Tolk.Load();
+        }
+
+        internal static void Unload()
+        {
+            Tolk.Unload();
+        }
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs
new file mode 100644
index 0000000..4f62bdf
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_01.cs
@@ -0,0 +1,1296 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_01 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification handBounceArrow;
+
+    private Notification handFadeArrow;
+
+    private TooltipPanel attackHelpPanel;
+
+    private TooltipPanel healthHelpPanel;
+
+    private Card mousedOverCard;
+
+    private GameObject costLabel;
+
+    private GameObject attackLabel;
+
+    private GameObject healthLabel;
+
+    private Card firstMurlocCard;
+
+    private Card firstRaptorCard;
+
+    private GameObject startingPack;
+
+    private bool packOpened;
+
+    private bool announcerIsFinishedYapping;
+
+    private bool m_jainaSpeaking;
+
+    private bool m_isShowingAttackHelpPanel;
+
+    private bool m_fullyReadMurlocRaider;
+
+    private bool m_finishedReadingOpponentMinion;
+
+    private bool m_attackedOpponentMinion;
+
+    private bool m_attackedOpponentMinionOnTurn6;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool>
+        {
+            {
+                GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN,
+                true
+            },
+            {
+                GameEntityOption.SHOW_HERO_TOOLTIPS,
+                true
+            },
+            {
+                GameEntityOption.DISABLE_TOOLTIPS,
+                true
+            }
+        };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_01()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+        MulliganManager.Get().ForceMulliganActive(active: true);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8");
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41");
+        PreloadSound("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada");
+        PreloadSound("VO_TUTORIAL_01_JAINA_13_10.prefab:b13670e36c248e141837c4eb0645a000");
+        PreloadSound("VO_TUTORIAL_01_JAINA_01_01.prefab:883391234efbde84eb99a16abd164d9d");
+        PreloadSound("VO_TUTORIAL_01_JAINA_02_02.prefab:cccdcb509085a974d922ac1d545d9bb6");
+        PreloadSound("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47");
+        PreloadSound("VO_TUTORIAL_01_JAINA_20_16.prefab:7980d02c581e4174991a8066e5785666");
+        PreloadSound("VO_TUTORIAL_01_JAINA_05_05.prefab:982193e53ab81f04ba562de4b32dd39c");
+        PreloadSound("VO_TUTORIAL_01_JAINA_06_06.prefab:ffe0ebdca06ca1d4c84cc28e4a1ed7cf");
+        PreloadSound("VO_TUTORIAL_01_JAINA_07_07.prefab:a8bf811494e94d742a3910fac9da906f");
+        PreloadSound("VO_TUTORIAL_01_JAINA_21_17.prefab:c1524bd0ef92bb845b5dab48cbd017f9");
+        PreloadSound("VO_TUTORIAL_01_JAINA_09_08.prefab:b7b739d9e31865a478275394ee57ad89");
+        PreloadSound("VO_TUTORIAL_01_JAINA_15_11.prefab:a644986d34ab8964582c6221cde54d45");
+        PreloadSound("VO_TUTORIAL_01_JAINA_16_12.prefab:e6b4ab6fc1f11634e88f013ce5351e46");
+        PreloadSound("VO_TUTORIAL_JAINA_02_55_ALT2.prefab:d049e67ad6c16db4da2c04be7a02a1ae");
+        PreloadSound("VO_TUTORIAL_01_JAINA_10_09.prefab:5bf553d532aca174083f48bf407b2b11");
+        PreloadSound("VO_TUTORIAL_01_JAINA_17_13.prefab:9b257c86e7c7f9045a2b819d35876aca");
+        PreloadSound("VO_TUTORIAL_01_JAINA_18_14.prefab:fedcdecb3346ec745b6fb4204f7dd4e0");
+        PreloadSound("VO_TUTORIAL_01_JAINA_19_15.prefab:659652a121ac01941a40c64c1c151f87");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_01_01.prefab:5833f4aeb72110741a2c9bc3a92f9bc8");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_02_02.prefab:7f321b26431a4974a82deefc368adf63");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_03_03.prefab:4ef21f71824b97842b33d8ebccb37ed2");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_04_04.prefab:3e16e42edb324e2469a25363ffd013a6");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_06_06_ALT.prefab:6c9ef3c501462474ab59a37b967cab6f");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_08_08_ALT.prefab:19ddb4ddaa4aee2468b17bae25da9419");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_09_09_ALT.prefab:70c4d2941509856448660f89d6c72b2b");
+        PreloadSound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        base.NotifyOfGameOver(gameResult);
+        if (attackHelpPanel != null)
+        {
+            Object.Destroy(attackHelpPanel.gameObject);
+            attackHelpPanel = null;
+        }
+        if (healthHelpPanel != null)
+        {
+            Object.Destroy(healthHelpPanel.gameObject);
+            healthHelpPanel = null;
+        }
+        EnsureCardGemsAreOnTheCorrectLayer();
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.HOGGER_COMPLETE);
+                PlaySound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_01_HOGGER_11_11.prefab:1fdb0543bf56c4b4e95148a518bd9a2d");
+                break;
+        }
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            InputManager.Get().RemovePhoneHandShownListener(OnPhoneHandShown);
+            InputManager.Get().RemovePhoneHandHiddenListener(OnPhoneHandHidden);
+        }
+    }
+
+    private void EnsureCardGemsAreOnTheCorrectLayer()
+    {
+        List<Card> list = new List<Card>();
+        list.AddRange(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+            .GetCards());
+        list.AddRange(GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+            .GetCards());
+        list.Add(GameState.Get().GetFriendlySidePlayer().GetHeroCard());
+        list.Add(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+        foreach (Card item in list)
+        {
+            if (!(item == null) && !(item.GetActor() == null))
+            {
+                if (item.GetActor().GetAttackObject() != null)
+                {
+                    SceneUtils.SetLayer(item.GetActor().GetAttackObject().gameObject, GameLayer.Default);
+                }
+                if (item.GetActor().GetHealthObject() != null)
+                {
+                    SceneUtils.SetLayer(item.GetActor().GetHealthObject().gameObject, GameLayer.Default);
+                }
+            }
+        }
+    }
+
+	public override bool ShouldAllowCardGrab(Entity entity)
+	{
+        if (GetTag(GAME_TAG.TURN) == 2 && !m_fullyReadMurlocRaider)
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_FORCE_CARD_READ);
+            return false;
+        }
+		return true;
+	}
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (GetTag(GAME_TAG.TURN) == 2 || entity.GetCardId() == "TU5_CS2_025")
+        {
+            BoardTutorial.Get().EnableHighlight(enable: true);
+        }
+        NukeNumberLabels();
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        if (GetTag(GAME_TAG.TURN) == 2 || entity.GetCardId() == "TU5_CS2_025")
+        {
+            BoardTutorial.Get().EnableHighlight(enable: false);
+        }
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN_ATK";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        if (!GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    public override bool NotifyOfPlayError(PlayErrors.ErrorType error, int? errorParam, Entity errorSource)
+    {
+        if (error == PlayErrors.ErrorType.REQ_ATTACK_GREATER_THAN_0 && errorSource.GetCardId() == "TU4a_006")
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public override void NotifyOfTargetModeCancelled()
+    {
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_11_HELP);
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 1)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_SUMMON_MINION_FIRST);
+                return false;
+            }
+            
+            if (!m_finishedReadingOpponentMinion)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST);
+                return false;
+            }
+
+            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_13_HELP);
+        }
+        if (GetTag(GAME_TAG.TURN) == 6 && clickedEntity.GetZone() == TAG_ZONE.PLAY && GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() < 2)
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_HOGGER_SUMMON_MINION_FIRST);
+            return false;
+        }
+
+        if (GetTag(GAME_TAG.TURN) == 6 && clickedEntity.GetCardId() == "TU4a_001" && wasInTargetMode)
+        {
+            NotificationManager.Get().DestroyAllPopUps();
+        }
+        if (wasInTargetMode && InputManager.Get().GetHeldCard() != null && InputManager.Get().GetHeldCard().GetEntity()
+            .GetCardId() == "TU5_CS2_029")
+        {
+            if (clickedEntity.IsControlledByLocalUser())
+            {
+                ShowDontFireballYourselfPopup(clickedEntity.GetCard().transform.position);
+                return false;
+            }
+            if (clickedEntity.GetCardId() == "TU4a_003" && GetTag(GAME_TAG.TURN) >= 8)
+            {
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_08);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public override bool NotifyOfCardTooltipDisplayShow(Card card)
+    {
+        if (GameState.Get().IsGameOver())
+        {
+            return false;
+        }
+        Entity entity = card.GetEntity();
+        if (entity.IsMinion())
+        {
+            if (attackHelpPanel == null)
+            {
+                m_isShowingAttackHelpPanel = true;
+            }
+            return false;
+        }
+        if (entity.IsHero())
+        {
+            return false;
+        }
+        return true;
+    }
+
+	public override void NotifyOfEntityAttacked(Entity attacker, Entity defender)
+	{
+        if (GetTag(GAME_TAG.TURN) == 4)
+        {
+            m_attackedOpponentMinion = true;
+        }
+        else if (GetTag(GAME_TAG.TURN) == 6)
+        {
+            m_attackedOpponentMinionOnTurn6 = true;
+        }
+	}
+
+    public override void NotifyOfCardTooltipDisplayHide(Card card)
+    {
+        if (attackHelpPanel != null)
+        {
+            if (card != null)
+            {
+                GemObject attackObject = card.GetActor().GetAttackObject();
+                SceneUtils.SetLayer(attackObject.gameObject, GameLayer.Default);
+                attackObject.Shrink();
+            }
+            Object.Destroy(attackHelpPanel.gameObject);
+            m_isShowingAttackHelpPanel = false;
+        }
+        if (healthHelpPanel != null)
+        {
+            if (card != null)
+            {
+                GemObject healthObject = card.GetActor().GetHealthObject();
+                SceneUtils.SetLayer(healthObject.gameObject, GameLayer.Default);
+                healthObject.Shrink();
+            }
+            Object.Destroy(healthHelpPanel.gameObject);
+        }
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+            if (costTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            costLabel = go;
+            go.transform.parent = costTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(-0.017f, 0.3512533f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+        }
+    }
+
+    private void AttackLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject attackTextObject = ((Card)callbackData).GetActor().GetAttackTextObject();
+            if (attackTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            attackLabel = go;
+            go.transform.parent = attackTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(-0.2f, -0.3039344f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_ATTACK");
+        }
+    }
+
+    private void HealthLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (!m_isShowingAttackHelpPanel)
+        {
+            GameObject healthTextObject = ((Card)callbackData).GetActor().GetHealthTextObject();
+            if (healthTextObject == null)
+            {
+                Object.Destroy(go);
+                return;
+            }
+            healthLabel = go;
+            go.transform.parent = healthTextObject.transform;
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.transform.localPosition = new Vector3(0.21f, -0.31f, 0f);
+            go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_HEALTH");
+        }
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOverEntity))
+        {
+            NotificationManager.Get().DestroyAllArrows();
+        }
+        if (mousedOverEntity.GetZone() == TAG_ZONE.HAND)
+        {
+            mousedOverCard = mousedOverEntity.GetCard();
+            IAssetLoader assetLoader = AssetLoader.Get();
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", AttackLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+            assetLoader.InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", HealthLabelLoadedCallback, mousedOverCard, AssetLoadingOptions.IgnorePrefabPosition);
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOffEntity))
+        {
+            Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+        }
+        NukeNumberLabels();
+    }
+
+    private void NukeNumberLabels()
+    {
+        mousedOverCard = null;
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+        if (attackLabel != null)
+        {
+            Object.Destroy(attackLabel);
+        }
+        if (healthLabel != null)
+        {
+            Object.Destroy(healthLabel);
+        }
+    }
+
+    private bool ShouldShowArrowOnCardInHand(Entity entity)
+    {
+        if (entity.GetZone() != TAG_ZONE.HAND)
+        {
+            return false;
+        }
+        switch (GetTag(GAME_TAG.TURN))
+        {
+            case 2:
+                return true;
+            case 4:
+                if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+                    .GetCards()
+                    .Count == 0)
+                {
+                    return true;
+                }
+                break;
+        }
+        return false;
+    }
+
+    private IEnumerator ShowArrowInSeconds(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count != 0)
+        {
+            Card cardInHand = cards[0];
+            while (iTween.Count(cardInHand.gameObject) > 0)
+            {
+                yield return null;
+            }
+            if (!cardInHand.IsMousedOver() && !(InputManager.Get().GetHeldCard() == cardInHand))
+            {
+                ShowHandBouncingArrow();
+            }
+        }
+    }
+
+    private void ShowHandBouncingArrow()
+    {
+        if (!(handBounceArrow != null))
+        {
+            List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                .GetCards();
+            if (cards.Count != 0)
+            {
+                Card card = cards[0];
+                Vector3 position = card.transform.position;
+                Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z + 2f) : new Vector3(position.x - 0.08f, position.y + 0.2f, position.z + 1.2f));
+                handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
+                handBounceArrow.transform.parent = card.transform;
+            }
+        }
+    }
+
+    private void ShowHandFadeArrow()
+    {
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count != 0)
+        {
+            ShowFadeArrow(cards[0]);
+        }
+    }
+
+    private void ShowFadeArrow(Card card, Card target = null)
+    {
+        if (!(handFadeArrow != null))
+        {
+            Vector3 position = card.transform.position;
+            Vector3 rotation = new Vector3(0f, 180f, 0f);
+            Vector3 vector2;
+            if (target != null)
+            {
+                Vector3 vector = target.transform.position - position;
+                vector2 = new Vector3(position.x, position.y + 0.47f, position.z + 0.27f);
+                float num = Vector3.Angle(target.transform.position - vector2, new Vector3(0f, 0f, -1f));
+                rotation = new Vector3(0f, (0f - Mathf.Sign(vector.x)) * num, 0f);
+                vector2 += 0.3f * vector;
+            }
+            else
+            {
+                vector2 = new Vector3(position.x, position.y + 0.047f, position.z + 0.95f);
+            }
+            handFadeArrow = NotificationManager.Get().CreateFadeArrow(vector2, rotation);
+            if (target != null)
+            {
+                handFadeArrow.transform.localScale = 1.25f * Vector3.one;
+            }
+            handFadeArrow.transform.parent = card.transform;
+        }
+    }
+
+    private void HideFadeArrow()
+    {
+        if (handFadeArrow != null)
+        {
+            NotificationManager.Get().DestroyNotification(handFadeArrow, 0f);
+            handFadeArrow = null;
+        }
+    }
+
+    private void OnPhoneHandShown(object userData)
+    {
+        if (handBounceArrow != null)
+        {
+            NotificationManager.Get().DestroyNotification(handBounceArrow, 0f);
+            handBounceArrow = null;
+        }
+        ShowHandFadeArrow();
+    }
+
+    private void OnPhoneHandHidden(object userData)
+    {
+        HideFadeArrow();
+        ShowHandBouncingArrow();
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 1:
+                {
+                    List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetDeckZone()
+                        .GetCards();
+                    firstMurlocCard = cards[cards.Count - 1];
+                    firstRaptorCard = cards[cards.Count - 2];
+                    GameState.Get().SetBusy(busy: true);
+                    Board.Get().FindCollider("DragPlane").enabled = false;
+                    yield return new WaitForSeconds(1.25f);
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL01_HELP_14", "TUTORIAL01_HELP_15", "TUTORIAL01_HELP_16", Vector2.zero);
+                    tutorialStartDialog.SetWantedText(GameStrings.Get("MISSION_PRE_TUTORIAL_WANTED"));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_START);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE, AccessibleKey.CONFIRM);
+                    break;
+                }
+            case 2:
+                {
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        InputManager.Get().RegisterPhoneHandShownListener(OnPhoneHandShown);
+                        InputManager.Get().RegisterPhoneHandHiddenListener(OnPhoneHandHidden);
+                    }
+                    yield return new WaitForSeconds(1f);
+                    yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_02_02.prefab:cccdcb509085a974d922ac1d545d9bb6", "TUTORIAL01_JAINA_02", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                    List<Card> cards2 = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                        .GetCards();
+
+                    var onlyCard = cards2[0];
+                    var cardSelected = false;
+                    AccessibleCard cardBeingRead = null;
+                    if (GetTag(GAME_TAG.TURN) == 2 && cards2.Count == 1 && InputManager.Get().GetHeldCard() == null && !onlyCard.IsMousedOver())
+                    {
+                        AccessibleGameplay.Get().RegisterCardSelectedListener(onlyCard, (ac) =>
+                        {
+                            cardSelected = true;
+                            cardBeingRead = ac;
+                        });
+                        Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0f));
+                        AccessibilityMgr.BlockAllInput(false, true);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_0);;
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_1);;
+                        AccessibilityMgr.UnblockAllInput();
+                        AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_2_1);
+                        yield return new WaitUntil(() => cardSelected);
+                        AccessibilityMgr.ResetHelpSpeech();
+                        AccessibilityMgr.BlockAllInput(false, true);
+                    }
+
+                    var cardRead = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        cardRead = true;
+                        m_fullyReadMurlocRaider = true;
+                    });
+                    yield return new WaitForSeconds(2);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_READ_CARD_HELP);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.GAMEPLAY_READ_CARDS_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_NEXT_LINE, AccessibleKey.READ_PREV_LINE);
+                    yield return new WaitUntil(() => cardRead);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_2D);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_3);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_4);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION);
+                    var cardGrabbed = false;
+                    AccessibleGameplay.Get().RegisterSummoningCardListener(onlyCard, () =>
+                    {
+                        cardGrabbed = true;
+                    });
+                    yield return new WaitUntil(() => cardGrabbed);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    AccessibilityMgr.ResetHelpSpeech();
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_5);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION);
+                    yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 1);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    break;
+                }
+            case 3:
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    InputManager.Get().RemovePhoneHandShownListener(OnPhoneHandShown);
+                    InputManager.Get().RemovePhoneHandHiddenListener(OnPhoneHandHidden);
+                }
+                break;
+            case 4:
+                AccessibilityMgr.BlockAllInput(false, true);
+                actor.SetActorState(ActorStateType.CARD_IDLE);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_06_06.prefab:ffe0ebdca06ca1d4c84cc28e4a1ed7cf", "TUTORIAL01_JAINA_06", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+
+                // 1
+                var summoningMinion = false;
+                AccessibleGameplay.Get().RegisterSummoningCardListener(firstRaptorCard, () =>
+                {
+                    summoningMinion = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_1);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_1_HELP);
+                yield return new WaitUntil(() => summoningMinion);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 2
+                yield return new WaitForSeconds(1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_TRY_IT_OUT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_1_HELP);
+                yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 2);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 4
+                yield return new WaitForSeconds(7);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_4);
+                var seenBattlefield = false;
+                AccessibleGameplay.Get().RegisterZoneSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone(), () =>
+                {
+                    seenBattlefield = true;
+                });
+                yield return new WaitForSeconds(0.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+                yield return new WaitUntil(() => seenBattlefield);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 6
+                var minionsRemaining = 2;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1), (_) =>
+                {
+                    minionsRemaining--;
+                });
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(2), (_) =>
+                {
+                    minionsRemaining--;
+                });
+                yield return new WaitForSeconds(2.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_6);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_6_HELP);
+                yield return new WaitUntil(() => minionsRemaining == 0);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 8
+                seenBattlefield = false;
+                AccessibleCard accessibleCard = null; 
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardAtPos(1), (opponentMinion) =>
+                {
+                    seenBattlefield = true;
+                    accessibleCard = opponentMinion;
+                });
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_8);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP);
+                yield return new WaitUntil(() => seenBattlefield);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 9
+                var readOpponentCard = false;
+                accessibleCard.RegisterFinishReadListener(() =>
+                {
+                    readOpponentCard = true;
+                    m_finishedReadingOpponentMinion = true; // Prevent an attack until this happens
+                });
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_9);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_4_9_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                yield return new WaitUntil(() => readOpponentCard);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 10
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_YOU_GOT_IT);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_10);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_11);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_11_HELP);
+                yield return new WaitUntil(() => GameState.Get().IsInTargetMode());
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return new WaitForSeconds(1.5f);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_13);
+
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_4_13_HELP);
+                yield return new WaitUntil(() => m_attackedOpponentMinion);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                // 16
+                yield return new WaitForSeconds(5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_ONE);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_16);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_4_17);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+
+                if (firstMurlocCard != null)
+                {
+                    firstMurlocCard.GetActor().ToggleForceIdle(bOn: true);
+                    firstMurlocCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
+                }
+                break;
+            case 6:
+                var minionInBattlefieldAtTurn6 = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1);
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_17_13.prefab:9b257c86e7c7f9045a2b819d35876aca", "TUTORIAL01_JAINA_17", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_4);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_5);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_LETS_LEARN_HOW);
+                var firstCardInHandSelected = false;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCardAtPos(1), (_) =>
+                {
+                    firstCardInHandSelected = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_6);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_6_6, AccessibleKey.READ_NEXT_VALID_ITEM);
+                yield return new WaitUntil(() => firstCardInHandSelected);
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.READ_NEXT_VALID_ITEM);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_7);
+                var firstMinionInBattlefieldSelected = false;
+                AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardAtPos(1), (_) =>
+                {
+                    firstMinionInBattlefieldSelected = true;
+                });
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_8);
+                AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_6_8, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.READ_PREV_VALID_ITEM);
+                yield return new WaitUntil(() => firstMinionInBattlefieldSelected);
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.READ_PREV_VALID_ITEM);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_9);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_10);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_12);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_CAN_YOU_DO_IT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_12_HELP);
+                yield return new WaitUntil(() => GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 2);
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                yield return new WaitForSeconds(3);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_JOB);
+
+                yield return new WaitForSeconds(1);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_13);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_THINK_YOU_CAN_DO_IT);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_13_HELP);
+
+                yield return new WaitUntil(() => GameState.Get().IsInTargetMode());
+                AccessibilityMgr.ResetHelpSpeech();
+                AccessibilityMgr.BlockAllInput(false, true);
+
+                yield return new WaitForSeconds(2);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_14);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_15);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_16);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_6_16_HELP);
+
+                // Wait for atk
+                yield return new WaitUntil(() => m_attackedOpponentMinionOnTurn6);
+                yield return new WaitForSeconds(4);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_WORK);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_6_21);
+                AccessibilityMgr.UnblockAllInput();
+                AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                break;
+            case 8:
+                AccessibilityMgr.BlockAllInput(false, false);
+                m_jainaSpeaking = true;
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_18_14.prefab:fedcdecb3346ec745b6fb4204f7dd4e0", "TUTORIAL01_JAINA_18", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                m_jainaSpeaking = false;
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_8_1);
+                AccessibilityMgr.UnblockAllInput();
+                yield return new WaitForSeconds(1f);
+                Gameplay.Get().StartCoroutine(FlashMinionUntilAttackBegins(firstRaptorCard));
+                break;
+            case 10:
+                AccessibilityMgr.BlockAllInput(false, true);
+                yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_19_15.prefab:659652a121ac01941a40c64c1c151f87", "TUTORIAL01_JAINA_19", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+                AccessibilityMgr.UnblockAllInput();
+
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor hoggerActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                GameState.Get().SetBusy(busy: true);
+                HistoryManager.Get().DisableHistory();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_01_01.prefab:883391234efbde84eb99a16abd164d9d", "TUTORIAL01_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                Gameplay.Get().SetGameStateBusy(busy: false, 2.2f);
+                break;
+            case 3:
+                {
+                    int turn = GameState.Get().GetTurn();
+                    yield return new WaitForSeconds(1.5f);
+                    if (turn == GameState.Get().GetTurn())
+                    {
+                        yield return PlaySoundAndWait("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47", "TUTORIAL01_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, jainaActor);
+
+                        if (GetTag(GAME_TAG.TURN) == 2 && !EndTurnButton.Get().IsInWaitingState())
+                        {
+                            ShowEndTurnBouncingArrow();
+                            yield return new WaitForSeconds(0.5f);
+                            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_2_6);
+                            yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                            AccessibilityMgr.UnblockAllInput();
+                            AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                            yield return new WaitUntil(() => GameState.Get().GetTurn() > turn);
+                            AccessibilityMgr.ResetHelpSpeech();
+                            AccessibilityMgr.BlockAllInput(false, true);
+                        }
+                    }
+                    break;
+                }
+            case 4:
+                {
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource prevLine = GetPreloadedSound("VO_TUTORIAL_01_JAINA_03_03.prefab:4921407046d90bb44b2bfcf3984ffd47");
+                    while (SoundManager.Get().IsPlaying(prevLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_20_16.prefab:7980d02c581e4174991a8066e5785666", "TUTORIAL01_JAINA_20", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_06_06_ALT.prefab:6c9ef3c501462474ab59a37b967cab6f", "TUTORIAL01_HOGGER_07", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    Vector3 position6 = jainaActor.transform.position;
+                    Vector3 position7 = new Vector3(position6.x + 3.3f, position6.y + 0.5f, position6.z - 0.85f);
+                    Notification.PopUpArrowDirection direction2 = Notification.PopUpArrowDirection.Left;
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        position7 = new Vector3(position6.x + 3f, position6.y + 0.5f, position6.z + 0.85f);
+                        direction2 = Notification.PopUpArrowDirection.LeftDown;
+                    }
+
+                    var seenHero = false;
+                    AccessibleCard cardBeingRead = null;
+                    AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), (accessibleCard) =>
+                    {
+                        seenHero = true;
+                        cardBeingRead = accessibleCard;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_0);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+                    yield return new WaitUntil(() => seenHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    // Hero has been selected at this point
+
+                    yield return new WaitForSeconds(1);
+                    var readHero = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        readHero = true;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_2);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_3_2, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                    yield return new WaitUntil(() => readHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1.5f);
+                    var seenOpponentHero = false;
+                    AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), (accessibleCard) =>
+                    {
+                        seenOpponentHero = true;
+                        cardBeingRead = accessibleCard;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_3);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_4);
+                    AccessibilityMgr.UnblockAllInput();
+                    AccessibilityMgr.OverrideHelpSpeech(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_HERO_HELP);
+                    yield return new WaitUntil(() => seenOpponentHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(2);
+                    var readOpponentHero = false;
+                    cardBeingRead.RegisterFinishReadListener(() =>
+                    {
+                        readOpponentHero = true;
+                    });
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_5);
+                    AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_HOGGER_3_5_HELP, AccessibleKey.READ_CUR_LINE, AccessibleKey.READ_TO_END, AccessibleKey.READ_PREV_LINE, AccessibleKey.READ_NEXT_LINE);
+                    yield return new WaitUntil(() => readOpponentHero);
+                    AccessibilityMgr.ResetHelpSpeech();
+                    AccessibilityMgr.BlockAllInput(false, true);
+
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NICE_JOB);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_6);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HOGGER_3_7);
+
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 5:
+                HideFadeArrow();
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_05_05.prefab:982193e53ab81f04ba562de4b32dd39c", "TUTORIAL01_JAINA_05", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 7:
+                NotificationManager.Get().DestroyAllPopUps();
+                yield return new WaitForSeconds(1.2f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_07_07.prefab:a8bf811494e94d742a3910fac9da906f", "TUTORIAL01_JAINA_07", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                yield return new WaitForSeconds(4f);
+                if (GetTag(GAME_TAG.TURN) == 4 && EndTurnButton.Get().IsInNMPState())
+                {
+                    yield return new WaitForSeconds(1f);
+                    ShowEndTurnBouncingArrow();
+                }
+                break;
+            case 8:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_03_03.prefab:4ef21f71824b97842b33d8ebccb37ed2", "TUTORIAL01_HOGGER_05", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_21_17.prefab:c1524bd0ef92bb845b5dab48cbd017f9", "TUTORIAL01_JAINA_21", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 12:
+                yield return new WaitForSeconds(1f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_15_11.prefab:a644986d34ab8964582c6221cde54d45", "TUTORIAL01_JAINA_15", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 13:
+                while (m_jainaSpeaking)
+                {
+                    yield return null;
+                }
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_16_12.prefab:e6b4ab6fc1f11634e88f013ce5351e46", "TUTORIAL01_JAINA_16", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 14:
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_08_08_ALT.prefab:19ddb4ddaa4aee2468b17bae25da9419", "TUTORIAL01_HOGGER_08", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    Vector3 position2 = hoggerActor.transform.position;
+                    Vector3 position3 = new Vector3(position2.x + 3.3f, position2.y + 0.5f, position2.z - 1f);
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        position3 = new Vector3(position2.x + 3f, position2.y + 0.5f, position2.z - 0.75f);
+                    }
+                    Notification.PopUpArrowDirection direction = Notification.PopUpArrowDirection.Left;
+                    if (GetTag(GAME_TAG.TURN) == 6 && EndTurnButton.Get().IsInNMPState())
+                    {
+                        yield return new WaitForSeconds(9f);
+                        ShowEndTurnBouncingArrow();
+                    }
+                    break;
+                }
+            case 15:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_JAINA_02_55_ALT2.prefab:d049e67ad6c16db4da2c04be7a02a1ae", "", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 20:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_JAINA_10_09.prefab:5bf553d532aca174083f48bf407b2b11", "TUTORIAL01_JAINA_10", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    yield return new WaitForSeconds(1.5f);
+                    GameState.Get().SetBusy(busy: false);
+                    List<Card> cards = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+                        .GetCards();
+                    cards[cards.Count - 1].GetActor().GetAttackObject().Jiggle();
+                    break;
+                }
+            case 22:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_09_09_ALT.prefab:70c4d2941509856448660f89d6c72b2b", "TUTORIAL01_HOGGER_02", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                Gameplay.Get().SetGameStateBusy(busy: false, 2f);
+                break;
+            case 55:
+                AccessibilityMgr.BlacklistKeys(AccessibleKey.CONFIRM);
+                GetGameOptions().SetBooleanOption(GameEntityOption.DISABLE_TOOLTIPS, value: false);
+                Board.Get().FindCollider("DragPlane").enabled = true;
+                while (!announcerIsFinishedYapping)
+                {
+                    yield return null;
+                }
+                if (!SoundUtils.CanDetectVolume())
+                {
+                    Notification battlebegin = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 84.8f), GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_05"), "", 15f);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada", "", Notification.SpeechBubbleDirection.None, null));
+                    NotificationManager.Get().DestroyNotification(battlebegin, 0f);
+                }
+                else
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_05.prefab:635b33010e4704a42a87c7625b5b5ada", "", Notification.SpeechBubbleDirection.None, null));
+                }
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_01_01.prefab:5833f4aeb72110741a2c9bc3a92f9bc8", "TUTORIAL01_HOGGER_01", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                GameState.Get().SetBusy(busy: false);
+                yield return new WaitForSeconds(4f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_04_04.prefab:3e16e42edb324e2469a25363ffd013a6", "TUTORIAL01_HOGGER_06", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                break;
+            case 66:
+                {
+                    Vector3 position = new Vector3(136f, NotificationManager.DEPTH, 131f);
+                    Vector3 middleSpot = new Vector3(136f, NotificationManager.DEPTH, 80f);
+                    if (!SoundUtils.CanDetectVolume())
+                    {
+                        Notification innkeeperLine3 = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, position, GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_01"), "", 15f);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8", "", Notification.SpeechBubbleDirection.None, null));
+                        NotificationManager.Get().DestroyNotification(innkeeperLine3, 0f);
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_01.prefab:79419083a1b828341be6d208491a88f8", "", Notification.SpeechBubbleDirection.None, null));
+                    }
+                    yield return new WaitForSeconds(0.5f);
+                    if (!SoundUtils.CanDetectVolume())
+                    {
+                        Notification innkeeperLine3 = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, middleSpot, GameStrings.Get("VO_TUTORIAL_01_ANNOUNCER_02"), "", 15f);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41", "", Notification.SpeechBubbleDirection.None, null));
+                        NotificationManager.Get().DestroyNotification(innkeeperLine3, 0f);
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_ANNOUNCER_02.prefab:d6b08fa7e06a51c4abd80eea2ea30a41", "", Notification.SpeechBubbleDirection.None, null));
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_01_HOGGER_02_02.prefab:7f321b26431a4974a82deefc368adf63", "TUTORIAL01_HOGGER_04", Notification.SpeechBubbleDirection.TopRight, hoggerActor));
+                    if ((bool)UniversalInputManager.UsePhoneUI)
+                    {
+                        Gameplay.Get().AddGamePlayNameBannerPhone();
+                    }
+                    announcerIsFinishedYapping = true;
+                    break;
+                }
+            default:
+                Debug.LogWarning("WARNING - Mission fired an event that we are not listening for.");
+                break;
+            case 6:
+                break;
+        }
+    }
+
+    private IEnumerator FlashMinionUntilAttackBegins(Card minionToFlash)
+    {
+        yield return new WaitForSeconds(8f);
+        Gameplay.Get().StartCoroutine(BeginFlashingMinionLoop(minionToFlash));
+    }
+
+    private IEnumerator BeginFlashingMinionLoop(Card minionToFlash)
+    {
+        if (!(minionToFlash == null) && !minionToFlash.GetEntity().IsExhausted() && minionToFlash.GetActor().GetActorStateType() != ActorStateType.CARD_IDLE && minionToFlash.GetActor().GetActorStateType() != ActorStateType.CARD_MOUSE_OVER)
+        {
+            minionToFlash.GetActorSpell(SpellType.WIGGLE).Activate();
+            yield return new WaitForSeconds(1.5f);
+            Gameplay.Get().StartCoroutine(BeginFlashingMinionLoop(minionToFlash));
+        }
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    private void ShowDontFireballYourselfPopup(Vector3 origin)
+    {
+        AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_07);
+    }
+
+    public override bool ShouldDoAlternateMulliganIntro()
+    {
+        return true;
+    }
+
+    public override bool DoAlternateMulliganIntro()
+    {
+        AssetLoader.Get().InstantiatePrefab("GameOpen_Pack.prefab:fca6ae094e9a74644b00fc9029f304c3", PackLoadedCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
+        return true;
+    }
+
+    private void PackLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        MusicManager.Get().StartPlaylist(MusicPlaylistType.Misc_Tutorial01);
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        Card heroCard2 = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
+        startingPack = go;
+        Transform transform = SceneUtils.FindChildBySubstring(startingPack, "Hero_Dummy").transform;
+        heroCard.transform.parent = transform;
+        heroCard.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        heroCard.transform.localPosition = new Vector3(0f, 0f, 0f);
+        SceneUtils.SetLayer(heroCard.GetActor().GetRootObject(), GameLayer.IgnoreFullScreenEffects);
+        Transform transform2 = SceneUtils.FindChildBySubstring(startingPack, "HeroEnemy_Dummy").transform;
+        heroCard2.transform.parent = transform2;
+        heroCard2.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        heroCard2.transform.localPosition = new Vector3(0f, 0f, 0f);
+        heroCard.SetDoNotSort(on: true);
+        Transform transform3 = Board.Get().FindBone("Tutorial1HeroStart");
+        go.transform.position = transform3.position;
+        heroCard.GetActor().GetHealthObject().Hide();
+        heroCard2.GetActor().GetHealthObject().Hide();
+        heroCard2.GetActor().Hide();
+        heroCard.GetActor().Hide();
+        SceneMgr.Get().NotifySceneLoaded();
+        Gameplay.Get().StartCoroutine(UpdatePresence());
+        Gameplay.Get().StartCoroutine(ShowPackOpeningArrow(transform3.position));
+    }
+
+    private IEnumerator UpdatePresence()
+    {
+        while (LoadingScreen.Get().IsPreviousSceneActive() || LoadingScreen.Get().IsFadingOut())
+        {
+            yield return null;
+        }
+        GameMgr.Get().UpdatePresence();
+    }
+
+    private IEnumerator ShowPackOpeningArrow(Vector3 packSpot)
+    {
+        yield return new WaitForSeconds(4f);
+        if (!packOpened)
+        {
+            AccessibleGameplay.Get().StopHidingMouse();
+            var packHovered = false;
+            AccessibilityMgr.WaitForForcedKey(AccessibleKey.CONFIRM, () => {
+                AccessibleInputMgr.MoveMouseToWorldPosition(packSpot);
+                packHovered = true;
+            });
+
+            AccessibilityMgr.BlockAllInput(false, true);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.WELCOME_TO_HEARTHSTONE);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_INTRO);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_HELP_KEYS);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_NARRATOR_INTRO_END);
+            yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_FREE_STARTING_PACK);
+            AccessibilityMgr.WhitelistKeys(AccessibleSpeech.TUTORIAL_FREE_STARTING_PACK, AccessibleKey.CONFIRM);
+            yield return new WaitUntil(() => packHovered);
+            yield return new WaitForSeconds(2);
+            AccessibleInputMgr.ClickLeftMouseButton();
+            AccessibleGameplay.Get().StartHidingMouse();
+            AccessibilityMgr.BlacklistKeys(AccessibleKey.CONFIRM);
+        }
+    }
+
+    public override void NotifyOfGamePackOpened()
+    {
+        packOpened = true;
+    }
+
+    public override void NotifyOfCustomIntroFinished()
+    {
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        Card heroCard2 = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
+        heroCard.SetDoNotSort(on: false);
+        heroCard2.GetActor().TurnOnCollider();
+        heroCard.GetActor().TurnOnCollider();
+        heroCard.transform.parent = null;
+        heroCard2.transform.parent = null;
+        SceneUtils.SetLayer(heroCard.GetActor().GetRootObject(), GameLayer.CardRaycast);
+        Gameplay.Get().StartCoroutine(ContinueFinishingCustomIntro());
+    }
+
+    private IEnumerator ContinueFinishingCustomIntro()
+    {
+        yield return new WaitForSeconds(3f);
+        Object.Destroy(startingPack);
+        GameState.Get().SetBusy(busy: false);
+        MulliganManager.Get().SkipMulligan();
+    }
+
+    public override bool ShouldShowBigCard()
+    {
+        return GetTag(GAME_TAG.TURN) > 8;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        PlaySound("VO_TUTORIAL_01_JAINA_13_10.prefab:b13670e36c248e141837c4eb0645a000");
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_023", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs
new file mode 100644
index 0000000..4df1957
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_02.cs
@@ -0,0 +1,495 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_02 : TutorialEntity
+{
+    private Notification endTurnNotifier;
+
+    private Notification manaNotifier;
+
+    private Notification manaNotifier2;
+
+    private GameObject costLabel;
+
+    private int numManaThisTurn = 1;
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_02_05.prefab:d1334881818e67d4c85216afa56226d6");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_01_04.prefab:5b48a6d28da46464ea99c7b278f63226");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_04_07.prefab:a804332a9a314af49b35d1c6d4a1f306");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_05_08.prefab:946dc71f989978844af5222d4342df4c");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_07_10.prefab:ffdc387467735484390ee8545698c57e");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_11_14.prefab:ada9c4aef7cd8dc418005c0a4c5f578d");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_13_16.prefab:80757414dc5a3b54b9cfc328ce2b7f6c");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_15_17.prefab:973e26c00c354b24595965035e8efba7");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_06_09.prefab:04bd4efe66a93bb438327216a4254560");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_03_06.prefab:c509f7e0eca4fb84dbf9be77a7ed5823");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_10_13.prefab:a22defa2f9b5ec242a1f4e502d9349eb");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+        PreloadSound("VO_TUTORIAL_02_JAINA_08_22.prefab:52cd86a7a20daeb4b8d1f3fd2647e9ea");
+        PreloadSound("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2");
+        PreloadSound("VO_TUTORIAL02_MILLHOUSE_19_21.prefab:bc8b4236bf74f1244afa49a8195c7f74");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.MILLHOUSE_COMPLETE);
+                PlaySound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        if (GameState.Get().IsFriendlySidePlayerTurn())
+        {
+            numManaThisTurn++;
+        }
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 1:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_02_HELP_01);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MILLHOUSE_SEE_MANA_HELP);
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return new WaitForSeconds(0.5f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_04_07.prefab:a804332a9a314af49b35d1c6d4a1f306", "TUTORIAL02_MILLHOUSE_04", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                yield return new WaitForSeconds(0.3f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_05_08.prefab:946dc71f989978844af5222d4342df4c", "TUTORIAL02_MILLHOUSE_05", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 3:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(1);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_03);
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 4:
+                {
+                    if (manaNotifier2 != null)
+                    {
+                        NotificationManager.Get().DestroyNotification(manaNotifier2, 0f);
+                    }
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource previousLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00");
+                    while (SoundManager.Get().IsPlaying(previousLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_07_10.prefab:ffdc387467735484390ee8545698c57e", "TUTORIAL02_MILLHOUSE_07", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 6:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_11_14.prefab:ada9c4aef7cd8dc418005c0a4c5f578d", "TUTORIAL02_MILLHOUSE_11", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 8:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_13_16.prefab:80757414dc5a3b54b9cfc328ce2b7f6c", "TUTORIAL02_MILLHOUSE_13", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 9:
+                yield return new WaitForSeconds(0.5f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_15_17.prefab:973e26c00c354b24595965035e8efba7", "TUTORIAL02_MILLHOUSE_15", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 10:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource comeOnLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8");
+                    while (SoundManager.Get().IsPlaying(comeOnLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_06_09.prefab:04bd4efe66a93bb438327216a4254560", "TUTORIAL02_MILLHOUSE_06", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return new WaitForSeconds(1.5f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_03_06.prefab:c509f7e0eca4fb84dbf9be77a7ed5823", "TUTORIAL02_MILLHOUSE_03", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                GameState.Get().SetBusy(busy: false);
+                yield return new WaitForSeconds(4f);
+                if (GetTag(GAME_TAG.TURN) == 1 && !EndTurnButton.Get().IsInWaitingState())
+                {
+                    ShowEndTurnBouncingArrow();
+                }
+                break;
+            case 3:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_17_19.prefab:a7aab1a8c3e6d304a9b6f451187fdb00", "TUTORIAL02_MILLHOUSE_17", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 4:
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7", "TUTORIAL02_MILLHOUSE_08", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2", "TUTORIAL02_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac", "TUTORIAL02_MILLHOUSE_09", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                break;
+            case 5:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AudioSource feelslikeLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_08_11.prefab:21d83afbda98c8844b0ba771b14833e7");
+                    while (SoundManager.Get().IsPlaying(feelslikeLine))
+                    {
+                        yield return null;
+                    }
+                    AudioSource whatLine = GetPreloadedSound("VO_TUTORIAL_02_JAINA_03_18.prefab:4942e6b39e0bf0747b0ad09944cf9ad2");
+                    while (SoundManager.Get().IsPlaying(whatLine))
+                    {
+                        yield return null;
+                    }
+                    AudioSource winngingLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_09_12.prefab:a050db78c641ba04d88382e2b759dbac");
+                    while (SoundManager.Get().IsPlaying(winngingLine))
+                    {
+                        yield return null;
+                    }
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_10_13.prefab:a22defa2f9b5ec242a1f4e502d9349eb", "TUTORIAL02_MILLHOUSE_10", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 6:
+                if (EndTurnButton.Get().IsInNMPState())
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_16_18.prefab:2493cb5abcdbf45468d74ab4ab4c10f8", "TUTORIAL02_MILLHOUSE_16", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                }
+                break;
+            case 54:
+                yield return new WaitForSeconds(2f);
+                var tutorialStartDialog = ShowTutorialDialog("TUTORIAL02_HELP_06", "TUTORIAL02_HELP_07", "TUTORIAL01_HELP_16", new Vector2(0.5f, 0f));
+                tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_06);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL02_HELP_07);
+                tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                break;
+            case 55:
+                FadeInHeroActor(millhouseActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_02_05.prefab:d1334881818e67d4c85216afa56226d6", "TUTORIAL02_MILLHOUSE_02", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+                HistoryManager.Get().DisableHistory();
+                MulliganManager.Get().BeginMulligan();
+                yield return new WaitForSeconds(1.1f);
+                FadeOutHeroActor(millhouseActor);
+                break;
+        }
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (mousedOverEntity.GetZone() == TAG_ZONE.HAND && GetTag(GAME_TAG.TURN) <= 7)
+        {
+            AssetLoader.Get().InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, mousedOverEntity.GetCard(), AssetLoadingOptions.IgnorePrefabPosition);
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+    }
+
+    public override void NotifyOfCoinFlipResult()
+    {
+        Gameplay.Get().StartCoroutine(HandleCoinFlip());
+    }
+
+    private IEnumerator HandleCoinFlip()
+    {
+        GameState.Get().SetBusy(busy: true);
+        yield return new WaitForSeconds(3.5f);
+        Actor millhouseActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        FadeInHeroActor(millhouseActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL02_MILLHOUSE_01_04.prefab:5b48a6d28da46464ea99c7b278f63226", "TUTORIAL02_MILLHOUSE_01", Notification.SpeechBubbleDirection.TopRight, millhouseActor));
+        GameState.Get().SetBusy(busy: false);
+        yield return new WaitForSeconds(0.175f);
+        FadeOutHeroActor(millhouseActor);
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null)
+        {
+            if (!optionsPacket.HasValidOption())
+            {
+                NotificationManager.Get().DestroyAllArrows();
+                return true;
+            }
+            bool flag = false;
+            for (int i = 0; i < optionsPacket.List.Count; i++)
+            {
+                Network.Options.Option option = optionsPacket.List[i];
+                if (option.Main.PlayErrorInfo.IsValid() && option.Type == Network.Options.Option.OptionType.POWER && !(GameState.Get().GetEntity(option.Main.ID).GetCardId() == "TU5_CS2_025"))
+                {
+                    flag = true;
+                    break;
+                }
+            }
+            if (!flag)
+            {
+                return true;
+            }
+        }
+        if (endTurnNotifier != null)
+        {
+            NotificationManager.Get().DestroyNotificationNowWithNoAnim(endTurnNotifier);
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN_ATK";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    public override string[] NotifyOfKeywordHelpPanelDisplay(Entity entity)
+    {
+        if (entity.GetCardId() == "CS2_122")
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_RAID_LEADER_DESCRIPTION);
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL_RAID_LEADER_HEADLINE"),
+                GameStrings.Get("TUTORIAL_RAID_LEADER_DESCRIPTION")
+            };
+        }
+        if (entity.GetCardId() == "TU5_CS2_023")
+        {
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL_ARCANE_INTELLECT_HEADLINE"),
+                GameStrings.Get("TUTORIAL_ARCANE_INTELLECT_DESCRIPTION")
+            };
+        }
+        return null;
+    }
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (entity.GetCardId() == "TU5_CS2_023" && GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources() >= entity.GetCost())
+        {
+            BoardTutorial.Get().EnableFullHighlight(enable: true);
+        }
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        if (entity.GetCardId() == "TU5_CS2_023")
+        {
+            BoardTutorial.Get().EnableFullHighlight(enable: false);
+        }
+    }
+
+    public override void NotifyOfManaCrystalSpawned()
+    {
+        AssetLoader.Get().InstantiatePrefab("plus1.prefab:7427d28c07eea8645a3308e04398ee30", Plus1ActorLoadedCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
+        if (GetTag(GAME_TAG.TURN) == 3)
+        {
+            Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+                .GetCard()
+                .GetActor();
+            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_02_JAINA_08_22.prefab:52cd86a7a20daeb4b8d1f3fd2647e9ea", "TUTORIAL02_JAINA_08", Notification.SpeechBubbleDirection.BottomLeft, actor));
+        }
+        FadeInManaSpotlight();
+    }
+
+    private void FadeInManaSpotlight()
+    {
+        Gameplay.Get().StartCoroutine(StartManaSpotFade());
+    }
+
+    private IEnumerator StartManaSpotFade()
+    {
+        Light manaSpot = BoardTutorial.Get().m_ManaSpotlight;
+        manaSpot.enabled = true;
+        manaSpot.spotAngle = 179f;
+        manaSpot.intensity = 0f;
+        float TARGET_INTENSITY = 0.6f;
+        while (manaSpot.intensity < TARGET_INTENSITY * 0.95f)
+        {
+            manaSpot.intensity = Mathf.Lerp(manaSpot.intensity, TARGET_INTENSITY, Time.deltaTime * 5f);
+            manaSpot.spotAngle = Mathf.Lerp(manaSpot.spotAngle, 80f, Time.deltaTime * 5f);
+            yield return null;
+        }
+        yield return new WaitForSeconds(2f);
+        while (manaSpot.intensity > 0.05f)
+        {
+            manaSpot.intensity = Mathf.Lerp(manaSpot.intensity, 0f, Time.deltaTime * 10f);
+            yield return null;
+        }
+        manaSpot.enabled = false;
+    }
+
+    private void Plus1ActorLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        Vector3 position = SceneUtils.FindChildBySubstring(Board.Get().gameObject, "ManaCounter_Friendly").transform.position;
+        Vector3 position2 = new Vector3(position.x - 0.02f, position.y + 0.2f, position.z);
+        go.transform.position = position2;
+        go.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
+        Vector3 localScale = go.transform.localScale;
+        go.transform.localScale = new Vector3(1f, 1f, 1f);
+        iTween.MoveTo(go, new Vector3(position2.x, position2.y, position2.z + 2f), 3f);
+        float num = 2.5f;
+        iTween.ScaleTo(go, new Vector3(localScale.x * num, localScale.y * num, localScale.z * num), 3f);
+        iTween.RotateTo(go, new Vector3(0f, 170f, 0f), 3f);
+        iTween.FadeTo(go, 0f, 2.75f);
+    }
+
+    public override void NotifyOfEnemyManaCrystalSpawned()
+    {
+        AssetLoader.Get().InstantiatePrefab("plus1.prefab:7427d28c07eea8645a3308e04398ee30", Plus1ActorLoadedCallbackEnemy, null, AssetLoadingOptions.IgnorePrefabPosition);
+    }
+
+    private void Plus1ActorLoadedCallbackEnemy(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        Vector3 position = SceneUtils.FindChildBySubstring(Board.Get().gameObject, "ManaCounter_Opposing").transform.position;
+        Vector3 position2 = new Vector3(position.x, position.y + 0.2f, position.z);
+        go.transform.position = position2;
+        go.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
+        Vector3 localScale = go.transform.localScale;
+        go.transform.localScale = new Vector3(1f, 1f, 1f);
+        iTween.MoveTo(go, new Vector3(position2.x, position2.y, position2.z - 2f), 3f);
+        float num = 2.5f;
+        iTween.ScaleTo(go, new Vector3(localScale.x * num, localScale.y * num, localScale.z * num), 3f);
+        iTween.RotateTo(go, new Vector3(0f, 170f, 0f), 3f);
+        iTween.FadeTo(go, 0f, 2.75f);
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+        if (costTextObject == null)
+        {
+            Object.Destroy(go);
+            return;
+        }
+        if (costLabel != null)
+        {
+            Object.Destroy(costLabel);
+        }
+        costLabel = go;
+        go.transform.parent = costTextObject.transform;
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localPosition = new Vector3(-0.025f, 0.28f, 0f);
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+    }
+
+    public override void NotifyOfTooltipZoneMouseOver(TooltipZone tooltip)
+    {
+        if (tooltip.targetObject.GetComponent<ManaCrystalMgr>() != null)
+        {
+            if (manaNotifier != null)
+            {
+                Object.Destroy(manaNotifier.gameObject);
+            }
+            if (manaNotifier2 != null)
+            {
+                Object.Destroy(manaNotifier2.gameObject);
+            }
+        }
+    }
+
+    public override string GetTurnStartReminderText()
+    {
+        return GameStrings.Format("TUTORIAL02_HELP_04", numManaThisTurn);
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        Gameplay.Get().StartCoroutine(PlayGoingOutSound());
+    }
+
+    private IEnumerator PlayGoingOutSound()
+    {
+        AudioSource deathLine = GetPreloadedSound("VO_TUTORIAL02_MILLHOUSE_20_22_ALT.prefab:79394b29df25e894085524bdad538962");
+        while (deathLine != null && deathLine.isPlaying)
+        {
+            yield return null;
+        }
+        PlaySound("VO_TUTORIAL02_MILLHOUSE_19_21.prefab:bc8b4236bf74f1244afa49a8195c7f74");
+    }
+
+    protected override void NotifyOfManaError()
+    {
+        NotificationManager.Get().DestroyNotificationNowWithNoAnim(manaNotifier);
+        NotificationManager.Get().DestroyNotificationNowWithNoAnim(manaNotifier2);
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("EX1_015", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs
new file mode 100644
index 0000000..f4bd683
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_03.cs
@@ -0,0 +1,389 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_03 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private int numTauntGorillasPlayed;
+
+    private bool enemyPlayedBigBrother;
+
+    private bool needATaunterVOPlayed;
+
+    private bool monkeyLinePlayedOnce;
+
+    private bool defenselessVoPlayed;
+
+    private bool seenTheBrother;
+
+    private bool warnedAgainstAttackingGorilla;
+
+    private bool victory;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool>
+        {
+            {
+                GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN,
+                false
+            },
+            {
+                GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+                true
+            },
+            {
+                GameEntityOption.SHOW_CRAZY_KEYWORD_TOOLTIP,
+                true
+            }
+        };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_03()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_03_JAINA_17_33.prefab:b96f78fff7ab94a42894930d51bd45bd");
+        PreloadSound("VO_TUTORIAL_03_JAINA_18_34.prefab:b9a2a99d30893804790829b3ceabc9b8");
+        PreloadSound("VO_TUTORIAL_03_JAINA_01_24.prefab:b9515cf173f876a458202c6092055709");
+        PreloadSound("VO_TUTORIAL_03_JAINA_05_25.prefab:38e2d64610e757245877b8f8e2f68584");
+        PreloadSound("VO_TUTORIAL_03_JAINA_07_26.prefab:e93d67263c3d99740aaa4acc4b7d87a4");
+        PreloadSound("VO_TUTORIAL_03_JAINA_12_28.prefab:d30f0c732643aa74aba9ec4cf2c2e6dd");
+        PreloadSound("VO_TUTORIAL_03_JAINA_13_29.prefab:efca9c5305a101e4d968d08e58061cda");
+        PreloadSound("VO_TUTORIAL_03_JAINA_16_32.prefab:b05bea699e2f897478c81a485a7d1a1a");
+        PreloadSound("VO_TUTORIAL_03_JAINA_14_30.prefab:0787881bd0a25a342ba06f566f16051b");
+        PreloadSound("VO_TUTORIAL_03_JAINA_15_31.prefab:4e0f1eaa19e283a4cac77219e1f10fe3");
+        PreloadSound("VO_TUTORIAL_03_JAINA_20_36.prefab:79671f155307aa24a89b0581e4c5c4b2");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_01_01.prefab:3f6638f7f0d96da4ca422a290035c97a");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_03_03.prefab:5018131495f68c247bac073424fab700");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_04_04.prefab:0e4a4c87ac994c845b06230a34b168f9");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_05_05.prefab:8c12c75976cdfe044ad8ff3dd14ae5b8");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_06_06.prefab:8ed0c9ff5d18314469821d5be3d62dc7");
+        PreloadSound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.MUKLA_COMPLETE);
+                PlaySound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_03_MUKLA_07_07.prefab:c7b7dc3589c10c94bb3b9c0c6c08e3f6");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.MUKLA_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (enemyPlayedBigBrother)
+        {
+            if (GameState.Get().IsFriendlySidePlayerTurn())
+            {
+                if (GameState.Get().GetNumEnemyMinionsInPlay(includeUntouchables: false) > 0)
+                {
+                    if (!needATaunterVOPlayed)
+                    {
+                        if (!GameState.Get().GetFriendlySidePlayer().HasATauntMinion())
+                        {
+                            needATaunterVOPlayed = true;
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_17_33.prefab:b96f78fff7ab94a42894930d51bd45bd", "TUTORIAL03_JAINA_17", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                        }
+                        yield break;
+                    }
+                    if (!defenselessVoPlayed)
+                    {
+                        bool flag = true;
+                        foreach (Card card in GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+                            .GetCards())
+                        {
+                            if (card.GetEntity().HasTaunt())
+                            {
+                                flag = false;
+                            }
+                        }
+                        if (flag)
+                        {
+                            defenselessVoPlayed = true;
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_18_34.prefab:b9a2a99d30893804790829b3ceabc9b8", "TUTORIAL03_JAINA_18", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                        }
+                    }
+                }
+            }
+            else if (!seenTheBrother)
+            {
+                Gameplay.Get().StartCoroutine(GetReadyForBro());
+            }
+        }
+        switch (turn)
+        {
+            case 1:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_01_24.prefab:b9515cf173f876a458202c6092055709", "TUTORIAL03_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                break;
+            case 5:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_05_25.prefab:38e2d64610e757245877b8f8e2f68584", "TUTORIAL03_JAINA_05", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_03_03.prefab:5018131495f68c247bac073424fab700", "TUTORIAL03_MUKLA_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 6:
+                if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_04_04.prefab:0e4a4c87ac994c845b06230a34b168f9", "TUTORIAL03_MUKLA_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 9:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_07_26.prefab:e93d67263c3d99740aaa4acc4b7d87a4", "TUTORIAL03_JAINA_07", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                break;
+            case 14:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_05_05.prefab:8c12c75976cdfe044ad8ff3dd14ae5b8", "TUTORIAL03_MUKLA_05", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    private IEnumerator GetReadyForBro()
+    {
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        seenTheBrother = true;
+        GameState.Get().SetBusy(busy: true);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_12_28.prefab:d30f0c732643aa74aba9ec4cf2c2e6dd", "TUTORIAL03_JAINA_12", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+        GameState.Get().SetBusy(busy: false);
+        yield return new WaitForSeconds(3.2f);
+        Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_13_29.prefab:efca9c5305a101e4d968d08e58061cda", "TUTORIAL03_JAINA_13", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                AssetLoader.Get().InstantiatePrefab("TutorialKeywordManager.prefab:c1276fda3e1df594990295731f80c9c2", AssetLoadingOptions.IgnorePrefabPosition);
+                break;
+            case 4:
+                numTauntGorillasPlayed++;
+                if (numTauntGorillasPlayed == 1)
+                {
+                    Gameplay.Get().StartCoroutine(ShowTauntPopup());
+                }
+                else if (numTauntGorillasPlayed == 2 && !DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_06_06.prefab:8ed0c9ff5d18314469821d5be3d62dc7", "TUTORIAL03_MUKLA_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 10:
+                enemyPlayedBigBrother = true;
+                Gameplay.Get().StartCoroutine(AdjustBigBrotherTransform());
+                if (!GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    Gameplay.Get().StartCoroutine(GetReadyForBro());
+                }
+                break;
+            case 11:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_16_32.prefab:b05bea699e2f897478c81a485a7d1a1a", "TUTORIAL03_JAINA_16", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                break;
+            case 12:
+                if (!monkeyLinePlayedOnce)
+                {
+                    monkeyLinePlayedOnce = true;
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_14_30.prefab:0787881bd0a25a342ba06f566f16051b", "TUTORIAL03_JAINA_14", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                else if (!DidLoseTutorial(TutorialProgress.MUKLA_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_JAINA_15_31.prefab:4e0f1eaa19e283a4cac77219e1f10fe3", "TUTORIAL03_JAINA_15", Notification.SpeechBubbleDirection.BottomLeft, actor));
+                }
+                break;
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    string bodyTextGameString = "TUTORIAL03_HELP_03";
+                    if (UniversalInputManager.Get().IsTouchMode())
+                    {
+                        bodyTextGameString = "TUTORIAL03_HELP_03_TOUCH";
+                    }
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL03_HELP_02", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0.5f, 0.5f));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START_B);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_START_C);
+                    break;
+                }
+            case 55:
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_03_MUKLA_01_01.prefab:3f6638f7f0d96da4ca422a290035c97a", "TUTORIAL03_MUKLA_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                MulliganManager.Get().BeginMulligan();
+                FadeOutHeroActor(enemyActor);
+                break;
+        }
+    }
+
+    private IEnumerator ShowTauntPopup()
+    {
+        Card gorillaCard = null;
+        while (gorillaCard == null)
+        {
+            gorillaCard = FindCardInEnemyBattlefield("TU5_CS2_127");
+            if (gorillaCard != null)
+            {
+                break;
+            }
+            yield return null;
+        }
+        while (!gorillaCard.IsActorReady())
+        {
+            yield return null;
+        }
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP);
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP_B);
+        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_MUKLA_TAUNT_HELP_C);
+    }
+
+    private IEnumerator AdjustBigBrotherTransform()
+    {
+        ZonePlay enemyBattlefield = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+        Vector3 prevBattlefieldScale = enemyBattlefield.transform.localScale;
+        enemyBattlefield.transform.localScale = 1.6f * enemyBattlefield.transform.localScale;
+        Vector3 position = enemyBattlefield.transform.position;
+        enemyBattlefield.transform.position = new Vector3(position.x + 2.3931637f, position.y, position.z + 0.7f);
+        Card bigBrotherCard = null;
+        while (bigBrotherCard == null)
+        {
+            bigBrotherCard = FindCardInEnemyBattlefield("TU4c_007");
+            if (bigBrotherCard != null)
+            {
+                break;
+            }
+            yield return null;
+        }
+        while (!bigBrotherCard.IsActorReady())
+        {
+            yield return null;
+        }
+        Actor actor = bigBrotherCard.GetActor();
+        Transform parent = actor.transform.parent;
+        Vector3 localScale = actor.transform.localScale;
+        actor.transform.parent = null;
+        bigBrotherCard.transform.localScale = prevBattlefieldScale;
+        GameObject gameObject = new GameObject();
+        gameObject.transform.parent = parent;
+        gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
+        gameObject.transform.localScale = new Vector3(1.6f, 1.6f, 1.6f);
+        actor.transform.parent = gameObject.transform;
+        actor.transform.localScale = localScale;
+        enemyBattlefield.transform.localScale = prevBattlefieldScale;
+    }
+
+    private Card FindCardInEnemyBattlefield(string cardId)
+    {
+        ZonePlay battlefieldZone = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+        for (int i = 0; i < battlefieldZone.GetCardCount(); i++)
+        {
+            Card cardAtIndex = battlefieldZone.GetCardAtIndex(i);
+            if (!(cardAtIndex.GetEntity().GetCardId() != cardId))
+            {
+                return cardAtIndex;
+            }
+        }
+        return null;
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        GetGameOptions().SetBooleanOption(GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN, value: false);
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (mousedOverEntity.HasTaunt())
+        {
+            GetGameOptions().SetBooleanOption(GameEntityOption.MOUSEOVER_DELAY_OVERRIDDEN, value: true);
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (!base.NotifyOfBattlefieldCardClicked(clickedEntity, wasInTargetMode))
+        {
+            return false;
+        }
+        if (wasInTargetMode && clickedEntity.GetCardId() == "TU4c_007" && !warnedAgainstAttackingGorilla)
+        {
+            warnedAgainstAttackingGorilla = true;
+            HandleMissionEvent(11);
+            return false;
+        }
+        return true;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (victory)
+        {
+            PlaySound("VO_TUTORIAL_03_JAINA_20_36.prefab:79671f155307aa24a89b0581e4c5c4b2");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_022", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs
new file mode 100644
index 0000000..e129991
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_04.cs
@@ -0,0 +1,641 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_04 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification endTurnNotifier;
+
+    private Notification handBounceArrow;
+
+    private Notification sheepTheBog;
+
+    private Notification noSheepPopup;
+
+    private int numBeastsPlayed;
+
+    private GameObject m_heroPowerCostLabel;
+
+    private Notification heroPowerHelp;
+
+    private bool victory;
+
+    private bool m_hemetSpeaking;
+
+    private int numComplaintsMade;
+
+    private bool m_shouldSignalPolymorph;
+
+    private bool m_isPolymorphGrabbed;
+
+    private bool m_isBogSheeped;
+
+    private bool m_playOneHealthCommentNextTurn;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_04()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+        PreloadSound("VO_TUTORIAL04_HEMET_15_13.prefab:c0da1267215708947a954e9c0ea1b061");
+        PreloadSound("VO_TUTORIAL04_HEMET_20_18.prefab:5d49a0bac4c03b94e9e13945624a581b");
+        PreloadSound("VO_TUTORIAL04_HEMET_16_14.prefab:df368c7075e4a2649803729f7b86601e");
+        PreloadSound("VO_TUTORIAL04_HEMET_13_12.prefab:fe14ab273aa4b7e4491f30310a7d0eca");
+        PreloadSound("VO_TUTORIAL04_HEMET_19_17.prefab:b9d5bd30659aae84b8a1380cbdba0398");
+        PreloadSound("VO_TUTORIAL_04_JAINA_09_43.prefab:1ee05d74948aba04ebd7065e44813921");
+        PreloadSound("VO_TUTORIAL_04_JAINA_10_44.prefab:6f5921db1071ead4585c8cc9689d22ea");
+        PreloadSound("VO_TUTORIAL04_HEMET_06_05.prefab:2527939914db3e543941a13266e88a01");
+        PreloadSound("VO_TUTORIAL04_HEMET_07_06_ALT.prefab:c19475ec3c3b0e648a97f423e0e86143");
+        PreloadSound("VO_TUTORIAL_04_JAINA_04_40.prefab:5bfc80c6184279140878a51eb1fa3469");
+        PreloadSound("VO_TUTORIAL04_HEMET_08_07.prefab:68207d2681a60c84d840d37c4b90740f");
+        PreloadSound("VO_TUTORIAL04_HEMET_09_08.prefab:2994b6b35f2e5f54782b6100ea92f40e");
+        PreloadSound("VO_TUTORIAL04_HEMET_10_09.prefab:3282099b41c7ab94aa99e84c20dd7db7");
+        PreloadSound("VO_TUTORIAL04_HEMET_11_10.prefab:db8c8cea0db51d14fbd5d4c782b8b160");
+        PreloadSound("VO_TUTORIAL04_HEMET_12_11.prefab:b0ea652d6f1ec6845845226680ade252");
+        PreloadSound("VO_TUTORIAL04_HEMET_12_11_ALT.prefab:b59f55e14876bee43a0d9ab4b7317f84");
+        PreloadSound("VO_TUTORIAL_04_JAINA_08_42.prefab:36763b11766e2b64198719d44b0fa8bf");
+        PreloadSound("VO_TUTORIAL04_HEMET_01_01.prefab:89be0839b16c1244a9221b373fd8fb61");
+        PreloadSound("VO_TUTORIAL_04_JAINA_01_37.prefab:c7fc40d1595ca3c49b524b9929264477");
+        PreloadSound("VO_TUTORIAL04_HEMET_02_02.prefab:c3ca1337cb01efe4194899d42918f80c");
+        PreloadSound("VO_TUTORIAL04_HEMET_03_03.prefab:b014c684c85f1c440bed5560c6b6dbf5");
+        PreloadSound("VO_TUTORIAL_04_JAINA_02_38.prefab:83b64d5eeb884db43b9fa5f20316da2c");
+        PreloadSound("VO_TUTORIAL04_HEMET_04_04_ALT.prefab:bb3fadd78adce274993862115f3c5137");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        if (m_heroPowerCostLabel != null)
+        {
+            Object.Destroy(m_heroPowerCostLabel);
+        }
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.NESINGWARY_COMPLETE);
+                PlaySound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL04_HEMET_23_21.prefab:86859f5cb798f304395a63f446fe9d00");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.NESINGWARY_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        m_shouldSignalPolymorph = false;
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (m_playOneHealthCommentNextTurn)
+        {
+            m_playOneHealthCommentNextTurn = false;
+            GameState.Get().SetBusy(busy: true);
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_08_42.prefab:36763b11766e2b64198719d44b0fa8bf", "TUTORIAL04_JAINA_08", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+            GameState.Get().SetBusy(busy: false);
+        }
+        switch (turn)
+        {
+            case 1:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_15_13.prefab:c0da1267215708947a954e9c0ea1b061", "TUTORIAL04_HEMET_15", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 4:
+                {
+                    yield return new WaitForSeconds(1f);
+                    GameState.Get().SetBusy(busy: true);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return new WaitForSeconds(1f);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP_B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_HEMET_HERO_POWER_HELP_C);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_TRY_IT_OUT);
+                    AccessibilityMgr.UnblockAllInput();
+                    GameState.Get().SetBusy(busy: false);
+
+                    AssetLoader.Get().InstantiatePrefab("NumberLabel.prefab:597544d5ed24b994f95fe56e28584992", ManaLabelLoadedCallback, GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard(), AssetLoadingOptions.IgnorePrefabPosition);
+                    break;
+                }
+            case 5:
+                NotificationManager.Get().DestroyNotification(heroPowerHelp, 0f);
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_20_18.prefab:5d49a0bac4c03b94e9e13945624a581b", "TUTORIAL04_HEMET_20", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+            case 7:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_16_14.prefab:df368c7075e4a2649803729f7b86601e", "TUTORIAL04_HEMET_16", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 9:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_13_12.prefab:fe14ab273aa4b7e4491f30310a7d0eca", "TUTORIAL04_HEMET_13", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 11:
+                GameState.Get().SetBusy(busy: true);
+                Gameplay.Get().SetGameStateBusy(busy: false, 3f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_19_17.prefab:b9d5bd30659aae84b8a1380cbdba0398", "TUTORIAL04_HEMET_19", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                yield return new WaitForSeconds(0.7f);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_09_43.prefab:1ee05d74948aba04ebd7065e44813921", "TUTORIAL04_JAINA_09", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                break;
+            case 12:
+                {
+                    if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                    {
+                        break;
+                    }
+                    m_shouldSignalPolymorph = true;
+                    List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                        .GetCards();
+                    if (!(InputManager.Get().GetHeldCard() == null))
+                    {
+                        break;
+                    }
+                    Card card = null;
+                    foreach (Card item in cards)
+                    {
+                        if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+                        {
+                            card = item;
+                        }
+                    }
+                    if (!(card == null) && !card.IsMousedOver())
+                    {
+                        Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0f));
+                    }
+                    break;
+                }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_06_05.prefab:2527939914db3e543941a13266e88a01", "TUTORIAL04_HEMET_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_07_06_ALT.prefab:c19475ec3c3b0e648a97f423e0e86143", "TUTORIAL04_HEMET_07", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                yield return Gameplay.Get().StartCoroutine(Wait(1f));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 3:
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(Wait(2f));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 4:
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    InputManager.Get().GetFriendlyHand().SetHandEnlarged(enlarged: false);
+                }
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_04_40.prefab:5bfc80c6184279140878a51eb1fa3469", "TUTORIAL04_JAINA_04", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 5:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    switch (numBeastsPlayed)
+                    {
+                        case 0:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_08_07.prefab:68207d2681a60c84d840d37c4b90740f", "TUTORIAL04_HEMET_08", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 1:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_09_08.prefab:2994b6b35f2e5f54782b6100ea92f40e", "TUTORIAL04_HEMET_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 2:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_10_09.prefab:3282099b41c7ab94aa99e84c20dd7db7", "TUTORIAL04_HEMET_10", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                        case 3:
+                            Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_11_10.prefab:db8c8cea0db51d14fbd5d4c782b8b160", "TUTORIAL04_HEMET_11", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                            break;
+                    }
+                    numBeastsPlayed++;
+                }
+                break;
+            case 6:
+                if (numComplaintsMade == 0)
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_12_11.prefab:b0ea652d6f1ec6845845226680ade252", "TUTORIAL04_HEMET_12a", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    numComplaintsMade++;
+                }
+                else
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_12_11_ALT.prefab:b59f55e14876bee43a0d9ab4b7317f84", "TUTORIAL04_HEMET_12b", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 7:
+                m_playOneHealthCommentNextTurn = true;
+                break;
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE));
+                    string bodyTextGameString = flag? "TUTORIAL04_HELP_15" : "TUTORIAL04_HELP_16";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL04_HELP_14", bodyTextGameString, "TUTORIAL01_HELP_16", Vector2.zero, swapMaterial: true);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL04_HELP_14);
+                    yield return AccessibilityMgr.Narrate(flag? AccessibleSpeech.TUTORIAL04_HELP_15 : AccessibleSpeech.TUTORIAL04_HELP_16);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_01_01.prefab:89be0839b16c1244a9221b373fd8fb61", "TUTORIAL04_HEMET_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    FadeInHeroActor(jainaActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_01_37.prefab:c7fc40d1595ca3c49b524b9929264477", "TUTORIAL04_JAINA_01", Notification.SpeechBubbleDirection.BottomLeft, jainaActor));
+                    FadeOutHeroActor(jainaActor);
+                    yield return new WaitForSeconds(0.5f);
+                }
+                MulliganManager.Get().BeginMulligan();
+                if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+                {
+                    m_hemetSpeaking = true;
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_02_02.prefab:c3ca1337cb01efe4194899d42918f80c", "TUTORIAL04_HEMET_02", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    m_hemetSpeaking = false;
+                }
+                break;
+        }
+    }
+
+    public override void NotifyOfCoinFlipResult()
+    {
+        Gameplay.Get().StartCoroutine(HandleCoinFlip());
+    }
+
+    private IEnumerator HandleCoinFlip()
+    {
+        GameState.Get().SetBusy(busy: true);
+        yield return Gameplay.Get().StartCoroutine(Wait(1f));
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        while (m_hemetSpeaking)
+        {
+            yield return null;
+        }
+        FadeInHeroActor(enemyActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_03_03.prefab:b014c684c85f1c440bed5560c6b6dbf5", "TUTORIAL04_HEMET_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+        FadeOutHeroActor(enemyActor);
+        yield return new WaitForSeconds(0.3f);
+        FadeInHeroActor(jainaActor);
+        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_02_38.prefab:83b64d5eeb884db43b9fa5f20316da2c", "TUTORIAL04_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+        FadeOutHeroActor(jainaActor);
+        yield return new WaitForSeconds(0.25f);
+        if (!DidLoseTutorial(TutorialProgress.NESINGWARY_COMPLETE))
+        {
+            FadeInHeroActor(enemyActor);
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL04_HEMET_04_04_ALT.prefab:bb3fadd78adce274993862115f3c5137", "TUTORIAL04_HEMET_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+            FadeOutHeroActor(enemyActor);
+            yield return new WaitForSeconds(0.4f);
+        }
+        GameState.Get().SetBusy(busy: false);
+    }
+
+    private IEnumerator Wait(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+    }
+
+    private bool AllowEndTurn()
+    {
+        if (!m_shouldSignalPolymorph || (m_shouldSignalPolymorph && m_isBogSheeped))
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        if (GetTag(GAME_TAG.TURN) != 4 && AllowEndTurn())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        if (endTurnNotifier != null)
+        {
+            NotificationManager.Get().DestroyNotificationNowWithNoAnim(endTurnNotifier);
+        }
+        Vector3 position = EndTurnButton.Get().transform.position;
+        Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+        string key = "TUTORIAL_NO_ENDTURN_HP";
+        HSASpeech speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_HP;
+        if (GameState.Get().GetFriendlySidePlayer().HasReadyAttackers())
+        {
+            key = "TUTORIAL_NO_ENDTURN_ATK";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK;
+        }
+        if (m_shouldSignalPolymorph && !m_isBogSheeped)
+        {
+            key = "TUTORIAL_NO_ENDTURN";
+            speech = AccessibleSpeech.TUTORIAL_NO_ENDTURN;
+        }
+        AccessibilityMgr.NarrateAndWait(speech);
+        return false;
+    }
+
+    public override void NotifyOfTargetModeCancelled()
+    {
+        if (!(sheepTheBog == null))
+        {
+            NotificationManager.Get().DestroyAllPopUps();
+        }
+    }
+
+    public override void NotifyOfCardGrabbed(Entity entity)
+    {
+        if (!m_shouldSignalPolymorph)
+        {
+            return;
+        }
+        if (entity.GetCardId() == "TU5_CS2_022")
+        {
+            m_isPolymorphGrabbed = true;
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            if (handBounceArrow != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(handBounceArrow);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            Vector3 position = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+                .GetFirstCard()
+                .transform.position;
+            Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL04_HELP_02);
+        }
+        else
+        {
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            if ((bool)UniversalInputManager.UsePhoneUI)
+            {
+                InputManager.Get().ReturnHeldCardToHand();
+            }
+            else
+            {
+                InputManager.Get().DropHeldCard();
+            }
+        }
+    }
+
+    public override void NotifyOfCardDropped(Entity entity)
+    {
+        m_isPolymorphGrabbed = false;
+        if (m_shouldSignalPolymorph)
+        {
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            if (ShouldShowArrowOnCardInHand(entity))
+            {
+                Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+            }
+        }
+    }
+
+    public override bool NotifyOfBattlefieldCardClicked(Entity clickedEntity, bool wasInTargetMode)
+    {
+        if (m_shouldSignalPolymorph)
+        {
+            if (!(clickedEntity.GetCardId() == "TU5_CS1_069" && wasInTargetMode))
+            {
+                if (m_isPolymorphGrabbed && wasInTargetMode)
+                {
+                    if (noSheepPopup != null)
+                    {
+                        NotificationManager.Get().DestroyNotificationNowWithNoAnim(noSheepPopup);
+                    }
+                    Vector3 position = clickedEntity.GetCard().transform.position;
+                    Vector3 position2 = new Vector3(position.x + 2.5f, position.y, position.z);
+                    AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL04_HELP_03);
+                    return false;
+                }
+                return false;
+            }
+            if (sheepTheBog != null)
+            {
+                NotificationManager.Get().DestroyNotificationNowWithNoAnim(sheepTheBog);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+            m_shouldSignalPolymorph = false;
+            m_isBogSheeped = true;
+        }
+        return true;
+    }
+
+    public override bool ShouldAllowCardGrab(Entity entity)
+    {
+        if (m_shouldSignalPolymorph && entity.GetCardId() != "TU5_CS2_022")
+        {
+            return false;
+        }
+        return true;
+    }
+
+    private void ManaLabelLoadedCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        GameObject costTextObject = ((Card)callbackData).GetActor().GetCostTextObject();
+        if (costTextObject == null)
+        {
+            Object.Destroy(go);
+            return;
+        }
+        m_heroPowerCostLabel = go;
+        SceneUtils.SetLayer(go, GameLayer.Default);
+        go.transform.parent = costTextObject.transform;
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localPosition = new Vector3(-0.02f, 0.38f, 0f);
+        go.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        go.transform.localScale = new Vector3(go.transform.localScale.x, go.transform.localScale.x, go.transform.localScale.x);
+        go.GetComponent<UberText>().Text = GameStrings.Get("GLOBAL_COST");
+    }
+
+    public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOverEntity))
+        {
+            NotificationManager.Get().DestroyAllArrows();
+        }
+    }
+
+    public override void NotifyOfCardMousedOff(Entity mousedOffEntity)
+    {
+        if (ShouldShowArrowOnCardInHand(mousedOffEntity))
+        {
+            Gameplay.Get().StartCoroutine(ShowArrowInSeconds(0.5f));
+        }
+    }
+
+    private bool ShouldShowArrowOnCardInHand(Entity entity)
+    {
+        if (entity.GetZone() != TAG_ZONE.HAND)
+        {
+            return false;
+        }
+        if (m_shouldSignalPolymorph && entity.GetCardId() == "TU5_CS2_022")
+        {
+            return true;
+        }
+        return false;
+    }
+
+    private IEnumerator ShowArrowInSeconds(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count == 0 || m_isPolymorphGrabbed)
+        {
+            yield break;
+        }
+        Card polyMorph = null;
+        foreach (Card item in cards)
+        {
+            if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+            {
+                polyMorph = item;
+            }
+        }
+        if (!(polyMorph == null))
+        {
+            while (iTween.Count(polyMorph.gameObject) > 0)
+            {
+                yield return null;
+            }
+            if (!polyMorph.IsMousedOver() && !(InputManager.Get().GetHeldCard() == polyMorph))
+            {
+                ShowHandBouncingArrow();
+            }
+        }
+    }
+
+    private void ShowHandBouncingArrow()
+    {
+        if (handBounceArrow != null)
+        {
+            return;
+        }
+        List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetHandZone()
+            .GetCards();
+        if (cards.Count == 0)
+        {
+            return;
+        }
+        Card card = null;
+        foreach (Card item in cards)
+        {
+            if (item.GetEntity().GetCardId() == "TU5_CS2_022")
+            {
+                card = item;
+            }
+        }
+        if (!(card == null) && !m_isPolymorphGrabbed)
+        {
+            Vector3 position = card.transform.position;
+            Vector3 position2 = new Vector3(position.x, position.y, position.z + 2f);
+            handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
+            handBounceArrow.transform.parent = card.transform;
+        }
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (victory)
+        {
+            PlaySound("VO_TUTORIAL_04_JAINA_10_44.prefab:6f5921db1071ead4585c8cc9689d22ea");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_213", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs
new file mode 100644
index 0000000..09a1272
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_05.cs
@@ -0,0 +1,302 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_05 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private int weaponsPlayed;
+
+    private int numTimesRemindedAboutGoal;
+
+    private bool heroPowerHasNotBeenUsed = true;
+
+    private bool victory;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_05()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+        PreloadSound("VO_TUTORIAL_04_JAINA_03_39.prefab:ef84060011610064abeee5d2d526bf85");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_11_11.prefab:8cd68956e13f8ee43bb816a92c56ab7e");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_02_03.prefab:00cdf773e524ae548a31d82db5bb35c2");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_04_05.prefab:eb68b53ffa7195841a18d4c50516ce35");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_08_08.prefab:32281bee676aa6d4e9c590dfb9e03cb6");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_03_04.prefab:38739c8e8bb7eba42a94afe8bce981f3");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_05_06.prefab:30bf89624d8c3df4b9f776218c7300ad");
+        PreloadSound("VO_TUTORIAL_05_JAINA_02_46.prefab:4daa9f9fc9fc730429c198b9a7212521");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_06_07.prefab:f8e57e165a11de047a2fcaa95e22457b");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_09_09.prefab:1ca9806eebcb0e841be971e486199833");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_10_10.prefab:30c0266100fcd714e804006040c241ad");
+        PreloadSound("VO_TUTORIAL_05_JAINA_05_47.prefab:8caf0051fc3c91c48852eed53e886e4b");
+        PreloadSound("VO_TUTORIAL_05_JAINA_06_48.prefab:fbfba7282a8cb334ba40699cab0524fd");
+        PreloadSound("VO_TUTORIAL_05_ILLIDAN_01_02.prefab:d4b65ea6366e7a64d8833321001590f1");
+        PreloadSound("VO_TUTORIAL_05_JAINA_01_45.prefab:d5b645ea8a95c0e44a90838ab77b2564");
+        PreloadSound("VO_INNKEEPER_TUT_COMPLETE_05.prefab:c8d19a552e18c7c429946f62102c9460");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.ILLIDAN_COMPLETE);
+                if (Network.ShouldBeConnectedToAurora() && Network.IsLoggedIn() && !GameMgr.Get().IsSpectator())
+                {
+                    BnetPresenceMgr.Get().SetGameField(15u, 1);
+                }
+                ResetTutorialLostProgress();
+                PlaySound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_05_ILLIDAN_12_12.prefab:dacd7715ffe4d38458679bd5cac593d1");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.ILLIDAN_COMPLETE);
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor actor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        if (GameState.Get().GetOpposingSidePlayer().HasWeapon())
+        {
+            GameState.Get().GetOpposingSidePlayer().GetWeaponCard()
+                .GetActorSpell(SpellType.DEATH)
+                .m_BlockServerEvents = true;
+        }
+        if (turn == 2)
+        {
+            yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_04_JAINA_03_39.prefab:ef84060011610064abeee5d2d526bf85", "TUTORIAL04_JAINA_03", Notification.SpeechBubbleDirection.BottomLeft, actor));
+            if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+            {
+                GameState.Get().SetBusy(busy: true);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_11_11.prefab:8cd68956e13f8ee43bb816a92c56ab7e", "TUTORIAL05_ILLIDAN_11", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                GameState.Get().SetBusy(busy: false);
+            }
+            if (GetTag(GAME_TAG.TURN) == 2 && EndTurnButton.Get().IsInNMPState())
+            {
+                ShowEndTurnBouncingArrow();
+            }
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    weaponsPlayed++;
+                    if (weaponsPlayed == 1)
+                    {
+                        AccessibilityMgr.BlockAllInput(false, true);
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_02_03.prefab:00cdf773e524ae548a31d82db5bb35c2", "TUTORIAL05_ILLIDAN_02", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H);
+                        AccessibilityMgr.UnblockAllInput();
+                    }
+                    else if (weaponsPlayed == 2)
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_04_05.prefab:eb68b53ffa7195841a18d4c50516ce35", "TUTORIAL05_ILLIDAN_04", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    }
+                    else
+                    {
+                        yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_08_08.prefab:32281bee676aa6d4e9c590dfb9e03cb6", "TUTORIAL05_ILLIDAN_08", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    }
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 3:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_03_04.prefab:38739c8e8bb7eba42a94afe8bce981f3", "TUTORIAL05_ILLIDAN_03", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                }
+                break;
+            case 4:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_05_06.prefab:30bf89624d8c3df4b9f776218c7300ad", "TUTORIAL05_ILLIDAN_05", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 5:
+                if (heroPowerHasNotBeenUsed)
+                {
+                    heroPowerHasNotBeenUsed = false;
+                    GameState.Get().SetBusy(busy: true);
+                    yield return new WaitForSeconds(2f);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_02_46.prefab:4daa9f9fc9fc730429c198b9a7212521", "TUTORIAL05_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_06_07.prefab:f8e57e165a11de047a2fcaa95e22457b", "TUTORIAL05_ILLIDAN_06", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 8:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_09_09.prefab:1ca9806eebcb0e841be971e486199833", "TUTORIAL05_ILLIDAN_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                }
+                break;
+            case 9:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_10_10.prefab:30c0266100fcd714e804006040c241ad", "TUTORIAL05_ILLIDAN_10", Notification.SpeechBubbleDirection.TopLeft, enemyActor));
+                }
+                break;
+            case 10:
+                if (numTimesRemindedAboutGoal == 0)
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_05_47.prefab:8caf0051fc3c91c48852eed53e886e4b", "TUTORIAL05_JAINA_05", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                else if (numTimesRemindedAboutGoal == 1)
+                {
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_06_48.prefab:fbfba7282a8cb334ba40699cab0524fd", "TUTORIAL05_JAINA_06", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                numTimesRemindedAboutGoal++;
+                break;
+            case 12:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    AccessibilityMgr.BlockAllInput(false, true);
+                    yield return new WaitForSeconds(2f);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B);
+                    AccessibilityMgr.UnblockAllInput();
+                    GameState.Get().SetBusy(busy: false);
+                    break;
+                }
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE));
+                    string bodyTextGameString = flag ? "TUTORIAL05_HELP_03" : "TUTORIAL05_HELP_04";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL05_HELP_02", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0.5f, 0f), swapMaterial: true);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(flag ? AccessibleSpeech.TUTORIAL05_HELP_03 : AccessibleSpeech.TUTORIAL05_HELP_03);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    FadeInHeroActor(enemyActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_ILLIDAN_01_02.prefab:d4b65ea6366e7a64d8833321001590f1", "TUTORIAL05_ILLIDAN_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    FadeOutHeroActor(enemyActor);
+                    yield return new WaitForSeconds(0.5f);
+                    FadeInHeroActor(jainaActor);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_05_JAINA_01_45.prefab:d5b645ea8a95c0e44a90838ab77b2564", "TUTORIAL05_JAINA_01", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                }
+                MulliganManager.Get().BeginMulligan();
+                if (!DidLoseTutorial(TutorialProgress.ILLIDAN_COMPLETE))
+                {
+                    yield return new WaitForSeconds(2.3f);
+                    FadeOutHeroActor(jainaActor);
+                }
+                break;
+        }
+    }
+
+    private void ShowEndTurnBouncingArrow()
+    {
+        if (!EndTurnButton.Get().IsInWaitingState())
+        {
+            Vector3 position = EndTurnButton.Get().transform.position;
+            Vector3 position2 = new Vector3(position.x - 2f, position.y, position.z);
+            NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, -90f, 0f));
+        }
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        NotificationManager.Get().DestroyAllArrows();
+        return true;
+    }
+
+    public override bool NotifyOfTooltipDisplay(TooltipZone specificZone)
+    {
+        return false;
+    }
+
+    public override string[] NotifyOfKeywordHelpPanelDisplay(Entity entity)
+    {
+        if (entity.GetCardId() == "TU4e_004" || entity.GetCardId() == "TU4e_007")
+        {
+            return new string[2]
+            {
+                GameStrings.Get("TUTORIAL05_WEAPON_HEADLINE"),
+                GameStrings.Get("TUTORIAL05_WEAPON_DESC")
+            };
+        }
+        return null;
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("EX1_277", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs
new file mode 100644
index 0000000..4f2f06e
--- /dev/null
+++ b/Decompiled/Assembly-CSharp/Accessibility/Tutorials/AccessibleTutorial_06.cs
@@ -0,0 +1,328 @@
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Accessibility;
+
+public class AccessibleTutorial_06 : TutorialEntity
+{
+    private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
+
+    private static Map<GameEntityOption, string> s_stringOptions = InitStringOptions();
+
+    private Notification m_endTurnNotifier;
+
+    private bool m_victory;
+
+    private bool m_choSpeaking;
+
+    private Spell m_choFloatSpell;
+
+    private static Map<GameEntityOption, bool> InitBooleanOptions()
+    {
+        return new Map<GameEntityOption, bool> {
+        {
+            GameEntityOption.KEYWORD_HELP_DELAY_OVERRIDDEN,
+            true
+        } };
+    }
+
+    private static Map<GameEntityOption, string> InitStringOptions()
+    {
+        return new Map<GameEntityOption, string>();
+    }
+
+    public AccessibleTutorial_06()
+    {
+        m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
+    }
+
+    public override void PreloadAssets()
+    {
+        PreloadSound("VO_TUTORIAL_06_CHO_15_15.prefab:5f0d0a2d3c6884a47aeadcf29b3d802d");
+        PreloadSound("VO_TUTORIAL_06_CHO_09_13.prefab:99a983ceaa6615848a8bea922e428a2d");
+        PreloadSound("VO_TUTORIAL_06_CHO_17_16.prefab:d337628cbe1422e4ca21dbe174ddef2e");
+        PreloadSound("VO_TUTORIAL_06_CHO_05_09.prefab:ef06af76837b9ff4c8ac27ee18516291");
+        PreloadSound("VO_TUTORIAL_06_JAINA_03_51.prefab:06bd40a237dd0674e8d377240de40e65");
+        PreloadSound("VO_TUTORIAL_06_CHO_06_10.prefab:cd28a9685f46936409d5300001540558");
+        PreloadSound("VO_TUTORIAL_06_CHO_21_18.prefab:48c935e7ec96a104ab04d185382898a4");
+        PreloadSound("VO_TUTORIAL_06_CHO_20_17.prefab:dfc795a107caddb42b3d131d6a627fd8");
+        PreloadSound("VO_TUTORIAL_06_CHO_07_11.prefab:b691c4acfee6c5342a727189de686b6d");
+        PreloadSound("VO_TUTORIAL_06_JAINA_04_52.prefab:5d75f42502bc99b4c84704bedf553ba5");
+        PreloadSound("VO_TUTORIAL_06_CHO_04_08.prefab:8164c968ccb1be44d9dfc01c1668b014");
+        PreloadSound("VO_TUTORIAL_06_CHO_12_14.prefab:13ee98fef9d3e6746a69c385c889dc3a");
+        PreloadSound("VO_TUTORIAL_06_CHO_01_05.prefab:10097a4886a24384d8e8f6dd668bb1c7");
+        PreloadSound("VO_TUTORIAL_06_JAINA_01_49.prefab:b9513645100911741b9bda379bc27a75");
+        PreloadSound("VO_TUTORIAL_06_CHO_02_06.prefab:a9c29883676f21d4e932dccc0f92feca");
+        PreloadSound("VO_TUTORIAL_06_JAINA_02_50.prefab:b97fe840305cae04f8486ac1770b126f");
+        PreloadSound("VO_TUTORIAL_06_CHO_03_07.prefab:c71aaff381cdbd346a9bcf54fa5d7db9");
+        PreloadSound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+        PreloadSound("VO_TUTORIAL_06_JAINA_05_53.prefab:6fb71de610db1234887f6d6c948f5174");
+    }
+
+    public override void NotifyOfGameOver(TAG_PLAYSTATE gameResult)
+    {
+        CancelChoFloating();
+        if (gameResult == TAG_PLAYSTATE.WON)
+        {
+            m_victory = true;
+        }
+        base.NotifyOfGameOver(gameResult);
+        switch (gameResult)
+        {
+            case TAG_PLAYSTATE.WON:
+                SetTutorialProgress(TutorialProgress.CHO_COMPLETE);
+                PlaySound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+                break;
+            case TAG_PLAYSTATE.TIED:
+                PlaySound("VO_TUTORIAL_06_CHO_22_19.prefab:8c70f69b5da1f9c43accca95c1854ddf");
+                break;
+            case TAG_PLAYSTATE.LOST:
+                SetTutorialLostProgress(TutorialProgress.CHO_COMPLETE);
+                break;
+        }
+    }
+
+    protected override Spell BlowUpHero(Card card, SpellType spellType)
+    {
+        if (card.GetEntity().GetCardId() != "TU4f_001")
+        {
+            return base.BlowUpHero(card, spellType);
+        }
+        Spell result = card.ActivateActorSpell(SpellType.CHODEATH);
+        Gameplay.Get().StartCoroutine(HideOtherElements(card));
+        return result;
+    }
+
+    protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (turn)
+        {
+            case 2:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_15_15.prefab:5f0d0a2d3c6884a47aeadcf29b3d802d", "TUTORIAL06_CHO_15", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 4:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_09_13.prefab:99a983ceaa6615848a8bea922e428a2d", "TUTORIAL06_CHO_09", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                }
+                break;
+            case 15:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    while (m_choSpeaking)
+                    {
+                        yield return null;
+                    }
+                    yield return new WaitForSeconds(0.5f);
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_05_09.prefab:ef06af76837b9ff4c8ac27ee18516291", "TUTORIAL06_CHO_05", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_03_51.prefab:06bd40a237dd0674e8d377240de40e65", "TUTORIAL06_JAINA_03", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_06_10.prefab:cd28a9685f46936409d5300001540558", "TUTORIAL06_CHO_06", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                }
+                break;
+            case 14:
+                if (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE))
+                {
+                    while (m_choSpeaking)
+                    {
+                        yield return null;
+                    }
+                    m_choSpeaking = true;
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_21_18.prefab:48c935e7ec96a104ab04d185382898a4", "TUTORIAL06_CHO_21", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    m_choSpeaking = false;
+                }
+                break;
+            case 16:
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_20_17.prefab:dfc795a107caddb42b3d131d6a627fd8", "TUTORIAL06_CHO_20", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    protected override IEnumerator HandleMissionEventWithTiming(int missionEvent)
+    {
+        Actor enemyActor = GameState.Get().GetOpposingSidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        Actor jainaActor = GameState.Get().GetFriendlySidePlayer().GetHero()
+            .GetCard()
+            .GetActor();
+        switch (missionEvent)
+        {
+            case 1:
+                HandleGameStartEvent();
+                break;
+            case 2:
+                GameState.Get().SetBusy(busy: true);
+                while (m_choSpeaking)
+                {
+                    yield return null;
+                }
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_17_16.prefab:d337628cbe1422e4ca21dbe174ddef2e", "TUTORIAL06_CHO_17", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                GameState.Get().SetBusy(busy: false);
+                break;
+            case 6:
+                {
+                    GameState.Get().SetBusy(busy: true);
+                    Card card = GameState.Get().GetOpposingSidePlayer().GetHero()
+                        .GetCard();
+                    m_choFloatSpell = card.GetActorSpell(SpellType.CHOFLOAT);
+                    m_choFloatSpell.ActivateState(SpellStateType.BIRTH);
+                    yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_07_11.prefab:b691c4acfee6c5342a727189de686b6d", "TUTORIAL06_CHO_07", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                    GameState.Get().SetBusy(busy: false);
+                    Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_04_52.prefab:5d75f42502bc99b4c84704bedf553ba5", "TUTORIAL06_JAINA_04", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                    break;
+                }
+            case 8:
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_04_08.prefab:8164c968ccb1be44d9dfc01c1668b014", "TUTORIAL06_CHO_04", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+            case 9:
+                CancelChoFloating();
+                m_choSpeaking = true;
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_12_14.prefab:13ee98fef9d3e6746a69c385c889dc3a", "TUTORIAL06_CHO_12", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                m_choSpeaking = false;
+                break;
+            case 10:
+                {
+                    Card card2 = FindVoodooDoctorInOpposingSide();
+                    if (!(card2 == null))
+                    {
+                        GameState.Get().SetBusy(busy: true);
+                        yield return new WaitForSeconds(2f);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL06_HELP_03);
+                        yield return AccessibilityMgr.Narrate(AccessibleSpeech.TUTORIAL_CHO_1);
+                        GameState.Get().SetBusy(busy: false);
+                    }
+                    break;
+                }
+            case 54:
+                {
+                    yield return new WaitForSeconds(2f);
+                    var flag = (!DidLoseTutorial(TutorialProgress.CHO_COMPLETE));
+                    string bodyTextGameString = flag? "TUTORIAL06_HELP_02" : "TUTORIAL06_HELP_04";
+                    var tutorialStartDialog = ShowTutorialDialog("TUTORIAL06_HELP_01", bodyTextGameString, "TUTORIAL01_HELP_16", new Vector2(0f, 0.5f));
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(false);
+                    AccessibilityMgr.SetNotification(tutorialStartDialog.m_ButtonStart);
+                    yield return AccessibilityMgr.Narrate(flag? AccessibleSpeech.TUTORIAL06_HELP_02 : AccessibleSpeech.TUTORIAL06_HELP_04);
+                    tutorialStartDialog.m_ButtonStart.SetEnabled(true);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.PRESS_ENTER_TO_START_VOICE);
+                    break;
+                }
+            case 55:
+                MulliganManager.Get().BeginMulligan();
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_01_05.prefab:10097a4886a24384d8e8f6dd668bb1c7", "TUTORIAL06_CHO_01", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                FadeOutHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.5f));
+                FadeInHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_01_49.prefab:b9513645100911741b9bda379bc27a75", "TUTORIAL06_JAINA_01", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                FadeOutHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.5f));
+                FadeInHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_02_06.prefab:a9c29883676f21d4e932dccc0f92feca", "TUTORIAL06_CHO_02", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                FadeOutHeroActor(enemyActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.25f));
+                FadeInHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_JAINA_02_50.prefab:b97fe840305cae04f8486ac1770b126f", "TUTORIAL06_JAINA_02", Notification.SpeechBubbleDirection.BottomRight, jainaActor));
+                FadeOutHeroActor(jainaActor);
+                yield return Gameplay.Get().StartCoroutine(Wait(0.25f));
+                Gameplay.Get().StartCoroutine(PlaySoundAndWait("VO_TUTORIAL_06_CHO_03_07.prefab:c71aaff381cdbd346a9bcf54fa5d7db9", "TUTORIAL06_CHO_03", Notification.SpeechBubbleDirection.TopRight, enemyActor));
+                break;
+        }
+    }
+
+    private void CancelChoFloating()
+    {
+        if (!(m_choFloatSpell == null) && m_choFloatSpell.GetActiveState() != 0)
+        {
+            m_choFloatSpell.ActivateState(SpellStateType.CANCEL);
+        }
+    }
+
+    private Card FindVoodooDoctorInOpposingSide()
+    {
+        foreach (Card card in GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
+            .GetCards())
+        {
+            if (card.GetEntity().GetCardId() == "EX1_011")
+            {
+                return card;
+            }
+        }
+        return null;
+    }
+
+    private IEnumerator Wait(float seconds)
+    {
+        yield return new WaitForSeconds(seconds);
+    }
+
+    public override float GetAdditionalTimeToWaitForSpells()
+    {
+        return 1.5f;
+    }
+
+    public override bool NotifyOfEndTurnButtonPushed()
+    {
+        Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+        if (optionsPacket != null && !optionsPacket.HasValidOption())
+        {
+            NotificationManager.Get().DestroyAllArrows();
+            return true;
+        }
+        for (int i = 0; i < optionsPacket.List.Count; i++)
+        {
+            Network.Options.Option option = optionsPacket.List[i];
+            if (option.Main.PlayErrorInfo.IsValid() && option.Type == Network.Options.Option.OptionType.POWER && GameState.Get().GetEntity(option.Main.ID).GetZone() == TAG_ZONE.PLAY)
+            {
+                if (m_endTurnNotifier != null)
+                {
+                    NotificationManager.Get().DestroyNotificationNowWithNoAnim(m_endTurnNotifier);
+                }
+                AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL_NO_ENDTURN_ATK);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public override void NotifyOfDefeatCoinAnimation()
+    {
+        if (m_victory)
+        {
+            PlaySound("VO_TUTORIAL_06_JAINA_05_53.prefab:6fb71de610db1234887f6d6c948f5174");
+        }
+    }
+
+    public override List<RewardData> GetCustomRewards()
+    {
+        if (!m_victory)
+        {
+            return null;
+        }
+        List<RewardData> list = new List<RewardData>();
+        CardRewardData cardRewardData = new CardRewardData("CS2_124", TAG_PREMIUM.NORMAL, 2);
+        cardRewardData.MarkAsDummyReward();
+        list.Add(cardRewardData);
+        return list;
+    }
+
+    protected override void MarkForAccessibility()
+    {
+    }
+}
diff --git a/Decompiled/Assembly-CSharp/AchieveManager.cs b/Decompiled/Assembly-CSharp/AchieveManager.cs
index 0b30ea3..8b41055 100644
--- a/Decompiled/Assembly-CSharp/AchieveManager.cs
+++ b/Decompiled/Assembly-CSharp/AchieveManager.cs
@@ -362,17 +362,26 @@ public class AchieveManager : IService, IHasUpdate
 		return value.IsCompleted();
 	}
 
-	public bool HasUnlockedDefaultHeroes()
-	{
+	public int NumDefaultHeroesUnlocked()
+    {
+		int ret = 0;
+
 		foreach (TAG_CLASS oRDERED_HERO_CLASS in GameUtils.ORDERED_HERO_CLASSES)
-		{
+        {
 			NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(oRDERED_HERO_CLASS);
-			if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
-			{
-				return false;
-			}
-		}
-		return true;
+			if (heroLevel != null && heroLevel.CurrentLevel.Level != 0)
+            {
+                ret++;
+            }
+        }
+
+		return ret;
+    }
+
+	public bool HasUnlockedDefaultHeroes()
+	{
+		// 21.0.0.88998 broke a bunch of stuff around this such as the quest markers
+		return NumDefaultHeroesUnlocked() == GameUtils.ORDERED_HERO_CLASSES.Count();
 	}
 
 	public bool HasUnlockedArena()
@@ -382,7 +391,7 @@ public class AchieveManager : IService, IHasUpdate
 
 	public Achievement GetAchievement(int achieveID)
 	{
-		if (!m_achievements.ContainsKey(achieveID))
+        if (!m_achievements.ContainsKey(achieveID))
 		{
 			return null;
 		}
diff --git a/Decompiled/Assembly-CSharp/Achievement.cs b/Decompiled/Assembly-CSharp/Achievement.cs
index e72e427..76ca010 100644
--- a/Decompiled/Assembly-CSharp/Achievement.cs
+++ b/Decompiled/Assembly-CSharp/Achievement.cs
@@ -646,7 +646,7 @@ public class Achievement
 		}
 	}
 
-	private void SetRewards(List<RewardData> rewardDataList)
+	internal void SetRewards(List<RewardData> rewardDataList)
 	{
 		m_rewards = new List<RewardData>(rewardDataList);
 		FixUpRewardOrigins(m_rewards);
diff --git a/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs b/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
index f63bd61..50c2dc0 100644
--- a/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureBookPageDisplay.cs
@@ -1145,7 +1145,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 			yield return null;
 		}
 		m_adventureBookPageContentsWidget.RemoveEventListener(AdventureNewlyCompletedEventListener);
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateAdventureComplete"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateAdventureComplete"))
 		{
 			bool allPopupsShown = false;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
@@ -1184,7 +1184,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 				yield return null;
 			}
 			m_adventureBookPageContentsWidget.RemoveEventListener(RewardChestAnimEventListener);
-			if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
+			if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
 			{
 				bool allPopupsShown = false;
 				if (AdventureScene.Get().IsDevMode)
diff --git a/Decompiled/Assembly-CSharp/AdventureChooserTray.cs b/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
index 654b15c..a96c0d0 100644
--- a/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
+++ b/Decompiled/Assembly-CSharp/AdventureChooserTray.cs
@@ -50,6 +50,7 @@ public class AdventureChooserTray : AccordionMenuTray
 		AdventureProgressMgr.Get().RegisterProgressUpdatedListener(OnAdventureProgressUpdated);
 		Box.Get().AddTransitionFinishedListener(OnBoxTransitionFinished);
 		StartCoroutine(InitTrayWhenReady());
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureChooserTrayAwake(this);
 	}
 
 	private void Start()
diff --git a/Decompiled/Assembly-CSharp/AdventureConfig.cs b/Decompiled/Assembly-CSharp/AdventureConfig.cs
index c8b0a47..24a4021 100644
--- a/Decompiled/Assembly-CSharp/AdventureConfig.cs
+++ b/Decompiled/Assembly-CSharp/AdventureConfig.cs
@@ -5,6 +5,7 @@ using Hearthstone.DataModels;
 using Hearthstone.DungeonCrawl;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureConfig : MonoBehaviour
@@ -71,7 +72,7 @@ public class AdventureConfig : MonoBehaviour
 
 	private Map<AdventureDbId, AdventureModeDbId> m_ClientChooserAdventureModes = new Map<AdventureDbId, AdventureModeDbId>();
 
-	private AdventureDbId SelectedAdventure
+	internal AdventureDbId SelectedAdventure
 	{
 		get
 		{
@@ -95,7 +96,7 @@ public class AdventureConfig : MonoBehaviour
 		}
 	}
 
-	private AdventureModeDbId SelectedMode
+	internal AdventureModeDbId SelectedMode
 	{
 		get
 		{
@@ -420,6 +421,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void SetSelectedAdventureMode(AdventureDbId adventureId, AdventureModeDbId modeId)
 	{
+		AccessibilityUtils.LogDebug($"SetSelectedAdventureMode({adventureId}, {modeId})");
 		SelectedAdventure = adventureId;
 		SelectedMode = modeId;
 		m_ClientChooserAdventureModes[adventureId] = modeId;
@@ -663,6 +665,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void ChangeSubScene(AdventureData.Adventuresubscene subscene, bool pushToBackStack = true)
 	{
+		AccessibilityUtils.LogDebug($"ChangeSubScene({subscene})");
 		if (subscene == m_CurrentSubScene)
 		{
 			Debug.Log($"Sub scene {subscene} is already set.");
@@ -999,9 +1002,10 @@ public class AdventureConfig : MonoBehaviour
 
 	public void OnAdventureSceneAwake()
 	{
-		SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
-		SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
-		if (!ShouldDisplayAdventure(SelectedAdventure))
+        SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
+        SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
+
+        if (!ShouldDisplayAdventure(SelectedAdventure))
 		{
 			SelectedAdventure = AdventureDbId.PRACTICE;
 			SelectedMode = AdventureModeDbId.LINEAR;
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
index 2c68893..5c62a57 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
@@ -5,7 +5,7 @@ public class AdventureDungeonCrawlDeckTray : BasePhoneDeckTray
 {
 	public PlayMakerFSM DeckTrayGlow;
 
-	private CollectionDeck m_deck;
+	internal CollectionDeck m_deck;
 
 	protected override void Awake()
 	{
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
index 51c79d8..3614891 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
@@ -9,9 +9,10 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class AdventureDungeonCrawlDisplay : MonoBehaviour
+public class AdventureDungeonCrawlDisplay : MonoBehaviour, AccessibleScreen
 {
 	[Serializable]
 	public class DungeonCrawlDisplayStyleOverride
@@ -294,15 +295,15 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		m_subsceneController.TransitionComplete += OnSubSceneTransitionComplete;
 		AdventureDbId selectedAdv = m_dungeonCrawlData.GetSelectedAdventure();
 		AdventureModeDbId selectedMode = m_dungeonCrawlData.GetSelectedMode();
-		AdventureDataDbfRecord adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
+		m_adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
 		m_playerHeroData = new PlayerHeroData(m_dungeonCrawlData);
 		m_playerHeroData.OnHeroDataChanged += delegate
 		{
 			m_playMat.SetPlayerHeroDbId(m_playerHeroData.HeroDbId);
 		};
-		m_AdventureTitle.Text = adventureDataRecord.Name;
-		m_gameSaveDataServerKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataServerKey;
-		m_gameSaveDataClientKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataClientKey;
+		m_AdventureTitle.Text = m_adventureDataRecord.Name;
+		m_gameSaveDataServerKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataServerKey;
+		m_gameSaveDataClientKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataClientKey;
 		if (m_gameSaveDataServerKey <= (GameSaveKeyId)0)
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has no GameSaveDataKey set! This mode does not work without defining GAME_SAVE_DATA_SERVER_KEY in ADVENTURE.dbi!", selectedAdv, selectedMode);
@@ -315,7 +316,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has an equal GameSaveDataKey for Client and Server. These keys are not allowed to be equal!", selectedAdv, selectedMode);
 		}
-		m_bossCardBackId = adventureDataRecord.BossCardBack;
+		m_bossCardBackId = m_adventureDataRecord.BossCardBack;
 		if (m_bossCardBackId == 0)
 		{
 			m_bossCardBackId = 0;
@@ -347,13 +348,13 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 				Log.Adventures.Print("Owns wing for this Dungeon Run? {0}", AdventureProgressMgr.Get().OwnsWing(scenarioDbfRecord2.WingId));
 			}
 		}
-		m_shouldSkipHeroSelect = adventureDataRecord.DungeonCrawlSkipHeroSelect;
-		m_mustPickShrine = adventureDataRecord.DungeonCrawlMustPickShrine;
-		m_mustSelectChapter = adventureDataRecord.DungeonCrawlSelectChapter;
-		m_anomalyModeCardDbId = adventureDataRecord.AnomalyModeDefaultCardId;
+		m_shouldSkipHeroSelect = m_adventureDataRecord.DungeonCrawlSkipHeroSelect;
+		m_mustPickShrine = m_adventureDataRecord.DungeonCrawlMustPickShrine;
+		m_mustSelectChapter = m_adventureDataRecord.DungeonCrawlSelectChapter;
+		m_anomalyModeCardDbId = m_adventureDataRecord.AnomalyModeDefaultCardId;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_dungeonCrawlPlayMatReference.RegisterReadyListener<AdventureDungeonCrawlPlayMat>(OnPlayMatReady);
-		bool retireButtonSupported = adventureDataRecord.DungeonCrawlIsRetireSupported;
+		bool retireButtonSupported = m_adventureDataRecord.DungeonCrawlIsRetireSupported;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_retireButtonReference.RegisterReadyListener(delegate(Widget w)
 		{
@@ -361,24 +362,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			{
 				if (eventName == "Button_Framed_Clicked" && retireButtonSupported)
 				{
-					m_retireButton.SetActive(value: false);
-					AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
-					{
-						m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
-						m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
-						m_showAlertIcon = true,
-						m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
-						m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
-					};
-					if (m_isPVPDR)
-					{
-						popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
-					}
-					else
-					{
-						popupInfo.m_responseCallback = OnRetirePopupResponse;
-					}
-					DialogManager.Get().ShowPopup(popupInfo);
+					RetireFromAdventure();
 				}
 			});
 			m_retireButton = w.gameObject;
@@ -415,7 +399,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		SetDungeonCrawlDisplayVisualStyle();
 	}
 
-	public void EnablePlayButton()
+    public void EnablePlayButton()
 	{
 		if (m_playMat != null)
 		{
@@ -1098,6 +1082,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			m_retireButton.SetActive(adventureDataRecord.DungeonCrawlIsRetireSupported);
 		}
 		m_assetLoadingHelper.AssetLoadCompleted();
+		ReadScreen();
 	}
 
 	private void OnPlayMatPaperControllerReady(VisualController paperController)
@@ -3129,4 +3114,214 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		Navigation.PopBlockBackingOut();
 		Navigation.GoBack();
 	}
+
+	#region Accessibility
+
+	private enum AccessibleState { WAITING, IS_VO_PLAYING, READING_PLAY_MENU, READING_DECK, RUN_COMPLETED };
+
+	private AccessibleState m_curAccessibleState;
+
+	private AccessibleState m_stateAfterVO;
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleDeckTray;
+
+	private AdventureDataDbfRecord m_adventureDataRecord;
+
+	private void ReadScreen()
+    {
+		if (!SupportedAdventure())
+        {
+			return;
+        }
+
+		AccessibilityMgr.SetScreen(this);
+
+		if (ShouldShowRunCompletedScreen())
+        {
+			ReadCompletedScreen();
+        }
+		else
+        {
+            ReadPlayMenu(); // TODO: Figure out a cleanway to delay this until VO plays that doesn't require refactoring playMat..
+        }
+    }
+
+    private void ReadCompletedScreen()
+    {
+		m_curAccessibleState = AccessibleState.RUN_COMPLETED;
+		m_stateAfterVO = AccessibleState.RUN_COMPLETED;
+
+		AccessibilityMgr.Output(GetAdventureCompleteSpeech());
+    }
+
+	private string GetAdventureCompleteSpeech()
+    {
+		return $"Adventure complete. Press {AccessibleKey.CONFIRM} to finish";
+    }
+
+    private void ReadPlayMenu()
+    {
+		m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+		m_stateAfterVO = AccessibleState.READING_PLAY_MENU;
+
+		var numDefeatedBosses = m_playMat.m_numBossesDefeated;
+		var numBossesInRun = m_playMat.m_bossesPerRun;
+
+        AccessibilityMgr.Output($"You're on opponent number {numDefeatedBosses + 1} out of {numBossesInRun}");
+
+		m_accessibleMenu = new AccessibleMenu("Adventure menu", () => m_BackButton.TriggerRelease());
+
+		m_accessibleMenu.AddOption("Play", () => m_playMat.ClickPlayButton());
+        m_accessibleMenu.AddOption("Read Deck", ReadDeck);
+
+        if (m_adventureDataRecord.DungeonCrawlIsRetireSupported)
+        {
+			m_accessibleMenu.AddOption("Retire", () => RetireFromAdventure());
+        }
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void ReadDeck()
+	{
+		if (m_dungeonCrawlDeckTray == null || m_dungeonCrawlDeckTray.m_deck == null || m_dungeonCrawlDeckTray.m_deck.GetCards().Count == 0)
+		{
+			AccessibilityMgr.Output("You can't read your deck in this adventure");
+			return;
+		}
+
+		m_curAccessibleState = AccessibleState.READING_DECK;
+
+		var cards = m_dungeonCrawlDeck.GetDeckContents();
+
+		var accessibleCards = new List<AccessibleCollectibleCard>(cards.Cards.Count);
+
+		foreach (var card in cards.Cards)
+        {
+			var cardDbId = card.Def.Asset;
+			var cardId = GameUtils.TranslateDbIdToCardId(cardDbId);
+			var cardQty = card.Qty;
+			var entityDef = DefLoader.Get().GetEntityDef(cardId);
+			var cardRecord = GameUtils.GetCardRecord(cardId);
+			var collectibleCard = new CollectibleCard(cardRecord, entityDef, TAG_PREMIUM.NORMAL);
+			collectibleCard.OwnedCount = cardQty;
+			var accessibleCollectibleCard = new AccessibleCollectibleCard(collectibleCard, true);
+
+			accessibleCards.Add(accessibleCollectibleCard);
+        }
+
+		m_accessibleDeckTray = new AccessibleListOfItems<AccessibleCollectibleCard>(accessibleCards);
+		m_accessibleDeckTray.StartReading();
+    }
+
+    private bool SupportedAdventure()
+    {
+		return m_dungeonCrawlData.GetSelectedAdventure() == AdventureDbId.BOH;
+    }
+
+    public void HandleInput()
+    {
+		// Wait for VO to finish
+		if (NotificationManager.Get().IsQuotePlaying)
+        {
+			m_curAccessibleState = AccessibleState.IS_VO_PLAYING;
+			return;
+        }
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+        {
+			if (m_stateAfterVO == AccessibleState.RUN_COMPLETED)
+            {
+				ReadCompletedScreen();
+            }
+			else
+            {
+                // Repeat menu
+                ReadPlayMenu();
+            }
+
+            return;
+        }
+
+		// Normal flow
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+            m_accessibleMenu.HandleAccessibleInput();
+        }
+		else if (m_curAccessibleState == AccessibleState.READING_DECK)
+        {
+			if (AccessibleKey.BACK.IsPressed())
+            {
+				m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+				m_accessibleMenu.StartReading();
+            }
+			else
+            {
+				m_accessibleDeckTray.HandleAccessibleInput();
+
+				var curCardIdx = m_accessibleDeckTray.GetItemBeingReadIndex();
+				var cardTiles = m_dungeonCrawlDeckTray.GetCardsContent().GetCardTiles();
+				AccessibleInputMgr.MoveMouseTo(cardTiles[curCardIdx]);
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_BackButton.TriggerRelease();
+            }
+        }
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+            return AccessibleSpeech.MENU_HELP(true);
+        }
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+        {
+			return GetAdventureCompleteSpeech();
+        }
+        else if (m_curAccessibleState == AccessibleState.READING_DECK)
+        {
+			return $"Use the arrow keys to read your cards. Press {AccessibleKey.BACK} once you're done";
+        }
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+        {
+			return "Waiting for voice-over to end";
+        }
+
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+		AccessibilityMgr.Output("Adventure screen");
+    }
+
+    private void RetireFromAdventure()
+    {
+        m_retireButton.SetActive(value: false);
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
+        {
+            m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
+            m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
+            m_showAlertIcon = true,
+            m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
+            m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
+        };
+        if (m_isPVPDR)
+        {
+            popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
+        }
+        else
+        {
+            popupInfo.m_responseCallback = OnRetirePopupResponse;
+        }
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
index ae331d3..3ed71b5 100644
--- a/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
+++ b/Decompiled/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
@@ -7,6 +7,7 @@ using Hearthstone.DungeonCrawl;
 using Hearthstone.Progression;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureDungeonCrawlPlayMat : MonoBehaviour
@@ -266,9 +267,9 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 
 	private OptionType m_currentOptionType;
 
-	private int m_numBossesDefeated;
+	internal int m_numBossesDefeated;
 
-	private int m_bossesPerRun;
+	internal int m_bossesPerRun;
 
 	private bool m_allowPlayButtonAnimation;
 
@@ -1112,10 +1113,13 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 		}
 		if ((!(m_bossHeroPowerTooltip != null) || m_bossHeroPowerTooltip.IsDying()) && m_shouldShowBossHeroPowerTooltip)
 		{
-			m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
-			m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
-			m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
-		}
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
+                m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
+                m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
+            }
+        }
 	}
 
 	public void HideBossHeroPowerTooltip(bool immediate = false)
@@ -1890,4 +1894,13 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 			}
 		}
 	}
+
+    #region Accessibility
+
+    internal void ClickPlayButton()
+    {
+		m_playButton.TriggerRelease();
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs b/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
index 080cec8..419b3fb 100644
--- a/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
+++ b/Decompiled/Assembly-CSharp/AdventureMissionDisplay.cs
@@ -885,7 +885,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 				wingIds.Add((int)item2.GetWingId());
 			}
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			m_WaitingForClassChallengeUnlocks = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
diff --git a/Decompiled/Assembly-CSharp/AdventureScene.cs b/Decompiled/Assembly-CSharp/AdventureScene.cs
index 2d2ea69..4a2dbdc 100644
--- a/Decompiled/Assembly-CSharp/AdventureScene.cs
+++ b/Decompiled/Assembly-CSharp/AdventureScene.cs
@@ -133,6 +133,7 @@ public class AdventureScene : PegasusScene
 		adventureConfig.AddSelectedModeChangeListener(OnSelectedModeChanged);
 		adventureConfig.AddAdventureModeChangeListener(OnAdventureModeChanged);
 		adventureConfig.AddAdventureMissionSetListener(OnAdventureMissionChanged);
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureSceneShown();
 		m_StartupAssetLoads++;
 		SetCurrentTransitionDirection();
 		Options.Get().SetBool(Option.BUNDLE_JUST_PURCHASE_IN_HUB, val: false);
@@ -311,7 +312,7 @@ public class AdventureScene : PegasusScene
 					runCallback((string)subSceneDef.m_Prefab, widgetInstance.Widget.gameObject, callbackData);
 				}
 				UpdateAdventureModeMusic();
-				m_isLoading = false;
+				DoneLoading(subscene);
 			});
 			return;
 		}
@@ -323,11 +324,12 @@ public class AdventureScene : PegasusScene
 				runCallback(assetRef, go, data);
 			}
 			UpdateAdventureModeMusic();
-			m_isLoading = false;
+			DoneLoading(subscene);
 		}, callbackData, AssetLoadingOptions.IgnorePrefabPosition);
 	}
 
-	private void OnSubSceneChange(AdventureData.Adventuresubscene newscene, bool forward)
+
+    private void OnSubSceneChange(AdventureData.Adventuresubscene newscene, bool forward)
 	{
 		m_transitionIsGoingBack = !forward;
 		LoadSubScene(newscene);
@@ -592,7 +594,9 @@ public class AdventureScene : PegasusScene
 
 	private void ShowExpertAIUnlockTip()
 	{
-		if (NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>().Levels.Count <= 0 && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("AdventureScene.ShowExpertAIUnlockTip"))
+		// vvv This is broken since Blizzard's 21.0.0.88998 patch
+		//if (NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>().Levels.Count <= 0 && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "AdventureScene.ShowExpertAIUnlockTip"))
+		if (AchieveManager.Get().HasUnlockedDefaultHeroes() && (SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.GAMEPLAY || Options.Get().GetBool(Option.HAS_SEEN_UNLOCK_ALL_HEROES_TRANSITION)) && !ReturningPlayerMgr.Get().IsInReturningPlayerMode && !Options.Get().GetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "AdventureScene.ShowExpertAIUnlockTip"))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_EXPERT_AI_10"), "VO_INNKEEPER_EXPERT_AI_10.prefab:7979b1ca6d60f7b448686a248246542d");
 			Options.Get().SetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, val: true);
@@ -661,4 +665,12 @@ public class AdventureScene : PegasusScene
 			m_CurrentTransitionDirection = m_TransitionDirection;
 		}
 	}
+
+    #region Accessibility
+    private void DoneLoading(AdventureData.Adventuresubscene subscene)
+    {
+        m_isLoading = false;
+		Accessibility.AccessibleAdventureScene.Get().OnSubSceneLoaded(subscene);
+    }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs b/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
index f673f12..8eff520 100644
--- a/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
+++ b/Decompiled/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
@@ -348,7 +348,7 @@ public class AdventureWingFrozenThroneHelper : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			waitingForNextStep = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
diff --git a/Decompiled/Assembly-CSharp/AlertPopup.cs b/Decompiled/Assembly-CSharp/AlertPopup.cs
index 3654f34..8100bf6 100644
--- a/Decompiled/Assembly-CSharp/AlertPopup.cs
+++ b/Decompiled/Assembly-CSharp/AlertPopup.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using Blizzard.T5.AssetManager;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AlertPopup : DialogBase
@@ -29,7 +30,8 @@ public class AlertPopup : DialogBase
 		OK,
 		CONFIRM,
 		CANCEL,
-		CONFIRM_CANCEL
+		CONFIRM_CANCEL,
+		EOE
 	}
 
 	public delegate void ResponseCallback(Response response, object userData);
@@ -236,6 +238,8 @@ public class AlertPopup : DialogBase
 		DoShowAnimation();
 		bool systemDialogActive = m_popupInfo == null || !m_popupInfo.m_layerToUse.HasValue || m_popupInfo.m_layerToUse.Value == GameLayer.UI || m_popupInfo.m_layerToUse.Value == GameLayer.HighPriorityUI;
 		UniversalInputManager.Get().SetSystemDialogActive(systemDialogActive);
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -467,4 +471,96 @@ public class AlertPopup : DialogBase
 			m_header.m_container.UpdateSlices();
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+        AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Alert Popup", true);
+		AccessibilityMgr.Output(m_alertText.Text);
+		AccessibilityMgr.Output(GetAccessibleHelp());
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		switch (m_popupInfo.m_responseDisplay)
+		{
+            case ResponseDisplay.OK:
+				HandleOkPopupInput();
+                break;
+            case ResponseDisplay.CONFIRM:
+				HandleConfirmPopupInput();
+                break;
+            case ResponseDisplay.CANCEL:
+				HandleCancelPopupInput();
+                break;
+            case ResponseDisplay.CONFIRM_CANCEL:
+				HandleConfirmCancelPopupInput();
+                break;
+			default:
+				break;
+        }
+    }
+
+	private void HandleOkPopupInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_okayButton.TriggerRelease();
+        }
+    }
+
+	private void HandleConfirmPopupInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_confirmButton.TriggerRelease();
+        }
+    }
+
+	private void HandleCancelPopupInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_cancelButton.TriggerRelease();
+        }
+    }
+
+	private void HandleConfirmCancelPopupInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_confirmButton.TriggerRelease();
+        }
+		else if (AccessibleKey.BACK.IsPressed())
+        {
+			m_cancelButton.TriggerRelease();
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		switch (m_popupInfo.m_responseDisplay)
+		{
+            case ResponseDisplay.OK:
+				return $"Press {AccessibleKey.CONFIRM} to continue";
+                break;
+            case ResponseDisplay.CONFIRM:
+				return $"Press {AccessibleKey.CONFIRM} to confirm";
+                break;
+            case ResponseDisplay.CANCEL:
+				return $"Press {AccessibleKey.CONFIRM} to cancel";
+                break;
+            case ResponseDisplay.CONFIRM_CANCEL:
+				return $"Press {AccessibleKey.CONFIRM} to confirm or {AccessibleKey.BACK} to cancel";
+                break;
+			default:
+				break;
+        }
+
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs b/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
index b81211e..3f68585 100644
--- a/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
+++ b/Decompiled/Assembly-CSharp/AssetDownloadDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.Streaming;
 
-public class AssetDownloadDialog : DialogBase
+public class AssetDownloadDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/Assets/AdventureData.cs b/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
index 0680bff..42d9a16 100644
--- a/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
+++ b/Decompiled/Assembly-CSharp/Assets/AdventureData.cs
@@ -25,7 +25,9 @@ namespace Assets
 			[Description("Bonus_Challenge")]
 			BONUS_CHALLENGE,
 			[Description("Location_Select")]
-			LOCATION_SELECT
+			LOCATION_SELECT,
+			[Description("EOE")]
+			EOE
 		}
 
 		public enum Adventurebooklocation
diff --git a/Decompiled/Assembly-CSharp/Assets/QuestPool.cs b/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
index 004674a..4a545a2 100644
--- a/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
+++ b/Decompiled/Assembly-CSharp/Assets/QuestPool.cs
@@ -11,7 +11,9 @@ namespace Assets
 			[Description("daily")]
 			DAILY,
 			[Description("weekly")]
-			WEEKLY
+			WEEKLY,
+			[Description("eoe")]
+			EOE
 		}
 
 		public static QuestPoolType ParseQuestPoolTypeValue(string value)
diff --git a/Decompiled/Assembly-CSharp/AttackSpellController.cs b/Decompiled/Assembly-CSharp/AttackSpellController.cs
index 0f2eb12..6d400a0 100644
--- a/Decompiled/Assembly-CSharp/AttackSpellController.cs
+++ b/Decompiled/Assembly-CSharp/AttackSpellController.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class AttackSpellController : SpellController
 {
@@ -31,6 +32,8 @@ public class AttackSpellController : SpellController
 
 	private bool m_repeatProposed;
 
+	private AccessibleAttackSpellController m_accController;
+
 	protected override bool AddPowerSourceAndTargets(PowerTaskList taskList)
 	{
 		m_attackType = taskList.GetAttackType();
@@ -49,6 +52,7 @@ public class AttackSpellController : SpellController
 		{
 			AddTarget(defender.GetCard());
 		}
+		m_accController = new AccessibleAttackSpellController(taskList);
 		return true;
 	}
 
@@ -144,6 +148,7 @@ public class AttackSpellController : SpellController
 
 	private void LaunchAttack()
 	{
+		m_accController.OnLaunchAttack();
 		Card source = GetSource();
 		Entity entity = source.GetEntity();
 		Card target = GetTarget();
diff --git a/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs b/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
index f83ef84..5caa31d 100644
--- a/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
+++ b/Decompiled/Assembly-CSharp/BaconCollectionDisplay.cs
@@ -85,7 +85,7 @@ public class BaconCollectionDisplay : CollectibleDisplay
 
 	protected override void OnDestroy()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/BannerPopup.cs b/Decompiled/Assembly-CSharp/BannerPopup.cs
index a8610a3..31d6c04 100644
--- a/Decompiled/Assembly-CSharp/BannerPopup.cs
+++ b/Decompiled/Assembly-CSharp/BannerPopup.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class BannerPopup : MonoBehaviour
+public class BannerPopup : MonoBehaviour, AccessibleUI
 {
 	public GameObject m_root;
 
@@ -55,6 +56,8 @@ public class BannerPopup : MonoBehaviour
 				m_onCloseBannerPopup();
 			}
 		}
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public void Show(string headerText, string bannerText, BannerManager.DelOnCloseBanner onCloseCallback = null)
@@ -89,6 +92,8 @@ public class BannerPopup : MonoBehaviour
 			m_dismissButton.AddEventListener(UIEventType.RELEASE, CloseBannerPopup);
 		}
 		m_showSpellComplete = false;
+
+		ReadPopup();
 	}
 
 	private void FadeEffectsIn()
@@ -185,4 +190,46 @@ public class BannerPopup : MonoBehaviour
 			m_HideSpell.Activate();
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Popup", true);
+
+		if (m_header != null && m_header.Text != null)
+		{
+			AccessibilityMgr.Output(m_header.Text);
+		}
+
+		if (m_text != null && m_text.Text != null)
+		{
+			AccessibilityMgr.Output(m_text.Text);
+		}
+
+		AccessibilityMgr.Output(GetAccessibleHelp());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (m_dismissButton != null)
+            {
+                m_dismissButton?.TriggerRelease();
+            }
+			else
+            {
+				AccessibleInputMgr.ClickCenterOfScreen();
+            }
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BasicPopup.cs b/Decompiled/Assembly-CSharp/BasicPopup.cs
index 8a8d3a7..4e1e7ee 100644
--- a/Decompiled/Assembly-CSharp/BasicPopup.cs
+++ b/Decompiled/Assembly-CSharp/BasicPopup.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections.Generic;
 using UnityEngine;
 
@@ -27,6 +28,13 @@ public class BasicPopup : DialogBase
 		public bool m_disableBnetBar;
 
 		public bool m_blurWhenShown;
+
+		public string m_accessibleText;
+
+		public PopupInfo(string accessibleText)
+        {
+			m_accessibleText = accessibleText;
+        }
 	}
 
 	public UIBButton m_cancelButton;
@@ -45,6 +53,10 @@ public class BasicPopup : DialogBase
 
 	protected PopupInfo m_popupInfo;
 
+	#region Accessibility
+	private string m_accessibleText;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -101,6 +113,8 @@ public class BasicPopup : DialogBase
 		{
 			SoundManager.Get().LoadAndPlay(m_showAnimationSound);
 		}
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -126,7 +140,7 @@ public class BasicPopup : DialogBase
 	{
 		if (m_popupInfo == null)
 		{
-			m_popupInfo = new PopupInfo();
+			m_popupInfo = new PopupInfo("Unimplemented popup. Please raise an issue");
 		}
 		if (m_headerText != null && m_popupInfo.m_headerText != null)
 		{
@@ -136,6 +150,8 @@ public class BasicPopup : DialogBase
 		{
 			m_bodyText.Text = m_popupInfo.m_bodyText;
 		}
+
+		m_accessibleText = m_popupInfo.m_accessibleText;
 	}
 
 	private void ButtonPress(Response response)
@@ -146,4 +162,41 @@ public class BasicPopup : DialogBase
 		}
 		Hide();
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    protected void ReadPopup()
+    {
+		m_accessibleMenu = new AccessibleMenu("Options", null, true);
+
+		if (m_customButton != null)
+        {
+			m_accessibleMenu.AddOption(m_customButton.GetText(), () => m_customButton.TriggerRelease());
+        }
+
+		if (m_cancelButton != null)
+        {
+			m_accessibleMenu.AddOption(m_cancelButton.GetText(), () => m_cancelButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Popup", true);
+		AccessibilityMgr.Output(m_accessibleText);
+
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        m_accessibleMenu.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.MENU_HELP(false);
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs b/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
index 6dc59e8..20c43ae 100644
--- a/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
+++ b/Decompiled/Assembly-CSharp/BoH_Jaina_06.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 {
@@ -296,7 +297,18 @@ public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 		switch (turn)
 		{
 		case 1:
-			yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
+				// TODO: Consider doing something generic on first turn start of PowerTaskListDescriber
+				if (AccessibilityMgr.IsAccessibilityEnabled())
+                {
+					var gatesOfTheramore = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCards();
+					var startingCardsInBattlefield = AccessibleSpeechUtils.GetNames(gatesOfTheramore);
+
+					if (gatesOfTheramore.Count > 0)
+                    {
+						AccessibilityMgr.Output($"Your battlefield starts with {startingCardsInBattlefield}");
+                    }
+                }
+                yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
 			yield return PlayLineAlways(enemyActor, VO_Story_Hero_Garrosh_Male_Orc_Story_Jaina_Mission6ExchangeA_01);
 			break;
 		case 5:
diff --git a/Decompiled/Assembly-CSharp/BookTab.cs b/Decompiled/Assembly-CSharp/BookTab.cs
index a39c1b9..8143436 100644
--- a/Decompiled/Assembly-CSharp/BookTab.cs
+++ b/Decompiled/Assembly-CSharp/BookTab.cs
@@ -92,6 +92,11 @@ public class BookTab : PegUIElement
 		return m_isVisible;
 	}
 
+	public bool IsSelected()
+	{
+		return m_selected;
+	}
+
 	public void SetTargetVisibility(bool visible)
 	{
 		m_shouldBeVisible = visible;
diff --git a/Decompiled/Assembly-CSharp/Box.cs b/Decompiled/Assembly-CSharp/Box.cs
index 92b5dff..f15abf5 100644
--- a/Decompiled/Assembly-CSharp/Box.cs
+++ b/Decompiled/Assembly-CSharp/Box.cs
@@ -1186,7 +1186,7 @@ public class Box : MonoBehaviour
 		else if (mode == SceneMgr.Mode.TOURNAMENT && flag)
 		{
 			ChangeState(State.SET_ROTATION_OPEN);
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 			m_transitioningToSceneMode = true;
 		}
 		else if (!SceneMgr.Get().IsDoingSceneDrivenTransition() && ChangeState(state))
@@ -2758,8 +2758,8 @@ public class Box : MonoBehaviour
 			m_setRotationDisk.SetActive(value: true);
 			return;
 		}
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
-		popupInfo.m_blurWhenShown = true;
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo("Core set is now available! You get 235 free cards. 25 free legendary cards and 31 new cards for deck-building. Basic and Classic cards are now Wild");
+        popupInfo.m_blurWhenShown = true;
 		popupInfo.m_prefabAssetRefs.Add("CoreSetIntroPopup.prefab:32fcd0d9c45bc9449af825460fac647b");
 		DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
 		m_setRotationDisk = AssetLoader.Get().InstantiatePrefab("TheBox_CenterDisk_SetRotation.prefab:6f2fa714f0d129e4197fd2922f544816");
@@ -2779,7 +2779,12 @@ public class Box : MonoBehaviour
 		RegisterButtonEvents(m_setRotationButton);
 	}
 
-	private IEnumerator SetRotationOpen_ChangeState()
+    public void ShowGameModesDialog()
+    {
+        DialogManager.Get().ShowGameModesPopup(OnForgeButtonPressed, OnBaconButtonPressed, OnPvPDungeonRunButtonPressed);
+    }
+
+    private IEnumerator SetRotationOpen_ChangeState()
 	{
 		BoxStateConfig boxStateConfig = m_stateConfigs[12];
 		if (!boxStateConfig.m_logoState.m_ignore)
@@ -2822,7 +2827,7 @@ public class Box : MonoBehaviour
 	private IEnumerator SetRotation_StartSetRotationIntro()
 	{
 		ResetSetRotationPopupProgress();
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.SET_ROTATION_INTRO);
 		NotificationManager.Get().DestroyAllPopUps();
 		PopupDisplayManager.Get().ReadyToShowPopups();
 		yield return StartCoroutine(PopupDisplayManager.Get().WaitForAllPopups());
@@ -3001,11 +3006,6 @@ public class Box : MonoBehaviour
 		m_isSpecialEventActive = true;
 	}
 
-	public void ShowGameModesDialog()
-	{
-		DialogManager.Get().ShowGameModesPopup(OnForgeButtonPressed, OnBaconButtonPressed, OnPvPDungeonRunButtonPressed);
-	}
-
 	private void InitializeComponents()
 	{
 		m_Logo.SetParent(this);
diff --git a/Decompiled/Assembly-CSharp/ButtonListMenu.cs b/Decompiled/Assembly-CSharp/ButtonListMenu.cs
index 802a573..e462f80 100644
--- a/Decompiled/Assembly-CSharp/ButtonListMenu.cs
+++ b/Decompiled/Assembly-CSharp/ButtonListMenu.cs
@@ -9,7 +9,7 @@ public abstract class ButtonListMenu : MonoBehaviour
 
 	private bool m_isShown;
 
-	private List<UIBButton> m_allButtons = new List<UIBButton>();
+	protected List<UIBButton> m_allButtons = new List<UIBButton>();
 
 	private List<GameObject> m_horizontalDividers = new List<GameObject>();
 
diff --git a/Decompiled/Assembly-CSharp/Card.cs b/Decompiled/Assembly-CSharp/Card.cs
index 2844a24..80af278 100644
--- a/Decompiled/Assembly-CSharp/Card.cs
+++ b/Decompiled/Assembly-CSharp/Card.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Hearthstone;
 using PegasusGame;
 using UnityEngine;
@@ -5186,6 +5187,7 @@ public class Card : MonoBehaviour
 		m_actor.TurnOffCollider();
 		GameState.Get().GetFriendlySidePlayer().GetDeckZone()
 			.UpdateLayout();
+		AccessibleGameplay.Get().OnDrawCard(this);
 		while (iTween.Count(base.gameObject) > 0)
 		{
 			yield return null;
@@ -5263,6 +5265,7 @@ public class Card : MonoBehaviour
 	private IEnumerator DrawUnknownOpponentCard(ZoneHand handZone)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_and_add_to_hand_opp_1.prefab:5a05fbb2c5833a94182e1b454647d5c8", base.gameObject);
+		AccessibleGameplay.Get().OnDrawUnknownOpponentCard(this);
 		base.gameObject.transform.rotation = IN_DECK_HIDDEN_ROTATION;
 		DetermineIfOverrideDrawTimeScale();
 		Transform transform = Board.Get().FindBone("OpponentDrawCard");
@@ -5340,6 +5343,7 @@ public class Card : MonoBehaviour
 	private IEnumerator RevealDrawnOpponentCard(string handActorPath, Actor handActor, ZoneHand handZone)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_1.prefab:19dd221ebfed9754e85ef1f104e0fddb", base.gameObject);
+		AccessibleGameplay.Get().OnRevealDrawnOpponentCard(this);
 		handActor.transform.parent = m_actor.transform.parent;
 		TransformUtil.CopyLocal(handActor, m_actor);
 		m_actor.Hide();
@@ -6042,6 +6046,7 @@ public class Card : MonoBehaviour
 	public IEnumerator AnimatePlayToDeck(GameObject mover, ZoneDeck deckZone, bool hideBackSide = false, float timeScale = 1f)
 	{
 		SoundManager.Get().LoadAndPlay("MinionToDeck_transition.prefab:8063f1b133f28e34aaeade8fcabe250c");
+		AccessibleGameplay.Get().OnCardToDeck(this);
 		Vector3 vector = deckZone.GetThicknessForLayout().GetMeshRenderer().bounds.center + IN_DECK_OFFSET;
 		Vector3 vector2 = vector + ABOVE_DECK_OFFSET;
 		Vector3 vector3 = new Vector3(0f, IN_DECK_ANGLES.y, 0f);
diff --git a/Decompiled/Assembly-CSharp/CardListPanel.cs b/Decompiled/Assembly-CSharp/CardListPanel.cs
index 2670877..b20f23f 100644
--- a/Decompiled/Assembly-CSharp/CardListPanel.cs
+++ b/Decompiled/Assembly-CSharp/CardListPanel.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CardListPanel : MonoBehaviour
@@ -18,11 +19,11 @@ public class CardListPanel : MonoBehaviour
 
 	private UIBButton m_rightArrow;
 
-	private const int MAX_CARDS_PER_PAGE = 3;
+	internal const int MAX_CARDS_PER_PAGE = 3;
 
 	private int m_numPages = 1;
 
-	private int m_pageNum;
+	internal int m_pageNum;
 
 	private List<CollectibleCard> m_cards = new List<CollectibleCard>();
 
@@ -55,7 +56,7 @@ public class CardListPanel : MonoBehaviour
 			m_cards = cards;
 		}
 		SetupPagingArrows();
-		m_numPages = (m_cards.Count + 3 - 1) / 3;
+		m_numPages = (m_cards.Count + MAX_CARDS_PER_PAGE - 1) / MAX_CARDS_PER_PAGE;
 		ShowPage(0);
 	}
 
@@ -90,8 +91,8 @@ public class CardListPanel : MonoBehaviour
 		}
 		m_cardActors.Clear();
 		list.Clear();
-		int num = m_pageNum * 3;
-		int num2 = Mathf.Min(3, m_cards.Count - num);
+		int num = m_pageNum * MAX_CARDS_PER_PAGE;
+		int num2 = Mathf.Min(MAX_CARDS_PER_PAGE, m_cards.Count - num);
 		for (int i = 0; i < num2; i++)
 		{
 			CollectibleCard collectibleCard = m_cards[num + i];
@@ -154,7 +155,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void UpdateCardPositions()
+    private void UpdateCardPositions()
 	{
 		int count = m_cardActors.Count;
 		for (int i = 0; i < count; i++)
@@ -169,7 +170,7 @@ public class CardListPanel : MonoBehaviour
 
 	private void SetupPagingArrows()
 	{
-		if (m_cards.Count > 3)
+		if (m_cards.Count > MAX_CARDS_PER_PAGE)
 		{
 			m_leftArrowNested.gameObject.SetActive(value: true);
 			m_rightArrowNested.gameObject.SetActive(value: true);
@@ -200,7 +201,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void TurnPage(bool right)
+	internal void TurnPage(bool right)
 	{
 		HighlightState componentInChildren = m_rightArrow.GetComponentInChildren<HighlightState>();
 		if ((bool)componentInChildren)
diff --git a/Decompiled/Assembly-CSharp/CardListPopup.cs b/Decompiled/Assembly-CSharp/CardListPopup.cs
index 7a9ad4a..f453d68 100644
--- a/Decompiled/Assembly-CSharp/CardListPopup.cs
+++ b/Decompiled/Assembly-CSharp/CardListPopup.cs
@@ -1,4 +1,7 @@
+using System;
 using System.Collections.Generic;
+using Accessibility;
+using UnityEngine;
 
 [CustomEditClass]
 public class CardListPopup : DialogBase
@@ -31,7 +34,12 @@ public class CardListPopup : DialogBase
 
 	private Info m_info = new Info();
 
-	protected override void Awake()
+    #region Accessibility
+    private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleCards;
+	private CardListPanel m_curCardsContainer;
+    #endregion
+
+    protected override void Awake()
 	{
 		base.Awake();
 		m_okayButton.AddEventListener(UIEventType.RELEASE, delegate
@@ -66,18 +74,80 @@ public class CardListPopup : DialogBase
 		{
 			m_CardsContainer_MultiLineDescription.Show(m_info.m_cards);
 			m_descriptionMultiLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_MultiLineDescription;
 		}
 		else
 		{
 			m_CardsContainer_SingleLineDescription.Show(m_info.m_cards);
 			m_descriptionSingleLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_SingleLineDescription;
 		}
 		UniversalInputManager.Get().SetSystemDialogActive(active: true);
-	}
 
-	public override void Hide()
+		ReadPopup();
+    }
+
+    public override void Hide()
 	{
 		base.Hide();
 		DialogBase.EndBlur();
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+        var accessibleCards = new List<AccessibleCollectibleCard>();
+        foreach (var card in m_info.m_cards)
+        {
+            accessibleCards.Add(new AccessibleCollectibleCard(card, false));
+        }
+
+        m_accessibleCards = new AccessibleListOfItems<AccessibleCollectibleCard>(accessibleCards);
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output("Popup", true);
+        AccessibilityMgr.Output($"{m_info.m_description}");
+		m_accessibleCards.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+            m_okayButton.TriggerRelease();
+        }
+        else
+        {
+			if (m_accessibleCards.HandleAccessibleInput())
+			{
+				ChangePageIfNeeded();
+			}
+        }
+    }
+
+    private void ChangePageIfNeeded()
+    {
+		int curCardIndex = m_accessibleCards.GetItemBeingReadIndex();
+		int cardsPerPage = CardListPanel.MAX_CARDS_PER_PAGE;
+		int curPage = m_curCardsContainer.m_pageNum;
+
+		int realPage = curCardIndex / cardsPerPage;
+
+		if (curPage < realPage)
+        {
+            m_curCardsContainer.TurnPage(true);
+        }
+		else if (curPage > realPage)
+        {
+			m_curCardsContainer.TurnPage(false);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+        return $"Use the arrow keys to read the cards. Press {AccessibleKey.CONFIRM} once you're done";
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs b/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
index 745be4f..a04faea 100644
--- a/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
+++ b/Decompiled/Assembly-CSharp/CastSpellCardFromHandSepll.cs
@@ -70,7 +70,7 @@ public class CastSpellCardFromHandSepll : Spell
 		targetCard.HideCard();
 		Entity entity = targetCard.GetEntity();
 		UpdateTags(entity);
-		HistoryManager.Get().CreatePlayedBigCard(entity, delegate
+		HistoryManager.Get().CreatePlayedBigCard(m_taskList, entity, delegate
 		{
 		}, delegate
 		{
@@ -126,7 +126,7 @@ public class CastSpellCardFromHandSepll : Spell
 		iTween.RotateTo(targetCard.gameObject, transform.rotation.eulerAngles, m_BigCardDisplayTime);
 		iTween.ScaleTo(targetCard.gameObject, new Vector3(1f, 1f, 1f), m_BigCardDisplayTime);
 		SoundManager.Get().LoadAndPlay("play_card_from_hand_1.prefab:ac4be75e319a97947a68308a08e54e88");
-		yield return new WaitForSeconds(m_BigCardDisplayTime);
+        yield return new WaitForSeconds(m_BigCardDisplayTime);
 	}
 
 	private IEnumerator PlayPowerUpSpell()
diff --git a/Decompiled/Assembly-CSharp/ChatMgr.cs b/Decompiled/Assembly-CSharp/ChatMgr.cs
index 248cdeb..42f8c52 100644
--- a/Decompiled/Assembly-CSharp/ChatMgr.cs
+++ b/Decompiled/Assembly-CSharp/ChatMgr.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using bgs;
 using Hearthstone;
 using UnityEngine;
@@ -671,6 +672,11 @@ public class ChatMgr : MonoBehaviour
 
 	public void HandleGUIInput()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Chat is not implemented yet
+			return;
+        }
 		if (!m_fatalErrorMgr.HasError() && !IsMobilePlatform())
 		{
 			HandleGUIInputForQuickChat();
diff --git a/Decompiled/Assembly-CSharp/CheatMgr.cs b/Decompiled/Assembly-CSharp/CheatMgr.cs
index be1e317..318e822 100644
--- a/Decompiled/Assembly-CSharp/CheatMgr.cs
+++ b/Decompiled/Assembly-CSharp/CheatMgr.cs
@@ -121,7 +121,7 @@ public class CheatMgr : IService
 		{
 			return false;
 		}
-		if (!InputCollection.GetKeyUp(KeyCode.BackQuote))
+		if (!InputCollection.GetKeyUp(KeyCode.Backslash))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/Cheats.cs b/Decompiled/Assembly-CSharp/Cheats.cs
index 71b3d3d..50c4e07 100644
--- a/Decompiled/Assembly-CSharp/Cheats.cs
+++ b/Decompiled/Assembly-CSharp/Cheats.cs
@@ -383,6 +383,24 @@ public class Cheats : IService
 		CheatMgr cheatMgr = serviceLocator.Get<CheatMgr>();
 		if (HearthstoneApplication.IsInternal())
 		{
+			cheatMgr.RegisterCategory("HSA changed cards");
+			cheatMgr.RegisterCheatHandler("hsashowchangedcardspopup", OnProcessCheat_hsashowchangedcardspopup, "Show 'these cards have changed' popup", "<command name>", "");
+			cheatMgr.RegisterCheatHandler("hsashowaddedcardspopup", OnProcessCheat_hsashowaddedcardspopup, "Show 'these cards were added' popup", "<command name>", "");
+			cheatMgr.RegisterCategory("HSA reconnect");
+			cheatMgr.RegisterCheatHandler("hsashowreconnecthelperdialog", OnProcessCheat_hsashowreconnecthelperdialog, "Show the recconect helper dialog", "<command> [fullResetRequired] [wasKickedForInactivity] [updateRequired]", "");
+			cheatMgr.RegisterCategory("HSA Quests");
+			cheatMgr.RegisterCheatHandler("hsashowquesttoastmount", OnProcessCheat_hsashowquesttoastmount, "Show a quest toast which rewards a mount", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowquesttoastminiset", OnProcessCheat_hsashowquesttoastminiset, "Show a quest toast which rewards a mini set", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowwelcomequests", OnProcessCheat_hsashowwelcomequests, "Show welcome quests", "<command>", "");
+			cheatMgr.RegisterCategory("HSA Returning player");
+			cheatMgr.RegisterCheatHandler("hsashowreturningplayerbanner", OnProcessCheat_hsashowreturningplayerbanner, "Show returning player banner", "<command>", "");
+			cheatMgr.RegisterCategory("HSA Basic popups");
+			cheatMgr.RegisterCheatHandler("hsashowstandardcomingsoonpopup", OnProcessCheat_hsashowstandardcomingsoonpopup, "Show Standard coming soon popup", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowcoresetavailablepopup", OnProcessCheat_hsashowcoresetavailablepopup, "Show core set available popup", "<command>", "");
+			cheatMgr.RegisterCheatHandler("hsashowwhizbangpopup", OnProcessCheat_hsashowwhizbangpopup, "Show Whizbang popup", "<command>", "");
+			cheatMgr.RegisterCategory("HSA others");
+			cheatMgr.RegisterCheatHandler("hsashowleaguepromotionrewards", OnProcessCheat_hsashowleaguepromotionrewards, "Show (legacy?) league promotion rewards", "<command> [rank]", "bronze10");
+			cheatMgr.RegisterCheatHandler("hsashowquestchestreward", OnProcessCheat_hsashowquestchestreward, "Show (legacy?) quest chest reward", "<command>", "");
 			cheatMgr.RegisterCategory("help");
 			cheatMgr.RegisterCheatHandler("help", OnProcessCheat_help, "Get help for a specific command or list of commands", "<command name>", "");
 			cheatMgr.RegisterCheatHandler("example", OnProcessCheat_example, "Run an example of this command if one exists", "<command name>");
@@ -472,7 +490,7 @@ public class Cheats : IService
 			cheatMgr.RegisterCheatHandler("iksaction", OnProcessCheat_iksgameaction, "Execute a game action as if IKS was clicked.");
 			cheatMgr.RegisterCheatHandler("iksseen", OnProcessCheat_iksseen, "Determine if an IKS message should be seen by its game action.");
 			cheatMgr.RegisterCategory("rank");
-			cheatMgr.RegisterCheatHandler("seasondialog", OnProcessCheat_seasondialog, "Open the season end dialog", "<rank> [standard|wild|classic]", "bronze5 wild");
+			cheatMgr.RegisterCheatHandler("seasondialog", OnProcessCheat_seasondialog, "Open the season end dialog", "<rank> [standard|wild|classic]", "bronze5 wild"); // BUG
 			cheatMgr.RegisterCheatHandler("rankrefresh", OnProcessCheat_rankrefresh, "Request medalinfo from server and show rankchange twoscoop after receiving it");
 			cheatMgr.RegisterCheatHandler("rankchange", OnProcessCheat_rankchange, "Show a fake rankchange twoscoop", "[rank] [up|down|win|loss] [wild] [winstreak] [chest]", "bronze5 up chest");
 			cheatMgr.RegisterCheatHandler("rankreward", OnProcessCheat_rankreward, "Show a fake RankedRewardDisplay for rank (or all ranks up to a rank)", "<rank> [standard|wild|classic|all]", "bronze5 all");
@@ -667,7 +685,7 @@ public class Cheats : IService
 		yield break;
 	}
 
-	public Type[] GetDependencies()
+    public Type[] GetDependencies()
 	{
 		return new Type[2]
 		{
@@ -3067,8 +3085,10 @@ public class Cheats : IService
 		}
 		if (flag)
 		{
-			achievement.SetDescription("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "");
-			achievement.SetName("Title Text", "");
+			//achievement.SetDescription("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", "");
+			achievement.SetName("Example quest", "");
+			achievement.SetDescription("Kill 5 minions", "");
+			achievement.SetRewards(list);
 			QuestToast.ShowQuestToast(UserAttentionBlocker.ALL, null, updateCacheValues: false, achievement);
 		}
 		else
@@ -3459,7 +3479,7 @@ public class Cheats : IService
 
 	private bool OnProcessCheat_setRotationRotatedBoostersPopup(string func, string[] args, string rawArgs)
 	{
-		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo("");
 		DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, info);
 		return true;
 	}
@@ -10213,7 +10233,7 @@ public class Cheats : IService
 
 	private bool OnProcessCheat_showtrackreward(string func, string[] args, string rawArgs)
 	{
-		string message = "showtrackreward <level> <forPaidTrack>";
+		string message = "showtrackreward <level> <forPaidTrack> <tracklevelOverrideForAccessibilityTesting>";
 		if (!int.TryParse(args[0], out var level))
 		{
 			UIStatus.Get().AddInfo(message);
@@ -10224,6 +10244,7 @@ public class Cheats : IService
 		{
 			bool.TryParse(args[1], out result);
 		}
+
 		RewardTrackLevelDbfRecord rewardTrackLevelDbfRecord = RewardTrackManager.Get().RewardTrackAsset.Levels.Where((RewardTrackLevelDbfRecord r) => r.Level == level).FirstOrDefault();
 		if (rewardTrackLevelDbfRecord == null)
 		{
@@ -10243,6 +10264,10 @@ public class Cheats : IService
 			}
 			return true;
 		}
+		if (args.Length > 2)
+        {
+			int.TryParse(args[2], out num);
+        }
 		RewardScroll.DebugShowFake(RewardTrackFactory.CreateRewardScrollDataModel(num, level));
 		return true;
 	}
@@ -10318,4 +10343,182 @@ public class Cheats : IService
 		}
 		return true;
 	}
+
+	#region Accessibility
+	private bool OnProcessCheat_hsashowchangedcardspopup(string func, string[] args, string rawArgs)
+	{
+        CheatMgr.Get().ProcessCheat("cardresetchange");
+        Vars.Key("Cheats.ShowFakeNerfedCards").Set(true.ToString(), false);
+        CheatMgr.Get().ProcessCheat("cardchangepopup false true 5");
+        return true;
+	}
+
+	private bool OnProcessCheat_hsashowaddedcardspopup(string func, string[] args, string rawArgs)
+	{
+        CheatMgr.Get().ProcessCheat("cardresetchange");
+        Vars.Key("Cheats.ShowFakeAddedCards").Set(true.ToString(), false);
+        CheatMgr.Get().ProcessCheat("cardchangepopup true true 5");
+        return true;
+	}
+	
+	private bool OnProcessCheat_hsashowreconnecthelperdialog(string func, string[] args, string rawArgs)
+	{
+		bool fullResetRequired = false;
+		bool wasKickedForInactivity = false;
+		bool updateRequired = false;
+
+		if (args.Length < 3)
+		{
+			UIStatus.Get().AddInfo("Usage: hsashowreconnecthelperdialog [fullResetRequired] [wasKickedForInactivity] [updateRequired] \nExample: hsashowreconnecthelperdialog true false true");
+			return false;
+		}
+
+		if (!bool.TryParse(args[0], out fullResetRequired))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[0]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (!bool.TryParse(args[1], out wasKickedForInactivity))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[1]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (!bool.TryParse(args[2], out updateRequired))
+		{
+			UIStatus.Get().AddError($"Unable to parse \"{args[2]}\". Please enter True or False.");
+			return false;
+		}
+
+		if (fullResetRequired)
+        {
+			ReconnectMgr.Get().FullResetRequired = true;
+        }
+
+		if (wasKickedForInactivity)
+        {
+			InactivePlayerKicker.Get().WasKickedForInactivity = true;
+        }
+
+		if (updateRequired)
+        {
+			ReconnectMgr.Get().UpdateRequired = true;
+        }
+
+        DialogManager.Get().ShowReconnectHelperDialog();
+        return true;
+	}
+
+    private bool OnProcessCheat_hsashowquesttoastmount(string func, string[] args, string rawArgs)
+    {
+        RewardData rwd = new MountRewardData(MountRewardData.MountType.WOW_HEARTHSTEED);
+        ShowQuestToast(rwd);
+		return true;
+    }
+
+    private bool OnProcessCheat_hsashowquesttoastminiset(string func, string[] args, string rawArgs)
+    {
+        RewardData rwd = new MiniSetRewardData(1);
+        ShowQuestToast(rwd);
+		return true;
+    }
+
+    private void ShowQuestToast(RewardData rwd)
+    {
+        QuestToast.ShowGenericRewardQuestToast(UserAttentionBlocker.NONE, null, rwd, "Example quest", "Kill 5 minions");
+    }
+
+    private bool OnProcessCheat_hsashowwelcomequests(string func, string[] args, string rawArgs)
+    {
+        Achievement achievement = AchieveManager.Get().GetAchievement(58);
+        WelcomeQuests.ShowSpecialQuest(UserAttentionBlocker.ALL, achievement);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowreturningplayerbanner(string func, string[] args, string rawArgs)
+    {
+        BannerManager.Get().ShowBanner("WoodenSign_Paint_Welcome_Back.prefab:4cb64d2b8c67feb45b4e17042d58f1ba", null, GameStrings.Get("GLUE_RETURNING_PLAYER_WELCOME_DESC"), delegate
+        {
+        });
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowstandardcomingsoonpopup(string func, string[] args, string rawArgs)
+    {
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo("Standard Format will update soon! You've been playing Standard, which allows only Basic, Classic, and the newest 2 years of sets. You will also gain access to Wild Format, which allows all cards!");
+        popupInfo.m_prefabAssetRefs.Add("RotationPopUp_ComingSoon.prefab:afff670e4001e11429c04d2e0c27dd76");
+        DialogManager.Get().ShowStandardComingSoonPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowcoresetavailablepopup(string func, string[] args, string rawArgs)
+    {
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo("Core set is now available! You get 235 free cards. 25 free legendary cards and 31 new cards for deck-building. Basic and Classic cards are now Wild");
+        popupInfo.m_blurWhenShown = true;
+        popupInfo.m_prefabAssetRefs.Add("CoreSetIntroPopup.prefab:32fcd0d9c45bc9449af825460fac647b");
+        DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowwhizbangpopup(string func, string[] args, string rawArgs)
+    {
+        var headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
+        var bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", "Mage", "My whizbang deck");
+        BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo($"{headerText} {bodyText}");
+        popupInfo.m_prefabAssetRefs.Add("WhizbangDialog_notification.prefab:89912cf72b2d5cf47820d2328de40f3f");
+        popupInfo.m_headerText = headerText;
+        popupInfo.m_bodyText = bodyText;
+        popupInfo.m_disableBnetBar = true;
+        DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.NONE, popupInfo);
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowleaguepromotionrewards(string func, string[] args, string rawArgs)
+    {
+		string cheatName = "bronze10";
+		if (args.Length != 0 && !string.IsNullOrEmpty(args[0]))
+		{
+			cheatName = args[0];
+		}
+
+        var leagueRecord = RankMgr.Get().GetLeagueRankRecordByCheatName(cheatName);
+		var leagueId = leagueRecord.LeagueId;
+
+		var rewards = GenerateFakeRewards();
+
+		var rewardBone = PopupDisplayManager.Get().GetChestRewardBoneForScene();
+
+        RewardUtils.ShowLeaguePromotionRewards(leagueId, rewards, rewardBone, () => DialogManager.Get().ShowRankedIntroPopUp(null));
+        return true;
+    }
+
+    private bool OnProcessCheat_hsashowquestchestreward(string func, string[] args, string rawArgs)
+    {
+		string questName = "Quest name";
+		string questDesc = "Kill 5 Murlocs";
+
+		var rewards = GenerateFakeRewards();
+
+		var rewardBone = PopupDisplayManager.Get().GetChestRewardBoneForScene(PopupDisplayManager.Get().QuestChestBones);
+
+        RewardUtils.ShowQuestChestReward(questName, questDesc, rewards, rewardBone, () => Accessibility.AccessibilityMgr.Output("Done"));
+        return true;
+    }
+
+    private List<RewardData> GenerateFakeRewards()
+    {
+        List<RewardData> list = new List<RewardData>();
+        GoldRewardData goldRewardData = new GoldRewardData();
+        goldRewardData.Amount = 327;
+        list.Add(goldRewardData);
+        list.Add(RewardUtils.CreateArcaneOrbRewardData(327));
+        ArcaneDustRewardData arcaneDustRewardData = new ArcaneDustRewardData();
+        arcaneDustRewardData.Amount = 327;
+        list.Add(arcaneDustRewardData);
+
+		return list;
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs b/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
index 43da71c..2d67097 100644
--- a/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
+++ b/Decompiled/Assembly-CSharp/ChestRewardDisplay.cs
@@ -1,8 +1,9 @@
 using System;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class ChestRewardDisplay : MonoBehaviour
+public class ChestRewardDisplay : MonoBehaviour, AccessibleUI
 {
 	public const string DEFAULT_PREFAB = "RewardChest_Lock.prefab:06ffa33e82036694e8cacb96aa7b48e8";
 
@@ -76,7 +77,12 @@ public class ChestRewardDisplay : MonoBehaviour
 		m_bannerUberText.Text = title;
 		m_descText.SetActive(value: true);
 		m_descText.GetComponent<UberText>().Text = desc;
-		ShowRewardChest();
+		ShowRewardChest(true);
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Rewards chest popup", true);
+		AccessibilityMgr.Output($"{title}; {desc}");
+		AccessibilityMgr.Output(GetAccessibleHelp());
 		return true;
 	}
 
@@ -85,7 +91,7 @@ public class ChestRewardDisplay : MonoBehaviour
 		m_doneCallbacks.Add(action);
 	}
 
-	private void ShowRewardChest()
+	private void ShowRewardChest(bool accessible)
 	{
 		if (FullScreenFXMgr.Get() != null)
 		{
@@ -98,17 +104,28 @@ public class ChestRewardDisplay : MonoBehaviour
 
 	private void ShowRewardChest_TavernBrawl()
 	{
-		ShowRewardChest();
+		ShowRewardChest(true);
 		string text = ((m_wins != 0) ? GameStrings.Format("GLUE_BRAWLISEUM_REWARDS_WIN_BANNER_TEXT", m_wins, m_wins) : GameStrings.Get("GLUE_BRAWLISEUM_NO_WINS_REWARD_PACK_TEXT"));
 		m_bannerUberText.Text = text;
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Rewards chest popup", true);
+		AccessibilityMgr.Output(text);
+		AccessibilityMgr.Output(GetAccessibleHelp());
 	}
 
 	private void ShowRewardChest_LeaguePromotion()
 	{
-		ShowRewardChest();
+		ShowRewardChest(true);
 		LeagueRankDbfRecord record = GameDbf.LeagueRank.GetRecord((LeagueRankDbfRecord r) => r.LeagueId == m_leagueId && r.StarLevel == 1);
 		m_bannerUberText.Text = record.RankName.GetString();
-		m_descText.GetComponent<UberText>().Text = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
+		var desc = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
+		m_descText.GetComponent<UberText>().Text = desc;
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Rewards chest popup", true);
+		AccessibilityMgr.Output($"{m_bannerUberText.Text}; {desc}");
+		AccessibilityMgr.Output(GetAccessibleHelp());
 	}
 
 	private void ShowRewardBags(UIEvent e)
@@ -157,6 +174,8 @@ public class ChestRewardDisplay : MonoBehaviour
 
 	public void OnSummonOutAnimationDone()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		foreach (Action doneCallback in m_doneCallbacks)
 		{
 			doneCallback?.Invoke();
@@ -173,4 +192,21 @@ public class ChestRewardDisplay : MonoBehaviour
 		}
 		return m_rewardBoxBone;
 	}
+
+    #region Accessibility
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_rewardChest.TriggerRelease();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return $"Press {AccessibleKey.CONFIRM} to open your rewards chest";
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs b/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
index a26503b..89953c5 100644
--- a/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
+++ b/Decompiled/Assembly-CSharp/ChoiceCardMgr.cs
@@ -1351,6 +1351,7 @@ public class ChoiceCardMgr : MonoBehaviour
 		ShowChoiceBanner(choiceState.m_cards);
 		ShowChoiceButtons();
 		HideEnlargedHand();
+		Accessibility.AccessibleGameplay.Get().OnChoice(choiceState.m_cards, m_choiceBanner, m_confirmChoiceButton);
 	}
 
 	private void HideChoiceUI()
@@ -1625,6 +1626,7 @@ public class ChoiceCardMgr : MonoBehaviour
 			}
 		}
 		HideEnlargedHand();
+		Accessibility.AccessibleGameplay.Get().OnSubOption(m_subOptionState.m_cards);
 	}
 
 	private void HideSubOptions(Entity chosenEntity = null)
diff --git a/Decompiled/Assembly-CSharp/ClientOption.cs b/Decompiled/Assembly-CSharp/ClientOption.cs
index d895a3e..8c6cb24 100644
--- a/Decompiled/Assembly-CSharp/ClientOption.cs
+++ b/Decompiled/Assembly-CSharp/ClientOption.cs
@@ -121,5 +121,9 @@ public enum ClientOption
 	DEBUG_SHOW_PRODUCT_IDS,
 	APKINSTALL_START,
 	APKINSTALL_FAILURE_REPORTED,
-	INTERNET_UNREACHABLE
+	INTERNET_UNREACHABLE,
+
+	#region Accessibility
+	ACCESSIBILITY_GAME_SPEED
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionDeckTray.cs b/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
index f34b281..8eef65d 100644
--- a/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
+++ b/Decompiled/Assembly-CSharp/CollectionDeckTray.cs
@@ -634,7 +634,7 @@ public class CollectionDeckTray : EditableDeckTray
 		}
 		else
 		{
-			if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
+			if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
 			{
 				Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
 				Options.Get().SetLong(Option.LAST_CUSTOM_DECK_CHOSEN, editedDeck.ID);
@@ -643,7 +643,7 @@ public class CollectionDeckTray : EditableDeckTray
 				Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, relativePosition, NotificationManager.NOTIFICATITON_WORLD_SCALE, GameStrings.Get("GLUE_COLLECTION_TUTORIAL16"), convertLegacyPosition: false);
 				notification.ShowPopUpArrow(Notification.PopUpArrowDirection.RightDown);
 				notification.PulseReminderEveryXSeconds(3f);
-				UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+				UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 				m_doneButton.GetComponentInChildren<HighlightState>().ChangeState(ActorStateType.HIGHLIGHT_PRIMARY_ACTIVE);
 			}
 			SaveCurrentDeckAndEnterDeckListMode();
diff --git a/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs b/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
index dc14880..f7388e4 100644
--- a/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManagerDisplay.cs
@@ -10,6 +10,7 @@ using Hearthstone;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerDisplay : CollectibleDisplay
@@ -191,7 +192,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		}
 		if (CollectionManager.Get().ShouldShowWildToStandardTutorial())
 		{
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
 		SetTavernBrawlTexturesIfNecessary();
 		SetDuelsTexturesIfNecessary();
@@ -229,7 +230,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			UnityEngine.Object.Destroy(m_deckTemplatePickerPhone.gameObject);
 			m_deckTemplatePickerPhone = null;
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
@@ -358,6 +359,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			m_cardActors = new List<CollectionCardActors>();
 			long arcaneDustBalance = NetCache.Get().GetArcaneDustBalance();
 			new Map<string, CollectionCardActors>();
+			//AccessibleCollectionManager.Get().OnPageChanged(cardsToDisplay);
 			foreach (CollectibleCard item in cardsToDisplay)
 			{
 				EntityDef entityDef = DefLoader.Get().GetEntityDef(item.CardId);
@@ -1647,7 +1649,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void ShowCraftingTipIfNeeded()
 	{
-		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
+		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_DISENCHANT_31"), "VO_INNKEEPER_DISENCHANT_31.prefab:4a0246488dc2d8146b1db88de5c603ff");
 			Options.Get().SetBool(Option.TIP_CRAFTING_UNLOCKED, val: true);
@@ -1729,7 +1731,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			yield return null;
 		}
-		if (CollectionManager.Get().ShouldShowWildToStandardTutorial() && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial"))
+		if (CollectionManager.Get().ShouldShowWildToStandardTutorial() && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial"))
 		{
 			int deckCount = CollectionManager.Get().GetDecks(DeckType.NORMAL_DECK).Count;
 			CollectionDeckTray deckTray = CollectionDeckTray.Get();
@@ -1756,7 +1758,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER_AFTER_PRACTICE, val: true);
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_WELCOME"), "VO_INNKEEPER_Male_Dwarf_CM_WELCOME_23.prefab:c8afdeaaf2189eb42aad9d29f6a97994");
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER, val: true);
@@ -1766,7 +1768,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			yield return new WaitForSeconds(1f);
 		}
-		if (!Options.Get().GetBool(Option.HAS_STARTED_A_DECK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK))
+		if (!Options.Get().GetBool(Option.HAS_STARTED_A_DECK, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK))
 		{
 			m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_editDeckTutorialBone.position, m_editDeckTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL07"));
 			m_deckHelpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
@@ -1799,7 +1801,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			}
 			else
 			{
-				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
+				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
 				{
 					return;
 				}
@@ -1985,7 +1987,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowConvertTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
 		{
 			m_showConvertTutorialCoroutine = ShowConvertTutorialCoroutine(blocker);
 			StartCoroutine(m_showConvertTutorialCoroutine);
@@ -2031,7 +2033,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowSetFilterTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
 		{
 			m_showSetFilterTutorialCoroutine = ShowSetFilterTutorialCoroutine(blocker);
 			StartCoroutine(m_showSetFilterTutorialCoroutine);
diff --git a/Decompiled/Assembly-CSharp/CollectionManagerScene.cs b/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
index 8af3e11..d8df4f8 100644
--- a/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
+++ b/Decompiled/Assembly-CSharp/CollectionManagerScene.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerScene : PegasusScene
@@ -13,6 +14,7 @@ public class CollectionManagerScene : PegasusScene
 	{
 		base.Awake();
 		AssetLoader.Get().InstantiatePrefab((string)m_CollectionManagerPrefab, OnUIScreenLoaded);
+		//AccessibleCollectionManager.Get().OnCollectionManagerOpened();
 	}
 
 	private void Update()
@@ -35,6 +37,7 @@ public class CollectionManagerScene : PegasusScene
 		CollectionManager.Get().GetCollectibleDisplay().Unload();
 		Network.Get().SendAckCardsSeen();
 		m_unloading = false;
+		//AccessibleCollectionManager.Get().OnCollectionManagerClosed();
 	}
 
 	private void OnUIScreenLoaded(AssetReference assetRef, GameObject go, object callbackData)
@@ -55,6 +58,7 @@ public class CollectionManagerScene : PegasusScene
 		{
 			yield return null;
 		}
+		//AccessibleCollectionManager.Get().OnCollectibleDisplayReady();
 		SceneMgr.Get().NotifySceneLoaded();
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/CollectionPageManager.cs b/Decompiled/Assembly-CSharp/CollectionPageManager.cs
index df0494e..9bd9fd7 100644
--- a/Decompiled/Assembly-CSharp/CollectionPageManager.cs
+++ b/Decompiled/Assembly-CSharp/CollectionPageManager.cs
@@ -152,7 +152,7 @@ public class CollectionPageManager : CollectiblePageManager
 
 	private static Map<TAG_CLASS, int> CLASS_TO_TAB_IDX = null;
 
-	private List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
+	internal List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
 
 	private MassDisenchant m_massDisenchant;
 
@@ -170,7 +170,7 @@ public class CollectionPageManager : CollectiblePageManager
 
 	private int m_numPageFlipsThisSession;
 
-	protected TAG_CLASS m_currentClassContext;
+	internal TAG_CLASS m_currentClassContext;
 
 	private CollectibleCard m_lastCardAnchor;
 
diff --git a/Decompiled/Assembly-CSharp/CraftingUI.cs b/Decompiled/Assembly-CSharp/CraftingUI.cs
index 3b6362e..229cecc 100644
--- a/Decompiled/Assembly-CSharp/CraftingUI.cs
+++ b/Decompiled/Assembly-CSharp/CraftingUI.cs
@@ -330,7 +330,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void ShowFirstTimeTips()
 	{
-		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber("CraftingUI.ShowFirstTimeTips"))
+		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.ShowFirstTimeTips"))
 		{
 			CreateDisenchantNotification();
 			CreateCraftNotification();
@@ -371,7 +371,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void UpdateTips()
 	{
-		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber("CraftingUI.UpdateTips"))
+		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.UpdateTips"))
 		{
 			HideTips();
 		}
diff --git a/Decompiled/Assembly-CSharp/CreateButton.cs b/Decompiled/Assembly-CSharp/CreateButton.cs
index 480d173..a8d8205 100644
--- a/Decompiled/Assembly-CSharp/CreateButton.cs
+++ b/Decompiled/Assembly-CSharp/CreateButton.cs
@@ -94,7 +94,7 @@ public class CreateButton : CraftingButton
 					Options.Get().SetBool(Option.HAS_SEEN_STANDARD_MODE_TUTORIAL, val: true);
 					Options.Get().SetInt(Option.SET_ROTATION_INTRO_PROGRESS, 6);
 					Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
-					UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+					UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 					Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_PLAY_SCREEN, val: true);
 					Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_CREATE_DECK, val: true);
 				}
diff --git a/Decompiled/Assembly-CSharp/CustomDeckPage.cs b/Decompiled/Assembly-CSharp/CustomDeckPage.cs
index d0d5d81..309a51b 100644
--- a/Decompiled/Assembly-CSharp/CustomDeckPage.cs
+++ b/Decompiled/Assembly-CSharp/CustomDeckPage.cs
@@ -34,7 +34,7 @@ public class CustomDeckPage : MonoBehaviour
 
 	protected int m_numCustomDecks;
 
-	protected List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
+	public List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
 
 	protected DeckButtonCallback m_deckButtonCallback;
 
diff --git a/Decompiled/Assembly-CSharp/DeckHelper.cs b/Decompiled/Assembly-CSharp/DeckHelper.cs
index 280f6a5..51f972c 100644
--- a/Decompiled/Assembly-CSharp/DeckHelper.cs
+++ b/Decompiled/Assembly-CSharp/DeckHelper.cs
@@ -345,7 +345,7 @@ public class DeckHelper : MonoBehaviour
 			Navigation.PushUnique(OnNavigateBack);
 			m_shown = true;
 			m_rootObject.SetActive(value: true);
-			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
+			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_ANNOUNCER_CM_HELP_DECK_50"), "VO_ANNOUNCER_CM_HELP_DECK_50.prefab:450881875d33d094e9a27f6260fb06d9");
 				Options.Get().SetBool(Option.HAS_SEEN_DECK_HELPER, val: true);
diff --git a/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
index 1b24368..266aeb8 100644
--- a/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/DeckPickerTrayDisplay.cs
@@ -753,7 +753,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 
 	public void ShowSwitchToWildTutorialIfNecessary()
 	{
-		if (!(m_switchFormatPopup != null) && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
+		if (!(m_switchFormatPopup != null) && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
 		{
 			if (Options.GetFormatType() == PegasusShared.FormatType.FT_WILD)
 			{
@@ -892,6 +892,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		InitDeckPages();
 		SetPageDecks(decks);
 		UpdateDeckVisuals();
+		Accessibility.AccessibleAdventureScene.Get().OnDeckPickerTrayDisplayReady(m_customPages);
 	}
 
 	private void UpdateDeckVisuals()
@@ -1016,13 +1017,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			m_switchFormatButton.SetVisualsFormatType(newVisualsFormatType);
 			if (SceneMgr.Get().GetMode() == SceneMgr.Mode.TOURNAMENT && SetRotationManager.HasSeenStandardModeTutorial())
 			{
-				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_WILD_GAME"), "VO_INNKEEPER_Male_Dwarf_SetRotation_35.prefab:db2f6e3818fa49b4d8423121eba762f6");
 					Options.Get().SetBool(Option.HAS_SEEN_WILD_MODE_VO, val: true);
 				}
-				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_CLASSIC_TAKES_YOU_BACK_ORIGINAL_HEARTHSTONE"), "VO_Innkeeper_Male_Dwarf_ClassicMode_06.prefab:f91da6f7e66fd754fb4e568d15d49116");
@@ -1688,7 +1689,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		if (m_showStandardComingSoonNotice)
 		{
-			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo("Standard Format will update soon! You've been playing Standard, which allows only Basic, Classic, and the newest 2 years of sets. You will also gain access to Wild Format, which allows all cards!");
 			popupInfo.m_responseCallback = OnStandardComingSoonResponse;
 			popupInfo.m_prefabAssetRefs.Add(STANDARD_COMING_SOON_POPUP_NAME);
 			DialogManager.Get().ShowStandardComingSoonPopup(UserAttentionBlocker.ALL_EXCEPT_FATAL_ERROR_SCENE, popupInfo);
@@ -1895,7 +1896,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		ShowPage(m_currentPageIndex - 1, skipTraySlidingAnimation);
 	}
 
-	private void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
+	internal void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
 	{
 		if (iTween.Count(m_randomDeckPickerTray) > 0 || pageNum < 0 || pageNum >= m_customPages.Count)
 		{
@@ -2394,7 +2395,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_heroActor.SetUnlit();
 		NetCache.HeroLevel heroLevel = ((!locked) ? GameUtils.GetHeroLevel(fullDef.EntityDef.GetClass()) : null);
 		int totalLevel = GameUtils.GetTotalHeroLevel() ?? 0;
-		m_xpBar.UpdateDisplay(heroLevel, totalLevel);
+		m_xpBar.UpdateDisplay(heroLevel, totalLevel, false);
 		string heroPowerCardIdFromHero = GameUtils.GetHeroPowerCardIdFromHero(fullDef.EntityDef.GetCardId());
 		if (!locked && ShouldShowHeroPower() && !string.IsNullOrEmpty(heroPowerCardIdFromHero))
 		{
@@ -3236,7 +3237,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		return GetDeckboxWithDeckID(deckId) != null;
 	}
 
-	private long GetLastChosenDeckId()
+	internal long GetLastChosenDeckId()
 	{
 		if (SceneMgr.Get().GetMode() != SceneMgr.Mode.FRIENDLY)
 		{
@@ -3440,7 +3441,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		bool result = false;
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
-		if (mode == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber("DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
+		if (mode == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, NotificationManager.DEFAULT_CHARACTER_POS, GameStrings.Get("VO_INNKEEPER_PLAY_STANDARD_TO_WILD"), "VO_INNKEEPER_Male_Dwarf_SetRotation_43.prefab:4b4ce858139927946905ec0d40d5b3c1");
 			Options.Get().SetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK, val: false);
@@ -3473,7 +3474,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		bool result = false;
 		if (num == 0 || num == 2 || num == 6)
 		{
-			if (UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
+			if (UserAttentionManager.CanShowAttentionGrabber(false, "DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
 			{
 				StartCoroutine(ShowWhizbangPopup(templateDeck));
 				num++;
@@ -3493,10 +3494,12 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		if (whizbangDeck != null)
 		{
 			yield return new WaitForSeconds(1f);
-			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+			var headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
+			var bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo($"{headerText} {bodyText}");
 			popupInfo.m_prefabAssetRefs.Add("WhizbangDialog_notification.prefab:89912cf72b2d5cf47820d2328de40f3f");
-			popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
-			popupInfo.m_bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			popupInfo.m_headerText = headerText;
+			popupInfo.m_bodyText = bodyText;
 			popupInfo.m_disableBnetBar = true;
 			DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.NONE, popupInfo);
 		}
@@ -3767,9 +3770,9 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	private IEnumerator ShowRotatedBoostersPopup(Action callbackOnHide = null)
 	{
 		yield return new WaitForSeconds(1f);
-		if (UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
 		{
-			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo("");
 			setRotationRotatedBoostersPopupInfo.m_onHiddenCallback = callbackOnHide;
 			DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, setRotationRotatedBoostersPopupInfo);
 			GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
@@ -3885,7 +3888,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			m_switchFormatButton.Enable();
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 	}
 
 	private bool ShouldShowStandardDeckVO(VisualsFormatType newVisualsFormatType)
@@ -3928,4 +3931,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			gameSaveDataManager.SaveSubkeys(list);
 		}
 	}
+
+    #region Accessibility
+
+    internal int GetCurrentPageIndex()
+    {
+		return m_currentPageIndex;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs b/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
index c663fd9..4132858 100644
--- a/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
+++ b/Decompiled/Assembly-CSharp/DeckTemplatePicker.cs
@@ -369,7 +369,7 @@ public class DeckTemplatePicker : MonoBehaviour
 	{
 		yield return new WaitForSeconds(0.5f);
 		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
+		if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
 		{
 			Transform deckTemplateTutorialWelcomeBone = collectionManagerDisplay.m_deckTemplateTutorialWelcomeBone;
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, deckTemplateTutorialWelcomeBone.localPosition, GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_WELCOME"), "VO_INNKEEPER_Male_Dwarf_RECIPE1_01.prefab:0261ef622a5e2b945a8f89e87cbe01a7", 3f);
diff --git a/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs b/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
index e9c4c5b..b1439a3 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayCardListContent.cs
@@ -543,7 +543,7 @@ public class DeckTrayCardListContent : DeckTrayContent
 			CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks(playSound: true);
 		}
 		DeckHelper.Get().OnCardAdded(editingDeck);
-		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber("DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
+		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber(false, "DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_PAGEFLIP_28"), "VO_INNKEEPER_CM_PAGEFLIP_28.prefab:47bb7bdb89ad93443ab7d031bbe666fb");
 			Options.Get().SetBool(Option.HAS_ADDED_CARDS_TO_DECK, val: true);
diff --git a/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs b/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
index 700f1af..a8057e4 100644
--- a/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
+++ b/Decompiled/Assembly-CSharp/DeckTrayDeckListContent.cs
@@ -46,7 +46,7 @@ public abstract class DeckTrayDeckListContent : DeckTrayContent
 
 	protected CollectionDeckInfo m_deckInfoTooltip;
 
-	protected List<TraySection> m_traySections = new List<TraySection>();
+	internal List<TraySection> m_traySections = new List<TraySection>();
 
 	protected TraySection m_editingTraySection;
 
diff --git a/Decompiled/Assembly-CSharp/DialogBase.cs b/Decompiled/Assembly-CSharp/DialogBase.cs
index 73d74f2..33bf5a8 100644
--- a/Decompiled/Assembly-CSharp/DialogBase.cs
+++ b/Decompiled/Assembly-CSharp/DialogBase.cs
@@ -1,8 +1,10 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
+using System;
 
-public class DialogBase : MonoBehaviour
+public abstract class DialogBase : MonoBehaviour, AccessibleUI
 {
 	public delegate void HideCallback(DialogBase dialog, object userData);
 
@@ -88,6 +90,7 @@ public class DialogBase : MonoBehaviour
 
 	public virtual void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
 		m_shown = false;
 		StartCoroutine(HideWhenAble());
 	}
@@ -217,4 +220,8 @@ public class DialogBase : MonoBehaviour
 		fullScreenFXMgr.StopVignette();
 		fullScreenFXMgr.StopBlur();
 	}
+
+    public abstract void HandleAccessibleInput();
+
+    public abstract string GetAccessibleHelp();
 }
diff --git a/Decompiled/Assembly-CSharp/DialogManager.cs b/Decompiled/Assembly-CSharp/DialogManager.cs
index ba7d98e..4557866 100644
--- a/Decompiled/Assembly-CSharp/DialogManager.cs
+++ b/Decompiled/Assembly-CSharp/DialogManager.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using bgs;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
@@ -45,7 +46,8 @@ public class DialogManager : MonoBehaviour
 		GAME_MODES,
 		BACON_CHALLENGE,
 		PRIVACY_POLICY,
-		GENERIC_BASIC_POPUP
+		GENERIC_BASIC_POPUP,
+		EOE
 	}
 
 	public class DialogRequest
@@ -206,7 +208,7 @@ public class DialogManager : MonoBehaviour
 	public bool AddToQueue(DialogRequest request)
 	{
 		UserAttentionBlocker attentionCategory = request?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
 		{
 			return false;
 		}
@@ -215,14 +217,14 @@ public class DialogManager : MonoBehaviour
 		return true;
 	}
 
-	private void UpdateQueue()
+    private void UpdateQueue()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
 		{
 			return;
 		}
 		DialogRequest dialogRequest = m_dialogRequests.Peek();
-		if (!UserAttentionManager.CanShowAttentionGrabber(dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
 		{
 			Processor.ScheduleCallback(0.5f, realTime: false, delegate
 			{
@@ -238,7 +240,7 @@ public class DialogManager : MonoBehaviour
 	public void ShowPopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (!UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (!UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			DialogRequest dialogRequest = new DialogRequest();
 			dialogRequest.m_type = DialogType.ALERT;
@@ -263,7 +265,7 @@ public class DialogManager : MonoBehaviour
 	public bool ShowUniquePopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			return false;
 		}
@@ -598,20 +600,20 @@ public class DialogManager : MonoBehaviour
 		AddToQueue(dialogRequest);
 	}
 
-	public void ShowGameModesPopup(UIEvent.Handler onArenaButtonReleased, UIEvent.Handler onBaconButtonReleased, UIEvent.Handler onPvPDungeonRunButtonReleased)
-	{
-		DialogRequest dialogRequest = new DialogRequest();
-		dialogRequest.m_type = DialogType.GAME_MODES;
-		GameModesPopup.Info info = (GameModesPopup.Info)(dialogRequest.m_info = new GameModesPopup.Info
-		{
-			m_onArenaButtonReleased = onArenaButtonReleased,
-			m_onBaconButtonReleased = onBaconButtonReleased
-		});
-		dialogRequest.m_callback = null;
-		AddToQueue(dialogRequest);
-	}
+    public void ShowGameModesPopup(UIEvent.Handler onArenaButtonReleased, UIEvent.Handler onBaconButtonReleased, UIEvent.Handler onPvPDungeonRunButtonReleased)
+    {
+        DialogRequest dialogRequest = new DialogRequest();
+        dialogRequest.m_type = DialogType.GAME_MODES;
+        GameModesPopup.Info info = (GameModesPopup.Info)(dialogRequest.m_info = new GameModesPopup.Info
+        {
+            m_onArenaButtonReleased = onArenaButtonReleased,
+            m_onBaconButtonReleased = onBaconButtonReleased
+        });
+        dialogRequest.m_callback = null;
+        AddToQueue(dialogRequest);
+    }
 
-	public void ShowClassUpcomingPopup()
+    public void ShowClassUpcomingPopup()
 	{
 		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 		popupInfo.m_showAlertIcon = false;
@@ -624,7 +626,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowBonusStarsPopup(RankedPlayDataModel dataModel, Action onHiddenCallback)
 	{
-		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo
+		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -641,7 +643,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowRankedIntroPopUp(Action onHiddenCallback)
 	{
-		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo
+		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -708,7 +710,7 @@ public class DialogManager : MonoBehaviour
 			return;
 		}
 		NetCache.ProfileNoticeMedal profileNoticeMedal = profileNotice as NetCache.ProfileNoticeMedal;
-		if (profileNoticeMedal == null || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("DialogManager.MaybeShowSeasonEndDialog"))
+		if (profileNoticeMedal == null || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "DialogManager.MaybeShowSeasonEndDialog"))
 		{
 			return;
 		}
@@ -835,7 +837,7 @@ public class DialogManager : MonoBehaviour
 	{
 		DialogRequest dialogRequest = ((m_dialogRequests.Count == 0) ? null : m_dialogRequests.Peek());
 		UserAttentionBlocker attentionCategory = dialogRequest?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
+		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
 		{
 			m_loadingDialog = false;
 			UnityEngine.Object.DestroyImmediate(go);
@@ -1123,14 +1125,14 @@ public class DialogManager : MonoBehaviour
 		loginPopupSequencePopup.LoadAssetsAndShowWhenReady();
 	}
 
-	private void ProcessGameModesPopupRequest(DialogRequest request, GameModesPopup gameModesPopup)
-	{
-		GameModesPopup.Info info = (GameModesPopup.Info)request.m_info;
-		gameModesPopup.SetInfo(info);
-		gameModesPopup.Show();
-	}
+    private void ProcessGameModesPopupRequest(DialogRequest request, GameModesPopup gameModesPopup)
+    {
+        GameModesPopup.Info info = (GameModesPopup.Info)request.m_info;
+        gameModesPopup.SetInfo(info);
+        gameModesPopup.Show();
+    }
 
-	private void ProcessPrivacyPolicyRequest(DialogRequest request, PrivacyPolicyPopup privacyPolicyPopup)
+    private void ProcessPrivacyPolicyRequest(DialogRequest request, PrivacyPolicyPopup privacyPolicyPopup)
 	{
 		privacyPolicyPopup.SetInfo((PrivacyPolicyPopup.Info)request.m_info);
 		privacyPolicyPopup.Show();
@@ -1184,4 +1186,16 @@ public class DialogManager : MonoBehaviour
 		AddToQueue(request);
 		m_waitingToShowSeasonEndDialog = false;
 	}
+
+    #region Accessibility
+    internal AccessibleUI GetCurrentDialog()
+    {
+		return m_currentDialog;
+    }
+
+	internal int GetNumQueuedDialogs()
+    {
+		return m_dialogRequests.Count;
+    }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/DraftDisplay.cs b/Decompiled/Assembly-CSharp/DraftDisplay.cs
index 846d55b..649565c 100644
--- a/Decompiled/Assembly-CSharp/DraftDisplay.cs
+++ b/Decompiled/Assembly-CSharp/DraftDisplay.cs
@@ -805,7 +805,7 @@ public class DraftDisplay : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
+		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
 		{
 			while (SceneMgr.Get().IsTransitioning())
 			{
@@ -1237,7 +1237,7 @@ public class DraftDisplay : MonoBehaviour
 
 	public void ShowInnkeeperInstructions()
 	{
-		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
+		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
 		{
 			if (!m_draftManager.HasSlotType(DraftSlotType.DRAFT_SLOT_HERO_POWER))
 			{
@@ -1245,13 +1245,13 @@ public class DraftDisplay : MonoBehaviour
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			}
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST2_20"), "VO_INNKEEPER_FORGE_INST2_20.prefab:242b6a30031534e47b1f8ddd69370eac", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, val: true);
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST3_21"), "VO_INNKEEPER_FORGE_INST3_21.prefab:06182dd3360965d4ea48952a6dd4a720", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, val: true);
@@ -1461,7 +1461,7 @@ public class DraftDisplay : MonoBehaviour
 			yield return new WaitForSeconds(0.3f);
 		}
 		ArenaTrayDisplay.Get().UpdateTray();
-		if (!UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowActiveDraftScreen"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowActiveDraftScreen"))
 		{
 			yield break;
 		}
@@ -1506,7 +1506,7 @@ public class DraftDisplay : MonoBehaviour
 		if (m_draftManager.ShouldActivateKey())
 		{
 			int maxWins = m_draftManager.GetMaxWins();
-			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
+			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_MAX_ARENA_WINS_04"), "VO_INNKEEPER_MAX_ARENA_WINS_04.prefab:cdf8e488f2d17604499f2cc358cb35f6");
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_MAX_WIN, val: true);
diff --git a/Decompiled/Assembly-CSharp/DraftManager.cs b/Decompiled/Assembly-CSharp/DraftManager.cs
index 8704e7d..c7db53a 100644
--- a/Decompiled/Assembly-CSharp/DraftManager.cs
+++ b/Decompiled/Assembly-CSharp/DraftManager.cs
@@ -434,11 +434,13 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo($"{headerText} {bodyText}");
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_responseUserData = CurrentSeasonId;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseCallback = delegate
@@ -468,11 +470,13 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo($"{headerText} {bodyText}");
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseUserData = m_currentSeason.NextSeasonId;
 		popupInfo.m_responseCallback = delegate
@@ -618,7 +622,7 @@ public class DraftManager : IService
 		sessionRecord.RunFinished = true;
 		sessionRecord.SessionRecordType = SessionRecordType.ARENA;
 		BnetPresenceMgr.Get().SetGameFieldBlob(22u, sessionRecord);
-		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
+		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_1ST_REWARD"), "VO_INNKEEPER_ARENA_1ST_REWARD.prefab:660e915849550ae4085735866647d529");
 			Options.Get().SetBool(Option.HAS_ACKED_ARENA_REWARDS, val: true);
@@ -681,7 +685,7 @@ public class DraftManager : IService
 		{
 			DemoMgr.Get().CreateDemoText(GameStrings.Get("GLUE_BLIZZCON2013_ARENA_5_WINS"), unclickable: false, shouldDoArenaInstruction: false);
 		}
-		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
+		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_3RD_LOSS"), "VO_INNKEEPER_ARENA_3RD_LOSS.prefab:6b2af024c9980d344a087295afb5e3df");
 			Options.Get().SetBool(Option.HAS_LOST_IN_ARENA, val: true);
diff --git a/Decompiled/Assembly-CSharp/EndGameScreen.cs b/Decompiled/Assembly-CSharp/EndGameScreen.cs
index 6411d13..a3c6e34 100644
--- a/Decompiled/Assembly-CSharp/EndGameScreen.cs
+++ b/Decompiled/Assembly-CSharp/EndGameScreen.cs
@@ -187,6 +187,8 @@ public class EndGameScreen : MonoBehaviour
 			}
 			ShowScoreScreen();
 			ShowStandardFlowIfReady();
+
+			Accessibility.AccessibleEndGameScreen.Get().OnShown(m_hitbox);
 		}
 	}
 
@@ -304,7 +306,7 @@ public class EndGameScreen : MonoBehaviour
 		{
 			return true;
 		}
-		if (ShowNextRewardTrackAutoClaimedReward())
+		if (ShowNextRewardTrackAutoClaimedReward()) // TODO
 		{
 			return true;
 		}
@@ -316,19 +318,19 @@ public class EndGameScreen : MonoBehaviour
 		{
 			return true;
 		}
-		if (ShowRankedCardBackProgress())
+		if (ShowRankedCardBackProgress()) // TODO Ranked only
 		{
 			return true;
 		}
-		if (ShowRankChange())
+		if (ShowRankChange()) // TODO Ranked only
 		{
 			return true;
 		}
-		if (ShowRankedRewards())
+		if (ShowRankedRewards()) // TODO Ranked only
 		{
 			return true;
 		}
-		if (ShowNextProgressionQuestReward())
+		if (ShowNextProgressionQuestReward()) // TODO
 		{
 			return true;
 		}
diff --git a/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs b/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
index bab7510..c1042e9 100644
--- a/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
+++ b/Decompiled/Assembly-CSharp/EndGameTwoScoop.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class EndGameTwoScoop : MonoBehaviour
 {
@@ -67,8 +68,9 @@ public class EndGameTwoScoop : MonoBehaviour
 			if (heroLevel == null)
 			{
 				HideXpBar();
-			}
-			else if (m_xpBarPrefab != null)
+                AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+            }
+            else if (m_xpBarPrefab != null)
 			{
 				m_xpBar = Object.Instantiate(m_xpBarPrefab);
 				m_xpBar.transform.parent = m_heroActor.transform;
@@ -79,9 +81,13 @@ public class EndGameTwoScoop : MonoBehaviour
 				m_xpBar.m_isAnimated = true;
 				m_xpBar.m_delay = BAR_ANIMATION_DELAY;
 				m_xpBar.m_levelUpCallback = PlayLevelUpEffect;
-				m_xpBar.UpdateDisplay(heroLevel, totalLevel);
+				m_xpBar.UpdateDisplay(heroLevel, totalLevel, true);
 			}
 		}
+		else
+        {
+			AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
 	}
 
 	public void Hide()
diff --git a/Decompiled/Assembly-CSharp/Entity.cs b/Decompiled/Assembly-CSharp/Entity.cs
index f8e9ddd..d634d4b 100644
--- a/Decompiled/Assembly-CSharp/Entity.cs
+++ b/Decompiled/Assembly-CSharp/Entity.cs
@@ -1578,6 +1578,22 @@ public class Entity : EntityBase
 		return entity;
 	}
 
+	public Entity CloneForAccessibility()
+	{
+		Entity entity = new Entity();
+		entity.m_duplicateForHistory = true;
+		entity.m_staticEntityDef = GetEntityDef();
+		entity.m_dynamicEntityDef = null;
+		entity.m_card = m_card;
+		entity.m_cardId = base.m_cardId;
+		entity.ReplaceTags(m_tags);
+		entity.m_subCardIDs = m_subCardIDs;
+		entity.m_loadState = m_loadState;
+		entity.m_displayedCreatorName = m_displayedCreatorName;
+		entity.m_enchantmentCreatorCardIDForPortrait = m_enchantmentCreatorCardIDForPortrait;
+		return entity;
+	}
+
 	public bool IsHistoryDupe()
 	{
 		return m_duplicateForHistory;
diff --git a/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs b/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
index 7a8babf..dbe25f6 100644
--- a/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
+++ b/Decompiled/Assembly-CSharp/ExistingAccountPopup.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using UnityEngine;
 
-public class ExistingAccountPopup : DialogBase
+public class ExistingAccountPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool hasAccount);
 
diff --git a/Decompiled/Assembly-CSharp/FatalErrorScene.cs b/Decompiled/Assembly-CSharp/FatalErrorScene.cs
index bf13053..b90b717 100644
--- a/Decompiled/Assembly-CSharp/FatalErrorScene.cs
+++ b/Decompiled/Assembly-CSharp/FatalErrorScene.cs
@@ -11,7 +11,7 @@ public class FatalErrorScene : PegasusScene
 		{
 			service.AppAbort();
 		}
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 		if (DialogManager.Get() != null)
 		{
 			DialogManager.Get().ClearAllImmediately();
@@ -34,7 +34,7 @@ public class FatalErrorScene : PegasusScene
 
 	public override void Unload()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StopBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 	}
 
 	private void OnFatalErrorScreenLoaded(AssetReference assetRef, GameObject go, object callbackData)
diff --git a/Decompiled/Assembly-CSharp/FatalErrorScreen.cs b/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
index 1fd2a6d..370c553 100644
--- a/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
+++ b/Decompiled/Assembly-CSharp/FatalErrorScreen.cs
@@ -4,8 +4,9 @@ using System.Collections.Generic;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
-public class FatalErrorScreen : MonoBehaviour
+public class FatalErrorScreen : MonoBehaviour, AccessibleScreen
 {
 	public UberText m_closedSignText;
 
@@ -126,6 +127,8 @@ public class FatalErrorScreen : MonoBehaviour
 		{
 			Processor.TerminateAllProcessing();
 		}
+
+		ReadScreen();
 	}
 
 	private void OnClick(UIEvent e)
@@ -165,4 +168,43 @@ public class FatalErrorScreen : MonoBehaviour
 		yield return new WaitForSeconds(waitDuration);
 		HearthstoneApplication.Get().Reset();
 	}
+
+    #region Accessibility
+
+	private void ReadScreen()
+    {
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output($"Fatal error screen");
+
+		if (m_closedSignTitle != null && m_closedSignTitle.Text != null)
+        {
+			AccessibilityMgr.Output(m_closedSignTitle.Text);
+        }
+
+		if (m_closedSignText != null && m_closedSignText.Text != null)
+        {
+			AccessibilityMgr.Output(m_closedSignText.Text);
+        }
+
+        AccessibilityMgr.Output(GetHelp());
+    }
+
+    public void HandleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			HearthstoneApplication.Get().Exit();
+        }
+    }
+
+    public string GetHelp()
+    {
+		return $"Press {AccessibleKey.CONFIRM} to exit";
+    }
+
+    public void OnGainedFocus()
+    {
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs b/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
index 1fd1226..d4b8178 100644
--- a/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideBrawlChoiceDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using PegasusShared;
 
-public class FiresideBrawlChoiceDialog : DialogBase
+public class FiresideBrawlChoiceDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(BrawlType choice);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs b/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
index e0b7eee..62167a6 100644
--- a/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideBrawlOkDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideBrawlOkDialog : DialogBase
+using Accessibility;
+
+public class FiresideBrawlOkDialog : InaccessibleDialogBase
 {
 	public UIBButton m_okBrawlButton;
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
index e92d6c0..e693e45 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringFindEventDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringFindEventDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringFindEventDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool search);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
index 213822a..4cdf1f6 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringInnkeeperSetupDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringInnkeeperSetupDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringInnkeeperSetupDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool search);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
index 5cad85e..4312358 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringJoinDialog.cs
@@ -1,4 +1,6 @@
-public class FiresideGatheringJoinDialog : DialogBase
+using Accessibility;
+
+public class FiresideGatheringJoinDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool joinFSG);
 
diff --git a/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs b/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
index 8aab063..1dbaa12 100644
--- a/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
+++ b/Decompiled/Assembly-CSharp/FiresideGatheringLocationHelperDialog.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using System;
 using System.Collections.Generic;
 using UnityEngine;
 
-public class FiresideGatheringLocationHelperDialog : DialogBase
+public class FiresideGatheringLocationHelperDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs b/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
index 293ae98..e092043 100644
--- a/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
+++ b/Decompiled/Assembly-CSharp/FixedRewardsMgr.cs
@@ -122,7 +122,7 @@ public class FixedRewardsMgr : IService
 
 	public bool ShowFixedRewards(UserAttentionBlocker blocker, HashSet<Achieve.RewardTiming> rewardVisualTimings, DelOnAllFixedRewardsShown allRewardsShownCallback, DelPositionNonToastReward positionNonToastRewardCallback)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs b/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
index 869b7b1..9adbc09 100644
--- a/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
+++ b/Decompiled/Assembly-CSharp/FreeArenaWinDialog.cs
@@ -1,7 +1,8 @@
+using Accessibility;
 using System.Collections;
 using UnityEngine;
 
-public class FreeArenaWinDialog : DialogBase
+public class FreeArenaWinDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs b/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
index c75b0e5..30bd62f 100644
--- a/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
+++ b/Decompiled/Assembly-CSharp/FriendChallengeMgr.cs
@@ -2235,7 +2235,13 @@ public class FriendChallengeMgr
 
 	private bool CanPromptReceivedChallenge()
 	{
-		bool flag = !UserAttentionManager.CanShowAttentionGrabber("FriendlyChallengeMgr.CanPromptReceivedChallenge");
+		if (Accessibility.AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Friends are not implemented yet
+            return false;
+        }
+
+        bool flag = !UserAttentionManager.CanShowAttentionGrabber(false, "FriendlyChallengeMgr.CanPromptReceivedChallenge");
 		if (!flag)
 		{
 			if (GameMgr.Get().IsFindingGame())
@@ -2654,7 +2660,7 @@ public class FriendChallengeMgr
 		}
 		if (availabilityBlockerReasons == AvailabilityBlockerReasons.NONE)
 		{
-			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: true);
+			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: true);
 		}
 		if (availabilityBlockerReasons != 0)
 		{
diff --git a/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs b/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
index 022dbc0..acb78fe 100644
--- a/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
+++ b/Decompiled/Assembly-CSharp/FriendListFSGFrame.cs
@@ -147,7 +147,7 @@ public class FriendListFSGFrame : FriendListUIElement
 	private bool ShouldEnableEnterButton()
 	{
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
-		if (UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: false) != 0 || mode == SceneMgr.Mode.FIRESIDE_GATHERING)
+		if (UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: false) != 0 || mode == SceneMgr.Mode.FIRESIDE_GATHERING)
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs b/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
index f080666..7765b04 100644
--- a/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
+++ b/Decompiled/Assembly-CSharp/FriendlyChallengeDialog.cs
@@ -1,5 +1,6 @@
 using System;
 using System.Collections;
+using Accessibility;
 using bgs;
 using Hearthstone.Core;
 using Hearthstone.DataModels;
@@ -9,7 +10,7 @@ using PegasusShared;
 using SpectatorProto;
 using UnityEngine;
 
-public class FriendlyChallengeDialog : DialogBase
+public class FriendlyChallengeDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool accept);
 
diff --git a/Decompiled/Assembly-CSharp/GAME_TAG.cs b/Decompiled/Assembly-CSharp/GAME_TAG.cs
index 7eaf652..ae301d1 100644
--- a/Decompiled/Assembly-CSharp/GAME_TAG.cs
+++ b/Decompiled/Assembly-CSharp/GAME_TAG.cs
@@ -557,5 +557,6 @@ public enum GAME_TAG
 	BACON_VERDANTSPHERES = 1598,
 	METAMORPHOSIS = 1644,
 	BACON_AVALANCHE = 1744,
-	BACON_COMEONECOMEALL = 1789
+	BACON_COMEONECOMEALL = 1789,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/GameMenu.cs b/Decompiled/Assembly-CSharp/GameMenu.cs
index d544e5f..283f2db 100644
--- a/Decompiled/Assembly-CSharp/GameMenu.cs
+++ b/Decompiled/Assembly-CSharp/GameMenu.cs
@@ -3,9 +3,11 @@ using bgs;
 using Hearthstone;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class GameMenu : ButtonListMenu, GameMenuInterface
+public class GameMenu : ButtonListMenu, GameMenuInterface, AccessibleUI
 {
 	[CustomEditField(Sections = "Template Items")]
 	public Vector3 m_ratingsObjectMinPadding = new Vector3(0f, 0f, -0.06f);
@@ -72,22 +74,22 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		ButtonListMenu.MakeButtonRed(m_endGameButton, m_redButtonMaterial);
 		m_leaveButton = CreateMenuButton("LeaveButton", "GLOBAL_LEAVE_SPECTATOR_MODE", LeaveButtonPressed);
 		m_restartButton = CreateMenuButton("RestartButton", "GLOBAL_RESTART", RestartButtonPressed);
-		if ((bool)HearthstoneApplication.CanQuitGame)
-		{
-			m_quitButton = CreateMenuButton("QuitButton", "GLOBAL_QUIT", QuitButtonPressed);
-		}
 		if (PlatformSettings.IsMobile())
 		{
 			m_loginButton = CreateMenuButton("LogoutButton", Network.ShouldBeConnectedToAurora() ? "GLOBAL_SWITCH_ACCOUNT" : "GLOBAL_LOGIN", LogoutButtonPressed);
 		}
+		if (m_menu.m_templateSignUpButton != null)
+		{
+			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+		}
 		m_optionsButton = CreateMenuButton("OptionsButton", "GLOBAL_OPTIONS", OptionsButtonPressed);
 		if (m_menu.m_templateDownloadButton != null)
 		{
 			m_downloadButton = CreateMenuButton("AssetDownloadButton", "GLOBAL_ASSET_DOWNLOAD", AssetDownloadButtonPressed, m_menu.m_templateDownloadButton);
 		}
-		if (m_menu.m_templateSignUpButton != null)
+		if ((bool)HearthstoneApplication.CanQuitGame)
 		{
-			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+			m_quitButton = CreateMenuButton("QuitButton", "GLOBAL_QUIT", QuitButtonPressed);
 		}
 		m_menu.m_headerText.Text = GameStrings.Get("GLOBAL_GAME_MENU");
 	}
@@ -160,6 +162,8 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		}
 		ShowLoginTooltipIfNeeded();
 		BnetBar.Get().m_menuButton.SetSelected(enable: true);
+
+		ReadMenu();
 	}
 
 	public override void Hide()
@@ -167,7 +171,13 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		base.Hide();
 		HideLoginTooltip();
 		BnetBar.Get().m_menuButton.SetSelected(enable: false);
-	}
+
+		if (!m_gameMenuBase.TransitioningToOptionsMenu)
+        {
+			// Don't hide when transitioning as we would just regain + lose focus on the main menu screen instantly (causing us to start reading it)
+            AccessibilityMgr.HideUI(this);
+        }
+    }
 
 	public void ShowLoginTooltipIfNeeded()
 	{
@@ -433,4 +443,41 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 			}
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadMenu()
+    {
+		m_accessibleMenu = new AccessibleMenu(AccessibleSpeech.GAME_MENU_TITLE, CloseMainMenu, true);
+
+		foreach (var btn in m_allButtons)
+        {
+			if (btn.gameObject.activeInHierarchy && btn.IsEnabled())
+            {
+                m_accessibleMenu.AddOption(btn.GetText(), () => btn.TriggerRelease());
+            }
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleMenu.StartReading();
+    }
+
+    public void HandleAccessibleInput()
+    {
+        m_accessibleMenu.HandleAccessibleInput();
+    }
+
+    private void CloseMainMenu()
+    {
+		BnetBar.Get().HideGameMenu();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.MENU_HELP(true);
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMenuBase.cs b/Decompiled/Assembly-CSharp/GameMenuBase.cs
index f436c1b..64fc087 100644
--- a/Decompiled/Assembly-CSharp/GameMenuBase.cs
+++ b/Decompiled/Assembly-CSharp/GameMenuBase.cs
@@ -18,7 +18,9 @@ public class GameMenuBase
 
 	public void ShowOptionsMenu()
 	{
-		if (m_hideCallback != null)
+        TransitioningToOptionsMenu = true;
+
+        if (m_hideCallback != null)
 		{
 			m_hideCallback();
 		}
@@ -35,9 +37,11 @@ public class GameMenuBase
 		{
 			SwitchToOptionsMenu();
 		}
-	}
 
-	public void DestroyOptionsMenu()
+        TransitioningToOptionsMenu = false;
+    }
+
+    public void DestroyOptionsMenu()
 	{
 		if (m_optionsMenu != null)
 		{
@@ -74,4 +78,8 @@ public class GameMenuBase
 			m_showCallback();
 		}
 	}
+
+	#region Accessibility
+	internal bool TransitioningToOptionsMenu { get; set; }
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/GameMgr.cs b/Decompiled/Assembly-CSharp/GameMgr.cs
index 4cf1246..25c725b 100644
--- a/Decompiled/Assembly-CSharp/GameMgr.cs
+++ b/Decompiled/Assembly-CSharp/GameMgr.cs
@@ -13,6 +13,7 @@ using PegasusShared;
 using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 public class GameMgr : IService
 {
@@ -664,22 +665,64 @@ public class GameMgr : IService
 		switch (m_missionId)
 		{
 		case 3:
-			gameEntity = new Tutorial_01();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_01();
+            }
+            else
+            {
+                gameEntity = new Tutorial_01();
+            }
 			break;
 		case 4:
-			gameEntity = new Tutorial_02();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_02();
+            }
+            else
+            {
+                gameEntity = new Tutorial_02();
+            }
 			break;
 		case 181:
-			gameEntity = new Tutorial_03();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_03();
+            }
+            else
+            {
+                gameEntity = new Tutorial_03();
+            }
 			break;
 		case 201:
-			gameEntity = new Tutorial_04();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_04();
+            }
+            else
+            {
+                gameEntity = new Tutorial_04();
+            }
 			break;
 		case 248:
-			gameEntity = new Tutorial_05();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_05();
+            }
+            else
+            {
+                gameEntity = new Tutorial_05();
+            }
 			break;
 		case 249:
-			gameEntity = new Tutorial_06();
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                gameEntity = new AccessibleTutorial_06();
+            }
+            else
+            {
+                gameEntity = new Tutorial_06();
+            }
 			break;
 		case 273:
 		case 300:
diff --git a/Decompiled/Assembly-CSharp/GameState.cs b/Decompiled/Assembly-CSharp/GameState.cs
index a0195a9..8c23099 100644
--- a/Decompiled/Assembly-CSharp/GameState.cs
+++ b/Decompiled/Assembly-CSharp/GameState.cs
@@ -7,6 +7,7 @@ using System.Text;
 using Assets;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class GameState
 {
@@ -16,14 +17,16 @@ public class GameState
 		OPTION,
 		SUB_OPTION,
 		OPTION_TARGET,
-		CHOICE
+		CHOICE,
+		EOE
 	}
 
 	public enum CreateGamePhase
 	{
 		INVALID,
 		CREATING,
-		CREATED
+		CREATED,
+		EOE
 	}
 
 	public delegate void GameStateInitializedCallback(GameState instance, object userData);
@@ -1391,6 +1394,12 @@ public class GameState
 
 	public bool CanShowScoreScreen()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            // The modes that use this screen are not implemented yet
+            return false;
+        }
+
 		if (HasScoreLabels(m_gameEntity))
 		{
 			return true;
@@ -1787,6 +1796,14 @@ public class GameState
 		{
 			return false;
 		}
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePowerTaskListDescriber.IsBusy())
+        {
+			return false;
+        }
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePlayDescriber.Get().IsBusy())
+        {
+			return false;
+        }
 		return true;
 	}
 
@@ -2407,6 +2424,7 @@ public class GameState
 
 	private void FireCreateGameEvent()
 	{
+		AccessiblePowerTaskListDescriber.OnGameStart();
 		CreateGameListener[] array = m_createGameListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
@@ -4098,6 +4116,7 @@ public class GameState
 				m_createGameListeners.Clear();
 			}
 		}
+		taskList.FireCompleteEvent();
 		RemoveQueuedEntitiesFromGame();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/GameStringTable.cs b/Decompiled/Assembly-CSharp/GameStringTable.cs
index 62cdfe4..f60e531 100644
--- a/Decompiled/Assembly-CSharp/GameStringTable.cs
+++ b/Decompiled/Assembly-CSharp/GameStringTable.cs
@@ -83,7 +83,7 @@ public class GameStringTable
 		return true;
 	}
 
-	public string Get(string key)
+    public string Get(string key)
 	{
 		m_table.TryGetValue(key, out var value);
 		return value;
diff --git a/Decompiled/Assembly-CSharp/Gameplay.cs b/Decompiled/Assembly-CSharp/Gameplay.cs
index 6a6caaf..ea74c32 100644
--- a/Decompiled/Assembly-CSharp/Gameplay.cs
+++ b/Decompiled/Assembly-CSharp/Gameplay.cs
@@ -107,6 +107,7 @@ public class Gameplay : PegasusScene
 
 	private void Start()
 	{
+		Accessibility.AccessibleGameplay.Get().OnGameplayScreenStart();
 		Log.LoadingScreen.Print("Gameplay.Start()");
 		CheckBattleNetConnection();
 		Network network = Network.Get();
diff --git a/Decompiled/Assembly-CSharp/GeneralStore.cs b/Decompiled/Assembly-CSharp/GeneralStore.cs
index c4ef35a..9173904 100644
--- a/Decompiled/Assembly-CSharp/GeneralStore.cs
+++ b/Decompiled/Assembly-CSharp/GeneralStore.cs
@@ -495,7 +495,7 @@ public class GeneralStore : Store
 		FriendChallengeMgr.Get().OnStoreOpened();
 		PreRender();
 		PresenceMgr.Get().SetStatus(Global.PresenceStatus.STORE);
-		if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_SEEN_GOLD_QTY_INSTRUCTION, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("GeneralStore.Show:" + Option.HAS_SEEN_GOLD_QTY_INSTRUCTION) && NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().GetTotal() >= MIN_GOLD_FOR_CHANGE_QTY_TOOLTIP)
+		if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_SEEN_GOLD_QTY_INSTRUCTION, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "GeneralStore.Show:" + Option.HAS_SEEN_GOLD_QTY_INSTRUCTION) && NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>().GetTotal() >= MIN_GOLD_FOR_CHANGE_QTY_TOOLTIP)
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 			popupInfo.m_attentionCategory = UserAttentionBlocker.NONE;
@@ -897,7 +897,7 @@ public class GeneralStore : Store
 			yield return null;
 		}
 		int currencyChangedVersion = StoreManager.Get().GetCurrencyChangedVersion();
-		if (currencyChangedVersion != 0 && currencyChangedVersion != Options.Get().GetInt(Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION) && UserAttentionManager.CanShowAttentionGrabber("GeneralStore.AnimateAndUpdateStoreMode:" + Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION))
+		if (currencyChangedVersion != 0 && currencyChangedVersion != Options.Get().GetInt(Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION) && UserAttentionManager.CanShowAttentionGrabber(false, "GeneralStore.AnimateAndUpdateStoreMode:" + Option.LATEST_SEEN_CURRENCY_CHANGED_VERSION))
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 			popupInfo.m_attentionCategory = UserAttentionBlocker.NONE;
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs b/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
index c946921..adc2731 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
@@ -90,6 +90,37 @@ namespace Hearthstone
 			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
 		}
 
+		public void ExceptionReportInitializeDebug()
+		{
+			ExceptionReporter.Get().Initialize(FileUtils.PersistentDataPath, m_logger, HearthstoneApplication.Get());
+			ExceptionReporter.Get().IsInDebugMode = true;
+			ExceptionReporter.Get().SendExceptions = false;
+			ExceptionReporter.Get().SendAsserts = false;
+			ExceptionReporter.Get().SendErrors = false;
+			ExceptionSettings exceptionSettings = new ExceptionSettings();
+			exceptionSettings.m_projectID = 70;
+			exceptionSettings.m_moduleName = "Hearthstone Client";
+			exceptionSettings.m_version = "20.8";
+			exceptionSettings.m_branchName = Network.BranchName;
+			exceptionSettings.m_buildNumber = 86601;
+			exceptionSettings.m_locale = Localization.GetLocaleName();
+			exceptionSettings.m_jiraProjectName = "HSTN";
+			exceptionSettings.m_jiraComponent = "T5QA Confirmation";
+			exceptionSettings.m_jiraVersion = "20.8 Patch";
+			exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.BUG] = -1;
+			if (HearthstoneApplication.IsInternal())
+			{
+				exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.EXCEPTION] = 0;
+			}
+			exceptionSettings.m_logPathsCallback = GetLogPaths;
+			exceptionSettings.m_attachableFilesCallback = GetAttachableFiles;
+			exceptionSettings.m_additionalInfoCallback = GetAdditionalInfo;
+			exceptionSettings.m_readFileMethodCallback = ReadLogFileSharing;
+			ExceptionReporter.Get().BeforeZipping += FlushAllLogs;
+			ExceptionReporter.Get().SetSettings(exceptionSettings);
+			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
+		}
+
 		public void ControlANRMonitor(bool on)
 		{
 			if (PlatformSettings.IsMobileRuntimeOS && (on ^ m_ANRMonitorOn))
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs b/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
index ed84489..c103ac8 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
@@ -5,6 +5,7 @@ using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Threading;
+using Accessibility;
 using Blizzard.BlizzardErrorMobile;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
@@ -51,6 +52,10 @@ namespace Hearthstone
 		};
 
 		private static bool s_initializedMode = false;
+		//private static bool s_initializedMode = true; // Dev mode
+
+		private static ApplicationMode s_mode = ApplicationMode.PUBLIC;
+		//private static ApplicationMode s_mode = ApplicationMode.INTERNAL; // Dev mode
 
 		private static string[] s_cachedCmdLineArgs = null;
 
@@ -78,8 +83,6 @@ namespace Hearthstone
 
 		private float m_unloadUnusedAssetsDelay;
 
-		private static ApplicationMode s_mode = ApplicationMode.INVALID;
-
 		private static HearthstoneApplication s_instance = null;
 
 		private static int s_mainThreadId = -1;
@@ -162,8 +165,10 @@ namespace Hearthstone
 			UpdateWorkingDirectory();
 			LocalOptions.Get().Initialize();
 			Localization.Initialize();
+			AccessibilityMgr.Initialize(gameObject);
+			AccessibleHearthstoneApplication.OnLoading();
 			LaunchArguments.ReadLaunchArgumentsFromDeeplink();
-			ApplyInitializationSettingsFromConfig();
+            ApplyInitializationSettingsFromConfig();
 			Processor.UseJobQueueAlerts = !IsPublic();
 			PreviousInstanceStatus.ReportAppStatus();
 			new JobQueueTelemetry(Processor.JobQueue, Processor.JobQueueAlerts, TestType);
@@ -191,7 +196,8 @@ namespace Hearthstone
 		{
 			HsAppsFlyer.Initialize(60);
 			TelemetryManager.Initialize();
-			ExceptionReporterControl.Get().ExceptionReportInitialize();
+			// ExceptionReporterControl.Get().ExceptionReportInitialize(); // Remove so we don't send Blizzard exceptions that may be caused by us
+			ExceptionReporterControl.Get().ExceptionReportInitializeDebug();
 			HearthstonePerformance.Initialize(TestType, 2227451.ToString());
 			HearthstonePerformance.Get()?.CaptureAppStartTime();
 			AppLaunchTracker.TrackAppLaunch();
@@ -205,6 +211,8 @@ namespace Hearthstone
 
 		private void OnApplicationQuit()
 		{
+			AccessibleHearthstoneApplication.OnClosing();
+			AccessibilityMgr.Shutdown();
 			IsHearthstoneClosing = true;
 			UberText.StoreCachedData();
 			if (this.OnShutdown != null)
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs b/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
index 180e21a..631f2eb 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
@@ -7,10 +7,11 @@ using Blizzard.T5.Services;
 using Hearthstone.Core;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.InGameMessage.UI
 {
-	public class MessagePopupDisplay : IService
+	public class MessagePopupDisplay : IService, AccessibleUI
 	{
 		private static readonly AssetReference m_modalMessageReference = new AssetReference("MessageModal.prefab:7d258ca7826c5ba4c8e86d37eb6e909d");
 
@@ -127,6 +128,7 @@ namespace Hearthstone.InGameMessage.UI
 			{
 				m_messageModal.SetMessage(dataToDisplay);
 				m_modalWidget.Show();
+				ReadMessage(dataToDisplay);
 			}
 			catch (Exception ex)
 			{
@@ -143,7 +145,7 @@ namespace Hearthstone.InGameMessage.UI
 			}
 		}
 
-		private void OnModalWidgetReady(object _)
+        private void OnModalWidgetReady(object _)
 		{
 			if (m_modalWidget != null)
 			{
@@ -169,6 +171,7 @@ namespace Hearthstone.InGameMessage.UI
 
 		private void OnMessageClosed()
 		{
+			AccessibilityMgr.HideUI(this);
 			m_currentlyDisplayedMessage = null;
 			DeactivateFullscreenBlur();
 			DestroyModal();
@@ -196,5 +199,58 @@ namespace Hearthstone.InGameMessage.UI
 			BnetBar.Get()?.CancelRequestToDisableButtons();
 			FullScreenFXMgr.Get().EndStandardBlurVignette(1f);
 		}
-	}
+
+		#region Accessibility
+
+        private void ReadMessage(MessageUIData data)
+        {
+			List<IDataModel> list = MessageDataModelFactory.CreateDataModel(data);
+
+			if (list == null)
+            {
+				m_messageModal.OnClosePressed();
+				return;
+            }
+
+			foreach (var item in list)
+            {
+				switch (item)
+                {
+					case TextMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output("Popup", true);
+						AccessibilityMgr.Output(i.TextBody);
+						break;
+					case ShopMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output("Popup", true);
+						AccessibilityMgr.Output(i.TextBody);
+						break;
+					case TestDebugMessageUIData i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output("Popup", true);
+						AccessibilityMgr.Output(i.TestString);
+						break;
+					default:
+                        m_messageModal.OnClosePressed();
+						return;
+                }
+            }
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_messageModal.OnClosePressed();
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			return $"Press {AccessibleKey.CONFIRM} to continue";
+        }
+
+        #endregion
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
index 72389a8..57da5d7 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
@@ -4,11 +4,13 @@ using Assets;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class QuestNotificationPopup : MonoBehaviour
+	public class QuestNotificationPopup : MonoBehaviour, AccessibleUI
 	{
 		public Widget m_questList;
 
@@ -28,12 +30,18 @@ namespace Hearthstone.Progression
 
 		private const int RETURNING_PLAYER_PROXY_QUEST_ID = 99;
 
+		#region Accessibility
+		private QuestListDataModel m_questListDataModel;
+
+		private AccessibleListOfItems<AccessibleQuest> m_accessibleQuests;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == CODE_HIDE)
 				{
 					Hide();
 				}
@@ -43,6 +51,8 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			m_callback?.Invoke();
 			if (m_IKSShown)
 			{
@@ -52,6 +62,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(RewardTrackDataModel rewardTrackDataModel, QuestListDataModel questListDataModel, Action callback, bool showIKS)
 		{
+			m_questListDataModel = questListDataModel;
 			m_callback = callback;
 			m_shouldShowIKS = showIKS;
 			if (rewardTrackDataModel != null)
@@ -60,6 +71,17 @@ namespace Hearthstone.Progression
 			}
 			if (questListDataModel != null)
 			{
+				// Accessiblity getting the pool type
+				foreach(var quest in questListDataModel.Quests)
+                {
+					if (m_questPoolType != null && quest.PoolType != m_questPoolType)
+                    {
+						m_questPoolType = QuestPool.QuestPoolType.NONE;
+						break;
+                    }
+					m_questPoolType = quest.PoolType;
+                }
+
 				m_widget.BindDataModel(new QuestListDataModel
 				{
 					Quests = questListDataModel.Quests.Take(m_maxQuestsPerRow).Aggregate(new DataModelList<QuestDataModel>(), delegate(DataModelList<QuestDataModel> acc, QuestDataModel dataModel)
@@ -85,10 +107,14 @@ namespace Hearthstone.Progression
 				}
 				m_widget.TriggerEvent("SHOW");
 			}, null, callImmediatelyIfSet: true, doOnce: true);
+
+			ReadPopup();
 		}
 
 		public void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			AckQuests();
 			SceneMgr.Get().UnregisterScenePreLoadEvent(OnPreLoadNextScene);
 			FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
@@ -145,5 +171,52 @@ namespace Hearthstone.Progression
 		{
 			Hide();
 		}
-	}
+
+        #region Accessibility
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(CODE_HIDE);
+            }
+			else
+            {
+				m_accessibleQuests.HandleAccessibleInput();
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+            return $"Use the arrow keys to read your quests. Press {AccessibleKey.CONFIRM} once you're done";
+        }
+
+        private void ReadPopup()
+        {
+			AccessibilityMgr.ShowUI(this);
+			AccessibilityMgr.Output("Popup", true);
+
+			var accessibleQuests = new List<AccessibleQuest>();
+			foreach(var quest in m_questListDataModel.Quests)
+            {
+				accessibleQuests.Add(new AccessibleQuest(quest));
+            }
+
+			m_accessibleQuests = new AccessibleListOfItems<AccessibleQuest>(accessibleQuests);
+			int numQuests = accessibleQuests.Count;
+
+			if (m_questPoolType != QuestPool.QuestPoolType.NONE)
+            {
+                AccessibilityMgr.Output($"You have {numQuests} {m_questPoolType} quest{(numQuests > 1? "s" : "")}");
+            }
+            else
+            {
+                AccessibilityMgr.Output($"You have {numQuests} quest{(numQuests > 1? "s" : "")}");
+            }
+
+			m_accessibleQuests.StartReading();
+        }
+
+        #endregion
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
index 24cda7e..4a1cc1c 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
@@ -1,6 +1,7 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -17,6 +18,10 @@ namespace Hearthstone.Progression
 
 		private const string CODE_HIDE = "CODE_HIDE";
 
+		#region Accessibility
+		private QuestDataModel m_questDataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_toast = GetComponent<WidgetTemplate>();
@@ -31,6 +36,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(QuestDataModel questDataModel)
 		{
+			m_questDataModel = questDataModel;
 			m_toast.BindDataModel(questDataModel);
 		}
 
@@ -38,12 +44,13 @@ namespace Hearthstone.Progression
 		{
 			if (!(m_toast == null))
 			{
+				ReadToast();
 				OverlayUI.Get().AddGameObject(base.gameObject.transform.parent.gameObject);
 				m_toast.Show();
 			}
 		}
 
-		public void Hide()
+        public void Hide()
 		{
 			if (!(m_toast == null))
 			{
@@ -68,5 +75,21 @@ namespace Hearthstone.Progression
 				componentInChildren.Show();
 			});
 		}
+
+        #region Accessibility
+
+        private void ReadToast()
+        {
+			var quota = m_questDataModel.Quota;
+			var progress = m_questDataModel.Progress;
+
+			if (quota > 0)
+            {
+				AccessibilityMgr.Output($"Quest progress toast: {m_questDataModel.Description}");
+				AccessibilityMgr.Output($"Progress is {progress} out of {quota}");
+            }
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
index e5c4896..879b0f5 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
@@ -2,11 +2,13 @@ using System;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class RewardScroll : MonoBehaviour
+	public class RewardScroll : MonoBehaviour, AccessibleUI
 	{
 		private const string HIDE = "CODE_HIDE";
 
@@ -20,12 +22,16 @@ namespace Hearthstone.Progression
 
 		private event Action OnRewardScrollShown;
 
+        #region Accessibility
+        private RewardScrollDataModel m_dataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == HIDE)
 				{
 					Hide();
 				}
@@ -40,6 +46,8 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (FatalErrorMgr.IsInitialized())
 			{
 				FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
@@ -48,6 +56,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(RewardScrollDataModel dataModel, Action onHiddenCallback = null, Action onShownCallback = null)
 		{
+			m_dataModel = dataModel;
 			this.OnRewardScrollHidden = onHiddenCallback;
 			this.OnRewardScrollShown = onShownCallback;
 			m_widget.BindDataModel(dataModel);
@@ -55,6 +64,8 @@ namespace Hearthstone.Progression
 
 		public void Show()
 		{
+			ReadScroll();
+
 			OverlayUI.Get().AddGameObject(m_owner);
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
@@ -67,8 +78,10 @@ namespace Hearthstone.Progression
 			this.OnRewardScrollShown?.Invoke();
 		}
 
-		private void Hide()
+        private void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
 				UIContext.GetRoot().DismissPopup(base.gameObject);
@@ -94,5 +107,78 @@ namespace Hearthstone.Progression
 				widget.GetComponentInChildren<RewardScroll>().Show();
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 		}
+
+        #region Accessibility
+
+		private void ReadScroll()
+        {
+			AccessibilityMgr.ShowUI(this);
+
+            AccessibilityMgr.Output("Popup", true);
+            AccessibilityMgr.Output($"You finished a quest");
+
+            AccessibilityMgr.Output(m_dataModel.DisplayName);
+			AccessibilityMgr.Output(m_dataModel.Description);
+
+			ReadRewards();
+        }
+
+		private AccessibleListOfItems<AccessibleRewardItemDataModel> m_accessibleRewards;
+
+		private AccessibleRewardItemDataModel m_accessibleReward;
+
+        private void ReadRewards()
+        {
+			AccessibilityMgr.Output("Rewards");
+
+			m_accessibleRewards = null; // Reset in case of reuse
+			m_accessibleReward = null; // Reset in case of reuse
+
+			var rewards = m_dataModel.RewardList.Items;
+			var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+
+			foreach (var reward in rewards)
+            {
+				accessibleRewards.Add(new AccessibleRewardItemDataModel(reward));
+            }
+
+			m_accessibleRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(accessibleRewards);
+
+			if (m_accessibleRewards.Count == 1)
+            {
+				m_accessibleReward = m_accessibleRewards.Items[0];
+				m_accessibleReward.ReadAllLines();
+            }
+			else
+            {
+                m_accessibleRewards.StartReading();
+            }
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(HIDE);
+            }
+			else
+            {
+				if (m_accessibleReward != null)
+                {
+					m_accessibleReward.HandleAccessibleInput();
+                }
+				else
+                {
+                    m_accessibleRewards.HandleAccessibleInput();
+                }
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			return $"Use the arrow keys to go through your rewards. Press {AccessibleKey.CONFIRM} to continue";
+        }
+
+		#endregion
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
index 39aefa2..c5525ea 100644
--- a/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
+++ b/Decompiled/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Text;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusUtil;
diff --git a/Decompiled/Assembly-CSharp/HeroDbId.cs b/Decompiled/Assembly-CSharp/HeroDbId.cs
index 79c6983..1bb1e15 100644
--- a/Decompiled/Assembly-CSharp/HeroDbId.cs
+++ b/Decompiled/Assembly-CSharp/HeroDbId.cs
@@ -14,5 +14,6 @@ public enum HeroDbId
 	ALLERIA,
 	MEDIVH,
 	LIADRIN,
-	KHADGAR
+	KHADGAR,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/HeroXPBar.cs b/Decompiled/Assembly-CSharp/HeroXPBar.cs
index e6dfd54..1ae26ca 100644
--- a/Decompiled/Assembly-CSharp/HeroXPBar.cs
+++ b/Decompiled/Assembly-CSharp/HeroXPBar.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class HeroXPBar : PegUIElement
 {
@@ -33,6 +34,11 @@ public class HeroXPBar : PegUIElement
 
 	private string m_rewardDesc;
 
+	#region Accessibility
+	private bool m_signaledEnterToContinue;
+	private bool m_fromEndGameScreen;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -44,12 +50,16 @@ public class HeroXPBar : PegUIElement
 	{
 	}
 
-	public void UpdateDisplay(NetCache.HeroLevel heroLevel, int totalLevel)
+	public void UpdateDisplay(NetCache.HeroLevel heroLevel, int totalLevel, bool fromEndGameScreen)
 	{
+		m_signaledEnterToContinue = false;
+		m_fromEndGameScreen = fromEndGameScreen;
+
 		if (heroLevel == null)
 		{
 			base.gameObject.SetActive(value: false);
-			return;
+            SignalEnterToContinue();
+            return;
 		}
 		m_heroLevel = heroLevel;
 		m_totalLevel = totalLevel;
@@ -72,6 +82,7 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.PrevLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
+				SignalEnterToContinue();
 				return;
 			}
 			SetBarValue((float)m_heroLevel.PrevLevel.XP / (float)m_heroLevel.PrevLevel.MaxXP);
@@ -83,12 +94,14 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.CurrentLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
-			}
-			else
+                SignalEnterToContinue();
+            }
+            else
 			{
 				SetBarValue((float)m_heroLevel.CurrentLevel.XP / (float)m_heroLevel.CurrentLevel.MaxXP);
-			}
-		}
+                SignalEnterToContinue();
+            }
+        }
 	}
 
 	public void AnimateBar(NetCache.HeroLevel.LevelInfo previousLevelInfo, NetCache.HeroLevel.LevelInfo currentLevelInfo)
@@ -110,9 +123,10 @@ public class HeroXPBar : PegUIElement
 			currVal2 = 1f;
 		}
 		m_progressBar.AnimateProgress(prevVal2, currVal2);
-	}
+        SignalEnterToContinue();
+    }
 
-	public void SetBarValue(float barValue)
+    public void SetBarValue(float barValue)
 	{
 		m_progressBar.SetProgressBar(barValue);
 	}
@@ -128,7 +142,7 @@ public class HeroXPBar : PegUIElement
 	private IEnumerator AnimatePostLevelUpXp(float delayTime, NetCache.HeroLevel.LevelInfo currentLevelInfo)
 	{
 		yield return new WaitForSeconds(delayTime);
-		if (currentLevelInfo.Level == 3 && !Options.Get().GetBool(Option.HAS_SEEN_LEVEL_3, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("HeroXPBar.AnimatePostLevelUpXp:" + Option.HAS_SEEN_LEVEL_3))
+		if (currentLevelInfo.Level == 3 && !Options.Get().GetBool(Option.HAS_SEEN_LEVEL_3, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "HeroXPBar.AnimatePostLevelUpXp:" + Option.HAS_SEEN_LEVEL_3))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_LEVEL3_TIP"), "VO_INNKEEPER_LEVEL3_TIP.prefab:0f82ce6c91fccf249b6abcc9f153ff1e");
 			Options.Get().SetBool(Option.HAS_SEEN_LEVEL_3, val: true);
@@ -140,6 +154,8 @@ public class HeroXPBar : PegUIElement
 		{
 			m_levelUpCallback();
 		}
+		AccessibilityMgr.Output($"Your Hero reached level {currentLevelInfo.Level}");
+		SignalEnterToContinue();
 	}
 
 	private IEnumerator DelayBarAnimation(NetCache.HeroLevel.LevelInfo prevInfo, NetCache.HeroLevel.LevelInfo currInfo)
@@ -171,4 +187,16 @@ public class HeroXPBar : PegUIElement
 	{
 		base.gameObject.GetComponent<TooltipZone>().HideTooltip();
 	}
+
+	#region Accessibility
+
+	private void SignalEnterToContinue()
+    {
+		if (m_fromEndGameScreen)
+        {
+            AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/HistoryCard.cs b/Decompiled/Assembly-CSharp/HistoryCard.cs
index 88251ce..4d61301 100644
--- a/Decompiled/Assembly-CSharp/HistoryCard.cs
+++ b/Decompiled/Assembly-CSharp/HistoryCard.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
@@ -87,7 +88,9 @@ public class HistoryCard : HistoryItem
 
 	private int m_displayTimeMS;
 
-	private HistoryInfoType m_historyInfoType;
+	internal HistoryInfoType m_historyInfoType;
+
+	internal PowerTaskList OriginTaskList { get; private set; }
 
 	public void LoadMainCardActor()
 	{
@@ -609,8 +612,10 @@ public class HistoryCard : HistoryItem
 		return -1.404475f + num2 * (float)num3;
 	}
 
-	public void LoadBigCard(HistoryBigCardInitInfo info)
+	public void LoadBigCard(PowerTaskList origin, HistoryBigCardInitInfo info)
 	{
+		OriginTaskList = origin;
+
 		m_entity = info.m_entity;
 		m_historyInfoType = info.m_historyInfoType;
 		m_portraitTexture = info.m_portraitTexture;
@@ -690,7 +695,7 @@ public class HistoryCard : HistoryItem
 
 	public void ShowBigCard(Vector3[] pathToFollow)
 	{
-		float num = 1f;
+        float num = 1f;
 		if (m_displayTimeMS > 0)
 		{
 			float b = (float)m_displayTimeMS / 1000f;
@@ -716,10 +721,11 @@ public class HistoryCard : HistoryItem
 			{
 				ShowDisplayedCreator();
 			}
-		}
-	}
+            AccessibleGameplay.Get().OnShowBigCard(this);
+        }
+    }
 
-	private void OnBigCardPathComplete()
+    private void OnBigCardPathComplete()
 	{
 		ShowDisplayedCreator();
 	}
diff --git a/Decompiled/Assembly-CSharp/HistoryInfoType.cs b/Decompiled/Assembly-CSharp/HistoryInfoType.cs
index 23926a8..8ba672c 100644
--- a/Decompiled/Assembly-CSharp/HistoryInfoType.cs
+++ b/Decompiled/Assembly-CSharp/HistoryInfoType.cs
@@ -7,5 +7,6 @@ public enum HistoryInfoType
 	TRIGGER,
 	WEAPON_BREAK,
 	FATIGUE,
-	BURNED_CARDS
+	BURNED_CARDS,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/HistoryManager.cs b/Decompiled/Assembly-CSharp/HistoryManager.cs
index 49626a0..8b937e9 100644
--- a/Decompiled/Assembly-CSharp/HistoryManager.cs
+++ b/Decompiled/Assembly-CSharp/HistoryManager.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class HistoryManager : CardTileListDisplay
 {
@@ -24,6 +25,14 @@ public class HistoryManager : CardTileListDisplay
 		public bool m_waitForSecretSpell;
 
 		public int m_displayTimeMS;
+
+		public PowerTaskList m_origin;
+
+		public BigCardEntry(PowerTaskList origin)
+        {
+			// Required to arbitrate TTS between big cards and power list parsing
+			m_origin = origin;
+        }
 	}
 
 	private enum BigCardTransformState
@@ -1490,26 +1499,27 @@ public class HistoryManager : CardTileListDisplay
 		return m_pendingBigCardEntry.m_info.GetOriginalEntity();
 	}
 
-	public void CreateFastBigCardFromMetaData(Entity entity)
+	public void CreateFastBigCardFromMetaData(PowerTaskList origin, Entity entity)
 	{
 		int displayTimeMS = 1000;
-		CreatePlayedBigCard(entity, delegate
+		CreatePlayedBigCard(origin, entity, delegate
 		{
 		}, delegate
 		{
 		}, fromMetaData: true, countered: false, displayTimeMS);
 	}
 
-	public void CreatePlayedBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
+	public void CreatePlayedBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard())
-		{
-			finishedCallback();
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard())
+        {
+            // Some tutorials don't show big cards but we depend on it for accessibility atm
+            finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		if (entity.IsWeapon())
@@ -1528,16 +1538,17 @@ public class HistoryManager : CardTileListDisplay
 		StartCoroutine("WaitForCardLoadedAndCreateBigCard", bigCardEntry);
 	}
 
-	public void CreateTriggeredBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
+	public void CreateTriggeredBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard())
-		{
-			finishedCallback();
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard())
+        {
+            // Some tutorials don't show big cards but we depend on it for accessibility atm
+            finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		bigCardEntry.m_info.m_infoType = HistoryInfoType.TRIGGER;
@@ -1657,7 +1668,7 @@ public class HistoryManager : CardTileListDisplay
 			historyBigCardInitInfo.m_postTransformedEntity = postTransformedEntity;
 			historyBigCardInitInfo.m_displayTimeMS = bigCardEntry.m_displayTimeMS;
 			HistoryCard component = go.GetComponent<HistoryCard>();
-			component.LoadBigCard(historyBigCardInitInfo);
+			component.LoadBigCard(bigCardEntry.m_origin, historyBigCardInitInfo);
 			if ((bool)m_currentBigCard)
 			{
 				InterruptCurrentBigCard();
diff --git a/Decompiled/Assembly-CSharp/Hub.cs b/Decompiled/Assembly-CSharp/Hub.cs
index 730f30c..5a2182d 100644
--- a/Decompiled/Assembly-CSharp/Hub.cs
+++ b/Decompiled/Assembly-CSharp/Hub.cs
@@ -8,6 +8,7 @@ using Hearthstone.Core;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class Hub : PegasusScene
 {
@@ -45,6 +46,10 @@ public class Hub : PegasusScene
 		{
 			Box.Get().DisableAllButtons();
 		}
+		else
+        {
+			AccessibleHub.Get().OnHubOpened();
+        }
 		yield break;
 	}
 
@@ -248,7 +253,7 @@ public class Hub : PegasusScene
 		{
 			return;
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_HUB))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_HUB))
 		{
 			StartCoroutine(DoFirstTimeHubWelcome());
 		}
@@ -259,18 +264,20 @@ public class Hub : PegasusScene
 			{
 				Debug.LogError("Hub.Start Error - NetCache.NetCacheGoldBalance is null");
 			}
-			if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
+			if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FIRST_100_GOLD"), "VO_INNKEEPER_FIRST_100_GOLD.prefab:c6a50337099a454488acd96d2f37320f");
 				Options.Get().SetBool(Option.HAS_SEEN_100g_REMINDER, val: true);
 			}
 		}
-		else if (TavernBrawlManager.Get().IsFirstTimeSeeingThisFeature)
+		else if (!AccessibilityMgr.IsAccessibilityEnabled() && TavernBrawlManager.Get().IsFirstTimeSeeingThisFeature)
 		{
+			// Tavern brawl is not implemented yet
 			DoTavernBrawlIntroVO();
 		}
-		if (TavernBrawlManager.Get().IsFirstTimeSeeingCurrentSeason && UserAttentionManager.CanShowAttentionGrabber("Hub.TavernBrawl.IsFirstTimeSeeingCurrentSeason") && !s_hasAlreadyShownTBAnimation)
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && TavernBrawlManager.Get().IsFirstTimeSeeingCurrentSeason && UserAttentionManager.CanShowAttentionGrabber(false, "Hub.TavernBrawl.IsFirstTimeSeeingCurrentSeason") && !s_hasAlreadyShownTBAnimation)
 		{
+			// Tavern brawl is not implemented yet
 			StartCoroutine(DoTavernBrawlAnims());
 		}
 	}
@@ -519,18 +526,28 @@ public class Hub : PegasusScene
 		NotificationManager notificationManager = NotificationManager.Get();
 		if (notificationManager != null)
 		{
-			notificationManager.CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_1ST_HUB_06"), "VO_INNKEEPER_1ST_HUB_06.prefab:9774392944a21424788286f80d401d8c", 3f);
-			if ((bool)UniversalInputManager.UsePhoneUI)
-			{
-				m_PracticeNotification = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, new Vector3(-30.46f, 33.5f, 3f), 25f * Vector3.one, GameStrings.Get("GLUE_PRACTICE_HINT"));
-			}
-			else
-			{
-				m_PracticeNotification = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, new Vector3(-33.62785f, 33.52365f, 3f), 15f * Vector3.one, GameStrings.Get("GLUE_PRACTICE_HINT"));
-			}
-			m_PracticeNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
-		}
-		Options.Get().SetBool(Option.HAS_SEEN_HUB, val: true);
+            if (AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                // Allow menu to be read before jumping in
+                yield return new WaitForSeconds(3f);
+            }
+            notificationManager.CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_1ST_HUB_06"), "VO_INNKEEPER_1ST_HUB_06.prefab:9774392944a21424788286f80d401d8c", 3f);
+
+            if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+				// This is a visual-only popup
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    m_PracticeNotification = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, new Vector3(-30.46f, 33.5f, 3f), 25f * Vector3.one, GameStrings.Get("GLUE_PRACTICE_HINT"));
+                }
+                else
+                {
+                    m_PracticeNotification = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, new Vector3(-33.62785f, 33.52365f, 3f), 15f * Vector3.one, GameStrings.Get("GLUE_PRACTICE_HINT"));
+                }
+                m_PracticeNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
+            }
+        }
+        Options.Get().SetBool(Option.HAS_SEEN_HUB, val: true);
 		AdTrackingManager adTrackingManager = AdTrackingManager.Get();
 		if (adTrackingManager != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
index 6b58bab..a5724d5 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/ActionHelpers.cs
@@ -1,4 +1,5 @@
 using System;
+using Accessibility;
 using HutongGames.PlayMaker.AnimationEnums;
 using UnityEngine;
 
@@ -335,7 +336,8 @@ namespace HutongGames.PlayMaker
 		{
 			if (!(Camera.main == null))
 			{
-				Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out mousePickInfo, distance, layerMask);
+				Physics.Raycast(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), out mousePickInfo, distance, layerMask);
+				//Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out mousePickInfo, distance, layerMask);
 				mousePickLayerMaskUsed = layerMask;
 				mousePickDistanceUsed = distance;
 				mousePickRaycastTime = Time.frameCount;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
index 8f7015a..0db1a61 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseX.cs
@@ -32,7 +32,8 @@ namespace HutongGames.PlayMaker.Actions
 		{
 			if (storeResult != null)
 			{
-				float num = Input.mousePosition.x;
+				float num = AccessibleUnityInput.Get().GetMousePosition().x;
+				//float num = Input.mousePosition.x;
 				if (normalize)
 				{
 					num /= (float)Screen.width;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
index 30f3fbf..327bca0 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/GetMouseY.cs
@@ -32,7 +32,8 @@ namespace HutongGames.PlayMaker.Actions
 		{
 			if (storeResult != null)
 			{
-				float num = Input.mousePosition.y;
+				float num = AccessibleUnityInput.Get().GetMousePosition().y;
+				//float num = Input.mousePosition.y;
 				if (normalize)
 				{
 					num /= (float)Screen.height;
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
index 44a1bbd..bf99203 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2d.cs
@@ -54,7 +54,8 @@ namespace HutongGames.PlayMaker.Actions
 
 		private void DoMousePick2d()
 		{
-			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			//RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
 			bool flag = rayIntersection.collider != null;
 			storeDidPickObject.Value = flag;
 			if (flag)
diff --git a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
index dcd9828..4f70c4f 100644
--- a/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
+++ b/Decompiled/Assembly-CSharp/HutongGames/PlayMaker/Actions/MousePick2dEvent.cs
@@ -84,7 +84,8 @@ namespace HutongGames.PlayMaker.Actions
 		private bool DoRaycast()
 		{
 			GameObject gameObject = ((GameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : GameObject.GameObject.Value);
-			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(AccessibleUnityInput.Get().GetMousePosition()), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
+			//RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
 			Fsm.RecordLastRaycastHit2DInfo(base.Fsm, rayIntersection);
 			if (rayIntersection.transform != null && rayIntersection.transform.gameObject == gameObject)
 			{
diff --git a/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs b/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
index 02b2985..f37d763 100644
--- a/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
+++ b/Decompiled/Assembly-CSharp/InactivePlayerKicker.cs
@@ -22,7 +22,7 @@ public class InactivePlayerKicker : IService, IHasUpdate
 
 	private GameMgr m_gameMgr;
 
-	public bool WasKickedForInactivity { get; private set; }
+	public bool WasKickedForInactivity { get; set; }
 
 	public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
 	{
diff --git a/Decompiled/Assembly-CSharp/InputCollection.cs b/Decompiled/Assembly-CSharp/InputCollection.cs
index 9fc8020..5568c6d 100644
--- a/Decompiled/Assembly-CSharp/InputCollection.cs
+++ b/Decompiled/Assembly-CSharp/InputCollection.cs
@@ -8,6 +8,7 @@ public static class InputCollection
 	static InputCollection()
 	{
 		m_Inputs = new List<IInput>();
+		m_Inputs.Add(AccessibleUnityInput.Get());
 		m_Inputs.Add(new UnityInput());
 	}
 
diff --git a/Decompiled/Assembly-CSharp/InputManager.cs b/Decompiled/Assembly-CSharp/InputManager.cs
index 188082d..eb36db9 100644
--- a/Decompiled/Assembly-CSharp/InputManager.cs
+++ b/Decompiled/Assembly-CSharp/InputManager.cs
@@ -1572,7 +1572,7 @@ public class InputManager : MonoBehaviour
 			Entity entity = heldCard.GetEntity();
 			heldCard.NotifyLeftPlayfield();
 			GameState.Get().GetGameEntity().NotifyOfCardDropped(entity);
-			DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
+            DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
 			if ((bool)component)
 			{
 				component.Disable();
@@ -1625,7 +1625,7 @@ public class InputManager : MonoBehaviour
 		Entity entity = heldCard.GetEntity();
 		heldCard.NotifyLeftPlayfield();
 		GameState.Get().GetGameEntity().NotifyOfCardDropped(entity);
-		DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
+        DragCardSoundEffects component = heldCard.GetComponent<DragCardSoundEffects>();
 		if ((bool)component)
 		{
 			component.Disable();
@@ -2284,7 +2284,7 @@ public class InputManager : MonoBehaviour
 				{
 					if (gameState.GetGameEntity().NotifyOfEndTurnButtonPushed())
 					{
-						gameState.SetSelectedOption(i);
+                                gameState.SetSelectedOption(i);
 						gameState.SendOption();
 						HidePhoneHand();
 						DoEndTurnButton_Option_OnEndTurnRequested();
diff --git a/Decompiled/Assembly-CSharp/JoustSpellController.cs b/Decompiled/Assembly-CSharp/JoustSpellController.cs
index d995418..5c861e5 100644
--- a/Decompiled/Assembly-CSharp/JoustSpellController.cs
+++ b/Decompiled/Assembly-CSharp/JoustSpellController.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Core;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class JoustSpellController : SpellController
@@ -267,6 +268,7 @@ public class JoustSpellController : SpellController
 		{
 			PlayNoJousterSpell(GameState.Get().GetOpposingSidePlayer());
 		}
+
 		while (IsJousterBusy(m_friendlyJouster) || IsJousterBusy(m_opponentJouster))
 		{
 			yield return null;
@@ -311,9 +313,21 @@ public class JoustSpellController : SpellController
 			DriftJouster(jouster);
 		};
 		iTween.Timer(card.gameObject, iTween.Hash("delay", delaySec, "time", showSec, "oncomplete", action));
+
+		var jousterName = card.GetEntity().GetName();
+		var jousterCost = card.GetEntity().GetDefCost();
+
+		if (card.GetEntity().IsControlledByFriendlySidePlayer())
+        {
+			OutputSpeech($"You revealed a {jousterCost} cost {jousterName}");
+        }
+		else
+        {
+			OutputSpeech($"Your opponent revealed a {jousterCost} cost {jousterName}");
+        }
 	}
 
-	private void PlayNoJousterSpell(Player player)
+    private void PlayNoJousterSpell(Player player)
 	{
 		ZoneDeck deckZone = player.GetDeckZone();
 		Spell spell2 = UnityEngine.Object.Instantiate(m_NoJousterSpellPrefab);
@@ -326,6 +340,15 @@ public class JoustSpellController : SpellController
 			}
 		});
 		spell2.Activate();
+
+		if (player.IsFriendlySide())
+        {
+			OutputSpeech("You didn't have any valid card left to reveal");
+        }
+		else
+        {
+			OutputSpeech("Your opponent didn't have any valid card left to reveal");
+        }
 	}
 
 	private void DriftJouster(Jouster jouster)
@@ -534,4 +557,14 @@ public class JoustSpellController : SpellController
 		}
 		return jouster.m_effectsPendingFinish > 0;
 	}
+
+    #region Accessibility
+
+    private void OutputSpeech(string speech)
+    {
+        AccessibilityMgr.Output(speech);
+        AccessibleHistoryMgr.Get().AddEntry(speech);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs b/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
index d34aaf9..d6e5e18 100644
--- a/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
+++ b/Decompiled/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.UI;
 
-public class LeaguePromoteSelfManuallyDialog : DialogBase
+public class LeaguePromoteSelfManuallyDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback();
 
diff --git a/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs b/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
index a76eca7..821580d 100644
--- a/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/LoadingPopupDisplay.cs
@@ -2,8 +2,9 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class LoadingPopupDisplay : TransitionPopup
+public class LoadingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	[Serializable]
 	public class LoadingbarTexture
@@ -93,12 +94,22 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 	}
 
+	public override void Show()
+    {
+		base.Show();
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output($"{m_title.Text}. Please wait", true);
+    }
+
 	public override void Hide()
 	{
 		if (m_shown)
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -408,4 +419,18 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 		m_progressBar.SetBarTexture(texture);
 	}
+
+	#region
+
+	public void HandleAccessibleInput()
+    {
+		// No-op
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/Localization.cs b/Decompiled/Assembly-CSharp/Localization.cs
index 86e4643..a0cff45 100644
--- a/Decompiled/Assembly-CSharp/Localization.cs
+++ b/Decompiled/Assembly-CSharp/Localization.cs
@@ -8,7 +8,8 @@ using Hearthstone.UI;
 
 public class Localization
 {
-	public const Locale DEFAULT_LOCALE = Locale.enUS;
+	public const Locale DEFAULT_LOCALE = Locale.enUS; // Note: we only seem to have enUS by default. Not sure how we force this to exist though (if it stops being the default) FIXME / TODO
+	// SAME THING WITH AUDIO PROBABLY!!
 
 	public static readonly string DEFAULT_LOCALE_NAME = Locale.enUS.ToString();
 
diff --git a/Decompiled/Assembly-CSharp/Log.cs b/Decompiled/Assembly-CSharp/Log.cs
index 4d04227..80de591 100644
--- a/Decompiled/Assembly-CSharp/Log.cs
+++ b/Decompiled/Assembly-CSharp/Log.cs
@@ -9,10 +9,10 @@ public class Log
 {
 	public enum LogLevel
 	{
-		[Description("None")]
-		None,
-		[Description("Debug")]
-		Debug,
+        [Description("None")]
+        None,
+        [Description("Debug")]
+        Debug,
 		[Description("Info")]
 		Info,
 		[Description("Warning")]
@@ -25,6 +25,8 @@ public class Log
 
 	public static Logger All = new Logger("All");
 
+	public static Logger Accessibility = new Logger("Accessibility");
+
 	public static Logger AchievementManager = new Logger("AchievementManager");
 
 	public static Logger Achievements = new Logger("Achievements");
@@ -203,7 +205,9 @@ public class Log
 
 	private const string CONFIG_FILE_NAME = "log.config";
 
-	private readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[5]
+	private const string ACCESSIBILITY_LOG_NAME = "Accessibility";
+
+	private static readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[]
 	{
 		new LogInfo
 		{
@@ -219,6 +223,14 @@ public class Log
 			m_minLevel = LogLevel.Info
 		},
 		new LogInfo
+		{
+			m_name = ACCESSIBILITY_LOG_NAME,
+			m_filePrinting = true,
+			m_consolePrinting = false,
+			m_minLevel = LogLevel.Info,
+			m_defaultLevel = LogLevel.Info
+		},
+		new LogInfo
 		{
 			m_name = "Login",
 			m_filePrinting = true,
@@ -410,6 +422,10 @@ public class Log
 				value2.m_verbose = GeneralUtils.ForceBool(value);
 			}
 		}
+
+		// Force Accessibility log for returning users (e.g. PCs shared with sighted people)
+		var accessibilityLog = Array.Find(DEFAULT_LOG_INFOS, x => x.m_name.Equals(ACCESSIBILITY_LOG_NAME));
+		map.Add(accessibilityLog.m_name, accessibilityLog);
 		return map;
 	}
 }
diff --git a/Decompiled/Assembly-CSharp/Login.cs b/Decompiled/Assembly-CSharp/Login.cs
index 69e8ff2..ef1d473 100644
--- a/Decompiled/Assembly-CSharp/Login.cs
+++ b/Decompiled/Assembly-CSharp/Login.cs
@@ -1,4 +1,5 @@
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using Blizzard.T5.Jobs;
 using Hearthstone;
@@ -73,6 +74,7 @@ public class Login : PegasusScene
 
 	private void ChangeMode()
 	{
+		HSADevTools.Init();
 		m_nextMissionId = GameUtils.GetNextTutorial();
 		MusicManager.Get().StartPlaylist(MusicPlaylistType.UI_MainTitle);
 		if (m_nextMissionId != 0)
@@ -88,9 +90,10 @@ public class Login : PegasusScene
 	private void ChangeToAppropriateHubMode()
 	{
 		Log.Login.PrintInfo("Changing mode");
-		if (SetRotationManager.ShouldShowSetRotationIntro())
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && SetRotationManager.ShouldShowSetRotationIntro())
 		{
-			ChangeMode_SetRotation();
+            // None of this is implemented yet (nor needed until ranked etc)
+            ChangeMode_SetRotation(false);
 		}
 		else
 		{
@@ -188,6 +191,7 @@ public class Login : PegasusScene
 	{
 		Box.Get().AddButtonPressListener(OnStartButtonPressed);
 		Box.Get().ChangeState(Box.State.PRESS_START);
+		AccessibleLoginScreen.Get().OnGameLoaded(Box.Get().m_StartButton);
 	}
 
 	private void OnStartButtonPressed(Box.ButtonType buttonType, object userData)
@@ -246,6 +250,7 @@ public class Login : PegasusScene
 
 	private void StartTutorial()
 	{
+		AccessibleTutorialProgressScreen.OnStartTutorial();
 		MusicManager.Get().StopPlaylist();
 		Box.Get().ChangeState(Box.State.CLOSED);
 		GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
@@ -259,9 +264,9 @@ public class Login : PegasusScene
 		return true;
 	}
 
-	private void ChangeMode_SetRotation()
+	private void ChangeMode_SetRotation(bool accessible)
 	{
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		Spell eventSpell = Box.Get().GetEventSpell(BoxEventType.STARTUP_SET_ROTATION);
 		Box.Get().m_StoreButton.gameObject.SetActive(value: false);
 		Box.Get().m_QuestLogButton.gameObject.SetActive(value: false);
diff --git a/Decompiled/Assembly-CSharp/LoginManager.cs b/Decompiled/Assembly-CSharp/LoginManager.cs
index b18bd80..3e3ac99 100644
--- a/Decompiled/Assembly-CSharp/LoginManager.cs
+++ b/Decompiled/Assembly-CSharp/LoginManager.cs
@@ -240,7 +240,7 @@ public class LoginManager : IService
 	private void OnProfileProgressResponse()
 	{
 		HearthstoneApplication.SendStartupTimeTelemetry("LoginManager.OnProfileProgressResponse");
-		if (!Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
+		if (!Accessibility.AccessibilityMgr.IsAccessibilityEnabled() && !Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
 		{
 			HearthstoneServices.Get<Cinematic>().Play(delegate
 			{
@@ -479,7 +479,7 @@ public class LoginManager : IService
 
 	private void ShowGoldCapAlert(Action callback)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber("Login.ShowGoldCapAlert"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, "Login.ShowGoldCapAlert"))
 		{
 			callback();
 			return;
diff --git a/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs b/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
index 94e757f..fd393fd 100644
--- a/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
+++ b/Decompiled/Assembly-CSharp/LoginPopupSequencePopup.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class LoginPopupSequencePopup : BasicPopup
 {
@@ -18,6 +19,8 @@ public class LoginPopupSequencePopup : BasicPopup
 		public AssetReference m_backgroundMaterialReference;
 
 		public HideCallback m_callbackOnHide;
+
+		public Info(bool markedForAccessibility) { } // If something new shows up we must ensure login popup sequence is still hidden
 	}
 
 	private struct CardActorLoadedData
@@ -129,14 +132,17 @@ public class LoginPopupSequencePopup : BasicPopup
 		if (m_headerText != null)
 		{
 			m_headerText.Text = info.m_headerText;
+			AccessibilityMgr.Output(info.m_headerText);
 		}
 		if (m_bodyText != null)
 		{
 			m_bodyText.Text = info.m_bodyText;
+			AccessibilityMgr.Output(info.m_bodyText);
 		}
 		if (m_cancelButton != null)
 		{
 			m_cancelButton.SetText(info.m_buttonText);
+			AccessibilityMgr.Output(info.m_buttonText);
 		}
 		if (m_backgroundMaterial != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs b/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
index 8d39aff..fdfb2ea 100644
--- a/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
+++ b/Decompiled/Assembly-CSharp/ManaFilterTabManager.cs
@@ -4,6 +4,8 @@ using UnityEngine;
 
 public class ManaFilterTabManager : MonoBehaviour
 {
+	internal static int NUM_MANA_FILTERS = 7;
+
 	public ManaFilterTab m_singleManaFilterPrefab;
 
 	public ManaFilterTab m_dynamicManaFilterPrefab;
@@ -12,7 +14,7 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	private bool m_tabsActive;
 
-	private List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
+	internal List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
 
 	private HashSet<int> m_currentFilterExactValues = new HashSet<int>();
 
@@ -169,11 +171,11 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	public void SetUpTabs()
 	{
-		for (int i = 0; i <= 6; i++)
+		for (int i = 0; i <= NUM_MANA_FILTERS - 1; i++)
 		{
 			CreateNewTab(m_singleManaFilterPrefab, i);
 		}
-		CreateNewTab(m_dynamicManaFilterPrefab, 7);
+		CreateNewTab(m_dynamicManaFilterPrefab, NUM_MANA_FILTERS);
 		m_manaCrystalContainer.UpdateSlices();
 	}
 
@@ -208,7 +210,7 @@ public class ManaFilterTabManager : MonoBehaviour
 		if (m_tabsActive)
 		{
 			ManaFilterTab manaFilterTab = (ManaFilterTab)e.GetElement();
-			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
+			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
 			{
 				Options.Get().SetBool(Option.HAS_CLICKED_MANA_TAB, val: true);
 				ShowManaTabHint(manaFilterTab);
diff --git a/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs b/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
index ce5fca1..4f5e715 100644
--- a/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
+++ b/Decompiled/Assembly-CSharp/MatchingPopupDisplay.cs
@@ -3,8 +3,9 @@ using System.Collections.Generic;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class MatchingPopupDisplay : TransitionPopup
+public class MatchingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	public UberText m_tipOfTheDay;
 
@@ -37,6 +38,8 @@ public class MatchingPopupDisplay : TransitionPopup
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -46,6 +49,8 @@ public class MatchingPopupDisplay : TransitionPopup
 		UpdateTipOfTheDay();
 		GenerateRandomSpinnerTexts(IsMultiOpponentGame());
 		m_title.Text = GetTitleTextBasedOnScenario();
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output($"{m_title.Text}. Please wait", true);
 		base.Show();
 	}
 
@@ -274,4 +279,18 @@ public class MatchingPopupDisplay : TransitionPopup
 		}
 		return record.Players > 2;
 	}
+
+	#region
+
+	public void HandleAccessibleInput()
+    {
+		// No-op
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/MountRewardData.cs b/Decompiled/Assembly-CSharp/MountRewardData.cs
index 98a724c..f40e67b 100644
--- a/Decompiled/Assembly-CSharp/MountRewardData.cs
+++ b/Decompiled/Assembly-CSharp/MountRewardData.cs
@@ -4,7 +4,8 @@ public class MountRewardData : RewardData
 	{
 		UNKNOWN,
 		WOW_HEARTHSTEED,
-		HEROES_MAGIC_CARPET_CARD
+		HEROES_MAGIC_CARPET_CARD,
+		EOE
 	}
 
 	public MountType Mount { get; set; }
diff --git a/Decompiled/Assembly-CSharp/MulliganManager.cs b/Decompiled/Assembly-CSharp/MulliganManager.cs
index 196c984..370d47e 100644
--- a/Decompiled/Assembly-CSharp/MulliganManager.cs
+++ b/Decompiled/Assembly-CSharp/MulliganManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using UnityEngine;
 
@@ -1535,13 +1536,25 @@ public class MulliganManager : MonoBehaviour
 			mulliganButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton();
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
-		}
+
+                if (AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+                    yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+                }
+                else
+                {
+                    innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+                }
+            }
+        }
 		GameState.Get().GetGameEntity().StartMulliganSoundtracks(soft: true);
 		m_waitingForUserInput = true;
 		while (innkeeperMulliganDialog != null)
@@ -1568,7 +1581,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterIntroBeforeMulligan());
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.DO_OPENING_TAUNTS) && !Cheats.Get().ShouldSkipMulligan())
 		{
-			m_PlayStartingTaunts = PlayStartingTaunts();
+            m_PlayStartingTaunts = PlayStartingTaunts();
 			StartCoroutine(m_PlayStartingTaunts);
 		}
 		Player friendlySidePlayer = GameState.Get().GetFriendlySidePlayer();
@@ -1576,11 +1589,11 @@ public class MulliganManager : MonoBehaviour
 		GetStartingLists();
 		if (m_startingCards.Count == 0)
 		{
-			SkipCardChoosing();
+            SkipCardChoosing();
 		}
 		foreach (Card startingCard in m_startingCards)
 		{
-			startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
 			startingCard.GetActor().TurnOffCollider();
 			startingCard.GetActor().GetMeshRenderer().gameObject.layer = 8;
 			startingCard.GetActor().m_nameTextMesh.UpdateNow();
@@ -1599,15 +1612,15 @@ public class MulliganManager : MonoBehaviour
 		int numCardsToDealExcludingBonusCard = m_startingCards.Count;
 		if (!friendlyPlayerGoesFirst)
 		{
-			numCardsToDealExcludingBonusCard = m_bonusCardIndex;
+            numCardsToDealExcludingBonusCard = m_bonusCardIndex;
 			spacingToUse = spaceForEachCard;
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
 			if (m_coinCardIndex >= 0)
 			{
-				m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
+                m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
 			}
 		}
 		opposingSideHandZone.SetDoNotUpdateLayout(enable: false);
@@ -1624,9 +1637,10 @@ public class MulliganManager : MonoBehaviour
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeDealingBaseMulliganCards());
 		float xOffset2 = spacingToUse / 2f;
+		AccessibleGameplay.Get().OnStartingHand(m_startingCards);
 		for (int i = 0; i < numCardsToDealExcludingBonusCard; i++)
 		{
-			GameObject topCard = m_startingCards[i].gameObject;
+            GameObject topCard = m_startingCards[i].gameObject;
 			iTween.Stop(topCard);
 			Vector3[] array = new Vector3[3]
 			{
@@ -1660,11 +1674,12 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeCoinFlip());
 		if (coinObject != null)
 		{
-			Transform transform = Board.Get().FindBone("MulliganCoinPosition");
+            Transform transform = Board.Get().FindBone("MulliganCoinPosition");
 			coinObject.transform.position = transform.position;
 			coinObject.transform.localEulerAngles = transform.localEulerAngles;
 			coinObject.SetActive(value: true);
 			coinObject.GetComponent<CoinEffect>().DoAnim(friendlyPlayerGoesFirst);
+			AccessibleGameplay.Get().OnCoinResult(friendlyPlayerGoesFirst);
 			SoundManager.Get().LoadAndPlay("FX_MulliganCoin03_CoinFlip.prefab:07015cb3f02713a45aa03fc3aa798778", coinObject);
 			coinLocation = transform.position;
 			AssetLoader.Get().InstantiatePrefab("MulliganResultText.prefab:0369b435afd2e344db21e58648f8636c", CoinTossTextCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
@@ -1673,7 +1688,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterCoinFlip());
 		if (!friendlyPlayerGoesFirst)
 		{
-			GameObject topCard = m_startingCards[m_bonusCardIndex].gameObject;
+            GameObject topCard = m_startingCards[m_bonusCardIndex].gameObject;
 			Vector3[] array2 = new Vector3[3]
 			{
 				topCard.transform.position,
@@ -1688,7 +1703,7 @@ public class MulliganManager : MonoBehaviour
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
 			opposingSideHandZone.UpdateLayout(null, forced: true, 4);
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterDealingBonusCard());
@@ -1700,7 +1715,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeSpreadingMulliganCards());
 		if (friendlyPlayerGoesFirst)
 		{
-			xOffset2 = 0f;
+            xOffset2 = 0f;
 			for (int num3 = m_startingCards.Count - 1; num3 >= 0; num3--)
 			{
 				GameObject target = m_startingCards[num3].gameObject;
@@ -1710,22 +1725,23 @@ public class MulliganManager : MonoBehaviour
 			}
 		}
 		GameState.Get().GetGameEntity().OnMulliganCardsDealt(m_startingCards);
+		AccessibleGameplay.Get().OnMulliganCardsDealt(m_startingCards);
 		yield return new WaitForSeconds(0.6f);
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterSpreadingMulliganCards());
 		if (skipCardChoosing)
 		{
-			if (GameState.Get().IsMulliganPhase())
+            if (GameState.Get().IsMulliganPhase())
 			{
-				if (GameState.Get().IsFriendlySidePlayerTurn())
+                if (GameState.Get().IsFriendlySidePlayerTurn())
 				{
-					TurnStartManager.Get().BeginListeningForTurnEvents();
+                    TurnStartManager.Get().BeginListeningForTurnEvents();
 				}
 				m_WaitForOpponentToFinishMulligan = WaitForOpponentToFinishMulligan();
 				StartCoroutine(m_WaitForOpponentToFinishMulligan);
 			}
 			else
 			{
-				yield return new WaitForSeconds(2f);
+                yield return new WaitForSeconds(2f);
 				EndMulligan();
 			}
 			yield break;
@@ -1759,12 +1775,26 @@ public class MulliganManager : MonoBehaviour
 			mulliganButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton();
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
+
+				if (AccessibilityMgr.IsAccessibilityEnabled())
+				{
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+				}
+				else
+                {
+                    innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+                }
+            }
+
+			AccessibleGameplay.Get().OnMulliganChoiceStart(m_startingCards, mulliganButton);
 		}
 		GameState.Get().GetGameEntity().StartMulliganSoundtracks(soft: true);
 		m_waitingForUserInput = true;
@@ -2434,6 +2464,7 @@ public class MulliganManager : MonoBehaviour
 
 	private IEnumerator WaitForOpponentToFinishMulligan()
 	{
+		AccessibleGameplay.Get().WaitingForOpponentToFinishMulligan();
 		DestroyChooseBanner();
 		DestroyDetailLabel();
 		DestroyTagConditionalVFXs();
@@ -3005,6 +3036,7 @@ public class MulliganManager : MonoBehaviour
 
 	public void EndMulligan()
 	{
+		AccessibleGameplay.Get().EndMulligan();
 		m_waitingForUserInput = false;
 		if (m_replaceLabels != null)
 		{
@@ -3144,7 +3176,7 @@ public class MulliganManager : MonoBehaviour
 				coinObject.GetComponentInChildren<PlayMakerFSM>().SendEvent("Birth");
 				yield return new WaitForSeconds(0.1f);
 			}
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_COIN_INTRO"), "VO_INNKEEPER_COIN_INTRO.prefab:6fb1b3b124d474c4c84e392646caada4");
 				Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, val: true);
@@ -3202,6 +3234,7 @@ public class MulliganManager : MonoBehaviour
 
 	private void CoinCardSummonFinishedCallback(Spell spell, object userData)
 	{
+		AccessibleGameplay.Get().OnCoinCard();
 		Card card = SceneUtils.FindComponentInParents<Card>(spell);
 		card.RefreshActor();
 		card.UpdateActorComponents();
diff --git a/Decompiled/Assembly-CSharp/MultiPagePopup.cs b/Decompiled/Assembly-CSharp/MultiPagePopup.cs
index 86a5704..78f7da9 100644
--- a/Decompiled/Assembly-CSharp/MultiPagePopup.cs
+++ b/Decompiled/Assembly-CSharp/MultiPagePopup.cs
@@ -1,9 +1,10 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
 
 [CustomEditClass]
-public class MultiPagePopup : DialogBase
+public class MultiPagePopup : InaccessibleDialogBase
 {
 	public enum PageType
 	{
@@ -26,6 +27,8 @@ public class MultiPagePopup : DialogBase
 		public List<CollectibleCard> m_cardsToShow;
 
 		public int m_dustAmount;
+
+		public PageInfo(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	public class Info
@@ -35,6 +38,8 @@ public class MultiPagePopup : DialogBase
 		public bool m_blurWhenShown;
 
 		public List<PageInfo> m_pages = new List<PageInfo>();
+
+		public Info(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	private readonly Map<PageType, string> m_pagePrefabRefs = new Map<PageType, string>
@@ -55,7 +60,7 @@ public class MultiPagePopup : DialogBase
 	[CustomEditField(Sections = "Sounds", T = EditType.SOUND_PREFAB)]
 	public string m_hideAnimationSound = "Shrink_Down_Quicker.prefab:2fe963b171811ca4b8d544fa53e3330c";
 
-	private Info m_info = new Info();
+	private Info m_info = new Info(true);
 
 	private int m_currentPageIdx;
 
@@ -63,6 +68,11 @@ public class MultiPagePopup : DialogBase
 
 	private int m_numPagesLoaded;
 
+	private MultiPagePopup()
+    {
+		// Protect against constructors due to accessibility and the fact that this has a dangling m_info (Info subclass)
+    }
+
 	protected override void OnDestroy()
 	{
 		base.OnDestroy();
diff --git a/Decompiled/Assembly-CSharp/NarrativeManager.cs b/Decompiled/Assembly-CSharp/NarrativeManager.cs
index e002069..ef5140e 100644
--- a/Decompiled/Assembly-CSharp/NarrativeManager.cs
+++ b/Decompiled/Assembly-CSharp/NarrativeManager.cs
@@ -837,7 +837,7 @@ public class NarrativeManager : MonoBehaviour
 		{
 			return false;
 		}
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/NotificationManager.cs b/Decompiled/Assembly-CSharp/NotificationManager.cs
index 79fd88b..4111cbe 100644
--- a/Decompiled/Assembly-CSharp/NotificationManager.cs
+++ b/Decompiled/Assembly-CSharp/NotificationManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -241,7 +242,7 @@ public class NotificationManager : MonoBehaviour
 
 	private Notification popUpDialog;
 
-	private Notification m_quote;
+	internal Notification m_quote;
 
 	private List<string> m_quotesThisSession;
 
@@ -289,28 +290,28 @@ public class NotificationManager : MonoBehaviour
 		return s_instance;
 	}
 
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
-	{
-		return CreatePopupDialog(headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
-	}
-
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
-	{
-		if (popUpDialog != null)
-		{
-			UnityEngine.Object.Destroy(popUpDialog.gameObject);
-		}
-		GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
-		Vector3 position = Camera.main.transform.position;
-		gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
-		popUpDialog = gameObject.GetComponent<Notification>();
-		popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
-		popUpDialog.PlayBirth();
-		UniversalInputManager.Get().SetGameDialogActive(active: true);
-		return popUpDialog;
-	}
-
-	public Notification CreateSpeechBubble(string speechText, Actor actor)
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
+    {
+        return CreatePopupDialog(accessible, headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
+    }
+
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
+    {
+        if (popUpDialog != null)
+        {
+            UnityEngine.Object.Destroy(popUpDialog.gameObject);
+        }
+        GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
+        Vector3 position = Camera.main.transform.position;
+        gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
+        popUpDialog = gameObject.GetComponent<Notification>();
+        popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
+        popUpDialog.PlayBirth();
+        UniversalInputManager.Get().SetGameDialogActive(active: true);
+        return popUpDialog;
+    }
+
+    public Notification CreateSpeechBubble(string speechText, Actor actor)
 	{
 		return CreateSpeechBubble(speechText, Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: false);
 	}
@@ -427,12 +428,13 @@ public class NotificationManager : MonoBehaviour
 			DestroyNotification(component, options.emoteDuration);
 		}
 		component.notificationGroup = options.speechBubbleGroup;
+		AccessibleNotificationMgr.OnCreateNotificationWithSound(component);
 		return component;
 	}
 
 	public Notification CreateBouncingArrow(UserAttentionBlocker blocker, bool addToList)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManger.CreateBouncingArrow"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManger.CreateBouncingArrow"))
 		{
 			return null;
 		}
@@ -452,7 +454,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreateBouncingArrow(UserAttentionBlocker blocker, Vector3 position, Vector3 rotation, bool addToList, float scaleFactor = 1f)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManger.CreateBouncingArrow"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManger.CreateBouncingArrow"))
 		{
 			return null;
 		}
@@ -498,7 +500,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreatePopupText(UserAttentionBlocker blocker, Vector3 position, Vector3 scale, string text, bool convertLegacyPosition = true, PopupTextType popupTextType = PopupTextType.BASIC)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreatePopupText"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreatePopupText"))
 		{
 			return null;
 		}
@@ -517,6 +519,7 @@ public class NotificationManager : MonoBehaviour
 		component.ChangeText(text);
 		component.PlayBirth();
 		popUpTexts.Add(component);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(component);
 		return component;
 	}
 
@@ -532,7 +535,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreateInnkeeperQuote(UserAttentionBlocker blocker, Vector3 position, string text, string soundPath, float durationSeconds = 0f, Action<int> finishCallback = null, bool clickToDismiss = false)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreateInnkeeperQuote"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreateInnkeeperQuote"))
 		{
 			finishCallback?.Invoke(0);
 			return null;
@@ -759,7 +762,8 @@ public class NotificationManager : MonoBehaviour
 			return;
 		}
 		m_quote.PlayBirthWithForcedScale(Vector3.one);
-		if (durationSeconds > 0f)
+        AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        if (durationSeconds > 0f)
 		{
 			if (persistCharacter)
 			{
@@ -789,8 +793,9 @@ public class NotificationManager : MonoBehaviour
 			quoteSoundCallbackData.m_quote = m_quote;
 			quoteSoundCallbackData.m_durationSeconds = durationSeconds;
 			SoundLoader.LoadSound(soundPath, OnQuoteSoundLoaded, quoteSoundCallbackData, SoundManager.Get().GetPlaceholderSound());
-		}
-		else
+            AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        }
+        else
 		{
 			PlayQuoteWithoutSound(durationSeconds, text);
 		}
@@ -799,6 +804,7 @@ public class NotificationManager : MonoBehaviour
 	private void PlayQuoteWithoutSound(float durationSeconds, string text = null)
 	{
 		m_quote.PlayBirthWithForcedScale(UniversalInputManager.UsePhoneUI ? NOTIFICATION_SCALE_PHONE : NOTIFICATION_SCALE);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(m_quote);
 		if (durationSeconds <= 0f && text != null)
 		{
 			durationSeconds = ClipLengthEstimator.StringToReadTime(text);
diff --git a/Decompiled/Assembly-CSharp/Option.cs b/Decompiled/Assembly-CSharp/Option.cs
index ae07f46..43b26f5 100644
--- a/Decompiled/Assembly-CSharp/Option.cs
+++ b/Decompiled/Assembly-CSharp/Option.cs
@@ -566,5 +566,10 @@ public enum Option
 	[Description("hasSeenClassicModeVO")]
 	HAS_SEEN_CLASSIC_MODE_VO,
 	[Description("hasAcceptedPrivacyPolicyAndEULA")]
-	HAS_ACCEPTED_PRIVACY_POLICY_AND_EULA
+	HAS_ACCEPTED_PRIVACY_POLICY_AND_EULA,
+
+	#region Accessibility
+	[Description("accessibilityGameSpeed")]
+	ACCESSIBILITY_GAME_SPEED
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/OptionDataTables.cs b/Decompiled/Assembly-CSharp/OptionDataTables.cs
index 88dcc36..6d88f98 100644
--- a/Decompiled/Assembly-CSharp/OptionDataTables.cs
+++ b/Decompiled/Assembly-CSharp/OptionDataTables.cs
@@ -651,7 +651,13 @@ public class OptionDataTables
 		{
 			Option.FORMAT_TYPE_LAST_PLAYED,
 			typeof(int)
-		}
+		},
+		#region Accessibility
+		{
+            Option.ACCESSIBILITY_GAME_SPEED,
+			typeof(int)
+        }
+		#endregion
 	};
 
 	public static readonly Map<Option, object> s_defaultsMap = new Map<Option, object>
@@ -678,7 +684,7 @@ public class OptionDataTables
 		},
 		{
 			Option.SOUND_VOLUME,
-			1f
+			0.5f // Start lower due to screen readers as it's easier for beginners
 		},
 		{
 			Option.MUSIC_VOLUME,
@@ -1111,6 +1117,12 @@ public class OptionDataTables
 		{
 			Option.HAS_SEEN_CLASSIC_MODE_VO,
 			false
-		}
+		},
+		#region Accessibility
+        {
+			Option.ACCESSIBILITY_GAME_SPEED,
+			3
+        }
+		#endregion
 	};
 }
diff --git a/Decompiled/Assembly-CSharp/OptionsMenu.cs b/Decompiled/Assembly-CSharp/OptionsMenu.cs
index e006aa4..84166ad 100644
--- a/Decompiled/Assembly-CSharp/OptionsMenu.cs
+++ b/Decompiled/Assembly-CSharp/OptionsMenu.cs
@@ -3,9 +3,10 @@ using System.Collections.Generic;
 using Hearthstone;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class OptionsMenu : MonoBehaviour
+public class OptionsMenu : MonoBehaviour, AccessibleUI
 {
 	public delegate void hideHandler();
 
@@ -251,10 +252,13 @@ public class OptionsMenu : MonoBehaviour
 		UpdateOtherUI();
 		ShowOrHide(showOrHide: true);
 		AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
+
+		ReadMenu();
 	}
 
 	public void Hide(bool callHideHandler = true)
 	{
+		AccessibilityMgr.HideUI(this);
 		ShowOrHide(showOrHide: false);
 		if (m_hideHandler != null && callHideHandler)
 		{
@@ -346,7 +350,7 @@ public class OptionsMenu : MonoBehaviour
 
 	private bool CanShowOtherMenuOptions()
 	{
-		if (UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: false) != 0)
+		if (UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: false) != 0)
 		{
 			return false;
 		}
@@ -608,4 +612,85 @@ public class OptionsMenu : MonoBehaviour
 		m_miscellaneousMenu.Show();
 		m_miscellaneousMenuLoading = false;
 	}
+
+	#region
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private enum AccessibleMenuState { MAIN_MENU, ADJUSTING_MASTER_VOLUME };
+
+	private AccessibleMenuState m_curState;
+
+	private void ReadMenu()
+    {
+		SetupMainMenu();
+
+        AccessibilityMgr.ShowUI(this);
+    }
+
+	private void SetupMainMenu()
+    {
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu = new AccessibleMenu(AccessibleSpeech.OPTIONS_MENU_TITLE, () => Hide(), true);
+
+        m_accessibleMenu.AddOption(AccessibleSpeech.OPTIONS_MENU_MASTER_VOLUME_OPTION, OnClickMasterVolume);
+        m_accessibleMenu.AddOption(AccessibleSpeech.OPTIONS_MENU_FULLSCREEN_OPTION, OnToggleFullscreen);
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void OnClickMasterVolume()
+    {
+		m_curState = AccessibleMenuState.ADJUSTING_MASTER_VOLUME;
+		AccessibilityMgr.Output(AccessibleSpeech.OPTIONS_MENU_ADJUST_MASTER_VOLUME);
+    }
+
+    private void OnToggleFullscreen()
+    {
+		m_fullScreenCheckbox.TriggerRelease();
+		AccessibilityMgr.Output(AccessibleSpeech.OPTIONS_MENU_FULLSCREEN_STATE(m_fullScreenCheckbox.IsChecked()));
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+        {
+            m_accessibleMenu.HandleAccessibleInput();
+        }
+		else if (m_curState == AccessibleMenuState.ADJUSTING_MASTER_VOLUME)
+        {
+			if (AccessibleKey.OPTIONS_REDUCE_VOLUME.IsPressed())
+            {
+				IncVolume(m_masterVolume, -1);
+            }
+			else if (AccessibleKey.OPTIONS_INCREASE_VOLUME.IsPressed())
+            {
+				IncVolume(m_masterVolume, 1);
+            }
+			else if (AccessibleKey.BACK.IsPressed() || AccessibleKey.CONFIRM.IsPressed())
+            {
+				SetupMainMenu();
+            }
+        }
+    }
+
+    private void IncVolume(ScrollbarControl volumeScrollbar, int sign)
+    {
+		float val = sign >= 0 ? 0.1f : -0.1f;
+
+		float target = volumeScrollbar.GetValue() + val;
+
+		volumeScrollbar.SetValue(target);
+		volumeScrollbar.FireUpdateEvent();
+		volumeScrollbar.FireFinishEvent();
+
+		AccessibilityMgr.Output(AccessibleSpeech.OPTIONS_MENU_MASTER_VOLUME_STATE(volumeScrollbar.GetValue()));
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.MENU_HELP(true);
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs b/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
index f5bc7a8..88c2b04 100644
--- a/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
+++ b/Decompiled/Assembly-CSharp/OutstandingDraftTicketDialog.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using System;
 using System.Collections;
 using UnityEngine;
 
-public class OutstandingDraftTicketDialog : DialogBase
+public class OutstandingDraftTicketDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Decompiled/Assembly-CSharp/PackOpening.cs b/Decompiled/Assembly-CSharp/PackOpening.cs
index 9bf0d61..610250f 100644
--- a/Decompiled/Assembly-CSharp/PackOpening.cs
+++ b/Decompiled/Assembly-CSharp/PackOpening.cs
@@ -628,7 +628,7 @@ public class PackOpening : MonoBehaviour
 			return;
 		}
 		list[0].PlayAlert();
-		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnUnopenedPack") && m_hintArrow == null)
+		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "PackOpening.ShowHintOnUnopenedPack") && m_hintArrow == null)
 		{
 			Bounds bounds = list[0].GetComponent<Collider>().bounds;
 			Vector3 center = bounds.center;
@@ -657,7 +657,7 @@ public class PackOpening : MonoBehaviour
 
 	private void ShowHintOnSlot()
 	{
-		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnSlot"))
+		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "PackOpening.ShowHintOnSlot"))
 		{
 			if (m_hintArrow == null)
 			{
diff --git a/Decompiled/Assembly-CSharp/PopupDisplayManager.cs b/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
index a4ec267..a12c53f 100644
--- a/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
+++ b/Decompiled/Assembly-CSharp/PopupDisplayManager.cs
@@ -12,6 +12,7 @@ using Hearthstone.Progression;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class PopupDisplayManager : IHasUpdate, IService
 {
@@ -78,7 +79,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private PopupDisplayManagerBones ChestBones { get; set; }
 
-	private PopupDisplayManagerBones QuestChestBones { get; set; }
+	internal PopupDisplayManagerBones QuestChestBones { get; set; }
 
 	private static HashSet<Assets.Achieve.RewardTiming> CurrentRewardTimings
 	{
@@ -221,7 +222,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 			m_isShowing = true;
 			return;
 		}
-		if (FiresideGatheringManager.Get() != null && FiresideGatheringManager.Get().ShowSignIfNeeded(OnPopupClosed))
+		if (FiresideGatheringManager.Get() != null && FiresideGatheringManager.Get().ShowSignIfNeeded(OnPopupClosed)) // Safe to ignore as we can't enter FSG mode anyways
 		{
 			this.OnPopupShown();
 			m_isShowing = true;
@@ -237,7 +238,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 			m_isShowing = true;
 			return;
 		}
-		if (DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(OnPopupClosed))
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(OnPopupClosed)) // To be reviewed if we implement arena
 		{
 			this.OnPopupShown();
 			m_isShowing = true;
@@ -254,7 +255,28 @@ public class PopupDisplayManager : IHasUpdate, IService
 		{
 			m_hasShownMetaShakeupEventPopups = true;
 		}
-		else if (!ShowNextTavernBrawlReward() && !ShowNextLeaguePromotionReward() && !ShowNextRankedIntro() && !ShowNextFreeDeckReward() && !ShowNextSellableDeckReward() && !ShowNextQuestChestReward() && !ShowNextDuelsReward() && !ShowNextProgressionAchievementReward() && !ShowNextProgressionQuestReward() && !ShowNextProgressionTrackReward() && !ShowRewardTrackXpGains() && !ShowRewardTrackSeasonRoll() && ((m_completedAchieves.Count <= 0 && m_rewards.Count <= 0 && m_purchasedCardRewards.Count <= 0 && m_genericRewards.Count <= 0) || (!ShowNextCompletedQuest() && !ShowNextUnAckedReward() && !ShowNextUnAckedGenericReward() && !ShowNextUnAckedPurchasedCardReward())) && !ShowFixedRewards(CurrentRewardTimings) && !IsLoadingRewards && !ShowNextQuestNotification() && !ShowWelcomeQuests() && !ShowInGameMessagePopups())
+		// Original (commented as this is way too hard to read as a one-liner): else if (!ShowNextTavernBrawlReward() && !ShowNextLeaguePromotionReward() && !ShowNextRankedIntro() && !ShowNextFreeDeckReward() && !ShowNextSellableDeckReward() && !ShowNextQuestChestReward() && !ShowNextDuelsReward() && !ShowNextProgressionAchievementReward() && !ShowNextProgressionQuestReward() && !ShowNextProgressionTrackReward() && !ShowRewardTrackXpGains() && !ShowRewardTrackSeasonRoll() && ((m_completedAchieves.Count <= 0 && m_rewards.Count <= 0 && m_purchasedCardRewards.Count <= 0 && m_genericRewards.Count <= 0) || (!ShowNextCompletedQuest() && !ShowNextUnAckedReward() && !ShowNextUnAckedGenericReward() && !ShowNextUnAckedPurchasedCardReward())) && !ShowFixedRewards(CurrentRewardTimings) && !IsLoadingRewards && !ShowNextQuestNotification() && !ShowWelcomeQuests() && !ShowInGameMessagePopups())
+		else if (!ShowNextTavernBrawlReward() &&
+			!ShowNextLeaguePromotionReward() &&
+			!ShowNextRankedIntro() &&
+			!ShowNextFreeDeckReward() &&
+			!ShowNextSellableDeckReward() &&
+			!ShowNextQuestChestReward() &&
+			!ShowNextDuelsReward() &&
+			!ShowNextProgressionAchievementReward() &&
+			!ShowNextProgressionQuestReward() &&
+			!ShowNextProgressionTrackReward() &&
+			!ShowRewardTrackXpGains() &&
+			!ShowRewardTrackSeasonRoll() &&
+			(
+                (m_completedAchieves.Count <= 0 && m_rewards.Count <= 0 && m_purchasedCardRewards.Count <= 0 && m_genericRewards.Count <= 0) ||
+				(!ShowNextCompletedQuest() && !ShowNextUnAckedReward() && !ShowNextUnAckedGenericReward() && !ShowNextUnAckedPurchasedCardReward())
+			) &&
+			!ShowFixedRewards(CurrentRewardTimings) &&
+			!IsLoadingRewards &&
+			!ShowNextQuestNotification() &&
+			!ShowWelcomeQuests() &&
+			!ShowInGameMessagePopups())
 		{
 			NarrativeManager.Get().OnAllPopupsShown();
 			if (!IsShowing)
@@ -619,7 +641,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		}
 		Reward reward = m_purchasedCardRewards[0];
 		UserAttentionBlocker userAttentionBlockerForReward = RewardUtils.GetUserAttentionBlockerForReward(reward.Data.Origin, reward.Data.OriginData);
-		if (!UserAttentionManager.CanShowAttentionGrabber(userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
 		{
 			return false;
 		}
@@ -662,7 +684,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextTavernBrawlReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.UpdateTavernBrawlRewards"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// TB is not implemented yet
+			return false;
+        }
+
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.UpdateTavernBrawlRewards"))
 		{
 			return false;
 		}
@@ -711,7 +739,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextLeaguePromotionReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextLeaguePromotionReward"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextLeaguePromotionReward"))
 		{
 			return false;
 		}
@@ -765,7 +793,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextRankedIntro()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextRankedIntro"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextRankedIntro"))
 		{
 			return false;
 		}
@@ -787,7 +815,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextFreeDeckReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextFreeDeckReward"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// To be implemented if we ever implement ranked
+			return false;
+        }
+
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextFreeDeckReward"))
 		{
 			return false;
 		}
@@ -861,7 +895,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextSellableDeckReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
@@ -1080,7 +1114,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowNextProgressionAchievementReward()
 	{
-		if (AchievementManager.Get() == null || !AchievementManager.Get().ShowNextReward(OnPopupClosed))
+        if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            // Not implemented yet
+            return false;
+        }
+
+        if (AchievementManager.Get() == null || !AchievementManager.Get().ShowNextReward(OnPopupClosed))
 		{
 			return false;
 		}
@@ -1132,6 +1172,11 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private bool ShowRewardTrackSeasonRoll()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			return false; // Not yet implemented
+        }
+
 		if (RewardTrackManager.Get() == null || !RewardTrackManager.Get().ShowUnclaimedTrackRewardsPopup(OnPopupClosed))
 		{
 			return false;
@@ -1189,7 +1234,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	private void ShowQuestProgressToasts()
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber("ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
 		{
 			if (QuestManager.Get() != null && QuestToastManager.Get() != null && QuestManager.Get().IsSystemEnabled)
 			{
@@ -1205,7 +1250,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	public bool ShowChangedCards(DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE, string featuredCardsEventTiming = null, List<CollectibleCard> cardsToShowOverride = null)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowChangedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowChangedCards"))
 		{
 			return false;
 		}
@@ -1231,11 +1276,12 @@ public class PopupDisplayManager : IHasUpdate, IService
 				flag = true;
 			}
 		}
-		if (Cheats.ShowFakeNerfedCards && !flag && !m_hasShownCheatedChangedCards)
+		//if (Cheats.ShowFakeNerfedCards && !flag && !m_hasShownCheatedChangedCards) <- was like this but was having some problems testing
+		if (Cheats.ShowFakeNerfedCards && !m_hasShownCheatedChangedCards)
 		{
 			UIStatus.Get().AddInfo("SHOWING FAKE NERFED CARDS!\nTo disable this, remove ShowFakeNerfedCards from client.config.", 5f);
 			list = CollectionManager.Get().GetAllCards().FindAll((CollectibleCard card) => card.PremiumType == TAG_PREMIUM.NORMAL)
-				.Take(3)
+				.Take(10)
 				.ToList();
 			flag = true;
 			m_hasShownCheatedChangedCards = true;
@@ -1261,7 +1307,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	public bool ShowAddedCards(DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE, string featuredCardsEventTiming = null, List<CollectibleCard> cardsToShowOverride = null)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowAddedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowAddedCards"))
 		{
 			return false;
 		}
@@ -1303,13 +1349,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 		return false;
 	}
 
-	private bool ShowFeaturedCards(string featuredCardsEventTiming, string headerText, DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE)
+	private bool ShowFeaturedCards(bool accessible, string featuredCardsEventTiming, string headerText, DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowFeaturedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowFeaturedCards"))
 		{
 			return false;
 		}
-		MultiPagePopup.Info info = new MultiPagePopup.Info
+		MultiPagePopup.Info info = new MultiPagePopup.Info(true)
 		{
 			m_callbackOnHide = callbackOnHide,
 			m_blurWhenShown = true
@@ -1325,7 +1371,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		{
 			return false;
 		}
-		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo
+		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo(true)
 		{
 			m_pageType = MultiPagePopup.PageType.CARD_LIST,
 			m_cardsToShow = changedCards,
@@ -1338,7 +1384,13 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	public bool ShowLoginPopupSequence()
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber("ShowLoginPopupSequence"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Not implemented yet as there's a few tricky ones
+			return false;
+        }
+
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "ShowLoginPopupSequence"))
 		{
 			return false;
 		}
@@ -1399,7 +1451,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 				}
 				if ((uint)popupType > 1u && popupType == Assets.LoginPopupSequencePopup.LoginPopupSequencePopupType.FEATURED_CARDS)
 				{
-					if (ShowFeaturedCards(loginPopupSequencePopupDbfRecord.FeaturedCardsEvent, loginPopupSequencePopupDbfRecord.HeaderText, callbackOnHide))
+					if (ShowFeaturedCards(true, loginPopupSequencePopupDbfRecord.FeaturedCardsEvent, loginPopupSequencePopupDbfRecord.HeaderText, callbackOnHide))
 					{
 						result = true;
 					}
@@ -1409,7 +1461,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 					}
 					continue;
 				}
-				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info
+				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info(true)
 				{
 					m_headerText = loginPopupSequencePopupDbfRecord.HeaderText,
 					m_bodyText = loginPopupSequencePopupDbfRecord.BodyText,
@@ -1547,6 +1599,9 @@ public class PopupDisplayManager : IHasUpdate, IService
 
 	public static bool ShouldDisableNotificationOnLogin()
 	{
+		// TODO
+		//return true; // Login sequence popups (see LoginPopupSequencePopup.cs) are way too random and hard to make accessible. It's easier to simply disable them
+
 		if (HearthstoneApplication.IsPublic())
 		{
 			return false;
@@ -1789,7 +1844,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		});
 	}
 
-	private Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
+	internal Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
 	{
 		PopupDisplayManagerBones popupDisplayManagerBones = ((boneSet != null) ? boneSet : ChestBones);
 		switch (SceneMgr.Get().GetMode())
diff --git a/Decompiled/Assembly-CSharp/PowerProcessor.cs b/Decompiled/Assembly-CSharp/PowerProcessor.cs
index 1d651f8..40b19d9 100644
--- a/Decompiled/Assembly-CSharp/PowerProcessor.cs
+++ b/Decompiled/Assembly-CSharp/PowerProcessor.cs
@@ -152,11 +152,11 @@ public class PowerProcessor
 				HistoryBlock.Type blockType = m_currentTaskList.GetBlockType();
 				if (sourceEntity != null && sourceEntity.HasTag(GAME_TAG.FAST_BATTLECRY) && blockType == HistoryBlock.Type.POWER)
 				{
-					HistoryManager.Get().CreateFastBigCardFromMetaData(entity);
+					HistoryManager.Get().CreateFastBigCardFromMetaData(m_currentTaskList, entity);
 					return;
 				}
 				int displayTimeMS = ((metaData.Info.Count > 1) ? metaData.Info[1] : 0);
-				HistoryManager.Get().CreatePlayedBigCard(entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
+				HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
 			}
 		}
 		else if (metaData.MetaType == HistoryMeta.Type.BEGIN_LISTENING_FOR_TURN_EVENTS)
@@ -1237,7 +1237,7 @@ public class PowerProcessor
 				{
 					bool countered = m_currentTaskList.WasThePlayedSpellCountered(sourceEntity2);
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreatePlayedBigCard(sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
+					HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
 				}
 			}
 			m_currentTaskList.NotifyHistoryOfAdditionalTargets();
@@ -1269,7 +1269,7 @@ public class PowerProcessor
 					HistoryManager.Get().CreateTriggerTile(sourceEntity);
 					m_currentTaskList.SetWillCompleteHistoryEntry(set: true);
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreateTriggeredBigCard(sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
+					HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
 				}
 				m_currentTaskList.NotifyHistoryOfAdditionalTargets();
 				break;
@@ -1288,7 +1288,7 @@ public class PowerProcessor
 					if (sourceEntity.GetController() != GameState.Get().GetFriendlySidePlayer() || !sourceEntity.HasTag(GAME_TAG.HISTORY_PROXY_NO_BIG_CARD))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(entity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, entity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 				}
 				else
@@ -1296,7 +1296,7 @@ public class PowerProcessor
 					if (ShouldShowTriggeredBigCard(sourceEntity))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 					HistoryManager.Get().CreateTriggerTile(sourceEntity);
 				}
@@ -1347,7 +1347,7 @@ public class PowerProcessor
 		m_historyBlocking = false;
 	}
 
-	private bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
+	internal static bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
 	{
 		if (!GameState.Get().GetBooleanGameOption(GameEntityOption.USES_BIG_CARDS))
 		{
@@ -1368,7 +1368,7 @@ public class PowerProcessor
 		return false;
 	}
 
-	private bool ShouldShowTriggeredBigCard(Entity sourceEntity)
+	internal static bool ShouldShowTriggeredBigCard(Entity sourceEntity)
 	{
 		if (sourceEntity.GetZone() != TAG_ZONE.HAND)
 		{
@@ -1492,7 +1492,7 @@ public class PowerProcessor
 		m_currentTaskList.DoAllTasks(delegate
 		{
 			EndCurrentTaskList();
-		});
+        });
 	}
 
 	private void EndCurrentTaskList()
diff --git a/Decompiled/Assembly-CSharp/PowerSpellController.cs b/Decompiled/Assembly-CSharp/PowerSpellController.cs
index 2a67bf4..a2ce113 100644
--- a/Decompiled/Assembly-CSharp/PowerSpellController.cs
+++ b/Decompiled/Assembly-CSharp/PowerSpellController.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class PowerSpellController : SpellController
 {
diff --git a/Decompiled/Assembly-CSharp/PowerTask.cs b/Decompiled/Assembly-CSharp/PowerTask.cs
index d1a44cd..c786b80 100644
--- a/Decompiled/Assembly-CSharp/PowerTask.cs
+++ b/Decompiled/Assembly-CSharp/PowerTask.cs
@@ -3,6 +3,8 @@ using PegasusGame;
 
 public class PowerTask
 {
+	public delegate void TaskStartCallback(PowerTask task);
+
 	public delegate void TaskCompleteCallback();
 
 	private Network.PowerHistory m_power;
@@ -11,6 +13,8 @@ public class PowerTask
 
 	private TaskCompleteCallback m_onCompleted;
 
+	private TaskStartCallback m_onStarted;
+
 	public Network.PowerHistory GetPower()
 	{
 		return m_power;
@@ -40,6 +44,11 @@ public class PowerTask
 		m_onCompleted = onComplete;
 	}
 
+	public void SetTaskStartCallback(TaskStartCallback onStart)
+	{
+		m_onStarted = onStart;
+	}
+
 	private bool IsZoneTransition(TAG_ZONE fromZone, TAG_ZONE toZone)
 	{
 		if (IsCompleted())
@@ -95,7 +104,8 @@ public class PowerTask
 
 	public void DoRealTimeTask(List<Network.PowerHistory> powerList, int index)
 	{
-		GameState gameState = GameState.Get();
+        m_onStarted(this);
+        GameState gameState = GameState.Get();
 		switch (m_power.Type)
 		{
 		case Network.PowerType.CREATE_GAME:
@@ -154,6 +164,7 @@ public class PowerTask
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
@@ -228,6 +239,7 @@ public class PowerTask
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
diff --git a/Decompiled/Assembly-CSharp/PowerTaskList.cs b/Decompiled/Assembly-CSharp/PowerTaskList.cs
index 22f279d..aaf5d5a 100644
--- a/Decompiled/Assembly-CSharp/PowerTaskList.cs
+++ b/Decompiled/Assembly-CSharp/PowerTaskList.cs
@@ -1,13 +1,15 @@
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class PowerTaskList
 {
 	public delegate void CompleteCallback(PowerTaskList taskList, int startIndex, int count, object userData);
 
-	public class DamageInfo
+    public class DamageInfo
 	{
 		public Entity m_entity;
 
@@ -505,6 +507,7 @@ public class PowerTaskList
 		PowerTask powerTask = new PowerTask();
 		powerTask.SetPower(netPower);
 		powerTask.SetTaskCompleteCallback(OnTaskCompleted);
+		powerTask.SetTaskStartCallback(OnTaskStarted);
 		m_tasks.Add(powerTask);
 		return powerTask;
 	}
@@ -1617,7 +1620,7 @@ public class PowerTaskList
 		callback?.Invoke(this, startIndex, count, userData);
 	}
 
-	private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
+    private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
 	{
 		for (int i = incompleteStartIndex; i <= endIndex; i++)
 		{
@@ -1888,4 +1891,33 @@ public class PowerTaskList
 			}
 		}
 	}
+
+    #region Accessibility
+
+	public delegate void GlobalCompleteCallback(PowerTaskList taskList);
+
+	private GlobalCompleteCallback m_globalCompleteCallback;
+
+    private bool m_startedTasks = false;
+
+    private void OnTaskStarted(PowerTask task)
+    {
+        if (!m_startedTasks)
+        {
+            m_startedTasks = true;
+            AccessiblePowerTaskListDescriber.OnPowerTaskListStart(this);
+        }
+    }
+
+    internal void SetGlobalCompleteCallback(GlobalCompleteCallback callback)
+    {
+		m_globalCompleteCallback = callback;
+    }
+
+	public void FireCompleteEvent()
+    {
+        m_globalCompleteCallback?.Invoke(this);
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs b/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
index 40de9bc..22bf6b2 100644
--- a/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
+++ b/Decompiled/Assembly-CSharp/PracticePickerTrayDisplay.cs
@@ -3,6 +3,8 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
+using Assets;
 
 [CustomEditClass]
 public class PracticePickerTrayDisplay : MonoBehaviour
@@ -42,8 +44,6 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 
 	private List<PracticeAIButton> m_practiceAIButtons = new List<PracticeAIButton>();
 
-	private List<Achievement> m_lockedHeroes = new List<Achievement>();
-
 	private PracticeAIButton m_selectedPracticeAIButton;
 
 	private Map<string, DefLoader.DisposableFullDef> m_heroDefs = new Map<string, DefLoader.DisposableFullDef>();
@@ -156,7 +156,9 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 		Hashtable args = iTween.Hash("position", PracticeDisplay.Get().GetPracticePickerShowPosition(), "isLocal", true, "time", m_trayAnimationTime, "easetype", m_trayInEaseType, "delay", 0.001f);
 		iTween.MoveTo(base.gameObject, args);
 		SoundManager.Get().LoadAndPlay("choose_opponent_panel_slide_on.prefab:66491d3d01ed663429ab80daf6a5e880");
-		if (!Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_TRAY, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PracticePickerTrayDisplay.Show:" + Option.HAS_SEEN_PRACTICE_TRAY))
+
+		bool introducingPracticeTray = !Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_TRAY, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "PracticePickerTrayDisplay.Show:" + Option.HAS_SEEN_PRACTICE_TRAY);
+		if (introducingPracticeTray)
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_TRAY, val: true);
 			StartCoroutine(DoPickHeroLines());
@@ -166,7 +168,13 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			m_playButton.Enable();
 		}
 		Navigation.Push(OnNavigateBack);
-	}
+
+		if (!introducingPracticeTray)
+        {
+			// Only read out if we're not going to introduce the tray (see DoPickHeroLines() for that)
+            AccessibleAdventureScene.Get().OnPracticePickerTrayDisplayShown(m_practiceAIButtons);
+        }
+    }
 
 	private IEnumerator DoPickHeroLines()
 	{
@@ -176,11 +184,23 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			yield return null;
 		}
 		yield return new WaitForSeconds(firstPart.GetAudio().clip.length);
-		yield return new WaitForSeconds(6f);
-		if (!m_playButton.IsEnabled() && !GameMgr.Get().IsTransitionPopupShown())
+
+		if (!AccessibilityMgr.IsAccessibilityEnabled())
 		{
-			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_PRACTICE_INST2_08"), "VO_INNKEEPER_PRACTICE_INST2_08.prefab:7f8a9981df8853d44b3cc423d4f44f52", 2f);
+			// Ignore second part ("I'd personally choose Uther") if accessibility is enabled as it might confuse people
+			yield return new WaitForSeconds(6f);
+			if (!m_playButton.IsEnabled() && !GameMgr.Get().IsTransitionPopupShown())
+			{
+				Notification secondPart = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_PRACTICE_INST2_08"), "VO_INNKEEPER_PRACTICE_INST2_08.prefab:7f8a9981df8853d44b3cc423d4f44f52", 2f);
+				while (secondPart.GetAudio() == null)
+				{
+					yield return null;
+				}
+				yield return new WaitForSeconds(secondPart.GetAudio().clip.length);
+			}
 		}
+
+		AccessibleAdventureScene.Get().OnPracticePickerTrayDisplayShown(m_practiceAIButtons);
 	}
 
 	public void Hide()
@@ -230,7 +250,7 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 
 	private void InitButtons()
 	{
-		if (NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>().Levels.Count > 1 && !Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_MODE, defaultVal: false))
+        if (NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>().Levels.Count > 1 && !Options.Get().GetBool(Option.HAS_SEEN_PRACTICE_MODE, defaultVal: false))
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_MODE, val: true);
 		}
@@ -362,14 +382,14 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			PracticeAIButton practiceAIButton = m_practiceAIButtons[i];
 			practiceAIButton.SetInfo(text, @class, disposableFullDef.DisposableCardDef, iD, flip: false);
 			bool shown = false;
-			foreach (Achievement lockedHero in m_lockedHeroes)
-			{
-				if (lockedHero.ClassReward.Value == @class)
-				{
-					shown = true;
-					break;
-				}
-			}
+
+            // "Undefeated" flags are broken on the official game so I had to tweak this
+            NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(@class);
+			if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
+            {
+				shown = true;
+            }
+
 			practiceAIButton.ShowQuestBang(shown);
 			if (practiceAIButton == m_selectedPracticeAIButton)
 			{
diff --git a/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs b/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
index 9726a07..6feb577 100644
--- a/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
+++ b/Decompiled/Assembly-CSharp/PrivacyPolicyPopup.cs
@@ -1,8 +1,9 @@
+using Accessibility;
 using Hearthstone;
 using Hearthstone.UI;
 using UnityEngine;
 
-public class PrivacyPolicyPopup : DialogBase
+public class PrivacyPolicyPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool confirmedPrivacyPolicy);
 
diff --git a/Decompiled/Assembly-CSharp/QuestLog.cs b/Decompiled/Assembly-CSharp/QuestLog.cs
index f7ab00d..60e40ef 100644
--- a/Decompiled/Assembly-CSharp/QuestLog.cs
+++ b/Decompiled/Assembly-CSharp/QuestLog.cs
@@ -405,7 +405,7 @@ public class QuestLog : UIBPopup
 			if (AchieveManager.Get().HasUnlockedFeature(Achieve.Unlocks.DAILY))
 			{
 				m_noQuestText.Text = GameStrings.Get("GLUE_QUEST_LOG_NO_QUESTS_DAILIES_UNLOCKED");
-				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
+				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
 				{
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, 0f, 34.5f), GameStrings.Get("VO_INNKEEPER_OUT_OF_QUESTS"), "VO_INNKEEPER_OUT_OF_QUESTS.prefab:b0073c56bf38c664dab532ad92f3baf9");
 					Options.Get().SetBool(Option.HAS_RUN_OUT_OF_QUESTS, val: true);
diff --git a/Decompiled/Assembly-CSharp/QuestProgressToast.cs b/Decompiled/Assembly-CSharp/QuestProgressToast.cs
index dcc9ec6..2a5eec4 100644
--- a/Decompiled/Assembly-CSharp/QuestProgressToast.cs
+++ b/Decompiled/Assembly-CSharp/QuestProgressToast.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class QuestProgressToast : GameToast
 {
@@ -31,5 +32,15 @@ public class QuestProgressToast : GameToast
 		}
 		m_questTitle.Text = title;
 		m_questDescription.Text = description;
-	}
+
+		// Accessibility
+		if (maxProgress > 1)
+        {
+            AccessibilityMgr.Output($"Quest progress toast: {m_questTitle.Text}; {progress} out of {maxProgress}");
+        }
+		else
+        {
+            AccessibilityMgr.Output($"Quest progress toast: {m_questTitle.Text}");
+        }
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/QuestTile.cs b/Decompiled/Assembly-CSharp/QuestTile.cs
index e2e800d..eff2b53 100644
--- a/Decompiled/Assembly-CSharp/QuestTile.cs
+++ b/Decompiled/Assembly-CSharp/QuestTile.cs
@@ -73,7 +73,7 @@ public class QuestTile : MonoBehaviour
 	[CustomEditField(Sections = "Special Event FX")]
 	public List<SpecialEventFxEntry> m_specialEventFx = new List<SpecialEventFxEntry>();
 
-	private Achievement m_quest;
+	internal Achievement m_quest;
 
 	private bool m_canShowCancelButton;
 
diff --git a/Decompiled/Assembly-CSharp/QuestToast.cs b/Decompiled/Assembly-CSharp/QuestToast.cs
index 12e5f8c..bc29b8b 100644
--- a/Decompiled/Assembly-CSharp/QuestToast.cs
+++ b/Decompiled/Assembly-CSharp/QuestToast.cs
@@ -1,6 +1,7 @@
 using System.Linq;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class QuestToast : MonoBehaviour
 {
@@ -124,7 +125,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToast(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, bool updateCacheValues, Achievement quest, bool fullscreenEffects)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -167,7 +168,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToastPopup(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, RewardData rewardData, string name, string description, bool fullscreenEffects, bool updateCacheValues, Achievement quest)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : string.Concat(rewardData.Origin, ":", rewardData.OriginData, ":", rewardData.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : string.Concat(rewardData.Origin, ":", rewardData.OriginData, ":", rewardData.RewardType))))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -265,6 +266,9 @@ public class QuestToast : MonoBehaviour
 		m_clickCatcher.AddEventListener(UIEventType.RELEASE, CloseQuestToast);
 		m_questName.Text = m_toastName;
 		m_requirement.Text = m_toastDescription;
+		AccessibilityMgr.Output("Popup", true);
+		AccessibilityMgr.Output($"You finished a quest");
+		AccessibilityMgr.Output($"{m_questName.Text}; {m_requirement.Text}");
 		if (m_toastReward != null)
 		{
 			if (SpecialEventManager.Get().IsEventActive(SpecialEventType.SPECIAL_EVENT_GOLD_DOUBLED, activeIfDoesNotExist: false) && m_quest != null && m_quest.IsAffectedByDoubleGold && m_toastReward is GoldRewardData)
diff --git a/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs b/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
index 54f93f0..f665767 100644
--- a/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
+++ b/Decompiled/Assembly-CSharp/RankedBonusStarsPopup.cs
@@ -4,6 +4,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedBonusStarsPopup : BasicPopup
@@ -11,6 +12,7 @@ public class RankedBonusStarsPopup : BasicPopup
 	public class BonusStarsPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+		public BonusStarsPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	public UberText m_descriptionText;
@@ -29,12 +31,18 @@ public class RankedBonusStarsPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+	#region Accessibility
+	private RankedPlayDataModel m_rankedPlayDataModel;
+
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -72,6 +80,8 @@ public class RankedBonusStarsPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -84,16 +94,18 @@ public class RankedBonusStarsPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
 		IncrementBonusStarsPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void OnWidgetReady()
 	{
 		IDataModel model = null;
 		m_widget.GetDataModel(123, out model);
-		RankedPlayDataModel rankedPlayDataModel = model as RankedPlayDataModel;
-		if (rankedPlayDataModel != null && m_descriptionText != null)
+		m_rankedPlayDataModel = model as RankedPlayDataModel;
+		if (m_rankedPlayDataModel != null && m_descriptionText != null)
 		{
-			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", rankedPlayDataModel.StarMultiplier);
+			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", m_rankedPlayDataModel.StarMultiplier);
 		}
 	}
 
@@ -112,4 +124,34 @@ public class RankedBonusStarsPopup : BasicPopup
 			GameSaveDataManager.Get().SaveSubkeys(list);
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_rankedPlayDataModel == null)
+        {
+			return;
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Popup", true);
+		AccessibilityMgr.Output($"Your performance in Ranked last season earned you {m_rankedPlayDataModel.StarMultiplier} star bonus!");
+		AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankedIntroPopup.cs b/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
index cfeeade..4906bac 100644
--- a/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
+++ b/Decompiled/Assembly-CSharp/RankedIntroPopup.cs
@@ -2,6 +2,7 @@ using System;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedIntroPopup : BasicPopup
@@ -9,6 +10,8 @@ public class RankedIntroPopup : BasicPopup
 	public class RankedIntroPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public RankedIntroPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	private const string SHOW_EVENT_NAME = "CODE_DIALOGMANAGER_SHOW";
@@ -23,12 +26,16 @@ public class RankedIntroPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+    #region Accessibility
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -63,6 +70,8 @@ public class RankedIntroPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -75,6 +84,8 @@ public class RankedIntroPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
 		IncrementRankedIntroPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void IncrementRankedIntroPopupSeenCount()
@@ -89,4 +100,30 @@ public class RankedIntroPopup : BasicPopup
 			gameSaveDataManager.SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.RANKED_PLAY, GameSaveKeySubkeyId.RANKED_PLAY_INTRO_SEEN_COUNT, array));
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		AccessibilityMgr.Output("Popup", true);
+		AccessibilityMgr.Output($"The new ranked system is here! You can find more about it online");
+		AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs b/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
index 6409d63..15c7199 100644
--- a/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
+++ b/Decompiled/Assembly-CSharp/RankedRewardDisplay.cs
@@ -5,9 +5,10 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class RankedRewardDisplay : MonoBehaviour
+public class RankedRewardDisplay : MonoBehaviour, AccessibleUI
 {
 	[CustomEditField(Sections = "Animate In")]
 	public Vector3_MobileOverride m_startScale;
@@ -56,6 +57,8 @@ public class RankedRewardDisplay : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (EndGameScreen.Get() != null)
 		{
 			EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
@@ -119,6 +122,8 @@ public class RankedRewardDisplay : MonoBehaviour
 		m_widget.Show();
 		AnimationUtil.ShowWithPunch(base.gameObject, m_startScale, m_punchScale, m_afterPunchScale, "OnShown", noFade: true);
 		m_fsm.SendEvent("Birth");
+
+		ReadRewardDisplay();
 	}
 
 	private void OnShown()
@@ -186,6 +191,8 @@ public class RankedRewardDisplay : MonoBehaviour
 
 	private void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (EndGameScreen.Get() != null)
 		{
 			EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
@@ -240,4 +247,30 @@ public class RankedRewardDisplay : MonoBehaviour
 		FullScreenFXMgr.Get().StopAllEffects();
 		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
 	}
+
+    #region Accessibility
+
+	private void ReadRewardDisplay()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		AccessibilityMgr.Output("Popup", true);
+		AccessibilityMgr.Output("You got a ranked reward but ranked mode is not accessible yet");
+		AccessibilityMgr.Output(GetAccessibleHelp());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+            OnClick(new UIEvent(UIEventType.RELEASE, null));
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return $"Press {AccessibleKey.CONFIRM} to continue";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs b/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
index 6075f06..7f79615 100644
--- a/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
+++ b/Decompiled/Assembly-CSharp/ReconnectHelperDialog.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Hearthstone;
 using UnityEngine;
 
@@ -23,7 +24,8 @@ public class ReconnectHelperDialog : DialogBase
 		BAD_VERSION_CAN_RESET,
 		BAD_VERSION_USE_LAUNCHER,
 		INACTIVE_TIMEOUT,
-		RESTART_REQUIRED
+		RESTART_REQUIRED,
+		EOE
 	}
 
 	private class Layout
@@ -47,9 +49,13 @@ public class ReconnectHelperDialog : DialogBase
 		public Action m_choiceButtonTwoAction;
 
 		public Action m_onInit;
-	}
 
-	public UIBButton m_continueButton;
+        #region Accessibility
+        public string m_accessibleMenuText = "Connection lost";
+        #endregion
+    }
+
+    public UIBButton m_continueButton;
 
 	public UIBButton m_choiceOneButton;
 
@@ -171,6 +177,7 @@ public class ReconnectHelperDialog : DialogBase
 	{
 		m_stateLayouts[DialogState.PROMPT] = new Layout
 		{
+			m_accessibleMenuText = "You are current offline. You must reconnect in order to play",
 			m_activePanel = m_reconnectPromptPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -187,6 +194,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.FAILURE] = new Layout
 		{
+			m_accessibleMenuText = "Failed to reconnect",
 			m_activePanel = m_reconnectFailurePanel,
 			m_twoButtons = true,
 			m_successRingState = SpellStateType.DEATH,
@@ -197,6 +205,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.WIFI_DISABLED] = new Layout
 		{
+			m_accessibleMenuText = "Please verify that your device has Internet access and try again",
 			m_activePanel = m_wifiDisabledPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -206,6 +215,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_CAN_RESET] = new Layout
 		{
+			m_accessibleMenuText = "New version available. You must update before you can proceed. Remember to patch Hearthstone for accessibility again afterwards",
 			m_activePanel = m_badVersionCanResetPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_UPDATE"),
@@ -215,6 +225,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_USE_LAUNCHER] = new Layout
 		{
+			m_accessibleMenuText = "New version available. Please relaunch Hearthstone to pick up the latest update. Remember to patch it for accessibility again afterwards",
 			m_activePanel = m_badVersionUseLauncherPanel,
 			m_twoButtons = false,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -223,6 +234,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.INACTIVE_TIMEOUT] = new Layout
 		{
+			m_accessibleMenuText = "Your connection was shut down due to inactivity so you are currently offline",
 			m_activePanel = m_inactiveTimeoutPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -232,6 +244,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.RESTART_REQUIRED] = new Layout
 		{
+			m_accessibleMenuText = "Unable to reconnect. Please relaunch Hearthstone",
 			m_activePanel = m_restartRequiredPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get(HearthstoneApplication.AllowResetFromFatalError ? "GLUE_RECONNECT_HELPER_RESTART_GAME" : "GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -272,9 +285,11 @@ public class ReconnectHelperDialog : DialogBase
 		{
 			layout.m_onInit();
 		}
+
+		ReadAccessibleDialog();
 	}
 
-	private void ChangeStateToPromptBasedOnReconnectMgr()
+    private void ChangeStateToPromptBasedOnReconnectMgr()
 	{
 		if (ReconnectMgr.Get().FullResetRequired)
 		{
@@ -355,6 +370,7 @@ public class ReconnectHelperDialog : DialogBase
 	private void OnReconnectSuccess()
 	{
 		ReconnectMgr.Get().SetNextReLoginCallback(m_reconnectSuccessCallback);
+		AccessibilityMgr.Output("Reconnected");
 		Hide();
 	}
 
@@ -403,4 +419,62 @@ public class ReconnectHelperDialog : DialogBase
 			ChangeState_FullResetRequired();
 		}
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    private void ReadAccessibleDialog()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			AccessibilityMgr.Output("Reconnecting");
+			return;
+        }
+
+		Layout layout = m_stateLayouts[m_state];
+		m_accessibleMenu = new AccessibleMenu("Options", null, true);
+
+		if (m_continueButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_continueButton.GetText(), () => m_continueButton.TriggerRelease());
+        }
+
+		if (m_choiceOneButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceOneButton.GetText(), () => m_choiceOneButton.TriggerRelease());
+        }
+
+		if (m_choiceTwoButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Reconnect dialog", true);
+		AccessibilityMgr.Output($"{layout?.m_accessibleMenuText}");
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return;
+        }
+
+        m_accessibleMenu.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return "Reconnecting. Please wait";
+        }
+
+		return AccessibleSpeech.MENU_HELP(false);
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/ReconnectMgr.cs b/Decompiled/Assembly-CSharp/ReconnectMgr.cs
index 59b4b2a..2dbf7a7 100644
--- a/Decompiled/Assembly-CSharp/ReconnectMgr.cs
+++ b/Decompiled/Assembly-CSharp/ReconnectMgr.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using bgs;
 using bgs.types;
 using Blizzard.T5.Jobs;
@@ -755,6 +756,8 @@ public class ReconnectMgr : IService, IHasUpdate
 
 	private void ChangeGameplayDialogToReconnected()
 	{
+		AccessibleGameplay.Get().OnReconnected();
+
 		if (!(m_gameplayReconnectDialog == null))
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
diff --git a/Decompiled/Assembly-CSharp/Reward.cs b/Decompiled/Assembly-CSharp/Reward.cs
index e152387..e6f50bf 100644
--- a/Decompiled/Assembly-CSharp/Reward.cs
+++ b/Decompiled/Assembly-CSharp/Reward.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public abstract class Reward : MonoBehaviour
+public abstract class Reward : MonoBehaviour, AccessibleUI
 {
 	public enum Type
 	{
@@ -11,19 +12,20 @@ public abstract class Reward : MonoBehaviour
 		BOOSTER_PACK,
 		CARD,
 		CARD_BACK,
-		CRAFTABLE_CARD,
-		FORGE_TICKET,
+		CRAFTABLE_CARD, // Not implemented
+		FORGE_TICKET, // Not implemented
 		GOLD,
 		MOUNT,
-		CLASS_CHALLENGE,
-		EVENT,
-		RANDOM_CARD,
-		BONUS_CHALLENGE,
-		ADVENTURE_DECK,
-		ADVENTURE_HERO_POWER,
+		CLASS_CHALLENGE, // Not implemented
+		EVENT, // Not implemented
+		RANDOM_CARD, // Not implemented
+		BONUS_CHALLENGE, // Not implemented
+		ADVENTURE_DECK, // Not implemented
+		ADVENTURE_HERO_POWER, // Not implemented
 		ARCANE_ORBS,
-		DECK,
-		MINI_SET
+		DECK, // Not implemented
+		MINI_SET,
+		EOE
 	}
 
 	public delegate void DelOnRewardLoaded(Reward reward, object callbackData);
@@ -124,9 +126,10 @@ public abstract class Reward : MonoBehaviour
 
 	protected virtual void OnDestroy()
 	{
-	}
+        AccessibilityMgr.HideUI(this);
+    }
 
-	public void Show(bool updateCacheValues)
+    public void Show(bool updateCacheValues)
 	{
 		Data.AcknowledgeNotices();
 		if (m_MeshRoot != null)
@@ -154,6 +157,8 @@ public abstract class Reward : MonoBehaviour
 		}
 		ShowReward(updateCacheValues);
 		m_shown = true;
+
+		ReadReward();
 	}
 
 	protected virtual void PlayShowSounds()
@@ -180,10 +185,14 @@ public abstract class Reward : MonoBehaviour
 			}
 		}
 		iTween.FadeTo(base.gameObject, 0f, RewardUtils.REWARD_HIDE_TIME);
+		AccessibilityMgr.HideUI(this);
+
 	}
 
 	public virtual void Hide(bool animate = false)
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (!animate)
 		{
 			OnHideAnimateComplete();
@@ -336,10 +345,45 @@ public abstract class Reward : MonoBehaviour
 
 	private void OnHide()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		OnHideListener[] array = m_hideListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
 			array[i].Fire();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleRewardData m_accessibleReward;
+
+	private void ReadReward()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleReward = new AccessibleRewardData(m_data);
+
+		AccessibilityMgr.Output("You got a reward!");
+		m_accessibleReward.ReadAllLines();
+    }
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			AccessibleInputMgr.ClickCenterOfScreen();
+        }
+        else
+        {
+			m_accessibleReward.HandleAccessibleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return $"Use the arrow keys to read the reward. Press {AccessibleKey.CONFIRM} to continue";
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs b/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
index d3fbb55..6517666 100644
--- a/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
+++ b/Decompiled/Assembly-CSharp/RewardBoxesDisplay.cs
@@ -3,9 +3,10 @@ using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class RewardBoxesDisplay : MonoBehaviour
+public class RewardBoxesDisplay : MonoBehaviour, AccessibleUI
 {
 	[Serializable]
 	public class RewardPackageData
@@ -113,6 +114,11 @@ public class RewardBoxesDisplay : MonoBehaviour
 
 	private List<RewardData> CurrentPageRewards => m_rewards.Skip(m_RewardSet.m_MaxPackagesPerPage * m_currentPageNum).Take(m_RewardSet.m_MaxPackagesPerPage).ToList();
 
+	#region Accessibility
+	private List<RewardBoxData> m_rewardsBoxData = new List<RewardBoxData>();
+	private int m_pendingAnimations;
+	#endregion
+
 	public bool IsClosing { get; private set; }
 
 	private void Awake()
@@ -222,6 +228,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 
 	public void AnimateRewards()
 	{
+		AccessibilityMgr.ShowUI(this);
+
 		List<RewardData> currentPageRewards = CurrentPageRewards;
 		int count = currentPageRewards.Count;
 		m_RewardPackages = GetPackageData(count);
@@ -286,6 +294,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			}
 		}
 		m_rewardPackageInstances.Clear();
+		m_rewardsBoxData.Clear(); // Accessibility
+		m_pendingAnimations = 0;
 		for (int i = 0; i < m_RewardPackages.Count; i++)
 		{
 			RewardPackageData rewardPackageData = m_RewardPackages[i];
@@ -321,6 +331,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			rewardBoxData.m_RewardPackage = component2;
 			rewardBoxData.m_FSM = component;
 			rewardBoxData.m_Index = i;
+			m_rewardsBoxData.Add(rewardBoxData);
+			m_pendingAnimations++;
 			iTween.MoveTo(gameObject, iTween.Hash("position", rewardPackageData.m_TargetBone.transform.position, "time", m_RewardSet.m_AnimationTime, "delay", rewardPackageData.m_StartDelay, "easetype", iTween.EaseType.linear, "onstarttarget", base.gameObject, "onstart", "RewardPackageOnStart", "onstartparams", rewardBoxData, "oncompletetarget", base.gameObject, "oncomplete", "RewardPackageOnComplete", "oncompleteparams", rewardBoxData));
 		}
 	}
@@ -340,9 +352,10 @@ public class RewardBoxesDisplay : MonoBehaviour
 		yield return new WaitForSeconds(0.5f);
 		SceneUtils.EnableColliders(boxData.m_GameObject, enable: true);
 		boxData.m_RewardPackage.AddEventListener(UIEventType.PRESS, RewardPackagePressed);
+		OnRewardPackageActivated();
 	}
 
-	private void RewardPackagePressed(UIEvent e)
+    private void RewardPackagePressed(UIEvent e)
 	{
 		Log.RewardBox.Print("box clicked!");
 	}
@@ -495,6 +508,7 @@ public class RewardBoxesDisplay : MonoBehaviour
 		{
 			FadeFullscreenEffectsOut();
 			Navigation.GoBack();
+			AccessibilityMgr.HideUI(this);
 			return;
 		}
 		m_currentPageNum++;
@@ -684,4 +698,116 @@ public class RewardBoxesDisplay : MonoBehaviour
 			Debug.Log($"  reward {i}={arg}");
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleRewardPackage> m_accessibleRewardPackages;
+
+    private void OnRewardPackageActivated()
+    {
+		m_pendingAnimations--;
+
+		if (m_pendingAnimations == 0)
+        {
+			List<AccessibleRewardPackage> rewardPackages = new List<AccessibleRewardPackage>(m_rewardsBoxData.Count);
+			m_rewardsBoxData.ForEach(r => rewardPackages.Add(new AccessibleRewardPackage(r, CurrentPageRewards[r.m_RewardPackage.m_RewardIndex])));
+			m_accessibleRewardPackages = new AccessibleListOfItems<AccessibleRewardPackage>(rewardPackages);
+
+			var numRewardPackages = m_rewardsBoxData.Count;
+
+			if (numRewardPackages > 1)
+            {
+                AccessibilityMgr.Output($"You got {numRewardPackages} reward packages!");
+            }
+			else
+            {
+                AccessibilityMgr.Output($"You got {numRewardPackages} reward package!");
+            }
+            m_accessibleRewardPackages.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (AllPackagesOpened())
+            {
+                m_DoneButton.TriggerRelease();
+            }
+			else
+            {
+                var focusedPackage = m_accessibleRewardPackages.GetItemBeingRead();
+
+                if (!focusedPackage.Open)
+                {
+                    focusedPackage.RewardBoxData.m_RewardPackage.TriggerPress();
+                    focusedPackage.Open = true;
+                    focusedPackage.ReadAllLines();
+
+                    OnRewardPackageOpened();
+                }
+            }
+        }
+		else
+        {
+			m_accessibleRewardPackages?.HandleAccessibleInput();
+        }
+    }
+
+    private void OnRewardPackageOpened()
+    {
+		if (AllPackagesOpened())
+        {
+            AccessibilityMgr.Output(GetAccessibleHelp());
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return "Please wait";
+        }
+		else if (AllPackagesOpened())
+        {
+            return $"Press {AccessibleKey.CONFIRM} to continue";
+        }
+        else
+        {
+			return $"Use the arrow keys and {AccessibleKey.CONFIRM} to open your rewards";
+        }
+    }
+
+	private bool AllPackagesOpened()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return false;
+        }
+
+		return GetNumOpenPackages() == m_rewardsBoxData.Count;
+    }
+
+    private int GetNumOpenPackages()
+    {
+        if (m_accessibleRewardPackages == null)
+        {
+			return 0;
+        }
+		else
+        {
+			var ret = 0;
+			foreach (var package in m_accessibleRewardPackages.Items)
+            {
+				if (package.Open)
+                {
+					ret++;
+                }
+            }
+
+			return ret;
+        }
+    }
+
+    #endregion
 }
diff --git a/Decompiled/Assembly-CSharp/RewardItemType.cs b/Decompiled/Assembly-CSharp/RewardItemType.cs
index ab7b3da..1430a88 100644
--- a/Decompiled/Assembly-CSharp/RewardItemType.cs
+++ b/Decompiled/Assembly-CSharp/RewardItemType.cs
@@ -22,5 +22,6 @@ public enum RewardItemType
 	CARD_SUBSET = 19,
 	SELLABLE_DECK = 20,
 	BATTLEGROUNDS_HERO_SKIN = 27,
-	BATTLEGROUNDS_GUIDE_SKIN = 28
+	BATTLEGROUNDS_GUIDE_SKIN = 28,
+	EOE = 29
 }
diff --git a/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs b/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
index 3679527..b9a74a3 100644
--- a/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
+++ b/Decompiled/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
@@ -46,7 +46,7 @@ public class RewardTrackForgotRewardsPopup : MonoBehaviour
 		m_widget.Show();
 	}
 
-	public void Hide()
+    public void Hide()
 	{
 		m_widget.GetComponentInParent<RewardTrackSeasonRoll>();
 		m_widget.Hide();
diff --git a/Decompiled/Assembly-CSharp/RewardUtils.cs b/Decompiled/Assembly-CSharp/RewardUtils.cs
index d712b28..8e2a84a 100644
--- a/Decompiled/Assembly-CSharp/RewardUtils.cs
+++ b/Decompiled/Assembly-CSharp/RewardUtils.cs
@@ -913,7 +913,7 @@ public class RewardUtils
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : string.Concat(reward.Data.Origin, ":", reward.Data.OriginData, ":", reward.Data.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : string.Concat(reward.Data.Origin, ":", reward.Data.OriginData, ":", reward.Data.RewardType))))
 		{
 			return false;
 		}
diff --git a/Decompiled/Assembly-CSharp/ScenarioDbId.cs b/Decompiled/Assembly-CSharp/ScenarioDbId.cs
index c37c1c4..a86f238 100644
--- a/Decompiled/Assembly-CSharp/ScenarioDbId.cs
+++ b/Decompiled/Assembly-CSharp/ScenarioDbId.cs
@@ -552,5 +552,6 @@ public enum ScenarioDbId
 	TB_RumbleDome = 3710,
 	TB_Rumbledome_1p = 3713,
 	PVPDR_Tavern = 3745,
-	PVPDR_Season_1 = 3466
+	PVPDR_Season_1 = 3466,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/SceneMgr.cs b/Decompiled/Assembly-CSharp/SceneMgr.cs
index 83c258a..aecafe9 100644
--- a/Decompiled/Assembly-CSharp/SceneMgr.cs
+++ b/Decompiled/Assembly-CSharp/SceneMgr.cs
@@ -904,7 +904,7 @@ public class SceneMgr : IService, IHasUpdate
 
 	private void OnFatalError(FatalErrorMessage message, object userData)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			Log.Offline.Print("SceneMgr.OnFatalError: Error blocked by set rotation.");
 			SetNextMode(Mode.FATAL_ERROR);
@@ -955,7 +955,7 @@ public class SceneMgr : IService, IHasUpdate
 		}
 	}
 
-	private void GoToFatalErrorScreen(FatalErrorMessage message)
+	internal void GoToFatalErrorScreen(FatalErrorMessage message)
 	{
 		if (HearthstoneApplication.Get().ResetOnErrorIfNecessary())
 		{
diff --git a/Decompiled/Assembly-CSharp/ScrollbarControl.cs b/Decompiled/Assembly-CSharp/ScrollbarControl.cs
index 3770e48..38102ce 100644
--- a/Decompiled/Assembly-CSharp/ScrollbarControl.cs
+++ b/Decompiled/Assembly-CSharp/ScrollbarControl.cs
@@ -158,7 +158,7 @@ public class ScrollbarControl : MonoBehaviour
 		FireFinishEvent();
 	}
 
-	private void FireUpdateEvent()
+	internal void FireUpdateEvent()
 	{
 		if (m_updateHandler != null)
 		{
@@ -166,7 +166,7 @@ public class ScrollbarControl : MonoBehaviour
 		}
 	}
 
-	private void FireFinishEvent()
+	internal void FireFinishEvent()
 	{
 		if (m_finishHandler != null)
 		{
diff --git a/Decompiled/Assembly-CSharp/SeasonEndDialog.cs b/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
index 6cdb353..294a1ff 100644
--- a/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
+++ b/Decompiled/Assembly-CSharp/SeasonEndDialog.cs
@@ -6,6 +6,7 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class SeasonEndDialog : DialogBase
 {
@@ -38,7 +39,8 @@ public class SeasonEndDialog : DialogBase
 		REDUCED_WELCOME,
 		REMINDER_CHEST,
 		STAR_MULTIPLIER,
-		REMINDER_CARDBACK
+		REMINDER_CARDBACK,
+		EOE
 	}
 
 	public GameObject m_root;
@@ -177,6 +179,8 @@ public class SeasonEndDialog : DialogBase
 
 	private const string REWARD_CHEST_EARNED_STRING_FORMAT = "GLOBAL_REWARD_CHEST_TIER{0}_EARNED";
 
+	private const string REWARD_CHEST_WIDGET_OPEN_EVENT_NAME = "CLICKED";
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -342,8 +346,9 @@ public class SeasonEndDialog : DialogBase
 			m_currentMode = MODE.CHEST_EARNED;
 			m_medalPlayMaker.SendEvent("RevealRewardChest");
 			iTween.FadeTo(m_rankAchieved.gameObject, 0f, 0.5f);
-		}
-		else
+			HandleAccessibility();
+        }
+        else
 		{
 			GotoBonusStarsOrWelcome();
 		}
@@ -391,11 +396,13 @@ public class SeasonEndDialog : DialogBase
 
 	public void GoToStarMultiplier()
 	{
-		m_currentMode = MODE.STAR_MULTIPLIER;
+        m_currentMode = MODE.STAR_MULTIPLIER;
 		m_welcomeItems.SetActive(value: false);
+        HandleAccessibility();
+
 		if (m_skipRankedIntroPopup)
 		{
-			StartCoroutine(DoPageTear());
+            StartCoroutine(DoPageTear());
 			return;
 		}
 		HideRewardChestPage();
@@ -405,9 +412,9 @@ public class SeasonEndDialog : DialogBase
 		StartCoroutine(FadeWidgetIn(m_starMultiplierWidget, 0f));
 		iTween.FadeTo(m_bonusStarItems, 1f, 0f);
 		EnableOkayButton();
-	}
+    }
 
-	public void GotoReducedMedal()
+    public void GotoReducedMedal()
 	{
 		m_currentMode = MODE.REDUCED_WELCOME;
 		StartCoroutine(DoPageTear());
@@ -418,9 +425,10 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarLabel.Text = m_currentMedalInfo.GetRankName();
 		m_bonusStarTitle.Text = GameStrings.Get("GLOBAL_SEASON_END_BONUS_STAR_TITLE");
 		UpdateBonusStarFinePrint();
-	}
+        HandleAccessibility();
+    }
 
-	public void GotoChestReminder()
+    public void GotoChestReminder()
 	{
 		m_currentMode = MODE.REMINDER_CHEST;
 		HideRewardChestPage();
@@ -428,19 +436,21 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
 		int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
-		m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
-	}
+        m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
+        HandleAccessibility();
+    }
 
-	public void GoToCardBackReminder()
+    public void GoToCardBackReminder()
 	{
 		m_currentMode = MODE.REMINDER_CARDBACK;
 		HideRewardChestPage();
 		m_welcomeItems.SetActive(value: false);
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
-	}
+        HandleAccessibility();
+    }
 
-	public void GoToRankedIntroPopUp()
+    public void GoToRankedIntroPopUp()
 	{
 		iTween.ScaleTo(m_root, new Vector3(0f, 0f, 0f), 0.5f);
 		m_rankedIntroPopUpWidget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
@@ -459,9 +469,10 @@ public class SeasonEndDialog : DialogBase
 		HideRewardChestPage();
 		m_bonusStarItems.SetActive(value: false);
 		m_welcomeDetails.Text = GameStrings.Format("GLOBAL_SEASON_END_NEW_SEASON", newSeasonName);
-	}
+		HandleAccessibility();
+    }
 
-	public IEnumerator DoPageTear()
+    public IEnumerator DoPageTear()
 	{
 		m_medalPlayMaker.SendEvent("PageTear");
 		yield return new WaitForSeconds(0.69f);
@@ -538,6 +549,8 @@ public class SeasonEndDialog : DialogBase
 		DoShowAnimation();
 		UniversalInputManager.Get().SetGameDialogActive(active: true);
 		SoundManager.Get().LoadAndPlay("rank_window_expand.prefab:9f3f1c260a5d8b34f9705caf4925f5cb");
+
+		HandleAccessibility();
 	}
 
 	public override void Hide()
@@ -794,7 +807,7 @@ public class SeasonEndDialog : DialogBase
 
 	private void RankedChestEventListener(string eventName)
 	{
-		if (eventName.Equals("CLICKED") && !m_chestOpened)
+		if (eventName.Equals(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME) && !m_chestOpened)
 		{
 			m_chestOpened = true;
 			PlayMakerFSM componentInChildren = m_rankedRewardChestWidget.GetComponentInChildren<PlayMakerFSM>();
@@ -907,4 +920,108 @@ public class SeasonEndDialog : DialogBase
 		m_showAnimState = ShowAnimState.IN_PROGRESS;
 		AnimationUtil.ShowWithPunch(base.gameObject, START_SCALE, Vector3.Scale(PUNCH_SCALE, m_originalScale), m_originalScale, "OnShowAnimFinished", noFade: true);
 	}
+
+	private void HandleAccessibility()
+    {
+        switch (m_currentMode)
+        {
+            case MODE.RANK_EARNED:
+				AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output("Popup", true);
+                AccessibilityMgr.Output($"{GetSeasonName(m_seasonEndInfo.m_seasonID)} has ended. You achieved the rank of {m_seasonBestMedalInfo.GetRankName()}");
+				AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.CHEST_EARNED:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output("Popup", true);
+                AccessibilityMgr.Output($"You have earned a rewards chest");
+                AccessibilityMgr.Output($"Press {AccessibleKey.CONFIRM} to open");
+                break;
+            case MODE.SEASON_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output("Popup", true);
+                AccessibilityMgr.Output($"The {GetSeasonName(m_rewardProgress.Season)} has begun!");
+				AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REDUCED_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output("Popup", true);
+                AccessibilityMgr.Output($"A new season has begun!");
+				AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CHEST:
+                int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output("Popup", true);
+                AccessibilityMgr.Output($"Win {seasonRollRewardMinWins} games this Season to earn a chest");
+				AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.STAR_MULTIPLIER:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output("Popup", true);
+                AccessibilityMgr.Output($"Your performance in Ranked last season earned you a Star Bonus of {m_currentMedalInfo.starsPerWin} stars per win");
+				AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CARDBACK:
+                int seasonCardBackMinWins = RankMgr.Get().GetLocalPlayerMedalInfo().GetSeasonCardBackMinWins();
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output("Popup", true);
+                AccessibilityMgr.Output($"Win {seasonCardBackMinWins} games this Season to earn your Season Card Back");
+				AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            default:
+                break;
+        }
+    }
+
+	private PegUIElement GetNextChest()
+    {
+		if (m_rewardChestLegacy != null)
+		{
+			return m_rewardChestLegacy;
+		}
+
+		foreach (var chest in m_rewardChests)
+		{
+			if (chest.gameObject.activeInHierarchy)
+            {
+				return chest;
+            }
+		}
+
+		return m_okayButton;
+    }
+
+	public override void HandleAccessibleInput()
+    {
+		if (m_currentMode == MODE.CHEST_EARNED && AccessibleKey.CONFIRM.IsPressed())
+		{
+			if (m_rewardChestLegacy != null)
+            {
+				m_rewardChestLegacy.TriggerRelease();
+				return;
+            }
+
+			if (!m_chestOpened)
+            {
+                m_rankedRewardChestWidget.TriggerEvent(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME);
+            }
+        }
+        else if (AccessibleKey.CONFIRM.IsPressed())
+		{
+            m_okayButton.TriggerRelease();
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+        if (m_currentMode == MODE.CHEST_EARNED)
+        {
+			return $"Press {AccessibleKey.CONFIRM} to open";
+        }
+		else
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/SetRotationManager.cs b/Decompiled/Assembly-CSharp/SetRotationManager.cs
index 6d315e0..fc166e0 100644
--- a/Decompiled/Assembly-CSharp/SetRotationManager.cs
+++ b/Decompiled/Assembly-CSharp/SetRotationManager.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class SetRotationManager : IService
 {
@@ -76,7 +77,13 @@ public class SetRotationManager : IService
 
 	public static bool ShouldShowSetRotationIntro()
 	{
-		if (ReturningPlayerMgr.Get().IsInReturningPlayerMode)
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Not implemented yet - making the clock accessible would be quite tricky
+            return false;
+        }
+
+        if (ReturningPlayerMgr.Get().IsInReturningPlayerMode)
 		{
 			return false;
 		}
@@ -205,7 +212,7 @@ public class SetRotationManager : IService
 		{
 			return false;
 		}
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo("Welcome back! New cards have arrived! Some of your older cards now require completion of Apprenticeship to play.");
 		popupInfo.m_prefabAssetRefs.Add("SetRotationNewPlayerPopup.prefab:cb6eb3b3df79ec34f826043f13e9a609");
 		popupInfo.m_blurWhenShown = true;
 		if (!RankMgr.Get().UseLegacyRankedPlay())
diff --git a/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs b/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
index e3788b7..f1476cd 100644
--- a/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
+++ b/Decompiled/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class SetRotationRotatedBoostersPopup : BasicPopup
@@ -11,6 +12,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 	public class SetRotationRotatedBoostersPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public SetRotationRotatedBoostersPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	private Widget m_widget;
@@ -25,12 +28,18 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 
 	private SetRotationRotatedBoostersPopupInfo m_info;
 
+    #region Accessibility
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+
+	private PackListDataModel m_packListDataModel;
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -55,6 +64,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 			}
 			Hashtable args = iTween.Hash("scale", localScale, "time", 0.3f, "easetype", iTween.EaseType.easeOutBack);
 			iTween.ScaleTo(base.gameObject, args);
+
+			ReadPopup();
 		}
 	}
 
@@ -66,11 +77,13 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 			setRotationRotatedBoostersPopupInfo.m_onHiddenCallback();
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void BindRankedPackListDataModel()
 	{
-		PackListDataModel packListDataModel = new PackListDataModel();
+		m_packListDataModel = new PackListDataModel();
 		SpecialEventManager events = SpecialEventManager.Get();
 		List<BoosterDbfRecord> records = GameDbf.Booster.GetRecords((BoosterDbfRecord r) => events.IsEventActive(r.BuyWithGoldEvent, activeIfDoesNotExist: false));
 		records.Sort((BoosterDbfRecord a, BoosterDbfRecord b) => b.LatestExpansionOrder.CompareTo(a.LatestExpansionOrder));
@@ -81,13 +94,52 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 				PackDataModel packDataModel = new PackDataModel();
 				packDataModel.Type = (BoosterDbId)item.ID;
 				packDataModel.BoosterName = item.Name;
-				packListDataModel.Packs.Insert(0, packDataModel);
-				if (packListDataModel.Packs.Count >= 3)
+				m_packListDataModel.Packs.Insert(0, packDataModel);
+				if (m_packListDataModel.Packs.Count >= 3)
 				{
 					break;
 				}
 			}
 		}
-		m_widget.BindDataModel(packListDataModel);
+		m_widget.BindDataModel(m_packListDataModel);
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_widget == null || m_packListDataModel == null)
+        {
+			return;
+        }
+
+		var packNames = new List<string>();
+
+		foreach (var pack in m_packListDataModel.Packs)
+		{
+			packNames.Add(pack.BoosterName);
+		}
+
+		var packNamesList = AccessibleSpeechUtils.HumanizeList(packNames);
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output("Popup", true);
+		AccessibilityMgr.Output($"The following sets are now Wild: {packNamesList}");
+		AccessibilityMgr.Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/SocialToastMgr.cs b/Decompiled/Assembly-CSharp/SocialToastMgr.cs
index 05df5d7..bafbe4e 100644
--- a/Decompiled/Assembly-CSharp/SocialToastMgr.cs
+++ b/Decompiled/Assembly-CSharp/SocialToastMgr.cs
@@ -162,7 +162,7 @@ public class SocialToastMgr : MonoBehaviour
 
 	public void AddToast(UserAttentionBlocker blocker, string textArg, TOAST_TYPE toastType, float displayTime, bool playSound)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "SocialToastMgr.AddToast:" + toastType))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, blocker, "SocialToastMgr.AddToast:" + toastType))
 		{
 			return;
 		}
diff --git a/Decompiled/Assembly-CSharp/SoundManager.cs b/Decompiled/Assembly-CSharp/SoundManager.cs
index 57977a9..68a0635 100644
--- a/Decompiled/Assembly-CSharp/SoundManager.cs
+++ b/Decompiled/Assembly-CSharp/SoundManager.cs
@@ -11,6 +11,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 {
@@ -711,8 +712,8 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			SoundLoadContext soundLoadContext = new SoundLoadContext();
 			soundLoadContext.Init(parent, volume, callback, callbackData);
 			SoundLoader.LoadSound(assetRef, OnLoadAndPlaySoundLoaded, soundLoadContext, GetPlaceholderSound());
-		}
-	}
+        }
+    }
 
 	public void PlayPreloaded(AudioSource source)
 	{
@@ -744,7 +745,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 		InitSourceTransform(source, parentObject);
 		m_generatedSources.Add(source);
 		Play(source);
-	}
+    }
 
 	public AudioSource PlayClip(SoundPlayClipArgs args, bool createNewSource = true, SoundOptions options = null)
 	{
@@ -849,7 +850,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			return;
 		}
 		RegisterSourceBundle(assetRef, component);
-		component.volume = 0f;
+        component.volume = 0f;
 		component.Play();
 		component.Stop();
 		UnregisterSourceBundle(assetRef.ToString(), component);
@@ -2103,7 +2104,14 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			}
 			HearthstoneApplication.Get().StartCoroutine(EnableInstanceLimitedSound(source.gameObject.name, num2));
 		}
-		source.Play();
+
+		if (HearthstoneAccessConstants.DEBUG_SOUND)
+        {
+            AccessibilityUtils.LogDebug($"Playing sound: {source.name}");
+			AccessibilityUtils.LogDebug(Environment.StackTrace);
+        }
+
+        source.Play();
 		return source;
 	}
 
diff --git a/Decompiled/Assembly-CSharp/SpectatorManager.cs b/Decompiled/Assembly-CSharp/SpectatorManager.cs
index 360b283..c02c86e 100644
--- a/Decompiled/Assembly-CSharp/SpectatorManager.cs
+++ b/Decompiled/Assembly-CSharp/SpectatorManager.cs
@@ -2294,7 +2294,7 @@ public class SpectatorManager
 					Processor.CancelScheduledCallback(SpectatePlayer_RequestInvite_OpposingSide_Timeout);
 				}
 			}
-			else if (!UserAttentionManager.CanShowAttentionGrabber("SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
+			else if (!UserAttentionManager.CanShowAttentionGrabber(false, "SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
 			{
 				flag3 = true;
 				text = "user_attention_blocked";
diff --git a/Decompiled/Assembly-CSharp/SubSpellController.cs b/Decompiled/Assembly-CSharp/SubSpellController.cs
index 04daa09..fb5629e 100644
--- a/Decompiled/Assembly-CSharp/SubSpellController.cs
+++ b/Decompiled/Assembly-CSharp/SubSpellController.cs
@@ -68,7 +68,7 @@ public class SubSpellController : SpellController
 		{
 			CheckForSubSpellEnd(taskList);
 		}
-		return num;
+        return num;
 	}
 
 	private SubSpellInstance GetSubSpellInstanceForTasklist(PowerTaskList taskList)
diff --git a/Decompiled/Assembly-CSharp/TAG_CLASS.cs b/Decompiled/Assembly-CSharp/TAG_CLASS.cs
index 25a920d..093b6c4 100644
--- a/Decompiled/Assembly-CSharp/TAG_CLASS.cs
+++ b/Decompiled/Assembly-CSharp/TAG_CLASS.cs
@@ -14,5 +14,6 @@ public enum TAG_CLASS
 	DREAM,
 	NEUTRAL,
 	WHIZBANG,
-	DEMONHUNTER
+	DEMONHUNTER,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_STEP.cs b/Decompiled/Assembly-CSharp/TAG_STEP.cs
index 110d6bb..e3a41f1 100644
--- a/Decompiled/Assembly-CSharp/TAG_STEP.cs
+++ b/Decompiled/Assembly-CSharp/TAG_STEP.cs
@@ -17,5 +17,6 @@ public enum TAG_STEP
 	FINAL_WRAPUP,
 	FINAL_GAMEOVER,
 	MAIN_CLEANUP,
-	MAIN_START_TRIGGERS
+	MAIN_START_TRIGGERS,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TAG_ZONE.cs b/Decompiled/Assembly-CSharp/TAG_ZONE.cs
index d0c316d..d9ee97b 100644
--- a/Decompiled/Assembly-CSharp/TAG_ZONE.cs
+++ b/Decompiled/Assembly-CSharp/TAG_ZONE.cs
@@ -8,5 +8,6 @@ public enum TAG_ZONE
 	REMOVEDFROMGAME,
 	SETASIDE,
 	SECRET,
-	STUB_ZONE_8
+	STUB_ZONE_8,
+	EOE
 }
diff --git a/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs b/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
index 8d16778..36935c0 100644
--- a/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
+++ b/Decompiled/Assembly-CSharp/TavernBrawlDisplay.cs
@@ -310,7 +310,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 			return;
 		}
 		UpdateRecordUI();
-		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
+		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
 		{
 			m_firstTimeIntroductionPopupShowing = true;
 			StartCoroutine(DoFirstTimeHeroicIntro());
@@ -916,7 +916,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 		{
 			return;
 		}
-		bool flag = UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.Show");
+		bool flag = UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.Show");
 		int latestSeenTavernBrawlChalkboard = TavernBrawlManager.Get().LatestSeenTavernBrawlChalkboard;
 		if (latestSeenTavernBrawlChalkboard == 0)
 		{
diff --git a/Decompiled/Assembly-CSharp/TooltipPanelManager.cs b/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
index bc0fba7..3c22610 100644
--- a/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
+++ b/Decompiled/Assembly-CSharp/TooltipPanelManager.cs
@@ -947,4 +947,13 @@ public class TooltipPanelManager : MonoBehaviour
 		}
 		return result;
 	}
+
+	#region Accessibility
+
+	internal List<TooltipPanel> GetTooltipPanels()
+    {
+		return m_tooltipPanels;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TournamentDisplay.cs b/Decompiled/Assembly-CSharp/TournamentDisplay.cs
index 5502edf..6595454 100644
--- a/Decompiled/Assembly-CSharp/TournamentDisplay.cs
+++ b/Decompiled/Assembly-CSharp/TournamentDisplay.cs
@@ -47,7 +47,7 @@ public class TournamentDisplay : MonoBehaviour
 	private void OnDestroy()
 	{
 		s_instance = null;
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		UnregisterListeners();
 	}
 
diff --git a/Decompiled/Assembly-CSharp/TurnStartManager.cs b/Decompiled/Assembly-CSharp/TurnStartManager.cs
index 8f84554..0c01f66 100644
--- a/Decompiled/Assembly-CSharp/TurnStartManager.cs
+++ b/Decompiled/Assembly-CSharp/TurnStartManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -319,6 +320,7 @@ public class TurnStartManager : MonoBehaviour
 				m_turnStartInstance.SetReminderText(GameState.Get().GetGameEntity().GetTurnStartReminderText());
 				m_turnStartInstance.Show();
 				SoundManager.Get().LoadAndPlay("ALERT_YourTurn_0v2.prefab:201bcb34d33384e48ab226f7e797771f");
+				AccessibleGameplay.Get().OnTurnStart();
 			}
 		}
 	}
diff --git a/Decompiled/Assembly-CSharp/TutorialEntity.cs b/Decompiled/Assembly-CSharp/TutorialEntity.cs
index 98cd550..bd9334a 100644
--- a/Decompiled/Assembly-CSharp/TutorialEntity.cs
+++ b/Decompiled/Assembly-CSharp/TutorialEntity.cs
@@ -1,7 +1,8 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
-public class TutorialEntity : MissionEntity
+public abstract class TutorialEntity : MissionEntity
 {
 	private static Map<GameEntityOption, bool> s_booleanOptions = InitBooleanOptions();
 
@@ -74,14 +75,24 @@ public class TutorialEntity : MissionEntity
 				Notification notification = NotificationManager.Get().CreateSpeechBubble(GameStrings.Get("TUTORIAL02_JAINA_05"), Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: true);
 				SoundManager.Get().LoadAndPlay("VO_TUTORIAL_02_JAINA_05_20.prefab:700f7c6b778de5d41bf6d45a2e01b13d");
 				NotificationManager.Get().DestroyNotification(notification, 3.5f);
-				Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_01")));
+
+                if (!AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    // This is a visual-only reminder
+                    Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_01")));
+                }
 			}
 			else
 			{
 				Notification notification2 = NotificationManager.Get().CreateSpeechBubble(GameStrings.Get("TUTORIAL02_JAINA_04"), Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: true);
 				SoundManager.Get().LoadAndPlay("VO_TUTORIAL_02_JAINA_04_19.prefab:af04fcf53166d04469dc1b22b4181bf9");
 				NotificationManager.Get().DestroyNotification(notification2, 3.5f);
-				Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_03")));
+
+                if (!AccessibilityMgr.IsAccessibilityEnabled())
+                {
+                    // This is a visual-only reminder
+                    Gameplay.Get().StartCoroutine(DisplayManaReminder(GameStrings.Get("TUTORIAL02_HELP_03")));
+                }
 			}
 			return true;
 		}
@@ -230,9 +241,18 @@ public class TutorialEntity : MissionEntity
 			NotificationManager.Get().DestroyNotificationNowWithNoAnim(thatsABadPlayPopup);
 		}
 		Vector3 position = new Vector3(origin.x - 3f, origin.y, origin.z);
-		thatsABadPlayPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, GetTextScale(), GameStrings.Get("TUTORIAL01_HELP_07"));
-		NotificationManager.Get().DestroyNotification(thatsABadPlayPopup, 2.5f);
-	}
+
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            AccessibilityMgr.NarrateAndWait(AccessibleSpeech.TUTORIAL01_HELP_07);
+        }
+		else
+        {
+			// Visual-only popups
+            thatsABadPlayPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, GetTextScale(), GameStrings.Get("TUTORIAL01_HELP_07"));
+            NotificationManager.Get().DestroyNotification(thatsABadPlayPopup, 2.5f);
+        }
+    }
 
 	protected void HandleGameStartEvent()
 	{
@@ -321,4 +341,6 @@ public class TutorialEntity : MissionEntity
 	{
 		Options.Get().SetInt(Option.TUTORIAL_LOST_PROGRESS, 0);
 	}
+
+	protected abstract void MarkForAccessibility();
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs b/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
index 512c063..da825d4 100644
--- a/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
+++ b/Decompiled/Assembly-CSharp/TutorialKeywordManager.cs
@@ -190,4 +190,13 @@ public class TutorialKeywordManager : MonoBehaviour
 		}
 		return m_keywordPanels[0].transform.position;
 	}
+
+	#region Accessibility
+
+	internal List<TutorialKeywordTooltip> GetPanels()
+    {
+		return m_keywordPanels;
+    }
+
+	#endregion
 }
diff --git a/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs b/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
index ae911d0..b5f552e 100644
--- a/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
+++ b/Decompiled/Assembly-CSharp/TutorialProgressScreen.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -401,17 +402,20 @@ public class TutorialProgressScreen : MonoBehaviour
 		coin.m_inputEnabled = false;
 		yield return new WaitForSeconds(1f);
 		coin.SetProgress(HeroCoin.CoinStatus.ACTIVE_TO_DEFEATED);
-	}
+		yield return new WaitForSeconds(2f);
+        AccessibleTutorialProgressScreen.Get().OnDefeatedOpponent(coin);
+    }
 
-	private IEnumerator SetUnrevealedToActive(HeroCoin coin)
+    private IEnumerator SetUnrevealedToActive(HeroCoin coin)
 	{
 		coin.SetProgress(HeroCoin.CoinStatus.UNREVEALED);
 		coin.m_inputEnabled = false;
-		yield return new WaitForSeconds(2f);
+		yield return new WaitForSeconds(4f);
 		coin.SetProgress(HeroCoin.CoinStatus.UNREVEALED_TO_ACTIVE);
-	}
+        AccessibleTutorialProgressScreen.Get().OnNextOpponent(coin);
+    }
 
-	private void ExitButtonPress(UIEvent e)
+    private void ExitButtonPress(UIEvent e)
 	{
 		SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
 		FullScreenFXMgr.Get().Vignette(0f, 0.5f, iTween.EaseType.easeInOutQuad);
diff --git a/Decompiled/Assembly-CSharp/Tutorial_01.cs b/Decompiled/Assembly-CSharp/Tutorial_01.cs
index 3ded2b4..a208291 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_01.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_01.cs
@@ -1165,4 +1165,9 @@ public class Tutorial_01 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_01
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_02.cs b/Decompiled/Assembly-CSharp/Tutorial_02.cs
index 883a882..23b4ec3 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_02.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_02.cs
@@ -528,4 +528,9 @@ public class Tutorial_02 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_02
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_03.cs b/Decompiled/Assembly-CSharp/Tutorial_03.cs
index 34e83b6..65b31e9 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_03.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_03.cs
@@ -400,4 +400,9 @@ public class Tutorial_03 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_03
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_04.cs b/Decompiled/Assembly-CSharp/Tutorial_04.cs
index e73d949..478ae18 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_04.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_04.cs
@@ -642,4 +642,9 @@ public class Tutorial_04 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_04
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_05.cs b/Decompiled/Assembly-CSharp/Tutorial_05.cs
index 1e509d0..b95df21 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_05.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_05.cs
@@ -285,4 +285,9 @@ public class Tutorial_05 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_05
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/Tutorial_06.cs b/Decompiled/Assembly-CSharp/Tutorial_06.cs
index c2e385c..592cc33 100644
--- a/Decompiled/Assembly-CSharp/Tutorial_06.cs
+++ b/Decompiled/Assembly-CSharp/Tutorial_06.cs
@@ -319,4 +319,9 @@ public class Tutorial_06 : TutorialEntity
 		list.Add(cardRewardData);
 		return list;
 	}
+
+    protected override void MarkForAccessibility()
+    {
+		// See AccessibleTutorial_06
+    }
 }
diff --git a/Decompiled/Assembly-CSharp/UniversalInputManager.cs b/Decompiled/Assembly-CSharp/UniversalInputManager.cs
index 7908d8f..9a482d8 100644
--- a/Decompiled/Assembly-CSharp/UniversalInputManager.cs
+++ b/Decompiled/Assembly-CSharp/UniversalInputManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
@@ -271,6 +272,10 @@ public class UniversalInputManager : IHasUpdate, IService
 
 	private void OnGUI()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			return;
+        }
 		IgnoreGUIInput();
 		HandleGUIInputInactive();
 		HandleGUIInputActive();
@@ -1003,6 +1008,12 @@ public class UniversalInputManager : IHasUpdate, IService
 
 	private void UpdateInput()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			AccessibilityMgr.HandleKeyboardInput();
+			return;
+        }
+
 		if (UpdateTextInput())
 		{
 			return;
diff --git a/Decompiled/Assembly-CSharp/UserAttentionManager.cs b/Decompiled/Assembly-CSharp/UserAttentionManager.cs
index 4186067..d826c03 100644
--- a/Decompiled/Assembly-CSharp/UserAttentionManager.cs
+++ b/Decompiled/Assembly-CSharp/UserAttentionManager.cs
@@ -14,7 +14,7 @@ public static class UserAttentionManager
 		get
 		{
 			IEnumerable<string> source = (from UserAttentionBlocker r in Enum.GetValues(typeof(UserAttentionBlocker))
-				where IsBlockedBy(r)
+				where IsBlockedBy(true, r)
 				select r).Select(delegate(UserAttentionBlocker r)
 			{
 				UserAttentionBlocker userAttentionBlocker = r;
@@ -28,7 +28,12 @@ public static class UserAttentionManager
 
 	public static event Action OnBlockingEnd;
 
-	public static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
+	public static bool IsBlockedBy(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		return IsBlockedBy(attentionCategory);
+    }
+
+	private static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
 	{
 		if (attentionCategory != 0)
 		{
@@ -37,17 +42,27 @@ public static class UserAttentionManager
 		return false;
 	}
 
-	public static bool CanShowAttentionGrabber(string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, string callerName)
+    {
+		return CanShowAttentionGrabber(callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(string callerName)
 	{
-		return CanShowAttentionGrabber(UserAttentionBlocker.NONE, callerName);
+		return CanShowAttentionGrabber(true, UserAttentionBlocker.NONE, callerName);
 	}
 
-	public static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, UserAttentionBlocker attentionCategory, string callerName)
+    {
+		return CanShowAttentionGrabber(attentionCategory, callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
 	{
 		if ((s_blockedReasons & ~attentionCategory) != 0)
 		{
 			IEnumerable<string> source = (from UserAttentionBlocker r in Enum.GetValues(typeof(UserAttentionBlocker))
-				where r != attentionCategory && IsBlockedBy(r)
+				where r != attentionCategory && IsBlockedBy(true, r)
 				select r).Select(delegate(UserAttentionBlocker r)
 			{
 				UserAttentionBlocker userAttentionBlocker = r;
@@ -60,9 +75,14 @@ public static class UserAttentionManager
 		return true;
 	}
 
-	public static void StartBlocking(UserAttentionBlocker attentionCategory)
+	public static void StartBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StartBlocking(attentionCategory);
+    }
+
+	private static void StartBlocking(UserAttentionBlocker attentionCategory)
 	{
-		if (!IsBlockedBy(attentionCategory))
+		if (!IsBlockedBy(true, attentionCategory))
 		{
 			bool isBlocked = IsBlocked;
 			if (isBlocked)
@@ -79,7 +99,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static void StopBlocking(UserAttentionBlocker attentionCategory)
+	public static void StopBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StopBlocking(attentionCategory);
+    }
+
+	private static void StopBlocking(UserAttentionBlocker attentionCategory)
 	{
 		bool isBlocked = IsBlocked;
 		s_blockedReasons &= ~attentionCategory;
@@ -101,7 +126,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
+	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool markedForAccessibility, bool isFriendlyChallenge)
+    {
+		return GetAvailabilityBlockerReason(isFriendlyChallenge);
+    }
+
+	private static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
 	{
 		if (SpectatorManager.Get().IsInSpectatorMode())
 		{
diff --git a/Decompiled/Assembly-CSharp/WelcomeQuests.cs b/Decompiled/Assembly-CSharp/WelcomeQuests.cs
index 131c909..8d05630 100644
--- a/Decompiled/Assembly-CSharp/WelcomeQuests.cs
+++ b/Decompiled/Assembly-CSharp/WelcomeQuests.cs
@@ -1,8 +1,9 @@
 using System.Collections.Generic;
 using Assets;
 using UnityEngine;
+using Accessibility;
 
-public class WelcomeQuests : MonoBehaviour
+public class WelcomeQuests : MonoBehaviour, AccessibleUI
 {
 	public delegate void DelOnWelcomeQuestsClosed();
 
@@ -70,7 +71,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static bool Show(UserAttentionBlocker blocker, bool fromLogin, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.Show:" + fromLogin))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.Show:" + fromLogin))
 		{
 			onCloseCallback?.Invoke();
 			return false;
@@ -95,7 +96,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static void ShowSpecialQuest(UserAttentionBlocker blocker, Achievement achievement, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
 		{
 			onCloseCallback?.Invoke();
 			return;
@@ -173,6 +174,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		FadeEffectsOut();
 		if (s_instance != null)
 		{
@@ -271,6 +274,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void ReinitAndShow(ShowRequestData showRequestData)
 	{
+		AccessibilityMgr.HideUI(this); // Seems like an error condition but not really sure - best effort
+
 		FadeEffectsOut();
 		UnlockBnetButtons();
 		InitAndShow(showRequestData);
@@ -406,6 +411,8 @@ public class WelcomeQuests : MonoBehaviour
 			m_loginQuestShownTime = Time.realtimeSinceStartup;
 			m_clickCatcher.AddEventListener(UIEventType.RELEASE, SendTelemetry);
 		}
+
+		ReadQuests();
 	}
 
 	private void CheckShowInnkeepersSpecial()
@@ -485,6 +492,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void Close()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		CleanUpEventListeners();
 		UnlockBnetButtons();
 		s_instance = null;
@@ -583,4 +592,65 @@ public class WelcomeQuests : MonoBehaviour
 			m_bnetButtonsLocked = false;
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleQuestTile> m_accessibleQuests;
+
+	private AccessibleQuestTile m_accessibleQuestTile;
+
+	private void ReadQuests()
+    {
+		m_accessibleQuestTile = null;
+		m_accessibleQuests = null;
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output("Popup", true);
+        AccessibilityMgr.Output(m_headlineBanner.m_headline.Text);
+
+		if (m_currentQuests.Count == 1)
+        {
+			m_accessibleQuestTile = new AccessibleQuestTile(m_currentQuests[0]);
+			m_accessibleQuestTile.ReadAllLines();
+        }
+		else
+        {
+            var accessibleQuests = new List<AccessibleQuestTile>();
+            foreach (var quest in m_currentQuests)
+            {
+                accessibleQuests.Add(new AccessibleQuestTile(quest));
+            }
+
+            m_accessibleQuests = new AccessibleListOfItems<AccessibleQuestTile>(accessibleQuests);
+            m_accessibleQuests.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_clickCatcher.TriggerRelease();
+        }
+        else
+        {
+			m_accessibleQuestTile?.HandleAccessibleInput();
+            m_accessibleQuests?.HandleAccessibleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_accessibleQuests != null)
+        {
+            return $"Use the arrow keys to read your quests. Press {AccessibleKey.CONFIRM} once you're done";
+        }
+		else if (m_accessibleQuestTile != null)
+        {
+            return $"Use the arrow keys to read your quest. Press {AccessibleKey.CONFIRM} once you're done";
+        }
+
+		return $"Press {AccessibleKey.CONFIRM} to continue";
+    }
+
+	#endregion
 }
